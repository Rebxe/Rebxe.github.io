
{
	"posts": [
	
	
	
		{
			"abstract": "",
			"content": "主题修改自 [Gridea NexT](https://github.com/hsxyhao/gridea-theme-next)，静态页面生成器用 C++17 重写以支持多个子博客和子博客加密。\n\n<details><summary>关于名称</summary><p>\n\n> ![](../post-images/1689338887148.png)\n</p></details>\n\n<details><summary>投喂博主</summary></p>\n\n![](../post-images/1727081069343.png)\n</p></details>\n\n",
			"tags": [],
			"title": "关于本博客",
			"link": "https://exber.qzz.io/post/%E5%85%B3%E4%BA%8E%E6%9C%AC%E5%8D%9A%E5%AE%A2",
			"date": "2023-07-14 20:47:40"
		},
	
		{
			"abstract": "\n> 数轴上有 $n$ 只老鼠和 $m$ 个洞，第 $i$ 只老鼠位于 $x_i$，第 $i$ 个洞位于 $y_i$ 且可以容纳 $c_i$ 只老鼠，其还有一个难受度 $w_i$。\n>\n> 第 $i$ 只老鼠进第 $j$ 个洞需要花费 $|x_i-y_j|+w_j$ 的代价，求让所有老鼠都进洞的最小代价，或报告无解。\n>\n> $1\\le n\\le 10^5$，$0\\le x_i,y_i,w_i\\le 10^9$，$1\\le c_i\\le 10^9$。\n\n",
			"content": "\n> 数轴上有 $n$ 只老鼠和 $m$ 个洞，第 $i$ 只老鼠位于 $x_i$，第 $i$ 个洞位于 $y_i$ 且可以容纳 $c_i$ 只老鼠，其还有一个难受度 $w_i$。\n>\n> 第 $i$ 只老鼠进第 $j$ 个洞需要花费 $|x_i-y_j|+w_j$ 的代价，求让所有老鼠都进洞的最小代价，或报告无解。\n>\n> $1\\le n\\le 10^5$，$0\\le x_i,y_i,w_i\\le 10^9$，$1\\le c_i\\le 10^9$。\n\n\n![](../post-images/UOJ455_1.jpg)\n\n![](../post-images/UOJ455_2.jpg)\n",
			"tags": [{"name":"学习笔记"},{"name":"做题记录"},{"name":"贪心"},{"name":"结论"}],
			"title": "UOJ455 雪灾与外卖做题记录 & 老鼠进洞模型学习笔记",
			"link": "https://exber.qzz.io/post/UOJ455%20%E9%9B%AA%E7%81%BE%E4%B8%8E%E5%A4%96%E5%8D%96%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95%20%26%20%E8%80%81%E9%BC%A0%E8%BF%9B%E6%B4%9E%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2026-01-28 21:30:21"
		},
	
		{
			"abstract": "\n> 给定 $n$ 和长 $n$ 的序列 $a$，Alice 和 Bob 开始博弈，Alice 先手。\n>\n> 每一轮当前操作的人选择一个 $a_i>0$ 的 $i$，获得 $a_i\\text{ mod }2$ 的得分，并令 $a_i:=\\lfloor\\frac{a_i}{2}\\rfloor$。\n>\n> 每个人都想最大化自己的得分，求最终 Alice 的得分减去 Bob 的得分的值。\n>\n> $1\\le n\\le 5\\times 10^4$，$1\\le a_i<2^{63}$。\n\n",
			"content": "\n> 给定 $n$ 和长 $n$ 的序列 $a$，Alice 和 Bob 开始博弈，Alice 先手。\n>\n> 每一轮当前操作的人选择一个 $a_i>0$ 的 $i$，获得 $a_i\\text{ mod }2$ 的得分，并令 $a_i:=\\lfloor\\frac{a_i}{2}\\rfloor$。\n>\n> 每个人都想最大化自己的得分，求最终 Alice 的得分减去 Bob 的得分的值。\n>\n> $1\\le n\\le 5\\times 10^4$，$1\\le a_i<2^{63}$。\n\n\n这题的做法可以推广到更一般的形式：\n\n> 有 $n$ 个栈，两个人博弈，每次当前操作的人选择一个非空的栈，取走栈顶 $x$，得分加上 $x$。每个人要最大化自己的得分。\n\n首先若每个栈的大小都为 $1$，或者所有栈都满足自底向上不降，那么直接将所有元素排序，两人交替取最大元素即可。\n\n考虑某个栈 $s_{[1,k]}$（$s_1$ 为栈顶），假设有 $s_1<s_2$，那么很有可能双方都不想动这个栈，因为一旦拿走了 $s_1$，对方可以马上拿走 $s_2$，从而给自己带来负收益。此时这两个元素似乎可以捆绑。所以一个想法是将所有栈通过某种操作都变成自底向上不降的。\n\n为了让问题更好做，不妨考虑从底到顶将原栈的每个元素插入到新栈中，并时刻保证所有栈自底向上不降。\n\n那么若 $s_1<s_2$ 则第一个人一旦拿走 $s_1$，对方一定会拿走 $s_2$。因为有 $s_2\\ge s_3\\ge s_4\\ge \\dots\\ge s_k$，对于这个栈，对方不会想放弃 $s_2$ 去拿后面的更小的元素。\n\n那么若存在 $s_3$ 则第一个人一定会马上又拿走 $s_3$，否则他肯定不会去拿 $s_1$。故此时可以将 $s_{[1,3]}$ 缩成一个物品 $s_1+s_3-s_2$。\n\n若不存在 $s_3$，则双方都不想动 $s_1$，那么一定是其它东西都被拿走后，最后一个人被迫获得 $s_1-s_2$ 的负收益。此时可以直接将栈 $s$ 清空，最后再给最后一个人算上 $s_1-s_2$。\n\n那么将元素自底向上依次加入栈，当 $k\\ge 2$ 且 $s_1<s_2$ 时可以通过上述操作将 $k$ 减少 $2$，最后剩下的栈一定满足 $s_i\\ge s_{i+1}$。\n\n那么做完了，时间复杂度 $O(n\\log n)$，代码如下：\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int S=50005,BS=63;\n\nint n;\nll a[S];\n\nint main()\n{\n\tios::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\tvector<int> res;\n\tint lft=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tvector<int> pre;\n\t\tfor(int j=BS,f=0;j>=0;j--)\n\t\t{\n\t\t\tint x=a[i]>>j&1;\n\t\t\tif(!f&&x==0) continue;\n\t\t\tf=true;\n\t\t\tbool fl=true;\n\t\t\twhile(!pre.empty()&&x<pre.back())\n\t\t\t{\n\t\t\t\tx-=pre.back(),pre.pop_back();\n\t\t\t\tif(pre.empty()) lft+=x,fl=false;\n\t\t\t\telse x+=pre.back(),pre.pop_back();\n\t\t\t}\n\t\t\tif(fl) pre.push_back(x);\n\t\t}\n\t\tfor(int x:pre) res.push_back(x);\n\t}\n\tsort(res.begin(),res.end(),greater<int>());\n\tint ans=0;\n\tfor(int i=0;i<res.size();i++)\n\t\tif(i&1^1) ans+=res[i];\n\t\telse ans-=res[i];\n\tif(res.size()&1) ans-=lft;\n\telse ans+=lft;\n\tcout<<ans<<'\\n';\n\treturn 0;\n}\n```\n\n注意要时刻保证栈里元素自底向上不降，所以这样的写法是错的：\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int S=50005,BS=63;\n\nint n;\nll a[S];\n\nint main()\n{\n\tios::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\tvector<int> res;\n\tint lft=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tvector<int> pre;\n\t\tfor(int j=BS,f=0;j>=0;j--)\n\t\t{\n\t\t\tint x=a[i]>>j&1;\n\t\t\tif(!f&&x==0) continue;\n\t\t\tf=true;\n\t\t\tpre.push_back(x);\n\t\t\twhile(pre.size()>=3)\n\t\t\t{\n\t\t\t\tint m=pre.size()-1;\n\t\t\t\tif(pre[m]<pre[m-1])\n\t\t\t\t{\n\t\t\t\t\tint sm=pre[m]-pre[m-1]+pre[m-2];\n\t\t\t\t\tpre[m-2]=sm;\n\t\t\t\t\tpre.pop_back(),pre.pop_back();\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t\t// for(int x:pre) cout<<x;\n\t\t// cout<<'\\n';\n\t\tif(pre.size()>=2&&pre[0]>pre[1])\n\t\t{\n\t\t\tlft+=pre[1]-pre[0];\n\t\t\tfor(int i=2;i<pre.size();i++) pre[i-2]=pre[i];\n\t\t\tpre.pop_back(),pre.pop_back();\n\t\t}\n\t\tfor(int x:pre) res.push_back(x);\n\t}\n\tsort(res.begin(),res.end(),greater<int>());\n\tint ans=0;\n\tfor(int i=0;i<res.size();i++)\n\t\tif(i&1^1) ans+=res[i];\n\t\telse ans-=res[i];\n\tif(res.size()&1) ans-=lft;\n\telse ans+=lft;\n\tcout<<ans<<'\\n';\n\treturn 0;\n}\n```\n\n",
			"tags": [{"name":"做题记录"},{"name":"博弈论"},{"name":"结论"}],
			"title": "QOJ10010 Kids And Sequence Game 做题记录",
			"link": "https://exber.qzz.io/post/QOJ10010%20Kids%20And%20Sequence%20Game%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2026-01-28 08:13:15"
		},
	
		{
			"abstract": "\n> 给定 $n,m,c$，长 $n$ 的序列 $a$ 和长 $m$ 的**不降**序列 $b$，定义 $f(x)$ 为最大的 $0\\le i\\le m$ 使得 $\\sum\\limits_{j=1}^i b_j\\le x$。\n>\n> 定义一个区间 $[l,r]$ 的权值为 $f\\left(\\sum\\limits_{i\\in [l,r]}a_i\\right)-c$，求将 $[1,n]$ 划分为若干区间的权值和最大值。\n>\n> $1\\le n,m\\le 5\\times 10^5$，$0\\le a_i,b_i,\\sum a_i,\\sum b_i\\le 10^{12}$。\n\n",
			"content": "\n> 给定 $n,m,c$，长 $n$ 的序列 $a$ 和长 $m$ 的**不降**序列 $b$，定义 $f(x)$ 为最大的 $0\\le i\\le m$ 使得 $\\sum\\limits_{j=1}^i b_j\\le x$。\n>\n> 定义一个区间 $[l,r]$ 的权值为 $f\\left(\\sum\\limits_{i\\in [l,r]}a_i\\right)-c$，求将 $[1,n]$ 划分为若干区间的权值和最大值。\n>\n> $1\\le n,m\\le 5\\times 10^5$，$0\\le a_i,b_i,\\sum a_i,\\sum b_i\\le 10^{12}$。\n\n\n这个形式很像有决策单调性的样子，但是由于 $f$ 并不是凸的，而是形如若干段长度递增的阶梯，故其实际上并不满足决策单调性。\n\n考虑将其变得光滑，即令 $f'(x)=f(x)+\\frac{x-\\sum\\limits_{j\\le f(x)}b_j}{b_{f(x)+1}}$ 也就是连接每段阶梯的开头位置。那么 $f'(x)$ 是凸的，并且 $f(x)=\\lfloor f'(x)\\rfloor$。\n\n那么根据 $f'-c$ 求出决策点，此时具有决策单调性，二分队列或者半在线分治即可。\n\n时间复杂度 $O(n\\log^2 n)$，代码如下：\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double db;\n\nconst int S=500005;\nconst ll inf=1e18;\n\nint n,m,c;\nll a[S],b[S],sm[S];\npair<ll,db> f[S];\nint pos[S];\n\ninline pair<ll,db> get(int l,int r)\n{\n\tll x=a[r]-a[l];\n\tint p=upper_bound(sm+1,sm+m+1,x)-sm-1;\n\treturn make_pair(f[l].first+p-c,p<m?(x-sm[p])/(db)b[p+1]:0);\n}\n\nvoid doit(int l,int r)\n{\n\tif(r-l+1<=2) return;\n\tint mid=l+r>>1;\n\t{\n\t\tf[mid]=make_pair(-inf,-inf);\n\t\tfor(int i=pos[l];i<=pos[r];i++)\n\t\t{\n\t\t\tauto pre=get(i,mid);\n\t\t\tif(pre>f[mid]) f[mid]=pre,pos[mid]=i;\n\t\t}\n\t\tdoit(l,mid);\n\t}\n\t{\n\t\tfor(int i=l+1;i<=mid;i++)\n\t\t{\n\t\t\tauto pre=get(i,r);\n\t\t\tif(pre>f[r]) f[r]=pre,pos[r]=i;\n\t\t}\n\t\tdoit(mid,r);\n\t}\n}\n\ninline void slove()\n{\n\tcin>>n>>m>>c;\n\tfor(int i=1;i<=n;i++) cin>>a[i],a[i]+=a[i-1];\n\tfor(int i=1;i<=m;i++) cin>>b[i],sm[i]=sm[i-1]+b[i];\n\tpos[n]=0,f[n]=get(0,n);\n\tdoit(0,n);\n\tcout<<f[n].first<<'\\n';\n}\n\nint main()\n{\n\tios::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tint T;\n\tcin>>T;\n\twhile(T-->0) slove();\t\n\treturn 0;\n}\n```\n\n",
			"tags": [{"name":"做题记录"},{"name":"结论"}],
			"title": "QOJ9737 Let's Go! New Adventure 做题记录",
			"link": "https://exber.qzz.io/post/QOJ9737%20Let%27s%20Go%21%20New%20Adventure%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2026-01-27 19:41:47"
		},
	
		{
			"abstract": "",
			"content": "决策单调性一般可用观察法/分析四边形不等式得出，这里主要介绍四边形不等式。\n\n在这里我们只讨论代价为二元函数 $w(l,r)$ 的 dp。\n\n## Part 1 定义 & 性质\n\n### 1.1 dp 维数定义\n\n描述 dp 的时间复杂度时，往往会用 xD/yD 这样的说法，其中 $x$ 为 $\\text{状态数}\\log n$，$y$ 为 $\\text{单次转移复杂度}\\log n$。\n\n例如 $f_{l,r}=\\sum\\limits_{k=l+1}^rf_{l,k-1}+f_{k,r}$ 是 2D/1D 的 dp。\n\n### 1.2 决策单调性\n\n设 dp 的状态集合为 $S$，状态 $u$ 的最优决策点为 $\\text{opt}(u)$。\n\n若 $\\forall i,j\\in S,i<j$ 都有 $\\text{opt}(i)\\le\\text{opt}(j)$，则称该 dp 满足决策单调性。\n\n### 1.3 区间包含单调性和四边形不等式\n\n这两个东西都是定义在二元函数 $f(l,r)$ 上的。\n\n#### 1.3.1 区间包含单调性\n\n若 $\\forall l\\le l'\\le r'\\le r$，都有 $f(l',r')\\le f(l,r)$，则称 $f$ 满足区间包含单调性。\n\n#### 1.3.2 四边形不等式\n\n若 $\\forall l\\le l'\\le r'\\le r$，都有 $f(l,r')+f(l',r)\\le f(l,r)+f(l',r')$，则称 $f$ 满足四边形不等式。\n\n即相交小于包含。\n\n#### 1.3.3 一些帮助证明的性质\n\n- 若 $w(l+1,r)\\le w(l,r)$ 且 $w(l,r-1)\\le w(l,r)$，则可以归纳证明 $w(l,r)$ 满足区间包含单调性；\n- 若 $w(l+1,r)+w(l,r-1)\\le w(l,r)+w(l+1,r-1)$，则可以归纳证明 $w(l,r)$ 满足四边形不等式；\n- 线性性：若 $f(l,r)$ 与 $g(l,r)$ 均满足区间包含单调性 / 四边形不等式，则 $\\forall c1,c2\\ge 0$，$c1\\times f(l,r)+c2\\times g(l,r)$ 也满足区间包含单调性 / 四边形不等式；\n- 若 $w(l,r)=f(r)-g(l)$：\n  - $w(l,r)$ 满足四边形恒等式（$\\le$ 恒取 $=$）；\n  - 若 $f,g$ 均单调不增，则 $w(l,r)$ 还满足区间包含单调性；\n- 若 $f(x)$ 为下凸函数（导数不降），$w(l,r)$ 满足区间包含单调性和四边形不等式：\n  - $f(w(l,r))$ 满足四边形不等式；\n  - 若 $f(x)$ 单调不降，则 $f(w(l,r))$ 还满足区间包含单调性；\n\n<details><summary>证明</summary><p>\n\n> (2）：\n> $$\n> \\begin{aligned}\n> w(l+1,r)+w(l,r-1)\\le w(l,r)+w(l+1,r-1)\\qquad&(1)\\\\\n> w(l+1,r-1)+w(l,r-2)\\le w(l,r-1)+w(l+1,r-2)\\qquad&(2)\\\\\n> w(l+1,r)+w(l,r-1)+w(l+1,r-1)+w(l,r-2)\\\\\n> \\le\\\\w(l,r)+w(l+1,r-1)+ w(l,r-1)+w(l+1,r-2)\\\\\n> &(1)+(2)\\\\\n> w(l+1,r)+w(l,r-2)\\le w(l,r)+w(l+1,r-2)\n> \\end{aligned}\n> $$\n> (5).1：不会证，感性理解一下：\n>\n> - 满足区间包含单调性：更长的区间 $w(l,r)$ 更大；\n> - 下凸函数：更大的 $w(l,r)$ 增长得更快；\n> - 原本就满足四边形不等式：相交总和更小；\n\n</p></details>\n\n## Part 2 应用\n\n这里默认代价函数为二元函数 $w(l,r)$，且该函数计算时间复杂度为 $O(1)$。\n\n### 2.1 优化 1D/1D dp\n\n若 $w(l,r)$ 满足四边形不等式，则如下 1D/1D dp 存在决策单调性：\n$$\nf_i=\\min\\limits_{j=0}^{i-1}\\{w(j+1,i)\\}\\qquad\\text{朴素形}\\\\\nf_i=\\min\\limits_{j=0}^{i-1}\\{f_j+w(j+1,i)\\}\\qquad\\text{区间划分形}\n$$\n即 $\\forall i<j$，$\\text{opt}(i)\\le \\text{opt}(j)$。\n\n<details><summary>证明</summary><p>\n\n> 先证明第二个：\n> \n>  ![](../post-images/1703129569887.jpg)\n>\n>  解释：若出现上面的情况，则可以交换变成下面的情况，$f_i+f_{j}$ 变小，与 $f_i$ 和 $f_j$ 均为最小值相悖。\n>  \n>  第一个只不过是把黑色部分去掉了。\n\n</p></details>\n\n那么就可以分治或者在队列上二分来快速转移，时间复杂度 $O(n\\log n)$。\n\n#### 2.1.1 分治优化转移\n\n该方法仅适用于转移不依赖之前状态的情况（朴素形），在这种情况下，仅需求出 $\\text{opt}(i)$ 即可得出 $f_i$。\n\n考虑分治，令 $mid=\\lfloor\\frac{n}{2}\\rfloor$，先求出 $k=\\text{opt}(mid)$，接下来：\n\n- 对于 $i\\in[1,mid-1]$，$\\text{opt}(i)\\le k$；\n- 对于 $i\\in [mid+1,n]$，$\\text{opt}(i)\\ge k$；\n\n那么在分治的时候记录 $\\text{opt}(i)$ 的上下界即可。这样分治树的高度为 $O(\\log n)$，每一层每一个转移点只会被遍历到最多两次，总时间复杂度即为 $O(n\\log n)$。\n\n<details><summary>示例代码</summary><p>\n\n```cpp\nvoid dfs(int opt[],int(*calw)(int,int),int l,int r,int kl,int kr)\n{\n\tif(l>r) return;\n\tint mid=l+r>>1,k=kl;\n\tfor(int i=kl;i<=kr&&i<=mid;i++)\n\t{\n\t\tif(calw(i,mid)<calw(k,mid)) k=i;\n\t}\n\topt[mid]=k;\n\tdfs(opt,calw,l,mid-1,kl,k);\n\tdfs(opt,calw,mid+1,r,k,kr);\n}\n```\n\n</p></details>\n\n例题：[P3515 [POI2011] Lightning Conductor](https://www.luogu.com.cn/problem/P3515)\n\n<details><summary>题解</summary><p>\n\n> 考虑拆成两半求解，先求满足 $[1,i]$ 的 $p$，再求满足 $[i,n]$ 的 $p$，取 $\\max$。\n>\n> 设 $f_i$ 为前一半的 $p$，有：\n> $$\n> \\begin{aligned}\n> f_i&=\\max\\limits_{j<i}\\{a_j+\\sqrt{i-j}-a_i\\}\\\\\n> &=-\\min\\limits_{j<i}\\{a_i-a_j-\\sqrt{i-j}\\}\n> \\end{aligned}\n> $$\n> 由于 $w1(j,i)=-\\sqrt{i-j}$ 和 $w2(j,i)=a_i-a_j$ 都满足四边形不等式，所以 $w(j,i)=w1(j,i)+w2(j,i)$ 也满足四边形不等式。\n>\n> 那么直接分治优化转移即可，时间复杂度 $O(n\\log n)$。\n>\n> 记得寻找 $\\text{opt}(i)$ 时代价不能上取整，要最后再上取整。\n>\n> <details><summary>参考代码</summary><p>\n>\n> ```cpp\n> #include <iostream>\n> #include <cstdio>\n> #include <cmath>\n> \n> using namespace std;\n> \n> typedef long double db;\n> \n> const int S=500005;\n> \n> int n,a[S];\n> int opt1[S],opt2[S];\n> int ans[S];\n> \n> inline db calw(int l,int r)\n> {\n> \treturn a[r]-a[l]-sqrt((db)(r-l));\n> }\n> \n> void dfs(int opt[],db(*calw)(int,int),int l,int r,int kl,int kr)\n> {\n> \tif(l>r) return;\n> \tint mid=l+r>>1,k=kl;\n> \tfor(int i=kl;i<=kr&&i<=mid;i++)\n> \t{\n> \t\tif(calw(i,mid)<calw(k,mid)) k=i;\n> \t}\n> \topt[mid]=k;\n> \tdfs(opt,calw,l,mid-1,kl,k);\n> \tdfs(opt,calw,mid+1,r,k,kr);\n> }\n> \n> int main()\n> {\n> \tscanf(\"%d\",&n);\n> \tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n> \tdfs(opt1,calw,1,n,1,n);\n> \tfor(int i=1;i<=n;i++) ans[i]=ceil(-calw(opt1[i],i));\n> \tfor(int i=1;i<=n/2;i++) swap(a[i],a[n-i+1]);\n> \tdfs(opt2,calw,1,n,1,n);\n> \tfor(int i=1;i<=n;i++) ans[n-i+1]=max(ans[n-i+1],(int)ceil(-calw(opt2[i],i)));\n> \tfor(int i=1;i<=n;i++) printf(\"%d\\n\",ans[i]);\n> \treturn 0;\n> }\n> ```\n>\n> </p></details>\n\n</p></details>\n\n练习：[Loj #6039. 「雅礼集训 2017 Day5」珠宝 /「NAIPC2016」Jewel Thief](https://loj.ac/p/6039)\n\n#### 2.1.2 二分队列优化转移\n\n该方法适用于转移依赖之前状态的情况（区间划分形）。\n\n观察到对于特定的 $j$，$\\text{opt}(i)=j$ 的 $i$ 肯定形成一个区间。\n\n那么不妨用单调队列维护 $j$ 和其对应的区间 $[l_j,r_j]$，队头为 $l_j$ 最小的，队尾为 $l_j$ 最大的。\n\n每次转移到新的 $i$ 时：\n\n- 先把队头 $r_j<i$ 的决策点弹掉，得到 $\\text{opt}(i)$，从而得到 $f_i$，令队头 $l_j=i+1$；\n- 然后对于队尾决策点 $j$，若 $f_i+w(i+1,l_j)<f_j+w(j+1,l_j)$ 则弹掉队尾；\n- 若队列为空，加入决策 $i$，令 $l_i=i+1$，$r_i=n$；\n- 否则二分找到分界点再加入决策 $i$；\n\n这样每个决策点最多只会入队一次，所以总时间复杂度为均摊 $O(n\\log n)$。\n\n<details><summary>参考代码</summary><p>\n\n```cpp\nlb[0]=1,rb[0]=n;\nhed=1,til=0;\nque[++til]=0;\nf[0]=0;\nfor(int i=1;i<=n;i++)\n{\n\twhile(rb[que[hed]]<i) hed++;\n\tint opti=que[hed];\n\tf[i]=f[opti]+calw(opti+1,i);\n\tif(rb[opti]==i) hed++;\n\telse lb[opti]=i+1;\n\twhile(hed<=til&&\n\t\tf[i]+calw(i+1,lb[que[til]])\n\t\t\t\t\t<\n\t\tf[que[til]]+calw(que[til]+1,lb[que[til]])\n\t) til--;\n\tif(hed>til)\n\t{\n\t\tif(i<n)\n\t\t{\n\t\t\tlb[i]=i+1,rb[i]=n;\n\t\t\tque[++til]=i;\n\t\t}\n\t}\n\telse\n\t{\n\t\tint j=que[til];\n\t\tint l=lb[j],r=rb[j],p=lb[j];\n\t\twhile(l<=r)\n\t\t{\n\t\t\tint mid=l+r>>1;\n\t\t\tif(f[j]+calw(j+1,mid)<f[i]+calw(i+1,mid)) p=mid,l=mid+1;\n\t\t\telse r=mid-1;\n\t\t}\n\t\trb[j]=p;\n\t\tif(p<n)\n\t\t{\n\t\t\tlb[i]=p+1,rb[i]=n;\n\t\t\tque[++til]=i;\n\t\t}\n\t}\n}\n```\n\n</p></details>\n\n例题：[P3195 [HNOI2008] 玩具装箱](https://www.luogu.com.cn/problem/P3195)\n\n<details><summary>题解</summary><p>\n\n> 设 $f_i$ 表示 $[1,i]$ 的代价，那么有转移：\n> $$\n> f_i=\\min\\limits_{0\\le j<i}\\{f_j+w(j+1,i)\\}\n> $$\n> 其中 $w(l,r)=(r-l+\\sum\\limits_{l\\le k\\le r}C_k-L)^2$。\n>\n> 设 $S_i=\\sum\\limits_{1\\le j\\le i}C_j$，那么 $w(l,r)=(r-l+S_r-S_{l-1}-L)^2$。\n>\n> 显然 $r-l+S_r-S_{l-1}-L$ 满足区间包含单调性和四边形不等式，由于 $f(x)=x^2$ 是下凸函数，所以 $w(l,r)$ 满足四边形不等式。\n>\n> 那么直接二分队列优化转移即可，时间复杂度 $O(n\\log n)$。\n>\n> <details><summary>参考代码</summary><p>\n>\n> ```cpp\n> #include <iostream>\n> #include <cstdio>\n> \n> using namespace std;\n> \n> typedef long long ll;\n> \n> const int S=50005;\n> \n> int n,L;\n> ll a[S];\n> int lb[S],rb[S];\n> int hed,til,que[S];\n> ll f[S];\n> \n> inline ll calw(int l,int r)\n> {\n> \tll x=r-l+a[r]-a[l-1];\n> \treturn (x-L)*(x-L);\n> }\n> \n> int main()\n> {\n> \tscanf(\"%d%d\",&n,&L);\n> \tfor(int i=1;i<=n;i++) scanf(\"%lld\",&a[i]),a[i]+=a[i-1];\n> \tlb[0]=1,rb[0]=n;\n> \thed=1,til=0;\n> \tque[++til]=0;\n> \tf[0]=0;\n> \tfor(int i=1;i<=n;i++)\n> \t{\n> \t\twhile(rb[que[hed]]<i) hed++;\n> \t\tint opti=que[hed];\n> \t\tf[i]=f[opti]+calw(opti+1,i);\n> \t\tif(rb[opti]==i) hed++;\n> \t\telse lb[opti]=i+1;\n> \t\twhile(hed<=til&&\n> \t\t\tf[i]+calw(i+1,lb[que[til]])\n> \t\t\t\t\t\t<\n> \t\t\tf[que[til]]+calw(que[til]+1,lb[que[til]])\n> \t\t) til--;\n> \t\tif(hed>til)\n> \t\t{\n> \t\t\tif(i<n)\n> \t\t\t{\n> \t\t\t\tlb[i]=i+1,rb[i]=n;\n> \t\t\t\tque[++til]=i;\n> \t\t\t}\n> \t\t}\n> \t\telse\n> \t\t{\n> \t\t\tint j=que[til];\n> \t\t\tint l=lb[j],r=rb[j],p=lb[j];\n> \t\t\twhile(l<=r)\n> \t\t\t{\n> \t\t\t\tint mid=l+r>>1;\n> \t\t\t\tif(f[j]+calw(j+1,mid)<f[i]+calw(i+1,mid)) p=mid,l=mid+1;\n> \t\t\t\telse r=mid-1;\n> \t\t\t}\n> \t\t\trb[j]=p;\n> \t\t\tif(p<n)\n> \t\t\t{\n> \t\t\t\tlb[i]=p+1,rb[i]=n;\n> \t\t\t\tque[++til]=i;\n> \t\t\t}\n> \t\t}\n> \t}\n> \tprintf(\"%lld\\n\",f[n]);\n> \treturn 0;\n> }\n> ```\n>\n> </p></details>\n\n</p></details>\n\n### 2.2 优化 2D/1D dp\n\n#### 2.2.1 恰好 $k$ 段的区间划分形\n\n若 $w(l,r)$ 满足四边形不等式，则如下 2D/1D dp 存在决策单调性：\n$$\nf_{i,k}=\\min\\limits_{0\\le j<i}\\{f_{j,k-1}+w(j+1,i)\\}\n$$\n即满足 $\\text{opt}(i,k-1)\\le\\text{opt}(i,k)\\le \\text{opt}(i+1,k)$。\n\n<details><summary>证明</summary><p>\n\n>$\\text{opt}(i,k)\\le \\text{opt}(i+1,k)$ 套用 1D/1D 的区间划分形 dp 的证明方法即可，仅需证明 $\\text{opt}(i,k-1)\\le \\text{opt}(i,k)$。\n>\n>不会证，感性理解一下。\n\n</p></details>\n\n并且这类问题有个神奇的性质（同样不会证）：\n\n> $f_{i,k}$ 是关于 $k$ 的下凸函数。\n\n感性理解一下就是刚开始分的越多越好，超过一个临界点分多点反而不好了。\n\n也就是说，这类问题都可以 wqs 二分。\n\n#### 2.2.2 区间合并形\n\n若 $w(l,r)$ 满足四边形不等式和区间包含单调性，则如下 2D/1D dp 存在决策单调性：\n$$\nf_{l,r}=\\min\\limits_{l\\le k< r}\\{f_{l,k}+f_{k+1,r}\\}+w(l,r)\n$$\n即满足 $\\text{opt}(l,r-1)\\le\\text{opt}(l,r)\\le \\text{opt}(l+1,r)$，且 $f_{l,r}$ 也满足四边形不等式。\n\n并且若 $w(l,r)$ 和 $f_{l,r}$ 均非负，$f_{l,r}$ 也满足区间包含单调性。\n\n<details><summary>证明</summary><p>\n\n> 四边形不等式和区间包含单调性的证明：\n>\n> - 四边形不等式：\n>\n>   考虑归纳，$l\\ge r-2$ 时显然成立。\n>\n>   仅需证明 $f_{l,r-1}+f_{l+1,r}\\le f_{l,r}+f_{l+1,r-1}$。\n>\n>   不妨设 $\\text{opt}(l,r)=k$。\n>\n>   - $k=l$ 或 $k=r-1$：\n>\n>     这里假设 $k=r-1$，另一种情况同理。\n>\n>     有：\n>     $$\n>     \\begin{aligned}\n>     f_{l,r}+f_{l+1,r-1}&=f_{l,k}+f_{k+1,r}+w(l,r)+f_{l+1,r-1}\\\\\n>     &=f_{l,r-1}+f_{r,r}+w(l,r)+f_{l+1,r-1}\\\\\n>     \\end{aligned}\n>     $$\n>\n>     由于 $w(l,r)$ 满足区间包含单调性，所以 $w(l,r-1)\\le w(l,r)$，那么有：\n>     $$\n>     \\begin{aligned}\n>     f_{l,r}+f_{l+1,r-1}&\\ge f_{l,r-1}+f_{r,r}+w(l,r-1)+f_{l+1,r-1}\\\\\n>     &\\ge f_{l,r-1}+f_{l+1,r}\\\\\n>     \\end{aligned}\n>     $$\n>     最后一步是根据 dp 转移式得到的。\n>\n>   - $l<k<r-1$：\n>\n>     此时设 $\\text{opt}(l+1,r-1)=p$，不妨假设 $k\\le p$，$k>p$ 同理：\n>     $$\n>     \\begin{aligned}\n>     f_{l,r}+f_{l+1,r-1}&=f_{l,k}+f_{k+1,r}+w(l,r)+f_{l+1,p}+f_{p+1,r-1}+w(l+1,r-1)\\\\\n>     &\\ge f_{k+1,r-1}+f_{p+1,r}+f_{l,k}+f_{l+1,p}+w(l,r)+w(l+1,r-1)\\\\\n>     &\\ge f_{k+1,r-1}+f_{p+1,r}+f_{l,k}+f_{l+1,p}+w(l,r-1)+w(l+1,r)\\\\\n>     &\\ge f_{l,r-1}+f_{l+1,r}\n>     \\end{aligned}\n>     $$\n>     其中：\n>\n>     - 第二个不等式是因为根据归纳假设，有 $f_{k+1,r-1}+f_{p+1,r}\\le f_{k+1,r}+f_{p+1,r-1}$；\n>     - 第三个不等式是因为 $w(l,r)$ 满足四边形不等式；\n>     - 第四个不等式是根据 dp 转移式得到的；\n>\n> - 区间包含单调性：\n>\n>   证明起来比较简单，依旧考虑归纳，$l=r$ 时显然成立。\n>\n>   仅需证明 $f_{l,r-1}\\le f_{l,r}$ 和 $f_{l+1,r}\\le f_{l,r}$。\n>\n>   这里证明 $f_{l,r-1}\\le f_{l,r}$，另一个的证明是一样的。\n>\n>   设 $\\text{opt}(l,r)=k$。\n>\n>   - $l\\le k<r-1$：\n>\n>     有：\n>     $$\n>     \\begin{aligned}\n>     f_{l,r}&=f_{l,k}+f_{k+1,r}+w(l,r)\\\\\n>     &\\ge f_{l,k}+f_{k+1,r-1}+w(l,r-1)\\\\\n>     &\\ge f_{l,r-1}\n>     \\end{aligned}\n>     $$\n>     其中：\n>\n>     - 第二个不等式是因为 $w(l,r)$ 满足区间包含单调性，并且根据归纳假设，有 $f_{k+1,r-1}\\le f_{k,r}$；\n>     - 第三个不等式是根据 dp 转移式得到的；\n>\n>   - $k=r-1$：\n>\n>     设 $\\text{opt}(l,r-1)=p$，有：\n>     $$\n>     \\begin{aligned}\n>     f_{l,r}&=f_{l,r-1}+f_{r,r}+w(l,r)\n>     \\end{aligned}\n>     $$\n>     由于 $w(l,r)$ 非负，$f_{r,r}$ 也非负，所以 $f_{l,r}\\ge f_{l,r-1}$。\n>\n>\n> 决策单调性的证明：\n>\n> ![](../post-images/1703581345467.jpg)\n>\n\n</p></details>\n\n根据决策单调性，我们在 dp 的时候就可以记录 $\\text{opt}(l,r)$，转移的时候先枚举区间长度，枚举 $k$ 只在 $\\text{opt}(l,r-1)$ 和 $\\text{opt}(l+1,r)$ 之间枚举。这样长度相同的区间的枚举 $k$ 的时间复杂度总和是 $O(n)$ 的，那么整体时间复杂度也就是 $O(n^2)$ 的了。\n\n例题：石子合并（加强版）\n\n> 有 n 堆石子排成一个环，第 $i$ 堆石子有 $a_i$ 个。\n>\n> 可以把相邻的两堆石子合并为一堆，合并的代价为两堆石子的个数之和，求把所有石子合并成一堆的最小代价和最大代价。\n>\n> $1\\le n\\le 2500$。\n\n<details><summary>题解</summary><p>\n\n> 先段环为链，设 $s_{i}=\\sum\\limits_{j=1}^i a_j$，$f_{l,r}$ 为把 $a_{[l,r]}$ 合并为一堆的最小代价，那么有转移：\n> $$\n> f_{l,r}=\\min\\limits_{l\\le k<r}\\{f_{l,k}+f_{k+1,r}\\}+s_{r}-s_{l-1}\n> $$\n> 显然由于 $a_i$ 非负，所以 $w(l,r)=s_r-s_{l-1}$ 满足区间包含单调性和四边形不等式，那么 $f_{l,r}$ 满足决策单调性，所以可以直接优化到 $O(n^2)$。\n\n</p></details>\n\n### 2.3 更多练习\n\n- [P4767 [IOI2000] 邮局](https://www.luogu.com.cn/problem/P4767)\n- [CF321E Ciel and Gondolas](https://www.luogu.com.cn/problem/CF321E)\n- [SP33372 LARMY](https://www.luogu.com.cn/problem/SP33372)\n- [P6932 [ICPC2017 WF] Money for Nothing](https://www.luogu.com.cn/problem/P6932)\n\n## Upd 20250206 更具有启发性的严格定义\n\n### 关于单调性的定义\n\n启发：对于这种二维的事物，不妨考虑矩阵/二维平面。\n\n仅考虑最小化的情况，最大化情况同理。\n\n关于最小值的位置，若有多个则默认为第一个。\n\n- 单调矩阵 $A_{n\\times m}$：设 $\\min_i$ 为第 $i$ 行的最小值的位置，则 $\\forall i_1< i_2$，有 $\\min_{i_1}\\le \\min_{i_2}$；\n- 完全单调矩阵 $C_{n\\times m}$：对于其所有子矩阵 $A$（不一定要连续），$A$ 都是单调矩阵；\n- 蒙日矩阵 $M_{n\\times m}$：对于任意一个 $2\\times 2$ 的子矩阵 $\\begin{bmatrix}a&b\\\\c&d\\end{bmatrix}$（不一定要连续），其满足 $a+d\\le b+c$（相交小于包含）；\n\n### 一些性质\n\n- 蒙日矩阵一定是完全单调矩阵。\n\n单调矩阵一般都是完全单调矩阵，而大部分完全单调矩阵都是蒙日矩阵。\n\n- 根据定义，不难发现仅需 check $2\\times 2$ 的子矩阵即可得知一个矩阵是否完全单调，相当于对于所有 $2\\times 2$ 的子矩阵 $\\begin{bmatrix}a&b\\\\c&d\\end{bmatrix}$ 都需要满足 $[a\\le b]+[c>d]>0$，即这两个条件至少满足一个；\n\n那么由此可以得出一个性质：\n\n- 对于一个完全单调矩阵 $C$ 的任意两列 $j_1$ 和 $j_2$，其对应位置的值的某个前缀满足 $\\le $，剩下的后缀满足 $>$，如图：\n\n  ![](../post-images/1738811494386.png)\n\n并且也可以证明蒙日矩阵一定是完全单调矩阵，反证法：若 $a>b$ 且 $c\\le d$，则一定有 $a+d>b+c$。\n\n- 根据蒙日矩阵的定义，check 一个矩阵 $M_{n\\times m}$ 是否蒙日矩阵仅需 check $2\\times 2$ 的**连续**子矩阵即可；\n\n  因为若 $a+d\\le b+c$ 则 $a+d-b-c\\le 0$，注意到这个是二维差分的形式，即 $M$ 可以看作一个非正矩阵的二维前缀和，而 $2\\times 2$ 的子矩阵（不一定连续）的 $a+d-b-c$ 相当于该非正矩阵一个矩形中数的和，显然其也非正；\n\n  故证明四边形不等式时仅需考虑 $[l,r]$ 和 $[l+1,r+1]$；\n\n- 给蒙日矩阵中某一行整体加同一个数，矩阵仍是蒙日矩阵；\n\n### 关于应用的定义\n\n蒙日矩阵一般都是定义在区间上的，即 $M_{n\\times n}$，其中 $M_{i,j}$ 是区间 $[i,j]$ 的代价。\n\n这样定义会带来一些问题，因为 $i>j$ 的区间不存在，若将其简单定义为 $\\infin$ 则会导致形如 $\\begin{bmatrix}\\infin&a\\\\\\infin&\\infin\\end{bmatrix}$ 的子矩阵会导出 $\\infin+\\infin\\le \\infin+a$ 的错误式子，且形如 $\\begin{bmatrix}\\infin&a\\\\\\infin&b\\end{bmatrix}$ 的子矩阵会导出 $b\\le a$ 的不一定成立的式子（给某一行整体加同一个数不改变蒙日性，但此时可能有 $b>a$）。\n\n一个聪慧的构造是考虑令 $i<j$ 时 $M_{i,j}=(j-i)^2\\times \\infin$，不难验证该构造满足蒙日性。\n\n#### 分治优化\n\n本质其实是找到矩阵中第 $mid$ 行的最小值的位置，并分治处理左和右下矩阵：\n\n![](../post-images/1738813756881.png)\n\n所以该方法仅要求矩阵是单调矩阵。\n\n#### 二分队列优化\n\n本质上是从左往右扫每一列，对于每列维护出最小值在该列的行的区间，每次插入一列的时候干掉一个后缀的区间并插入一个新区间：\n\n![](../post-images/1738814520441.png)\n\n所以该方法仅要求矩阵是完全单调矩阵。\n\n#### 蒙日矩阵最短路——区间划分型 dp\n\n不难发现，若将区间 $(l,r]$ 的代价对应的蒙日矩阵看作 $n$ 个点的图 $G$ 的邻接矩阵，则序列的最小代价区间划分对应着由 $0$ 到 $n$ 的最短路。特别的，任意两点 $l,r$ 间的最短路对应着区间 $[l+1,r]$ 的最小代价区间划分。\n\n##### 一些性质\n\n- 设 $f(x,y,k)$ 为 $x\\to y$ 的经过 $k$ 条边的的蒙日矩阵最短路的长度，则 $f(x,y,k)$ 关于 $k$ 是凸的；\n\n  > 考虑证 $f(x,y,k)-f(x,y,k-1)\\le f(x,y,k+1)-f(x,y,k)$ 相当于证 $2f(x,y,k)\\le f(x,y,k-1)+f(x,y,k+1)$。\n  >\n  > 将 $f(x,y,k-1)$ 和 $f(x,y,k+1)$ 对应的最短路径拿出来，考虑根据这两条路径构造两条长度为 $k$ 的路径使得它们的和不变大。按照编号若某个点来自 $k-1$ 则写下 $\\text{a}$，否则写下 $\\text b$，编号相同的顺序任意，得到序列 $p_{[1,2k]}$，那么 $\\text a$ 一定比 $\\text b$ 少两个。\n  >\n  > 考虑找到某个前缀 $p_{[1,i]}$ 满足 $\\text a$ 比 $\\text b$ 恰好少一个，且 $p_i=p_{i+1}=\\text b$：\n  >\n  > ![](../post-images/1738840162672.png)\n  >\n  > 则此时 $p_{[i+1,2k]}$ 一定也满足 $\\text a$ 比 $\\text b$ 恰好少一个，那么可以这样构造两条长 $k$ 的路径：\n  >\n  > - $p_{[1,i]}$ 中的 $\\text a$ 接上 $p_{[i+1,2k]}$ 中的 $\\text b$；\n  > - $p_{[1,i]}$ 中的 $\\text b$ 接上 $p_{[i+1,2k]}$ 中的 $\\text a$；\n  >\n  > 注意到由于 $p_i=p_{i+1}=\\text b$，所以中间部分实际上是将一个包含变为了相交，故路径代价总和不增。\n  >\n  > 故证明一定能找到这样的 $i$ 即可。\n  >\n  > 考虑折线图，将 $\\text a$ 看作 $1$，$\\text b$ 看作 $-1$，则该折线从 $0$ 出发，在 $-2$ 处终止。由于折线是连续的，故一定有某个时刻位于 $-1$，此时若下一个时刻位于 $0$，则后半部分递归了，否则就找到了连续的两个 $\\text b$。\n\n##### 经典例题：环上划分问题\n\n- [QOJ2211 IOI Problem Revised](../QOJ2211 IOI Problem Revised 做题记录/)，【2025NOIP模拟赛44】网络规划\n\n## Upd 20260127 1D/1D dp 更具有通用性的算法\n\n普通分治要求离线，二分队列无法处理转移代价 $w(l,r)$ 要莫队算的情况。\n\n这里介绍一种可以 $O(n\\log n)$ 处理半在线且代价需要莫队算的 1D/1D dp 的方法，要求 $w(l,r)$ 是完全单调矩阵。\n\n### 大体思想\n\n依旧考虑分治。我们希望设计一个函数 $\\text{doit}(l,r)$，使得在计算完 $f_{[0,l-1]}$ 后调用它即可计算出 $f_{[l,r]}$。\n\n考虑充分利用完全单调矩阵的性质，即 $f_{[0,l]}$ 到 $f_{[l,r]}$ 的转移也满足决策单调性，设计如下函数：\n\n- $\\text{doit}(l,r)$ 要求已经计算完 $f_{[0,l]}$ 和对应决策点 $p_{[0,l]}$，并且 $f_{[0,l]}$ 对 $f_r$ 的贡献和对应决策点 $p_r$（只考虑 $f_{[0,l]}$）也算完了；\n\n显然边界 $\\text{doit}(l,l+1)$ 是对的。\n\n对于 $r>l+1$ 的 $\\text{doit}(l,r)$ 的具体流程：\n\n1. 遍历决策点 $[p_l,p_r]$，计算 $f_{[0,l]}$ 对 $f_{mid}$ 的贡献和对应决策点 $p_{mid}$；\n2. 递归 $\\text{doit}(l,mid)$；\n3. 遍历决策点 $[l+1,mid]$，计算 $f_{l+1,mid}$ 对 $f_r$ 的贡献，更新 $p_r$；\n4. 递归 $\\text{doit}(mid,r)$；\n\n那么这样做正确性显然是对的，由于每层第一步和第三步的决策点区间分别拼起来可以得到整个序列，故时间复杂度是 $O(n\\log n)$。\n\n并且若给第一步和第三步分别开一个莫队计算 $w(l,r)$，莫队的端点总移动次数也是 $O(n\\log n)$ 的。证明可以考虑决策点区间 $[l,r]$ 对莫队端点移动次数的贡献是 $O(r-l+1)$ 的，而决策点区间总长度是 $O(n\\log n)$。\n\n### 示例代码\n\n```cpp\nvoid doit(int l,int r)\n{\n\tif(r-l+1<=2) return;\n\tint mid=l+r>>1;\n    f[mid]=-inf;\n    for(int i=pos[l];i<=pos[r];i++)\n    {\n        int pre=get(i,mid);\n        if(pre>f[mid]) f[mid]=pre,pos[mid]=i;\n    }\n    doit(l,mid);\n    for(int i=l+1;i<=mid;i++)\n    {\n        int pre=get(i,r);\n        if(pre>f[r]) f[r]=pre,pos[r]=i;\n    }\n    doit(mid,r);\n}\n```\n",
			"tags": [{"name":"学习笔记"},{"name":"DP"},{"name":"数学"}],
			"title": "决策单调性优化 dp 学习笔记",
			"link": "https://exber.qzz.io/post/%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7%E4%BC%98%E5%8C%96%20dp%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2026-01-27 19:28:52"
		},
	
		{
			"abstract": "\n> 定义一个字符串 $s$ 的权值 $f(s)$ 为其中出现次数最多的字符的出现次数减去出现次数最少（不为 $0$ 次）的字符的出现次数。\n>\n> 给定一个字符集为 $\\{\\text{a},\\text{b},\\text{c}\\}$ 的字符串 $S$，求 $\\sum\\limits_{[l,r]\\subseteq [1,|S|]}f(S_{[l,r]})$，即其所有子串的权值之和。\n>\n> $1\\le |S|\\le 2\\times 10^5$，要求**复杂度线性**。\n\n",
			"content": "\n> 定义一个字符串 $s$ 的权值 $f(s)$ 为其中出现次数最多的字符的出现次数减去出现次数最少（不为 $0$ 次）的字符的出现次数。\n>\n> 给定一个字符集为 $\\{\\text{a},\\text{b},\\text{c}\\}$ 的字符串 $S$，求 $\\sum\\limits_{[l,r]\\subseteq [1,|S|]}f(S_{[l,r]})$，即其所有子串的权值之和。\n>\n> $1\\le |S|\\le 2\\times 10^5$，要求**复杂度线性**。\n\n\n设子串中三种字符出现次数分别为 $c_a,c_b,c_c$。\n\n包含两种字符的子串是好处理的，仅需数 $|c_a-c_b|+|c_b-c_c|+|c_a-c_c|$。考虑包含三种字符的子串怎么做。\n\n注意到 $\\max(c_a,c_b,c_c)-\\min(c_a,c_b,c_c)=\\frac{|c_a-c_b|+|c_b-c_c|+|c_a-c_c|}{2}$，所以包含三种字符的子串乘上 $\\frac{1}{2}$ 的系数就好了。\n\n考虑如何计算 $|c_a-c_b|$ 带来的贡献，另外两对同理。令 $b_i=\\sum\\limits_{j\\le i} [S_j=\\text{a}]-[S_j=\\text{b}]$，那么 $S_{[l,r]}$ 的贡献即为 $|b_{r}-b_{l-1}|$。系数问题也是好处理的，最后会转化成一个二维数点问题。\n\n常规方法只能做到 $O(n\\log n)$，但是注意到要数的点 $(i,b_i)$ 满足 $|b_i-b_{i+1}|\\le 1$，那么可以维护 $[-n,b_i]$ 的前缀和和 $[b_i+1,n]$ 的后缀和，即维护两个对顶栈，每次 $b$ 移动的时候弹掉某一边的栈顶并在另一个栈顶新加元素即可。\n\n时间复杂度 $O(n)$，代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int S=200005;\n\nint n;\nchar a[S];\nint lb[S],rb[S];\nint b[S];\nll prect[S],presm[S];\nll ans,ans2;\n\nstruct exb\n{\n\tint pos;\n\tll a[S*2],pre[S*2],suf[S*2];\n\tinline void init()\n\t{\n\t\tpos=0;\n\t\tmemset(a,0,sizeof(a));\n\t\tmemset(pre,0,sizeof(pre));\n\t\tmemset(suf,0,sizeof(suf));\n\t}\n\tinline void add(int p,int x)\n\t{\n\t\ta[p]+=x;\n\t\tpre[p]+=x;\n\t\twhile(pos<p)\n\t\t{\n\t\t\tpos++;\n\t\t\tpre[pos]=pre[pos-1]+a[pos];\n\t\t}\n\t\twhile(pos>p)\n\t\t{\n\t\t\tsuf[pos]=suf[pos+1]+a[pos];\n\t\t\tpos--;\n\t\t}\n\t}\n\tinline ll que(int p)\n\t{\n\t\tif(p<=pos) return pre[p];\n\t\treturn pre[pos]+suf[pos+1]-suf[p+1];\n\t}\n}s1,s2;\n\ninline void calc()\n{\n\ts1.init(),s2.init();\n\tfor(int i=1,l=0;i<=n;i++)\n\t{\n\t\twhile(l<rb[i])\n\t\t{\n\t\t\ts1.add(b[l]+n+1,1);\n\t\t\ts2.add(b[l]+n+1,b[l]);\n\t\t\tl++;\n\t\t}\n\t\tprect[i]=s1.que(b[i]+n+1);\n\t\tpresm[i]=s2.que(b[i]+n+1);\n\t}\n\ts1.init(),s2.init();\n\tll c1=0,c2=0,t1=0,t2=0;\n\tfor(int i=1,l=0,r=0;i<=n;i++)\n\t{\n\t\twhile(l<lb[i])\n\t\t{\n\t\t\ts1.add(b[l]+n+1,1);\n\t\t\ts2.add(b[l]+n+1,b[l]);\n\t\t\tc1++,c2+=b[l];\n\t\t\tl++;\n\t\t}\n\t\twhile(r<rb[i])\n\t\t{\n\t\t\tt1++,t2+=b[r];\n\t\t\tr++;\n\t\t}\n\t\tll cur1=s1.que(b[i]+n+1),cur2=s2.que(b[i]+n+1);\n\t\t{\n\t\t\tll x=cur1,sx=cur2;\n\t\t\tll y=c1-x,sy=c2-sx;\n\t\t\tans2+=x*b[i]-sx;\n\t\t\tans2+=sy-y*b[i];\n\t\t}\n\t\t{\n\t\t\tll ct1=t1-c1,ct2=t2-c2;\n\t\t\tll x=prect[i]-cur1,sx=presm[i]-cur2;\n\t\t\tll y=ct1-x,sy=ct2-sx;\n\t\t\t// printf(\"%lld %lld %lld %lld\\n\",x,sx,y,sy);\n\t\t\tans+=x*b[i]-sx;\n\t\t\tans+=sy-y*b[i];\n\t\t}\n\t}\n}\n\nint main()\n{\n\tios::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tcin>>n>>a;\n\tfor(int i=n;i>=1;i--) a[i]=a[i-1]-'a';\n\tint cnt[3]={0,0,0},tt=0;\n\tauto add=[&](int x){tt+=(++cnt[x]==1);};\n\tauto del=[&](int x){tt-=(--cnt[x]==0);};\n\tfor(int i=1,l=1;i<=n;i++)\n\t{\n\t\tadd(a[i]);\n\t\twhile(tt==3) del(a[l++]);\n\t\tif(l>1) add(a[--l]);\n\t\tlb[i]=(tt==3?l:0);\n\t}\n\tauto doit=[&](int x,int y){\n\t\tmemset(cnt,0,sizeof(cnt)),tt=0;\n\t\tfor(int i=1,l=1;i<=n;i++)\n\t\t{\n\t\t\tadd(a[i]);\n\t\t\twhile(cnt[x]>0&&cnt[y]>0) del(a[l++]);\n\t\t\tif(l>1) add(a[--l]);\n\t\t\trb[i]=(cnt[x]>0&&cnt[y]>0?l:0);\n\t\t}\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif(a[i]==x) b[i]=1;\n\t\t\telse if(a[i]==y) b[i]=-1;\n\t\t\telse b[i]=0;\n\t\tfor(int i=1;i<=n;i++) b[i]+=b[i-1];\n\t\tcalc();\n\t};\n\t// doit(0,1);\n\tdoit(0,1),doit(0,2),doit(1,2);\n\t// cout<<ans<<'\\n';\n\tcout<<ans+ans2/2<<'\\n';\n\treturn 0;\n}\n```\n\n",
			"tags": [{"name":"做题记录"},{"name":"结论"},{"name":"数据结构"}],
			"title": "QOJ12181 abc 做题记录",
			"link": "https://exber.qzz.io/post/QOJ12181%20abc%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2026-01-27 16:57:38"
		},
	
		{
			"abstract": "\n> 给定一个 $n$ 个点 $m$ 条边的无向图，一些点上有充电站。有一个火车初始在点 $S$ 且满电，火车走到一个充电站会充满电，充满电的火车走 $n$ 条边就会没电。\n>\n> Alice 和 Bob 开始博弈，每个节点属于 Alice 或者 Bob。当火车走到某个点 $x$ 时，若其是第一次到达 $x$，则拥有 $x$ 的人指定一条 $x$ 的出边 $x\\to y$ 并删除 $x$ 的其它出边。火车以后在点 $x$ 就会沿着 $x\\to y$ 走。\n>\n> Alice 想让火车永远运行下去，Bob 则要阻止 Alice。\n>\n> 对于每个点 $S\\in [1,n]$ 判断火车从这里出发的话能否永远运行下去。\n>\n> $1\\le n\\le 5000$，$n\\le m\\le 2\\times 10^4$，每个点至少有一条出边。\n\n",
			"content": "\n> 给定一个 $n$ 个点 $m$ 条边的无向图，一些点上有充电站。有一个火车初始在点 $S$ 且满电，火车走到一个充电站会充满电，充满电的火车走 $n$ 条边就会没电。\n>\n> Alice 和 Bob 开始博弈，每个节点属于 Alice 或者 Bob。当火车走到某个点 $x$ 时，若其是第一次到达 $x$，则拥有 $x$ 的人指定一条 $x$ 的出边 $x\\to y$ 并删除 $x$ 的其它出边。火车以后在点 $x$ 就会沿着 $x\\to y$ 走。\n>\n> Alice 想让火车永远运行下去，Bob 则要阻止 Alice。\n>\n> 对于每个点 $S\\in [1,n]$ 判断火车从这里出发的话能否永远运行下去。\n>\n> $1\\le n\\le 5000$，$n\\le m\\le 2\\times 10^4$，每个点至少有一条出边。\n\n\n观察到每个点 $x$ 处的决策应该是固定的，即就算不删其它出边，之后再到达 $x$ 也会选择同样的出边 $x\\to y$，否则不如我一开始就不选择 $x\\to y$。\n\n那么问题就变成每次某个人选择一条出边走，问能不能经过充电站无限次。\n\n考虑对充电站 $i$ 求出 $f_i$ 表示从它出发能否到达无限个充电站，最后再跑一遍拓扑即可求出每个点的答案。\n\n而 $f_i$ 是可以迭代求的，刚开始设置 $f_i=[i\\text{ 是充电站}]$，然后跑一次拓扑求出 $g_i$ 表示从 $i$ 出发能否到达下一个 $f_j=1$ 的点（不算起点 $i$，但可以走一圈回来），令 $f_i:=f_i\\land g_i$。这样最多迭代 $n$ 轮，每一轮复杂度 $O(n+m)$，故总时间复杂度 $O(n^2+nm)$。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nnamespace Exber\n{\n\nconst int S=5005;\n\nint n,m;\nvector<int> g[S];\nint ind[S],d[S];\nint hed,til,que[S*2];\nbool f[S],nf[S];\n\nvector<int> doit(\n\tvector<int> a,\n\tvector<int> r,\n\tvector<int> u,\n\tvector<int> v\n){\n\tn=a.size();\n\tm=u.size();\n\tfor(int i=0;i<n;i++) g[i].clear(),ind[i]=0;\n\tfor(int i=0;i<m;i++) g[v[i]].push_back(u[i]),ind[u[i]]++;\n\tfor(int i=0;i<n;i++) f[i]=r[i];\n\tauto doit=[&](){\n\t\thed=1,til=0;\n\t\tfor(int i=0;i<n;i++) nf[i]=false;\n\t\tfor(int i=0;i<n;i++)\n\t\t\tif(a[i]) d[i]=1;\n\t\t\telse d[i]=ind[i]; \n\t\tfor(int i=0;i<n;i++) if(f[i]) que[++til]=i;\n\t\twhile(hed<=til)\n\t\t{\n\t\t\tint u=que[hed++];\n\t\t\tfor(int v:g[u])\n\t\t\t\tif(--d[v]==0&&!nf[v])\n\t\t\t\t{\n\t\t\t\t\tnf[v]=true;\n\t\t\t\t\tif(!f[v]) que[++til]=v;\n\t\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++) f[i]&=nf[i];\n\t};\n\tfor(int i=1;i<=n+1;i++) doit();\n\tvector<int> res;\n\tfor(int i=0;i<n;i++) res.push_back(nf[i]);\n\treturn res;\n}\n\n}\n\nvector<int> who_wins(\n\tvector<int> a,\n\tvector<int> r,\n\tvector<int> u,\n\tvector<int> v\n){\n\treturn Exber::doit(a,r,u,v);\n}\n\n// int main()\n// {\n\t// ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\t// int n,m;\n\t// cin>>n>>m;\n\t// vector<int> a(n),r(n),u(m),v(m);\n\t// for(int &x:a) cin>>x;\n\t// for(int &x:r) cin>>x;\n\t// for(int i=0;i<m;i++) cin>>u[i]>>v[i];\n\t// vector<int> res=who_wins(a,r,u,v);\n\t// for(int x:res) cout<<x<<' ';\n\t// cout<<'\\n';\n\t// return 0;\n// }\n```\n\n",
			"tags": [{"name":"做题记录"},{"name":"博弈论"},{"name":"结论"}],
			"title": "P3838 [IOI 2017] Toy Train 做题记录",
			"link": "https://exber.qzz.io/post/P3838%20%5BIOI%202017%5D%20Toy%20Train%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2026-01-27 15:24:54"
		},
	
		{
			"abstract": "\n> 有 $n$ 名选手，编号为 $i$ 的选手的实力值为 $i$。所有选手分为红、蓝两队，其中编号为 $i$ 的选手所在的队伍用字符 $s_i$ 描述。\n>\n> 现在将所有选手排成一个环，每一对相邻且不属于同一队的选手会进行一场比赛，实力值较大的选手获胜，他所在的队伍的得分增加一。\n>\n> 然而，蓝队的选手勾结了裁判，如果一场比赛中红队选手获胜，且他在蓝队选手的顺时针方向上，则这场比赛不计入得分。\n>\n> 现在你想知道，对于每个 $k \\in [-n,n]$，有多少种将选手排列的方法，使得红队得分恰好比蓝队得分大 $k$。两种方案不同，当且仅当存在某个选手，使得他顺时针方向的下一个选手在两个方案中不同。\n>\n> 对 $998244353$ 取模。\n>\n> $1\\le n\\le 3000$。\n\n",
			"content": "\n> 有 $n$ 名选手，编号为 $i$ 的选手的实力值为 $i$。所有选手分为红、蓝两队，其中编号为 $i$ 的选手所在的队伍用字符 $s_i$ 描述。\n>\n> 现在将所有选手排成一个环，每一对相邻且不属于同一队的选手会进行一场比赛，实力值较大的选手获胜，他所在的队伍的得分增加一。\n>\n> 然而，蓝队的选手勾结了裁判，如果一场比赛中红队选手获胜，且他在蓝队选手的顺时针方向上，则这场比赛不计入得分。\n>\n> 现在你想知道，对于每个 $k \\in [-n,n]$，有多少种将选手排列的方法，使得红队得分恰好比蓝队得分大 $k$。两种方案不同，当且仅当存在某个选手，使得他顺时针方向的下一个选手在两个方案中不同。\n>\n> 对 $998244353$ 取模。\n>\n> $1\\le n\\le 3000$。\n\n\n首先有一个朴素的连续段 dp：考虑从小到大插入每个人，记录当前的连续段相关信息。不过这个做法没有前途。\n\n注意到这个不计入得分很可疑。观察性质，设 $[R<B]$ 表示相邻两个人按顺时针分别属于红队和蓝队，且第一个人的编号比第二个人小的位置数，$[R>B],[B<R],[B>R]$ 同理。我们关心的即为 $ans=[B<R]-[B>R]-[R<B]$。\n\n注意到由于是环，故 $[RB]=[BR]$，那么 $[R>B]+[R<B]=[B>R]+[B<R]$，$[B<R]+[B>R]-[R<B]=[R>B]$。所以 $ans=[R>B]-2[B>R]$。\n\n那么现在我们只关心两个对称的量，而且都是前面比后面大的关系。\n\n这是好做的，直接从编号为 $1$ 的人后面把环切开，变成序列问题。钦定存在 $i$ 个 $[R>B]$ 和 $j$ 个 $[B>R]$，那么会形成 $n-i-j$ 条链，去掉包含 $1$ 的被固定的链，链间重排的方案数为 $(n-i-j-1)!$。而 $[R>B]$ 和 $[B>R]$ 是独立的，因为一个关心 $R$ 的出度和 $B$ 的入度，另一个关心 $B$ 的出度和 $R$ 的入度，那么直接跑两次二分图匹配计数即可，这部分复杂度 $O(n^2)$。\n\n接下来要进行容斥，设钦定 $i$ 个 $[R>B]$ 和 $j$ 个 $[B>R]$ 的方案数为 $f_{i,j}$，容斥显然可以两维单独进行，要求的形式形如 $g_{i,j}=\\sum\\limits_{k\\ge j}(-1)^{k-j}\\binom{k}{j}f_{i,k}$，使用 NTT 加速卷积即可。这部分复杂度 $O(n^2\\log n)$。\n\n总复杂度 $O(n^2\\log n)$，代码如下：\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\n#define p 998244353\n\ninline void add(int &x,int y)\n{\n\tx+=y;\n\tif(x>=p) x-=p;\n}\ninline int qpow(int x,int y)\n{\n\tint res=1;\n\tfor(;y>0;y>>=1,x=1ll*x*x%p) res=y&1?1ll*res*x%p:res;\n\treturn res;\n}\n\nconst int S=3005;\n\nnamespace ploy\n{\n\tint rev[S*4];\n\tinline int getlen(int n)\n\t{\n\t\tint x=1;\n\t\twhile(x<n) x<<=1;\n\t\treturn x;\n\t}\n\tinline void NTT(int n,int* const a,int t)\n\t{\n\t\tfor(int i=0;i<n;i++) rev[i]=(rev[i>>1]>>1)|(i&1?n>>1:0);\n\t\tfor(int i=0;i<n;i++) if(i<rev[i]) swap(a[i],a[rev[i]]);\n\t\tint g=(t==1?3:qpow(3,p-2));\n\t\tfor(int len=2;len<=n;len<<=1)\n\t\t{\n\t\t\tint Wn=qpow(g,(p-1)/len);\n\t\t\tint mid=len>>1;\n\t\t\tfor(int l=0;l<n-len+1;l+=len)\n\t\t\t\tfor(int i=0,Wk=1;i<mid;i++,Wk=1ll*Wk*Wn%p)\n\t\t\t\t{\n\t\t\t\t\tint x=a[l+i],y=1ll*a[l+mid+i]*Wk%p;\n\t\t\t\t\ta[l+i]=(x+y)%p;\n\t\t\t\t\ta[l+mid+i]=(x-y+p)%p;\n\t\t\t\t}\n\t\t}\n\t}\n\tinline void DFT(int n,int* const a){NTT(n,a,1);}\n\tinline void IDFT(int n,int* const a)\n\t{\n\t\tNTT(n,a,-1);\n\t\tint inv=qpow(n,p-2);\n\t\tfor(int i=0;i<n;i++) a[i]=1ll*a[i]*inv%p;\n\t}\n}\n\nint fra[S],inv[S],C[S][S];\nint n;\nchar a[S];\nvector<int> va,vb;\nint tmp[S][S],f[S],g[S],res[S][S];\nint tf[S*4],tg[S*4];\nint ans[S*2];\n\nint main()\n{\n\tfra[0]=1;\n\tfor(int i=1;i<=S-3;i++) fra[i]=1ll*fra[i-1]*i%p;\n\tinv[S-3]=qpow(fra[S-3],p-2);\n\tfor(int i=S-3;i>=1;i--) inv[i-1]=1ll*inv[i]*i%p;\n\tfor(int i=0;i<=S-3;i++)\n\t{\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<=S-3;j++) C[i][j]=(C[i-1][j]+C[i-1][j-1])%p;\n\t}\n\tios::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tcin>>n;\n\tcin>>a;\n\tfor(int i=n;i>=1;i--) a[i]=(a[i-1]=='R'?0:1);\n\tfor(int i=n;i>=1;i--)\n\t\tif(a[i]==0) va.push_back(i);\n\t\telse vb.push_back(i);\n\tauto doit=[&](int* const f,vector<int> &va,vector<int> &vb){\n\t\tint n=va.size(),m=vb.size();\n\t\tmemset(tmp,0,sizeof(tmp));\n\t\ttmp[0][0]=1;\n\t\tfor(int i=1,x=0;i<=n;i++)\n\t\t{\n\t\t\twhile(x<m&&vb[x]>va[i-1]) x++;\n\t\t\tfor(int j=0;j<=i-1&&j<=x;j++)\n\t\t\t{\n\t\t\t\tint w=tmp[i-1][j];\n\t\t\t\tif(w==0) continue;\n\t\t\t\tadd(tmp[i][j],w);\n\t\t\t\tadd(tmp[i][j+1],1ll*w*(x-j)%p);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=n;i++) f[i]=tmp[n][i];\n\t};\n\tdoit(f,va,vb);\n\tdoit(g,vb,va);\n\tint na=va.size(),nb=vb.size();\n\tfor(int i=0;i<=na;i++)\n\t\tfor(int j=0;j<=nb;j++)\n\t\t{\n\t\t\tint pre=1ll*f[i]*g[j]%p;\n\t\t\tif(pre==0) continue;\n\t\t\tpre=1ll*pre*fra[n-i-j-1]%p;\n\t\t\tres[i][j]=pre;\n\t\t}\n\t{\n\t\tmemset(tg,0,sizeof(tg));\n\t\tint m=ploy::getlen(nb*2+1);\n\t\tfor(int j=0;j<=nb;j++) tg[j]=inv[j];\n\t\tploy::DFT(m,tg);\n\t\tfor(int i=0;i<=na;i++)\n\t\t{\n\t\t\tmemset(tf,0,sizeof(tf));\n\t\t\tfor(int j=0;j<=nb;j++)\n\t\t\t{\n\t\t\t\tint pre=1ll*res[i][j]*fra[j]%p;\n\t\t\t\tif(j&1) tf[nb-j]=(p-pre)%p;\n\t\t\t\telse tf[nb-j]=pre;\n\t\t\t}\n\t\t\tploy::DFT(m,tf);\n\t\t\tfor(int j=0;j<m;j++) tf[j]=1ll*tf[j]*tg[j]%p;\n\t\t\tploy::IDFT(m,tf);\n\t\t\tfor(int j=0;j<=nb;j++)\n\t\t\t{\n\t\t\t\tint pre=1ll*tf[nb-j]*inv[j]%p;\n\t\t\t\tif(j&1) res[i][j]=(p-pre)%p;\n\t\t\t\telse res[i][j]=pre;\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tmemset(tg,0,sizeof(tg));\n\t\tint m=ploy::getlen(na*2+1);\n\t\tfor(int j=0;j<=na;j++) tg[j]=inv[j];\n\t\tploy::DFT(m,tg);\n\t\tfor(int i=0;i<=nb;i++)\n\t\t{\n\t\t\tmemset(tf,0,sizeof(tf));\n\t\t\tfor(int j=0;j<=na;j++)\n\t\t\t{\n\t\t\t\tint pre=1ll*res[j][i]*fra[j]%p;\n\t\t\t\tif(j&1) tf[na-j]=(p-pre)%p;\n\t\t\t\telse tf[na-j]=pre;\n\t\t\t}\n\t\t\tploy::DFT(m,tf);\n\t\t\tfor(int j=0;j<m;j++) tf[j]=1ll*tf[j]*tg[j]%p;\n\t\t\tploy::IDFT(m,tf);\n\t\t\tfor(int j=0;j<=na;j++)\n\t\t\t{\n\t\t\t\tint pre=1ll*tf[na-j]*inv[j]%p;\n\t\t\t\tif(j&1) res[j][i]=(p-pre)%p;\n\t\t\t\telse res[j][i]=pre;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<=na;i++)\n\t\tfor(int j=0;j<=nb;j++)\n\t\t{\n\t\t\tif(res[i][j]==0) continue;\n\t\t\tint x=i*2-j;\n\t\t\tadd(ans[n-x],res[i][j]);\n\t\t}\n\tfor(int i=-n;i<=n;i++) cout<<ans[n+i]<<' ';\n\tcout<<'\\n';\n\treturn 0;\n}\n```\n\n\n\n",
			"tags": [{"name":"做题记录"},{"name":"组合计数"},{"name":"结论"}],
			"title": "P11426 [清华集训 2024] 比赛 做题记录",
			"link": "https://exber.qzz.io/post/P11426%20%5B%E6%B8%85%E5%8D%8E%E9%9B%86%E8%AE%AD%202024%5D%20%E6%AF%94%E8%B5%9B%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2026-01-27 08:20:42"
		},
	
		{
			"abstract": "\n> 二维平面上存在 $n$ 个点，第 $i$ 个点位于 $(i,p_i)$，其中 $p$ 是一个 $n$ 的排列。\n>\n> 每次操作可以选择将平面横切一刀或者竖切一刀，递归左右/上下两半（先递归进左/上），直到范围内只剩下一个点，将其加入答案序列末尾。\n>\n> 求最终能生成多少种本质不同的答案序列，对 $10^9+7$ 取模。\n>\n> $1\\le n\\le 30$。\n\n",
			"content": "\n> 二维平面上存在 $n$ 个点，第 $i$ 个点位于 $(i,p_i)$，其中 $p$ 是一个 $n$ 的排列。\n>\n> 每次操作可以选择将平面横切一刀或者竖切一刀，递归左右/上下两半（先递归进左/上），直到范围内只剩下一个点，将其加入答案序列末尾。\n>\n> 求最终能生成多少种本质不同的答案序列，对 $10^9+7$ 取模。\n>\n> $1\\le n\\le 30$。\n\n\n首先有一个朴素的想法：设 $dp_{l,r,u,d}$ 表示 $[l,r]\\times [u,d]$ 范围内的点能生成多少种序列，转移枚举第一刀怎么切。\n\n这样显然会算重。\n\n考虑钦定每个答案序列一定由字典序最小的切割方案生成，这需要我们钦定一种字典序。\n\n如果钦定切 $x$ 小于切 $y$ 且同种升序排列的话就输了。我们需要充分利用两维的对称性，钦定字典序为 $x_1<y_1<x_2<y_2<\\dots<x_{m-1}<y_{m-1}$，其中 $x_i$ 表示切成 $[1,x_i]\\times [1,m]$ 和 $[x_i+1,m]\\times [1,m]$，$y_i$ 同理。\n\n那么容斥，先离散化将范围变成 $[1,m]\\times [1,m]$，设 $f_i,g_i$ 分别表示第一刀为 $x_i,y_i$ 且第一刀符合字典序限制的切割 $[1,i]\\times [1,m],[1,m]\\times [1,i]$ 的方案数。这么设状态假定了只有左/上半中切的刀会导致这第一刀违反字典序限制。\n\n那么先来考虑 $f$，显然无限制的方案数是 $dp_{1,i,1,m}$。\n\n显然只有左半中的第一刀可能导致字典序违法，分情况讨论：\n\n- 第一刀是 $x_j$，那么枚举 $j<i$，夹在中间的部分无影响：令 $f_i:=f_i-\\sum\\limits_{j<i} f_j\\times dp_{j+1,i,1,m}$；\n\n- 第一刀是 $y_j$，此时需要从 $g_j$ 转移过来，观察平面被划分的四个区域：\n\n  ![](../post-images/ARC138F_1.jpg)\n\n  因此绿 $2$ 和绿 $3$ 必须有至少一个区域中无点。\n\n  如果绿 $3$ 中无点，绿 $1,3$ 两个区域的方案数直接就是 $f_j$。可惜绿 $3$ 中有点，绿 $2$ 中无点的方案我们没有刻画。\n\n  似乎卡住了？但是注意到 $j<i$，所以区域 $1$ 中的点数一定 $\\le j<i$，而绿 $1,2$ 两个区域中总点数为 $i$，故绿 $2$ 中一定有点。\n\n  所以合法时绿 $3$ 中一定无点，直接用 $f_j$ 进行转移即可。\n\n那么 $f$ 的转移就做完了。\n\n$g$ 是类似的，不过从 $f$ 转移到 $g$ 时当 $i=j$ 会出现红 $2$ 可以无点的情况。不过此时红 $1,2,3$ 中的点一定都集中在红 $1$ 处，所以依旧可以直接用 $f$ 来转移。\n\n那么就做完了，时间复杂度 $O(n^6)$。\n\n状压的形式很好写，代码如下：\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\n#define p 1000000007\n\ninline void add(int &x,int y)\n{\n\tx+=y;\n\tif(x>=p) x-=p;\n}\n\nnamespace exb\n{\n\t#define p2 1145143\n\tvector<pair<int,int> > vec[p2];\n\tinline void ins(int x,int y){vec[x%p2].emplace_back(x,y);}\n\tinline int get(int x)\n\t{\n\t\tint id=x%p2;\n\t\tfor(auto t:vec[id]) if(t.first==x) return t.second;\n\t\treturn -1;\n\t}\n}\n\nconst int S=35;\n\n#define popc(x) __builtin_popcount(x)\n\nint n,a[S];\n\nint dp(int st)\n{\n\tif(popc(st)<=1) return 1;\n\tif(exb::get(st)!=-1) return exb::get(st);\n\tvector<int> px,py;\n\tfor(int i=1;i<=n;i++)\n\t\tif(st>>i-1&1) px.push_back(i),py.push_back(a[i]);\n\tsort(py.begin(),py.end());\n\tint m=popc(st)-1;\n\tvector<int> sx(m,0),sy(m,0);\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tfor(int j=1;j<=px[i];j++)\n\t\t\tif(st>>j-1&1) sx[i]|=(1<<j-1);\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif((st>>j-1&1)&&a[j]<=py[i]) sy[i]|=(1<<j-1);\n\t}\n\tint res=0;\n\tvector<int> f(m,0),g(m,0);\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tf[i]=dp(sx[i]),g[i]=dp(sy[i]);\n\t\tfor(int j=0;j<i;j++)\n\t\t\tadd(f[i],p-1ll*f[j]*dp(sx[i]^sx[j])%p),\n\t\t\tadd(g[i],p-1ll*g[j]*dp(sy[i]^sy[j])%p);\n\t\tfor(int j=0;j<i;j++) // g -> f\n\t\t\tif(((st^sx[i])&sy[j])==0)\n\t\t\t\tadd(f[i],p-1ll*g[j]*dp(sx[i]^sy[j])%p);\n\t\tfor(int j=0;j<=i;j++) // f -> g\n\t\t\tif(((st^sy[i])&sx[j])==0)\n\t\t\t\tadd(g[i],p-1ll*f[j]*dp(sy[i]^sx[j])%p);\n\t\tadd(res,1ll*f[i]*dp(st^sx[i])%p);\n\t\tadd(res,1ll*g[i]*dp(st^sy[i])%p);\n\t}\n\texb::ins(st,res);\n\treturn res;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\tcout<<dp((1<<n)-1)<<'\\n';\n\treturn 0;\n}\n```\n\n",
			"tags": [{"name":"做题记录"},{"name":"结论"},{"name":"DP"}],
			"title": "ARC138F KD Tree 做题记录",
			"link": "https://exber.qzz.io/post/ARC138F%20KD%20Tree%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2026-01-26 20:27:23"
		},
	
		{
			"abstract": "\n> 给定一个长 $n$，值域 $[0,n-1]$ 的序列 $a$。$q$ 次查询，第 $i$ 次查询给定区间 $[l_i,r_i]$，求以下问题的答案：\n>\n> - 令 $b=a_{[l_i,r_i]}$，你可以进行无限次如下操作：\n>   - 找到一对下标 $i<j$ 使得 $b_i=b_j$，将 $b_i$ 修改为 $\\max(b_i-1,0)$ 或者 $b_i+1$；\n> - 求最终 $b$ 的 $\\text{MEX}$ 的最大值；\n>\n> $1\\le n,q\\le 5\\times 10^5$。\n\n",
			"content": "\n> 给定一个长 $n$，值域 $[0,n-1]$ 的序列 $a$。$q$ 次查询，第 $i$ 次查询给定区间 $[l_i,r_i]$，求以下问题的答案：\n>\n> - 令 $b=a_{[l_i,r_i]}$，你可以进行无限次如下操作：\n>   - 找到一对下标 $i<j$ 使得 $b_i=b_j$，将 $b_i$ 修改为 $\\max(b_i-1,0)$ 或者 $b_i+1$；\n> - 求最终 $b$ 的 $\\text{MEX}$ 的最大值；\n>\n> $1\\le n,q\\le 5\\times 10^5$。\n\n\n相当于查询最大的 $w$ 使得区间内 $<w$ 的数的个数 $cnt$ 等于 $w$。\n\n这个东西没有单调性，不好处理，于是考虑在答案维上从大到小扫描线，维护每个询问的 $c_i=cnt_i-w$，每次把 $cnt_i-w=0$ 的询问拉出来回答。\n\n考虑 $w\\to w-1$ 会发生什么，首先每个询问的 $c_i$ 会增加 $1$，这是好维护的；然后依次找到所有 $a_p=w-1$ 的位置，将包含 $a_p$ 的询问的 $c_i$ 减少 $1$，这是不好维护的。\n\n发动注意力，注意到若询问区间互不包含，那么每次 $c_i$ 减少 $1$ 的询问是一个区间，直接用线段树做区间减即可。\n\n继续观察，其实询问区间有包含也是一样的，由于小区间的答案一定 $\\le $ 包含它的大区间的答案，所以每次找到所有极大的互不包含的区间跑上面的做法，删掉一个区间的时候加入新冒出来的小区间即可。\n\n时间复杂度 $O(n\\log n)$，代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <set>\n#include <vector>\n\nusing namespace std;\n\nconst int S=500005,inf=1e8;\n\nint n,q,a[S];\nint ql[S],qr[S];\nvector<int> vec[S];\nint ans[S];\n\nnamespace zseg\n{\n\tconst int TS=10000005;\n\tint cnt,ls[TS],rs[TS];\n\tint sm[TS],rt[S];\n\tinline void upda(int u){sm[u]=sm[ls[u]]+sm[rs[u]];}\n\tvoid addp(int &u,int l,int r,int p,int x)\n\t{\n\t\tcnt++;\n\t\tsm[cnt]=sm[u];\n\t\tls[cnt]=ls[u],rs[cnt]=rs[u];\n\t\tu=cnt;\n\t\tif(l==r) return sm[u]+=x,void();\n\t\tint mid=l+r>>1;\n\t\tif(p<=mid) addp(ls[u],l,mid,p,x);\n\t\telse addp(rs[u],mid+1,r,p,x);\n\t\tupda(u);\n\t}\n\tint quelr(int u,int v,int l,int r,int L,int R)\n\t{\n\t\tif(u==0&&v==0) return 0;\n\t\tif(l>R||r<L) return 0;\n\t\tif(l>=L&&r<=R) return sm[u]-sm[v];\n\t\tint mid=l+r>>1,res=0;\n\t\tif(L<=mid) res+=quelr(ls[u],ls[v],l,mid,L,R);\n\t\tif(R>=mid+1) res+=quelr(rs[u],rs[v],mid+1,r,L,R);\n\t\treturn res;\n\t}\n\tinline void init()\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\trt[i]=rt[i-1];\n\t\t\taddp(rt[i],0,n,a[i],1);\n\t\t}\n\t}\n\tinline int quelr(int l,int r,int vl,int vr)\n\t{\n\t\tif(vl>vr) return 0;\n\t\treturn quelr(rt[r],rt[l-1],0,n,vl,vr);\n\t}\n}\n\nnamespace seg1\n{\n\tset<pair<int,int> > st[S],seg;\n\tint mxr[S<<2];\n\tinline void upda(int u){mxr[u]=max(mxr[u<<1],mxr[u<<1|1]);}\n\tvoid build(int u,int l,int r)\n\t{\n\t\tif(l==r)\n\t\t{\n\t\t\tif(!st[l].empty()) mxr[u]=-st[l].begin()->first;\n\t\t\telse mxr[u]=0;\n\t\t\treturn;\n\t\t}\n\t\tint mid=l+r>>1;\n\t\tbuild(u<<1,l,mid),build(u<<1|1,mid+1,r);\n\t\tupda(u);\n\t}\n\tvoid updp(int u,int l,int r,int p)\n\t{\n\t\tif(l==r)\n\t\t{\n\t\t\tif(!st[l].empty()) mxr[u]=-st[l].begin()->first;\n\t\t\telse mxr[u]=0;\n\t\t\treturn;\n\t\t}\n\t\tint mid=l+r>>1;\n\t\tif(p<=mid) updp(u<<1,l,mid,p);\n\t\telse updp(u<<1|1,mid+1,r,p);\n\t\tupda(u);\n\t}\n\tint quep(int u,int l,int r,int x)\n\t{\n\t\tif(mxr[u]<=x) return 0;\n\t\tif(l==r)\n\t\t{\n\t\t\tif(!st[l].empty()) return st[l].begin()->second;\n\t\t\treturn 0;\n\t\t}\n\t\tint mid=l+r>>1;\n\t\tif(mxr[u<<1]>x) return quep(u<<1,l,mid,x);\n\t\telse return quep(u<<1|1,mid+1,r,x);\n\t}\n\tinline vector<int> init()\n\t{\n\t\tfor(int i=1;i<=q;i++) st[ql[i]].emplace(-qr[i],i);\n\t\tbuild(1,1,n);\n\t\tvector<int> res;\n\t\tint r=0;\n\t\twhile(1)\n\t\t{\n\t\t\tint id=quep(1,1,n,r);\n\t\t\tif(id==0) break;\n\t\t\t// printf(\"+ %d\\n\",id);\n\t\t\tres.push_back(id);\n\t\t\tseg.emplace(ql[id],id);\n\t\t\tr=qr[id];\n\t\t}\n\t\treturn res;\n\t}\n\tinline vector<int> del(int id)\n\t{\n\t\t// printf(\"- %d\\n\",id);\n\t\tst[ql[id]].erase(make_pair(-qr[id],id));\n\t\tseg.erase(make_pair(ql[id],id));\n\t\tupdp(1,1,n,ql[id]);\n\t\tint r;\n\t\tauto rp=seg.lower_bound(make_pair(ql[id],id));\n\t\tif(rp==seg.begin()) r=0;\n\t\telse r=qr[prev(rp)->second];\n\t\t// printf(\"r = %d\\n\",r);\n\t\tvector<int> res;\n\t\twhile(1)\n\t\t{\n\t\t\tint id=quep(1,1,n,r);\n\t\t\tif(id==0||seg.count(make_pair(ql[id],id))) break;\n\t\t\t// printf(\"+ %d\\n\",id);\n\t\t\tres.push_back(id);\n\t\t\tseg.emplace(ql[id],id);\n\t\t\tr=qr[id];\n\t\t}\n\t\treturn res;\n\t}\n}\n\nnamespace seg2\n{\n\tint idx[S];\n\tint tag[S<<2],mx[S<<2],mxr[S<<2];\n\tinline void upda(int u)\n\t{\n\t\tmx[u]=max(mx[u<<1],mx[u<<1|1]);\n\t\tmxr[u]=max(mxr[u<<1],mxr[u<<1|1]);\n\t}\n\tinline void addtag(int u,int x)\n\t{\n\t\tif(mxr[u]==0) return;\n\t\ttag[u]+=x,mx[u]+=x;\n\t}\n\tinline void dwntag(int u)\n\t{\n\t\tif(tag[u]==0) return;\n\t\taddtag(u<<1,tag[u]),addtag(u<<1|1,tag[u]);\n\t\ttag[u]=0;\n\t}\n\tvoid build(int u,int l,int r)\n\t{\n\t\ttag[u]=0,mx[u]=-inf,mxr[u]=0;\n\t\tif(l==r) return;\n\t\tint mid=l+r>>1;\n\t\tbuild(u<<1,l,mid),build(u<<1|1,mid+1,r);\n\t}\n\tvoid updp(int u,int l,int r,int p,int id,int w)\n\t{\n\t\tif(l==r)\n\t\t{\n\t\t\tif(id>0)\n\t\t\t{\n\t\t\t\tidx[p]=id;\n\t\t\t\tmx[u]=w,mxr[u]=qr[id];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tidx[p]=0;\n\t\t\t\tmx[u]=-inf,mxr[u]=0;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tdwntag(u);\n\t\tint mid=l+r>>1;\n\t\tif(p<=mid) updp(u<<1,l,mid,p,id,w);\n\t\telse updp(u<<1|1,mid+1,r,p,id,w);\n\t\tupda(u);\n\t}\n\tint fndl(int u,int l,int r,int p)\n\t{\n\t\tif(l==r) return l;\n\t\tdwntag(u);\n\t\tint mid=l+r>>1;\n\t\tif(mxr[u<<1]>=p) return fndl(u<<1,l,mid,p);\n\t\telse return fndl(u<<1|1,mid+1,r,p);\n\t}\n\tvoid addlr(int u,int l,int r,int L,int R,int x)\n\t{\n\t\tif(l>R||r<L) return;\n\t\tif(l>=L&&r<=R) return addtag(u,x),void();\n\t\tdwntag(u);\n\t\tint mid=l+r>>1;\n\t\tif(L<=mid) addlr(u<<1,l,mid,L,R,x);\n\t\tif(R>=mid+1) addlr(u<<1|1,mid+1,r,L,R,x);\n\t\tupda(u);\n\t}\n\tint fnd0(int u,int l,int r)\n\t{\n\t\tif(l==r) return idx[l];\n\t\tdwntag(u);\n\t\tint mid=l+r>>1;\n\t\tif(mx[u<<1]==0) return fnd0(u<<1,l,mid);\n\t\telse return fnd0(u<<1|1,mid+1,r);\n\t}\n\tinline void insid(int id,int w)\n\t{\n\t\tupdp(1,1,n,ql[id],id,\n\t\t\tzseg::quelr(ql[id],qr[id],0,w-1)-w);\n\t}\n\tinline void delid(int id)\n\t{\n\t\tupdp(1,1,n,ql[id],-id,0);\n\t}\n\tinline void init(vector<int> vec,int w)\n\t{\n\t\tbuild(1,1,n);\n\t\tfor(int x:vec) insid(x,w);\n\t}\n\tinline void doit(int w) // w -> w-1\n\t{\n\t\taddlr(1,1,n,1,n,1);\n\t\tfor(int x:vec[w-1])\n\t\t{\n\t\t\tint l=fndl(1,1,n,x);\n\t\t\tif(l<=x) addlr(1,1,n,l,x,-1);\n\t\t}\n\t}\n\tinline vector<int> flush()\n\t{\n\t\tvector<int> res;\n\t\twhile(mx[1]==0)\n\t\t{\n\t\t\tint id=fnd0(1,1,n);\n\t\t\tres.push_back(id);\n\t\t\tdelid(id);\n\t\t}\n\t\treturn res;\n\t}\n}\n\nint main()\n{\n\tios::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tcin>>n>>q;\n\tfor(int i=1;i<=n;i++) cin>>a[i],vec[a[i]].push_back(i);\n\tfor(int i=1;i<=q;i++) cin>>ql[i]>>qr[i];\n\tzseg::init();\n\tseg2::init(seg1::init(),n);\n\tfor(int w=n;w>=0;w--)\n\t{\n\t\t// printf(\"-------\\n%d:\\n\",w);\n\t\twhile(1)\n\t\t{\n\t\t\tvector<int> cur=seg2::flush(),nxt;\n\t\t\tif(cur.empty()) break;\n\t\t\tfor(int x:cur)\n\t\t\t{\n\t\t\t\tans[x]=w;\n\t\t\t\tvector<int> tmp=seg1::del(x);\n\t\t\t\tfor(int id:tmp) nxt.push_back(id);\n\t\t\t}\n\t\t\tfor(int x:nxt) seg2::insid(x,w);\n\t\t}\n\t\tif(w>0) seg2::doit(w);\n\t}\n\tfor(int i=1;i<=q;i++) cout<<ans[i]<<'\\n';\n\treturn 0;\n}\n```\n\n",
			"tags": [{"name":"做题记录"},{"name":"数据结构"},{"name":"结论"}],
			"title": "QOJ964 Excluded Min 做题记录",
			"link": "https://exber.qzz.io/post/QOJ964%20Excluded%20Min%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2026-01-24 21:46:18"
		},
	
		{
			"abstract": "\n> 给定 $n,C$ 和一棵 $n$ 个点的树 $T$，根据 $T$ 构建一个新的 $n$ 个点的无向图 $G$：\n>\n> - $\\forall 1\\le x<y\\le n$，$(u,v)\\in G$ 当且仅当树 $T$ 中 $u,v$ 间距离 $\\le C$；\n>\n> $m$ 次询问，每次给定一个区间 $[l,r]$，求 $G$ 中编号在 $[l,r]$ 内的点的导出子图有多少个连通块。\n>\n> $1\\le C\\le n\\le 3\\times 10^5$，$1\\le m\\le 6\\times 10^5$。\n\n",
			"content": "\n> 给定 $n,C$ 和一棵 $n$ 个点的树 $T$，根据 $T$ 构建一个新的 $n$ 个点的无向图 $G$：\n>\n> - $\\forall 1\\le x<y\\le n$，$(u,v)\\in G$ 当且仅当树 $T$ 中 $u,v$ 间距离 $\\le C$；\n>\n> $m$ 次询问，每次给定一个区间 $[l,r]$，求 $G$ 中编号在 $[l,r]$ 内的点的导出子图有多少个连通块。\n>\n> $1\\le C\\le n\\le 3\\times 10^5$，$1\\le m\\le 6\\times 10^5$。\n\n\n发现 $G$ 中的连边不好刻画，考虑为每个连通块找到一个代表元。\n\n发动智慧，钦定代表元为每个连通块中树上 bfs 序最小的点。\n\n要证明这样钦定是对的，仅需证明任意点 $x$ 都不能通过某个 bfs 序比它大的点 $y$ 走到 bfs 序比它小的点。\n\n首先 bfs 序比 $x$ 小的点 $v$ 一定有 $dep_v\\le dep_x$。\n\n那么首先 $dep_y>dep_x$ 的 $y$ 不需要考虑，而对于 $dep_y=dep_x$ 的 $y$，由于 $dep_v=dep_x$ 的 $v$ 是第 $dep_x$ 层的一个 dfn 序上的前缀，故它们也不会违法。\n\n那么就做完了，点分治对于每个 $u$ 找到 bfs 序比它小的那些点中 $u$ 编号的前驱后继，然后扫描线即可。\n\n由于信息是最值类型的，所以点分治时可以直接将当前分治范围的所有点拉出来按照到分治中心的距离排序，然后依次加入线段树，并在线段树上二分。\n\n时间复杂度 $O(n\\log ^2n+q\\log n)$，需要卡常。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nconst int S=300005,inf=1e8;\n\nint n,m,k;\nvector<int> g[S];\nvector<pair<int,int> > qq[S];\nint cnt,dfn[S];\nint hed,til,que[S];\nint pre[S],suf[S];\nvector<int> vec[S];\nint c[S];\nint ans[S*2];\n\ninline void addc(int i,int x)\n{\n\tfor(;i<=n;i+=i&-i) c[i]+=x;\n}\ninline int quec(int i)\n{\n\tint res=0;\n\tfor(;i>=1;i-=i&-i) res+=c[i];\n\treturn res;\n}\n\ninline void bfs()\n{\n\thed=1,til=0;\n\tque[++til]=1;\n\tdfn[1]=++cnt;\n\twhile(hed<=til)\n\t{\n\t\tint u=que[hed++];\n\t\tfor(int v:g[u])\n\t\t\tif(dfn[v]==0)\n\t\t\t{\n\t\t\t\tdfn[v]=++cnt;\n\t\t\t\tque[++til]=v;\n\t\t\t}\n\t}\n}\n\nnamespace dfz\n{\n\tnamespace seg\n\t{\n\t\tint mn[S<<2];\n\t\tvoid build(int u,int l,int r)\n\t\t{\n\t\t\tmn[u]=inf;\n\t\t\tif(l==r) return;\n\t\t\tint mid=l+r>>1;\n\t\t\tbuild(u<<1,l,mid),build(u<<1|1,mid+1,r);\n\t\t}\n\t\tvoid updp(int u,int l,int r,int p,int x)\n\t\t{\n\t\t\tmn[u]=min(mn[u],x);\n\t\t\tif(l==r) return;\n\t\t\tint mid=l+r>>1;\n\t\t\tif(p<=mid) updp(u<<1,l,mid,p,x);\n\t\t\telse updp(u<<1|1,mid+1,r,p,x);\n\t\t}\n\t\tvoid delp(int u,int l,int r,int p)\n\t\t{\n\t\t\tmn[u]=inf;\n\t\t\tif(l==r) return;\n\t\t\tint mid=l+r>>1;\n\t\t\tif(p<=mid) delp(u<<1,l,mid,p);\n\t\t\telse delp(u<<1|1,mid+1,r,p); \n\t\t}\n\t\tint fndpre(int u,int l,int r,int p,int x)\n\t\t{\n\t\t\tif(mn[u]>=x) return 0;\n\t\t\tif(l==r) return l;\n\t\t\tint mid=l+r>>1,ls=u<<1,rs=u<<1|1;\n\t\t\tif(r<p)\n\t\t\t{\n\t\t\t\tif(mn[rs]<x) return fndpre(rs,mid+1,r,p,x);\n\t\t\t\telse return fndpre(ls,l,mid,p,x);\n\t\t\t}\n\t\t\tif(p>mid+1)\n\t\t\t{\n\t\t\t\tint res=fndpre(rs,mid+1,r,p,x);\n\t\t\t\tif(res==0) return fndpre(ls,l,mid,p,x);\n\t\t\t\telse return res;\n\t\t\t}\n\t\t\treturn fndpre(ls,l,mid,p,x);\n\t\t}\n\t\tint fndsuf(int u,int l,int r,int p,int x)\n\t\t{\n\t\t\tif(mn[u]>=x) return n+1;\n\t\t\tif(l==r) return l;\n\t\t\tint mid=l+r>>1,ls=u<<1,rs=u<<1|1;\n\t\t\tif(l>p)\n\t\t\t{\n\t\t\t\tif(mn[ls]<x) return fndsuf(ls,l,mid,p,x);\n\t\t\t\telse return fndsuf(rs,mid+1,r,p,x);\n\t\t\t}\n\t\t\tif(p<mid)\n\t\t\t{\n\t\t\t\tint res=fndsuf(ls,l,mid,p,x);\n\t\t\t\tif(res==n+1) return fndsuf(rs,mid+1,r,p,x);\n\t\t\t\telse return res;\n\t\t\t}\n\t\t\treturn fndsuf(rs,mid+1,r,p,x);\n\t\t}\n\t}\n\tbool vis[S];\n\tint siz[S];\n\tint hed,til,que[S];\n\tint m,d[S],pot[S];\n\tvoid getsiz(int u,int fa)\n\t{\n\t\tsiz[u]=1;\n\t\tfor(int v:g[u])\n\t\t\tif(v!=fa&&!vis[v])\n\t\t\t{\n\t\t\t\tgetsiz(v,u);\n\t\t\t\tsiz[u]+=siz[v];\n\t\t\t}\n\t}\n\tvoid getrt(int u,int fa,int r,int &rt,int &rtsiz)\n\t{\n\t\tint mx=siz[r]-siz[u];\n\t\tfor(int v:g[u])\n\t\t\tif(v!=fa&&!vis[v])\n\t\t\t{\n\t\t\t\tgetrt(v,u,r,rt,rtsiz);\n\t\t\t\tmx=max(mx,siz[v]);\n\t\t\t}\n\t\tif(mx<rtsiz) rt=u,rtsiz=mx;\n\t}\n\tvoid bfs(int u)\n\t{\n\t\tm=0;\n\t\thed=1,til=0;\n\t\tque[++til]=u;\n\t\td[u]=0;\n\t\twhile(hed<=til)\n\t\t{\n\t\t\tint u=que[hed++];\n\t\t\tpot[++m]=u;\n\t\t\tif(d[u]>k) continue;\n\t\t\tfor(int v:g[u])\n\t\t\t\tif(!vis[v]&&d[v]==0)\n\t\t\t\t{\n\t\t\t\t\td[v]=d[u]+1;\n\t\t\t\t\tque[++til]=v;\n\t\t\t\t}\n\t\t}\n\t}\n\tvoid doit(int u)\n\t{\n\t\tvis[u]=true;\n\t\tbfs(u);\n\t\tint r=1;\n\t\tfor(int i=m;i>=1;i--)\n\t\t{\n\t\t\twhile(r<=m&&d[pot[r]]+d[pot[i]]<=k)\n\t\t\t{\n\t\t\t\tseg::updp(1,1,n,pot[r],dfn[pot[r]]);\n\t\t\t\tr++;\n\t\t\t}\n\t\t\tif(r>1)\n\t\t\t{\n\t\t\t\tint u=pot[i];\n\t\t\t\tpre[u]=max(pre[u],seg::fndpre(1,1,n,u,dfn[u]));\n\t\t\t\tsuf[u]=min(suf[u],seg::fndsuf(1,1,n,u,dfn[u]));\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<r;i++) seg::delp(1,1,n,pot[i]);\n\t\tfor(int i=1;i<=m;i++) d[pot[i]]=0;\n\t\tfor(int v:g[u])\n\t\t\tif(!vis[v])\n\t\t\t{\n\t\t\t\tgetsiz(v,u);\n\t\t\t\tint rt=v,rtsiz=inf;\n\t\t\t\tgetrt(v,u,v,rt,rtsiz);\n\t\t\t\tdoit(rt);\n\t\t\t}\n\t}\n\tvoid doit()\n\t{\n\t\tfor(int i=1;i<=n;i++) pre[i]=0,suf[i]=n+1;\n\t\tgetsiz(1,0);\n\t\tint rt=1,rtsiz=inf;\n\t\tgetrt(1,0,1,rt,rtsiz);\n\t\tseg::build(1,1,n);\n\t\tdoit(rt);\n\t}\n}\n\nint main()\n{\n\tios::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tcin>>n>>m>>k;\n\tfor(int i=2,x;i<=n;i++)\n\t{\n\t\tcin>>x;\n\t\tg[i].push_back(x);\n\t\tg[x].push_back(i);\n\t\t// printf(\"%d %d\\n\",i,x);\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint l,r;\n\t\tcin>>l>>r;\n\t\tqq[r].emplace_back(i,l);\n\t}\n\tbfs();\n\tdfz::doit();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tvec[i].push_back(-pre[i]);\n\t\tvec[suf[i]].push_back(pre[i]);\n\t\tvec[suf[i]].push_back(-i);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\taddc(n-i+1,1);\n\t\tfor(int x:vec[i])\n\t\t\tif(x>0) addc(n-x+1,1);\n\t\t\telse addc(n-(-x)+1,-1);\n\t\tfor(auto t:qq[i])\n\t\t\tans[t.first]=quec(n-t.second+1);\n\t}\n\tfor(int i=1;i<=m;i++) cout<<ans[i]<<'\\n';\n\treturn 0;\n}\n```\n\n",
			"tags": [{"name":"做题记录"},{"name":"数据结构"},{"name":"结论"}],
			"title": "P7126 [Ynoi2008] rdCcot 做题记录",
			"link": "https://exber.qzz.io/post/P7126%20%5BYnoi2008%5D%20rdCcot%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2026-01-23 21:57:28"
		},
	
		{
			"abstract": "\n> 给定 $n,k$ 和一个长 $n$ 的序列 $a$，每次操作可以：\n>\n> 1. 选择一个长度 $\\le d$ 的区间 $[l,r]$；\n> 2. 令 $c=\\max\\limits_{i\\in[l,r]} a_i$；\n> 3. 若 $c\\not=0$ 则 $\\forall i\\in[l,r]\\land a_i=c$，令 $a_i:=a_i-1$；\n>\n> 求至少需要多少次操作才能将 $a$ 变为全 $0$ 序列。\n>\n> $1\\le d\\le n\\le 5\\times 10^5$，$1\\le a_i\\le 10^9$。\n\n",
			"content": "\n> 给定 $n,k$ 和一个长 $n$ 的序列 $a$，每次操作可以：\n>\n> 1. 选择一个长度 $\\le d$ 的区间 $[l,r]$；\n> 2. 令 $c=\\max\\limits_{i\\in[l,r]} a_i$；\n> 3. 若 $c\\not=0$ 则 $\\forall i\\in[l,r]\\land a_i=c$，令 $a_i:=a_i-1$；\n>\n> 求至少需要多少次操作才能将 $a$ 变为全 $0$ 序列。\n>\n> $1\\le d\\le n\\le 5\\times 10^5$，$1\\le a_i\\le 10^9$。\n\n\n类似的题：[QOJ8612 The Best Wife](https://qoj.ac/problem/8612)\n\n显然可以通过交换操作的顺序使得每次操作都覆盖全局最大值，那么按全局最大值给操作划分阶段，阶段 $w$ 的目标是将所有初始时 $a_i\\ge w$ 的 $a_i$（现在已经减少为 $w$）变成 $w-1$。\n\n相当于要选最少的长度 $\\le d$ 的线段覆盖所有 $a_i\\ge w$ 的位置，这个是经典问题，设 $p$ 为最靠前的未被覆盖的位置，那么每次一定是贪心地放一个线段覆盖 $[p,p+d-1]$。\n\n这时可以按阶段做，分块维护这个贪心做到 $O(n\\sqrt n)$。\n\n但更聪明的做法是将所有阶段的贪心一起做。\n\n在每个位置 $i$ 维护一个阶段集合 $S_i$ 表示这些阶段考虑完了位置 $[1,i-1]$，刚开始 $S_1=\\{1,2,3,\\dots,\\infin\\}$。从左往右扫，扫到位置 $i$ 时将 $T=S_{i}\\cap[1,a_i]$ 从 $S_i$ 中分裂出来，扔到 $S_{\\min(i+d,n+1)}$ 去，并将答案加上 $|T|$。\n\n直接使用线段树/平衡树分裂合并即可，由于合并产生的额外复杂度来源于分裂时新建的节点，而分裂复杂度是 $O(n\\log n)$ 的，故时间复杂度 $O(n\\log n)$。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=500005;\n\nint n,d,a[S];\nint tot,b[S],rt[S];\nint ans[S];\n\nnamespace seg\n{\n\tconst int TS=20000005;\n\tint cnt,ls[TS],rs[TS],val[TS],tag[TS];\n\tinline void init()\n\t{\n\t\tfor(int i=1;i<=cnt;i++) ls[i]=rs[i]=val[i]=tag[i]=0;\n\t\tcnt=0;\n\t}\n\tinline void addtag(int u,int x){val[u]+=x,tag[u]+=x;}\n\tinline void dwntag(int u)\n\t{\n\t\tif(tag[u]==0) return;\n\t\tif(ls[u]!=0) addtag(ls[u],tag[u]);\n\t\tif(rs[u]!=0) addtag(rs[u],tag[u]);\n\t\ttag[u]=0;\n\t}\n\tvoid build(int &u,int l,int r)\n\t{\n\t\tu=++cnt;\n\t\tif(l==r) return;\n\t\tint mid=l+r>>1;\n\t\tbuild(ls[u],l,mid),build(rs[u],mid+1,r);\n\t}\n\tvoid split(int u,int &x,int &y,int l,int r,int p)\n\t{\n\t\tif(u==0) return x=y=0,void();\n\t\tif(l==r) return x=u,y=0,void();\n\t\tdwntag(u);\n\t\tx=u,y=++cnt;\n\t\tls[y]=ls[u],rs[y]=rs[u];\n\t\tint mid=l+r>>1;\n\t\tif(p<=mid) rs[x]=0,split(ls[u],ls[x],ls[y],l,mid,p);\n\t\telse ls[y]=0,split(rs[u],rs[x],rs[y],mid+1,r,p);\n\t}\n\tint merge(int x,int y,int l,int r)\n\t{\n\t\tif(x==0||y==0) return x+y;\n\t\tif(l==r) return x;\n\t\tdwntag(x),dwntag(y);\n\t\tint mid=l+r>>1;\n\t\tls[x]=merge(ls[x],ls[y],l,mid);\n\t\trs[x]=merge(rs[x],rs[y],mid+1,r);\n\t\treturn x;\n\t}\n\tvoid dfs(int u,int l,int r)\n\t{\n\t\tif(l==r) return ans[l]=val[u],void();\n\t\tdwntag(u);\n\t\tint mid=l+r>>1;\n\t\tdfs(ls[u],l,mid),dfs(rs[u],mid+1,r);\n\t}\n\tvoid print(int u,int l,int r)\n\t{\n\t\tif(u==0) return;\n\t\tif(l==r) return printf(\"(%d %d) \",l,val[u]),void();\n\t\tdwntag(u);\n\t\tint mid=l+r>>1;\n\t\tprint(ls[u],l,mid),print(rs[u],mid+1,r);\n\t}\n}\n\ninline void slove()\n{\n\tcin>>n>>d;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\tfor(int i=1;i<=n;i++) b[i]=a[i];\n\tsort(b+1,b+n+1);\n\ttot=unique(b+1,b+n+1)-b-1;\n\tfor(int i=1;i<=n;i++) a[i]=lower_bound(b+1,b+tot+1,a[i])-b;\n\tfor(int i=0;i<=n+1;i++) rt[i]=0;\n\tseg::init();\n\tseg::build(rt[0],1,tot);\n\tfor(int i=1;i<=n+1;i++)\n\t{\n\t\t// printf(\"%d:\\n\",i);\n\t\t// seg::print(rt[i],1,tot);\n\t\t// printf(\"\\n\");\n\t\trt[i]=seg::merge(rt[i],rt[i-1],1,tot);\n\t\tif(i<=n)\n\t\t{\n\t\t\tint to=min(i+d,n+1);\n\t\t\tint tmp=0;\n\t\t\tseg::split(rt[i],tmp,rt[i],1,tot,a[i]);\n\t\t\tif(tmp!=0) seg::addtag(tmp,1);\n\t\t\trt[to]=seg::merge(rt[to],tmp,1,tot);\n\t\t}\n\t\t// seg::print(rt[i],1,tot);\n\t\t// printf(\"\\n\");\n\t}\n\tseg::dfs(rt[n+1],1,tot);\n\t// for(int i=1;i<=tot;i++) cout<<ans[i]<<' ';cout<<'\\n';\n\tlong long res=0;\n\tfor(int i=1;i<=tot;i++) res+=1ll*ans[i]*(b[i]-b[i-1]);\n\tcout<<res<<'\\n';\n}\n\nint main()\n{\n\tios::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tint T;\n\tcin>>T;\n\twhile(T-->0) slove();\n\treturn 0;\n}\n```\n\n",
			"tags": [{"name":"做题记录"},{"name":"数据结构"},{"name":"贪心"},{"name":"结论"}],
			"title": "CF2097E Clearing the Snowdrift 做题记录",
			"link": "https://exber.qzz.io/post/CF2097E%20Clearing%20the%20Snowdrift%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2026-01-23 15:33:58"
		},
	
		{
			"abstract": "\n>给定 $n$ 和长 $n$ 的序列 $A$，求有多少对 $S,T\\subseteq \\{1,2,3,\\dots,n\\}$ 满足 $S,T$ 不能均为空且 $S\\cap T=\\empty$ 且 $\\oplus_{i\\in S}A_i=\\oplus_{i\\in T}A_i$，其中 $\\oplus$ 为异或。\n>\n>$1\\le n\\le 10^6$，$0\\le A_i\\le 10^6$。\n\n",
			"content": "\n>给定 $n$ 和长 $n$ 的序列 $A$，求有多少对 $S,T\\subseteq \\{1,2,3,\\dots,n\\}$ 满足 $S,T$ 不能均为空且 $S\\cap T=\\empty$ 且 $\\oplus_{i\\in S}A_i=\\oplus_{i\\in T}A_i$，其中 $\\oplus$ 为异或。\n>\n>$1\\le n\\le 10^6$，$0\\le A_i\\le 10^6$。\n\n\n相当于要求 $S\\cap T=\\empty,\\oplus_{i\\in S\\cup T}A_i=0$。\n\n也即求 $[x^0]\\prod\\limits_i(1+2x^{A_i})$，其中乘法是 XOR 意义下的，即 $x^ax^b=x^{a\\oplus b}$。相当于做 FWT 后，点乘起来，再 IFWT 回去。\n\n考虑 $1+2x^{A_i}$ 的异或 FWT：\n$$\n[x^S]\\text{FWT}(1+2x^{A_i})=1+2\\times(-1)^{|S\\cap A_i|}\n$$\n相当于要对每个 $S$ 快速求：\n$$\n\\prod\\limits_i\\left(1+2\\times(-1)^{|S\\cap A_i|}\\right)\n$$\n发动注意力，注意到对 $\\sum\\limits_{i}x^{A_i}$ 做异或 FWT 可以求出 $\\sum\\limits_{i}(-1)^{|S\\cap A_i|}$，那么解方程即可知道有多少个 $i$ 贡献 $-1$，有多少个 $i$ 贡献 $1$。\n\n时间复杂度 $O(V\\log V+n)$，其中 $V=10^6$，代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\n#define p 998244353\n#define inv2 499122177\n\nconst int XORC[2][2]={{1,1},{1,p-1}};\nconst int IXORC[2][2]={{inv2,inv2},{inv2,p-inv2}};\n\ninline void FWT(int n,int a[],const int C[2][2])\n{\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<(1<<n);j++)\n\t\t\tif(j>>i&1^1)\n\t\t\t{\n\t\t\t\tint x=a[j],y=a[j+(1<<i)];\n\t\t\t\ta[j]=(1ll*x*C[0][0]+1ll*y*C[0][1])%p;\n\t\t\t\ta[j+(1<<i)]=(1ll*x*C[1][0]+1ll*y*C[1][1])%p;\n\t\t\t}\n}\n\ninline int qpow(int x,int y)\n{\n\tint res=1;\n\tfor(;y>0;y>>=1,x=1ll*x*x%p) res=y&1?1ll*res*x%p:res;\n\treturn res;\n}\n\nconst int BS=1<<20;\n\nint n,a[BS],res[BS];\n\nint main()\n{\n\tios::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tcin>>n;\n\tfor(int i=1,x;i<=n;i++) cin>>x,a[x]++;\n\tFWT(20,a,XORC);\n\tfor(int s=0;s<BS;s++)\n\t{\n\t\tint sm=a[s]>n?a[s]-p:a[s];\n\t\tint x=(n+sm)/2;\n\t\tint y=n-x;\n\t\tres[s]=1ll*qpow(3,x)*qpow(p-1,y)%p;\n\t}\n\tFWT(20,res,IXORC);\n\tcout<<(res[0]-1+p)%p<<'\\n';\n\treturn 0;\n}\n```\n\n",
			"tags": [{"name":"做题记录"},{"name":"结论"},{"name":"多项式、生成函数"},{"name":"组合计数"}],
			"title": "UOJ310 黎明前的巧克力 做题记录",
			"link": "https://exber.qzz.io/post/UOJ310%20%E9%BB%8E%E6%98%8E%E5%89%8D%E7%9A%84%E5%B7%A7%E5%85%8B%E5%8A%9B%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2026-01-22 19:22:52"
		},
	
		{
			"abstract": "",
			"content": "### 定义\n\n设全集 $[n]=\\{1,2,3,\\dots,n\\}$ 和环 $R$（例如全体整数和加法、乘法构成的整数环）。\n\n在 $[n]$ 和 $R$ 上定义集合幂级数 $F$ 为从 $S\\subseteq [n]$ 到 $R$ 的映射，即一个大小为 $2^n$ 的数组，$F_i$ 为 $i$ 对应的集合 $S$（用二进制表示每个元素是否存在）映射到的 $R$ 中的元素。\n\n定义集合幂级数上的运算：\n\n- 加法：$(F+G)_S=F_S+G_S$；\n- OR 乘法：$(F*G)_S=\\sum\\limits_{X,Y\\subseteq U,X\\cup Y =S}F_XG_Y$（同理还能定义 AND 乘法、XOR 乘法等）；\n\n一般定义集合幂级数间的乘法为**无交并乘法**，因为大部分时候其组合意义鲜明：\n$$\n(F\\times G)_S=\\sum\\limits_{X\\subseteq S} F_XG_{S-X}\n$$\n这使得集合幂级数也可以看作是要求每个元次数 $\\in\\{0,1\\}$ 的 $n$ 元形式幂级数：\n$$\nF(x_1,x_2,x_3,\\dots,x_n)=\\sum\\limits_{S\\subseteq [n]}F_S\\prod\\limits_{i\\in S}x_i\n$$\n那么也可以定义集合幂级数的幂运算 $F^x$，其中指数 $x$ 是非负整数，$F^0=1$（即 $F^0_{\\empty}=1$，其它项为 $0$）。\n\n### 高维前缀和（FMT）\n\n探讨如何计算无交并乘法。\n\n定义集合幂级数的高维前缀和（FMT）：\n$$\n\\text{FMT}(F)_S=\\sum\\limits_{T\\subseteq S} F_T\n$$\n显然可以在 $O(n2^n)$ 的复杂度内求出，而其逆变换 $\\text{IFMT}$ 也可以在 $O(n2^n)$ 的复杂度内完成。\n\n考虑其性质：\n\n- $\\text{FMT}(F+G)_S=\\sum\\limits_{T\\subseteq S}F_T+G_T=\\text{FMT}(F)_S+\\text{FMT}(G)_S$；\n- $\\text{FMT}(F*G)_S=\\sum\\limits_{T\\subseteq S}\\sum\\limits_{X,Y\\subseteq U,X\\cup Y = T} F_XG_Y=\\sum\\limits_{X,Y\\subseteq U,X\\cup Y\\subseteq S} F_XG_Y=\\text{FMT}(F)_S\\times \\text{FMT}(G)_S$；\n\n于是 $F*G$ 可以通过两次 $\\text{FMT}$ 加一次 $\\text{IFMT}$ 完成，复杂度 $O(n2^n)$。（这实际上相当于按位 OR 的 FWT）\n\n而对于 $\\text{FMT}(F\\times G)$，相当于在计算 $\\text{FMT}(F*G)$ 的同时要求 $|X|+|Y|=|S|$，那么令 $R'=R[x]$，即 $R$ 上的多项式环，并令 $F'_S=x^{|S|}F_S$，$G'_S=x^{|S|}G_S$，则 $\\text{FMT}(F\\times G)_S=[x^{|S|}]\\text{FMT}(F'*G')_S$。\n\n实现时一般分开对 $x$ 的每个次幂跑 $\\text{FMT}$，于是 $F\\times G$ 可以通过 $R[x]$ 上的 $n$ 次 $\\text{FMT}$，$2^n$ 次 $n$ 次多项式乘法和一次 $\\text{IFMT}$ 完成，复杂度 $n^22^n$。\n\n### 集合幂级数和形式幂级数复合\n\n对于同样定义在 $R$ 上的形式幂级数 $H(x)\\in R[x]$，设其为 $H(x)=\\sum\\limits_{i=0}^\\infin h_ix^i$。\n\n定义集合幂级数 $F$ 在 $H$ 上的复合 $H(F)$：\n$$\nH(F)=\\sum\\limits_{i=0}^\\infin h_iF^i\n$$\n\n由于 $\\text{FMT}$ 性质优良，考虑无交并乘法的计算过程，注意到有：\n$$\n\\text{FMT}(H(F))_S=\\sum\\limits_{i=0}^\\infin h_i\\text{FMT}(F^i)_S=[x^{|S|}]\\sum\\limits_{i=0}^\\infin h_i\\text{FMT}(F')^i_S\n$$\n\n也就是相当于在做完 $\\text{FMT}$ 后的 $2^n$ 个 $n$ 次多项式上分别做 $H$ 的模 $x^{n+1}$ 意义下的复合，所以 $H(F)$ 可以直接 $O(n^32^n)$ 算出。\n\n但对于简单的 $H$，一般可以 $O(n^2)$ 递推计算该复合。若无法直接写出递推，也可以通过求导将次数界 $-1$，从而解微分方程推得。\n\n接下来设 $F=\\sum\\limits_{i=0}^n f_ix^i$，即分开考虑做完 $\\text{FMT}$ 后的 $2^n$ 个 $n$ 次多项式。\n\n#### 常规方法\n\n##### 求逆\n\n令 $G=\\frac{1}{F}$，有 $GF=1$，即：\n$$\n[i=0]=\\sum\\limits_{j=0}^i f_jg_{i-j}\n$$\n故有：\n$$\ng_0=\\frac{1}{f_0}\\\\\ng_i=-\\frac{1}{f_0}\\sum\\limits_{j=0}^{i-1} g_jf_{i-j}\n$$\n可以 $O(n^2)$ 递推。\n\n##### exp\n\n此时要求 $f_0=0$ 即原来的集合幂级数有 $F_{\\empty}=0$。\n\n令 $G=e^F$，两边同时求导有 $G'=F'e^F=F'G$，故：\n$$\ng_0=1\\\\\nig_i=\\sum\\limits_{j=0}^{i-1}g_j(i-j)f_{i-j}\n$$\n可以 $O(n^2)$ 递推。\n\n##### ln\n\n此时要求 $f_0=1$ 即原来的集合幂级数有 $F_{\\empty}=1$。\n\n令 $G=\\ln(F)$，同时求导有 $G'=\\frac{F'}{F}$。\n\n那么直接给 $F$ 求逆，再乘上 $F'$，最后积分回去即可。复杂度 $O(n^2)$。\n\n##### k-exp\n\n例题：[LOJ154 集合划分计数](https://loj.ac/p/154)\n\n这是 $G=H(F)=\\sum\\limits_{i=0}^k \\frac{F^i}{i!}$ 的情况。\n\n显然 $g_0=1$，对其求导：\n$$\n\\begin{aligned}\nG'&=F'\\sum\\limits_{i=0}^{k-1}\\frac{F^i}{i!}\\\\\n&=F'\\left(G-\\frac{F^k}{k!}\\right)\\\\\n&=F'G-\\frac{F'F^k}{k!}\n\\end{aligned}\n$$\n那么只要求出 $F^k$ 就好做了，令 $M=F^k$，同时求导：\n$$\n\\begin{aligned}\nM'&=kF'F^{k-1}\\\\\nM'&=kF'\\frac{M}{F}\\\\\nM'F&=kMF'\n\\end{aligned}\n$$\n则：\n$$\n\\sum\\limits_{j=0}^i(j+1)m_{j+1}f_{i-j}=k\\sum\\limits_{j=0}^i m_j(i-j+1)f_{i-j+1}\n$$\n左边有 $m_{i+1}$，右边没有，故可以 $O(n^2)$ 递推出 $M$。注意特殊计算 $m_0=f_0^k$。复杂度 $O(n^2)$。\n\n#### 无脑方法——逐点牛顿迭代法\n\n可以 $O(n^22^n)$ 求集合幂级数复合上任意 $m$ 次多项式，如果能任意模数求 $[x^0]H^{(i)}$ 的话支持任意模数（ln、exp、k-exp 均可以）。\n\n无脑且跑得快。\n\n例题：[P10461 多项式复合集合幂级数](https://www.luogu.com.cn/problem/P10461)\n\n将集合幂级数看作 $n$ 元形式幂级数，即：\n$$\nF(x_1,x_2,x_3,\\dots,x_n)=\\sum\\limits_{S\\subseteq [n]}F_S\\prod\\limits_{i\\in S}x_i\n$$\n令 $G=H(F)$，对两侧求 $x_n$ 的偏导：\n$$\nG'=H'(F)\\times F'\n$$\n注意到 $G'=[x_n^1]G,F'=[x_n^1]F$，他们都不含 $x_n$，故 $H'(F)$ 含 $x_n$ 的部分无用：\n$$\n[x_n^1]G=[x_n^0]H'(F)\\times [x_n^1]F\n$$\n这样就将 $n$ 减少了 $1$，代价是要多求一个 $H'(F)$，也就是在 $n$ 减少至 $i$ 时要进行 $(n-i+1)$ 次无交并乘法。\n\n这部分时间复杂度 $O\\left(\\sum\\limits_{i=1}^n(n-i+1)i^22^i\\right)=O(n^22^n)$，来自 AI 的证明：\n\n![](../post-images/QQ20260120-214425.png)\n\n参考代码：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\n#define p 998244353\n\ninline void add(int &x,int y)\n{\n\tx+=y;\n\tif(x>=p) x-=p;\n}\n\nconst int S=25,BS=1<<20;\n\n#define popc(x) __builtin_popcount(x)\n\nint n,a[BS],f[S][S];\nint res[S][BS];\nint tmp1[S][BS],tmp2[S][BS],tmp3[S][BS];\n\ninline void FMT(int n,int a[],int w)\n{\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<(1<<n);j++)\n\t\t\tif(j>>i&1) add(a[j],w==1?a[j-(1<<i)]:p-a[j-(1<<i)]);\n}\n\ninline void mul(int n,int a[],int b[],int c[])\n{\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=0;j<(1<<n);j++)\n\t\t\ttmp1[i][j]=tmp2[i][j]=tmp3[i][j]=0;\n\tfor(int i=0;i<(1<<n);i++)\n\t\ttmp1[popc(i)][i]=a[i],tmp2[popc(i)][i]=b[i];\n\tfor(int i=0;i<=n;i++) FMT(n,tmp1[i],1),FMT(n,tmp2[i],1);\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=0;j<=n-i;j++)\n\t\t\tfor(int k=0;k<(1<<n);k++)\n\t\t\t\tadd(tmp3[i+j][k],1ll*tmp1[i][k]*tmp2[j][k]%p);\n\tfor(int i=0;i<=n;i++) FMT(n,tmp3[i],-1);\n\tfor(int i=0;i<(1<<n);i++) c[i]=tmp3[popc(i)][i];\n}\n\nint main()\n{\n\tios::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tcin>>n;\n\tfor(int i=0;i<(1<<n);i++) cin>>a[i];\n\tfor(int i=0;i<=n;i++) cin>>f[0][i];\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=n;j++)\n\t\t\tf[i][j]=1ll*(j+1)*f[i-1][j+1]%p;\n\tfor(int i=0;i<=n;i++) res[i][0]=f[i][0];\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=n-i;j++)\n\t\t\tmul(i-1,res[j+1],a+(1<<i-1),res[j]+(1<<i-1));\n\tfor(int i=0;i<(1<<n);i++) cout<<res[0][i]<<' ';\n\tcout<<'\\n';\n\treturn 0;\n}\n```\n\n并且注意到若能确定 `res` 的初值就可以支持任意模数。\n\n##### exp\n\n直接令 $H(x)=\\sum \\frac{x^i}{i!}$ 即可，有 $res_{i,0}=[x^0]H^{(i)}=1$，所以支持任意模数。\n\n##### k-exp\n\n令 $H(x)=\\sum\\limits_{i\\le k} \\frac{x^i}{i!}$，有 $res_{i,0}=[x^0]H^{(i)}=[i\\le k]$，支持任意模数。\n\n##### ln\n\n将常数项减 $1$ 后令 $H(x)=\\sum\\frac{x^i}{i}$，有 $res_{i,0}=[x^0]H^{(i)}=(-1)^{i+1}(i-1)!$，支持任意模数。\n\n##### 求逆\n\n支持任意模数当且仅当 $F_{\\empty}=1$（这就比较鸡肋，因为此时常规方法也支持任意模数）。\n\n令 $H(x)=\\frac{1}{1-x}=\\sum x^i$，那么 $\\frac{1}{F}=\\frac{1}{1-(1-F)}=H(1-F)$。\n\n注意 $H(x)$ 收敛当且仅当其常数项为 $0$，故要求 $F_{\\empty}=1$，若 $F_{\\empty}\\not=1$ 则要先将其除掉，最后由于其在分母，所以再在结果中除掉。\n",
			"tags": [{"name":"学习笔记"},{"name":"数学"},{"name":"多项式、生成函数"}],
			"title": "集合幂级数&FMT 学习笔记",
			"link": "https://exber.qzz.io/post/%E9%9B%86%E5%90%88%E5%B9%82%E7%BA%A7%E6%95%B0%26FMT%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2026-01-21 21:43:31"
		},
	
		{
			"abstract": "\n> 小 X 有 $2^n$ 个数，编号为 $0$ 到 $2^n - 1$，第 $i$ ($0 \\leq i < 2^n$) 个数为 $a_i$。\n>\n> 对于 $S \\subseteq \\{0, 1, \\ldots, 2^n - 1\\}$，定义 $f(S)$ 为集合 $S$ 中 **所有数的二进制按位与**。特别地，若 $S$ 为空集，则 $f(S) = 2^n - 1$。\n>\n> 定义两个 $\\{0, 1, \\ldots, 2^n - 1\\}$ 的子集 $P, Q$（可以为空）构成的有序对 $(P, Q)$ 是 **特别的** 当且仅当 $P \\cap Q = \\varnothing$ 且 $f(P) = f(Q)$。定义有序对 $(P, Q)$ 的 **权值** 为 **编号** 包含在 $P \\cup Q$ 内的所有数的乘积，即 $\\prod_{i \\in P \\cup Q} a_i$。特别地，若 $P \\cup Q = \\varnothing$，则有序对 $(P, Q)$ 的权值为 $1$。\n>\n> 小 X 想要知道所有特别的有序对的权值之和，请你帮助他求出这个值。由于答案可能较大，你只需要求出答案对 $998244353$ 取模后的结果。\n>\n> $2\\le n\\le 20$，$0\\le a_i<998244353$。\n\n",
			"content": "\n> 小 X 有 $2^n$ 个数，编号为 $0$ 到 $2^n - 1$，第 $i$ ($0 \\leq i < 2^n$) 个数为 $a_i$。\n>\n> 对于 $S \\subseteq \\{0, 1, \\ldots, 2^n - 1\\}$，定义 $f(S)$ 为集合 $S$ 中 **所有数的二进制按位与**。特别地，若 $S$ 为空集，则 $f(S) = 2^n - 1$。\n>\n> 定义两个 $\\{0, 1, \\ldots, 2^n - 1\\}$ 的子集 $P, Q$（可以为空）构成的有序对 $(P, Q)$ 是 **特别的** 当且仅当 $P \\cap Q = \\varnothing$ 且 $f(P) = f(Q)$。定义有序对 $(P, Q)$ 的 **权值** 为 **编号** 包含在 $P \\cup Q$ 内的所有数的乘积，即 $\\prod_{i \\in P \\cup Q} a_i$。特别地，若 $P \\cup Q = \\varnothing$，则有序对 $(P, Q)$ 的权值为 $1$。\n>\n> 小 X 想要知道所有特别的有序对的权值之和，请你帮助他求出这个值。由于答案可能较大，你只需要求出答案对 $998244353$ 取模后的结果。\n>\n> $2\\le n\\le 20$，$0\\le a_i<998244353$。\n\n\n枚举 $f(P)=f(Q)=S$，容斥：\n$$\n\\sum\\limits_{S}\\sum\\limits_{S\\subseteq A}\\sum\\limits_{S\\subseteq B}(-1)^{|A|+|B|}\\prod\\limits_{i}\\left(([A\\subseteq i]+[B\\subseteq i])a_i+1\\right)\\\\\n\\sum\\limits_{A}\\sum\\limits_{B}(-1)^{|A|+|B|}2^{|A\\cap B|}\\prod\\limits_{i}\\left(([A\\subseteq i]+[B\\subseteq i])a_i+1\\right)\\\\\n\\sum\\limits_{A}(-2)^{|A|}\\prod\\limits_{i}([A\\subseteq i]a_i+1)\\sum\\limits_{B}(-2)^{|B|}\\prod\\limits_{i}([B\\subseteq i]a_i+1)2^{|A\\cup B|}\\prod\\limits_{A\\cup B\\subseteq i}\\frac{2a_i+1}{(a_i+1)^2}\n$$\n\n令：\n$$\nf_S=(-2)^{|S|}\\prod\\limits_{S\\subseteq i} (a_i+1)\\\\\nG_S=\\frac{1}{2^{S}}\\prod\\limits_{S\\subseteq i}\\frac{2a_i+1}{(a_i+1)^2}\n$$\n则答案为：\n$$\n\\sum\\limits_{A,B}f_Af_Bg_{A\\cup B}\n$$\n出现了除以 $0$，而 FWT 过程中有加减法，所以不能直接用 $a\\times 0^b$ 维护。暴力 $O(3^n)$ 计算拼上性质 $\\text{B}$ 有 $76$ 分，场上止步于此。\n\n注意到 OR 意义下的 FWT 是高维前缀和，我们干的事情实际上是：\n\n1. 做高维前缀和（FMT）；\n2. 令 $f_i:=f_i^2$；\n3. 做高维差分（IFMT）；\n4. 计算 $\\sum f_i\\times g_i$；\n\n故 FMT 和 IFMT 时贡献到 $f_i$ 的值中 $0$ 的次数最低的（设该次数为 $c$）就是 $f_i$，而 $g_i$ 中 $0$ 的次数不小于 $-c$，故 FMT 和 IFMT 中做加减法时只需要保留 $0$ 的次数较低的那个。\n\n时间复杂度 $O(n2^n)$，代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\n#define p 998244353\n\ninline void add(int &x,int y)\n{\n\tx+=y;\n\tif(x>=p) x-=p;\n}\ninline int qpow(int x,int y)\n{\n\tint res=1;\n\tfor(;y>0;y>>=1,x=1ll*x*x%p) res=y&1?1ll*res*x%p:res;\n\treturn res;\n}\n\nconst int S=25,MS=1<<20;\n\nstruct node\n{\n\tint x,y; // x*0^y\n\tinline node(){x=y=0;}\n\tinline node(int a)\n\t{\n\t\ta%=p;\n\t\tif(a==0) x=1,y=1;\n\t\telse x=a,y=0;\n\t}\n\tinline node(int a,int b){x=a,y=b;}\n\tinline node inv(){return node(qpow(x,p-2),-y);}\n};\ninline node operator*(node x,node y)\n{\n\treturn node(1ll*x.x*y.x%p,x.y+y.y);\n}\ninline node operator+(node x,node y)\n{\n\tif(x.x==0) return y;\n\tif(y.x==0) return x;\n\tif(x.y==y.y) return node((x.x+y.x)%p,x.y);\n\tif(x.y<y.y) return x;\n\telse return y;\n}\ninline node operator-(node x){return node((p-x.x)%p,x.y);}\n\nint n,m,a[MS];\nnode f[MS],g[MS];\n\n#define popc(x) __builtin_popcount(x)\n\ninline void FMT(node a[])\n{\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<m;j++)\n\t\t\tif(j>>i&1) f[j]=f[j]+f[j-(1<<i)];\n}\ninline void IFMT(node a[])\n{\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<m;j++)\n\t\t\tif(j>>i&1) f[j]=f[j]+(-f[j-(1<<i)]);\n}\n\ninline void slove()\n{\n\tcin>>n;\n\tm=(1<<n);\n\tfor(int i=0;i<m;i++) cin>>a[i];\n\tfor(int i=0;i<m;i++)\n\t\tf[i]=node(a[i]+1),\n\t\tg[i]=node(a[i]*2+1)*(node(a[i]+1)).inv()*(node(a[i]+1)).inv();\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<m;j++)\n\t\t\tif(j>>i&1)\n\t\t\t\tf[j-(1<<i)]=f[j-(1<<i)]*f[j],\n\t\t\t\tg[j-(1<<i)]=g[j-(1<<i)]*g[j];\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tf[i]=f[i]*node(qpow(p-2,popc(i)));\n\t\tg[i]=g[i]*node(qpow(qpow(2,p-2),popc(i)));\n\t}\n\tFMT(f);\n\tfor(int i=0;i<m;i++) f[i]=f[i]*f[i];\n\tIFMT(f);\n\tint ans=0;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tnode pre=f[i]*g[i];\n\t\tif(pre.y==0) add(ans,pre.x);\n\t}\n\tcout<<ans<<'\\n';\n}\n\nint main()\n{\n\tios::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tint c,T;\n\tcin>>c>>T;\n\twhile(T-->0) slove();\n\treturn 0;\n}\n```\n\n",
			"tags": [{"name":"做题记录"},{"name":"组合计数"},{"name":"容斥"},{"name":"结论"}],
			"title": "P13275 [NOI2025] 集合 做题记录",
			"link": "https://exber.qzz.io/post/P13275%20%5BNOI2025%5D%20%E9%9B%86%E5%90%88%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2026-01-21 19:50:18"
		},
	
		{
			"abstract": "\n\n> 有 $m$ 个互不相同的盘子和 $n$ 个互不相同的苹果，现在要把每个苹果都放到 $m$ 个盘子里面的一个，总共 $m^n$ 种情况。 \n>\n> 定义一次操作为将一个苹果移动到某个相邻的盘子里。 对于一种放苹果的情况，代价为将所有苹果放到同一个盘子的最少操作的次数。 求所有 $m^n$ 种情况的代价的和。\n>\n> $1\\le n\\le 2\\times 10^5$，$1\\le m\\le 10^9$。\n\n",
			"content": "\n\n> 有 $m$ 个互不相同的盘子和 $n$ 个互不相同的苹果，现在要把每个苹果都放到 $m$ 个盘子里面的一个，总共 $m^n$ 种情况。 \n>\n> 定义一次操作为将一个苹果移动到某个相邻的盘子里。 对于一种放苹果的情况，代价为将所有苹果放到同一个盘子的最少操作的次数。 求所有 $m^n$ 种情况的代价的和。\n>\n> $1\\le n\\le 2\\times 10^5$，$1\\le m\\le 10^9$。\n\n\n$$\n\\sum\\limits_{i=0}^n\\min(i,n-i)\\binom{n}{i}\\sum\\limits_{j=1}^{m-1}j^i(m-j)^{n-i}\\\\\n\\sum\\limits_{i=0}^n\\min(i,n-i)\\binom{n}{i}\\sum\\limits_{j=1}^{m-1}\\sum \\limits_{k=0}^{n-i}\\binom{n-i}{k}j^{i+k}m^{n-i-k}\\\\\n\\sum\\limits_{i=0}^n\\min(i,n-i)\\binom{n}{i}\\sum \\limits_{k=0}^{n-i}\\binom{n-i}{k}m^{n-i-k}\\sum\\limits_{j=1}^{m-1}j^{i+k}\\\\\n$$\n\n仅需求 $\\sum\\limits_{j=1}^{m-1}j^r$，剩余部分是卷积。\n\n发动注意力，注意到 $[\\frac{x^r}{r!}]e^{jx}=j^r$，那么仅需求 $[\\frac{x^r}{r!}]\\sum\\limits_{j=1}^{m-1}e^{jx}=[\\frac{x^r}{r!}]\\frac{e^{mx}-e^x}{e^x-1}$，多项式求逆即可。\n\n时间复杂度 $O(n\\log n)$。\n",
			"tags": [{"name":"做题记录"},{"name":"结论"},{"name":"组合计数"},{"name":"多项式、生成函数"}],
			"title": "QOJ8715 放苹果 做题记录",
			"link": "https://exber.qzz.io/post/QOJ8715%20%E6%94%BE%E8%8B%B9%E6%9E%9C%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2026-01-20 20:34:24"
		},
	
		{
			"abstract": "\n> 给定 $n,k$，有 $n$ 个物品，第 $i$ 个物品有进价 $a_i$ 和售价 $b_i$。\n>\n> 你需要选择一个区间 $[l,r]$ 的物品，将其买入，并卖出其中恰好 $k$ 个物品。\n>\n> 最大化你的收益，并求出有哪些物品能在最大化收益的同时被卖出。\n>\n> $1\\le k\\le n\\le 2.5\\times 10^5$，$1\\le a_i,b_i\\le 10^9$。\n\n",
			"content": "\n> 给定 $n,k$，有 $n$ 个物品，第 $i$ 个物品有进价 $a_i$ 和售价 $b_i$。\n>\n> 你需要选择一个区间 $[l,r]$ 的物品，将其买入，并卖出其中恰好 $k$ 个物品。\n>\n> 最大化你的收益，并求出有哪些物品能在最大化收益的同时被卖出。\n>\n> $1\\le k\\le n\\le 2.5\\times 10^5$，$1\\le a_i,b_i\\le 10^9$。\n\n\n显然对于一个区间 $[l,r]$，其收益为 $b_{[l,r]}$ 的前 $k$ 大减去 $a_{[l,r]}$ 的和。这可以使用主席树实现 $O(\\log n)$ 单次计算。\n\n看到前 $k$ 大这种东西，不妨观察凸性相关性质。注意到其满足四边形不等式。\n\n那么最大收益 $ans$ 直接分治即可求出。\n\n对于一个收益为 $ans$ 的区间 $[l,r]$，设 $b_{[l,r]}$ 中第 $k$ 大值为 $x$，那么显然 $\\forall i\\in [l,r]\\land b_i\\ge x$ 的 $i$ 都可以在最大化收益的同时被卖出。\n\n问题是这样的区间可能有很多个，继续观察。\n\n称 $w(l,r)=ans$ 的 $[l,r]$ 为答案区间。\n\n继续利用四边形不等式，对于 $a<b<c<d$，若 $w(a,d)=w(b,c)=ans$，则由于相交优于包含，故 $w(a,c)=w(b,d)=ans$。注意到 $b_{[a,d]}$ 的第 $k$ 大一定大于等于 $b_{[a,c]}$ 的第 $k$ 大和 $b_{b,d}$ 的第 $k$ 大，故区间 $[a,d]$ 被支配了。\n\n所以所有严格被包含的答案区间 $[l,r]$ 都被支配了（即存在 $l'<l,r'>r$ 满足 $w(l',r')=ans$），那么剩下的答案区间一定满足左右端点不降。故对于每个 $r$，求出最大的 $lb_r$ 使得 $w(lb_r,r)=ans$ 后，以 $r$ 为右端点的答案区间 $[l,r]$ 一定满足 $l\\in [lb_{r'},lb_r]$，其中 $r'$ 为最大的 $<r$ 的存在 $lb_{r'}$ 的下标。\n\n那么这样的区间只有 $O(n)$ 个，直接使用 multiset 扫描线即可。\n\n时间复杂度 $O(n\\log n)$，代码如下：\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <set>\n#include <vector>\n\nusing namespace std;\n\nnamespace Exber\n{\n\ntypedef long long ll;\n\nconst int S=250005;\nconst ll inf=1e17;\n\nnamespace seg\n{\n\tconst int TS=10000005;\n\tll val[S];\n\tint lb[S];\n\tint cnt,ls[TS],rs[TS];\n\tll sm[TS];\n\tint tot[TS];\n\tinline void upda(int u)\n\t{\n\t\tsm[u]=sm[ls[u]]+sm[rs[u]];\n\t\ttot[u]=tot[ls[u]]+tot[rs[u]];\n\t}\n\tvoid updp(int &u,int lst,int l,int r,int p)\n\t{\n\t\tu=++cnt;\n\t\tsm[u]=sm[lst],tot[u]=tot[lst],ls[u]=ls[lst],rs[u]=rs[lst];\n\t\tif(l==r) return sm[u]=val[p],tot[u]=1,void();\n\t\tint mid=l+r>>1;\n\t\tif(p<=mid) updp(ls[u],ls[lst],l,mid,p);\n\t\telse updp(rs[u],rs[lst],mid+1,r,p);\n\t\tupda(u);\n\t}\n\tpair<ll,int> que(int u,int v,int l,int r,int k) // sm,kth\n\t{\n\t\tif(l==r) return make_pair(sm[u],lb[l]);\n\t\tint mid=l+r>>1;\n\t\tint ru=rs[u],rv=rs[v];\n\t\tif(tot[ru]-tot[rv]>=k) return que(ru,rv,mid+1,r,k);\n\t\telse\n\t\t{\n\t\t\tauto res=que(ls[u],ls[v],l,mid,k-(tot[ru]-tot[rv]));\n\t\t\tres.first+=sm[ru]-sm[rv];\n\t\t\treturn res;\n\t\t}\n\t}\n}\n\nint n,k;\nll a[S],b[S];\npair<ll,int> tmp[S];\nint rt[S],lb[S];\nvector<int> vec[S];\n\ninline ll calc(int l,int r)\n{\n\treturn seg::que(rt[r],rt[l-1],1,n,k).first-(a[r]-a[l-1]);\n}\n\nvoid slove(int l,int r,int kl,int kr)\n{\n\tif(l>r) return;\n\tint mid=l+r>>1;\n\tll mxw=-inf;\n\tint pre=0;\n\tfor(int i=kl;i<=kr&&i<=mid-k+1;i++)\n\t{\n\t\tll w=calc(i,mid);\n\t\tif(w>=mxw) mxw=w,pre=i;\n\t}\n\tlb[mid]=pre;\n\tslove(l,mid-1,kl,pre),slove(mid+1,r,pre,kr);\n}\n\nint main()\n{\n\tios::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tcin>>n>>k;\n\tfor(int i=1;i<=n;i++) cin>>a[i],a[i]+=a[i-1];\n\tfor(int i=1;i<=n;i++) cin>>b[i];\n\tfor(int i=1;i<=n;i++) tmp[i]=make_pair(b[i],i);\n\tsort(tmp+1,tmp+n+1);\n\tfor(int i=1;i<=n;i++)\n\t\tb[i]=lower_bound(tmp+1,tmp+n+1,make_pair(b[i],i))-tmp;\n\tfor(int i=1,j=1;i<=n;i++)\n\t{\n\t\twhile(tmp[j].first!=tmp[i].first) j++;\n\t\tseg::val[i]=tmp[i].first;\n\t\tseg::lb[i]=j;\n\t}\n\tfor(int i=1;i<=n;i++) seg::updp(rt[i],rt[i-1],1,n,b[i]);\n\tslove(k,n,1,n-k+1);\n\tll ans=-inf;\n\tfor(int i=k;i<=n;i++) ans=max(ans,calc(lb[i],i));\n\tfor(int i=k,lst=1;i<=n;i++)\n\t\tif(calc(lb[i],i)==ans)\n\t\t{\n\t\t\tfor(int j=lst;j<=lb[i];j++)\n\t\t\t\tif(calc(j,i)==ans)\n\t\t\t\t{\n\t\t\t\t\tint kth=seg::que(rt[i],rt[j-1],1,n,k).second;\n\t\t\t\t\tvec[j].push_back(kth);\n\t\t\t\t\tvec[i+1].push_back(-kth);\n\t\t\t\t}\n\t\t\tlst=lb[i];\n\t\t}\n\tcout<<ans<<'\\n';\n\tmultiset<int> st;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int x:vec[i])\n\t\t{\n\t\t\tif(x>0) st.insert(x);\n\t\t\telse st.erase(st.find(-x));\n\t\t}\n\t\tcout<<(!st.empty()&&b[i]>=*st.begin());\n\t}\n\tcout<<'\\n';\n\treturn 0;\n}\n\n}\n\nint main(){return Exber::main();}\n```\n\n",
			"tags": [{"name":"做题记录"},{"name":"结论"}],
			"title": "P9732 [CEOI 2023] Trade 做题记录",
			"link": "https://exber.qzz.io/post/P9732%20%5BCEOI%202023%5D%20Trade%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2026-01-19 21:27:05"
		},
	
		{
			"abstract": "\n> 给定 $n,m,L,R$ 和一棵 $n$ 个点的树，点有点权，对于每个 $i\\in [0,m]$ 求出：\n>\n> - 能否割掉树上的 $i$ 条边使得每个连通块的点权和均在 $[L,R]$ 中；\n>\n> $1\\le n\\le 1000$，$0\\le m\\le \\min(n-1,50)$，值域 $10^{18}$。\n\n",
			"content": "\n> 给定 $n,m,L,R$ 和一棵 $n$ 个点的树，点有点权，对于每个 $i\\in [0,m]$ 求出：\n>\n> - 能否割掉树上的 $i$ 条边使得每个连通块的点权和均在 $[L,R]$ 中；\n>\n> $1\\le n\\le 1000$，$0\\le m\\le \\min(n-1,50)$，值域 $10^{18}$。\n\n\n有一个朴素的 DP：\n\n> 设 $f_{u,i,w}$ 表示点 $u$ 的子树割掉 $i$ 条边能否使 $u$ 所在连通块点权和为 $w$ 且其它连通块点权和合法。\n\n考虑利用仅要求点权和在区间 $[L,R]$ 内的性质。若存在 $x<y<z$ 均满足 $f_{u,i,*}=1$，则：\n\n- 若 $s+y\\in [L,R]$ 且 $s+z\\le R$，那么可以将 $y$ 替换为 $z$；\n- 否则 $s+z\\ge R+1$，若 $z-x\\le R-L+1$ 则 $s+x\\ge L$，可以将 $y$ 替换为 $x$；\n\n故若 $z-x\\le R-L+1$ 则 $y$ 被支配，故将有用的 $w$ 从小到大排序后相邻奇数（或偶数）位间的差 $> R-L+1$。\n\n注意到对于 $f_{u,i,w}$，有用的 $w$ 一定在 $[sm_u-iR,sm_u-iL]$ 中，其中 $sm_u$ 为 $u$ 子树点权和。故有用的 $w$ 总共只有 $O(i)$ 个。\n\n那么直接对有用的 $w$ 做 dp 即可，复杂度 $O(nk^3)$，代码如下：\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int S=1005,MS=55;\n\nint n,m;\nll L,R,a[S];\nvector<int> g[S];\nvector<ll> f[S][MS],tmp[MS];\n\ninline vector<ll> reduse(vector<ll> vec)\n{\n\tsort(vec.begin(),vec.end());\n\tvector<ll> res;\n\tfor(ll x:vec)\n\t{\n\t\tint sz=res.size();\n\t\tif(sz>=2&&x-res[sz-2]<=R-L+1) res.pop_back();\n\t\tres.push_back(x);\n\t}\n\treturn res;\n}\n\nvoid dfs(int u,int fa)\n{\n\t// printf(\"%d %d\\n\",u,fa);\n\tfor(int i=0;i<=m;i++) f[u][i].clear();\n\tf[u][0].push_back(a[u]);\n\tfor(int v:g[u])\n\t{\n\t\tif(v==fa) continue;\n\t\tdfs(v,u);\n\t\tfor(int i=0;i<=m;i++) tmp[i].clear();\n\t\tfor(int i=0;i<=m;i++)\n\t\t\tfor(int j=0;j<=m-i;j++)\n\t\t\t\tfor(ll a:f[u][i])\n\t\t\t\t\tfor(ll b:f[v][j])\n\t\t\t\t\t{\n\t\t\t\t\t\tif(a+b<=R)\n\t\t\t\t\t\t\ttmp[i+j].push_back(a+b);\n\t\t\t\t\t\tif(i+j+1<=m&&L<=b&&b<=R)\n\t\t\t\t\t\t\ttmp[i+j+1].push_back(a);\n\t\t\t\t\t}\n\t\tfor(int i=0;i<=m;i++) f[u][i]=reduse(tmp[i]);\n\t}\n}\n\ninline void slove()\n{\n\tcin>>n>>m>>L>>R;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\tfor(int i=1;i<=n;i++) g[i].clear();\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tdfs(1,0);\n\tfor(int i=0;i<=m;i++) cout<<(!f[1][i].empty()&&f[1][i].back()>=L);\n\tcout<<'\\n';\n}\n\nint main()\n{\n\tios::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tint T;\n\tcin>>T;\n\twhile(T-->0) slove();\n\treturn 0;\n}\n```\n\n",
			"tags": [{"name":"做题记录"},{"name":"结论"},{"name":"DP"}],
			"title": "QOJ2562 Fake Plastic Trees 2 做题记录",
			"link": "https://exber.qzz.io/post/QOJ2562%20Fake%20Plastic%20Trees%202%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2026-01-19 21:26:56"
		},
	
		{
			"abstract": "\n> 给定 $n$ 和两个长 $n$ 的序列 $a,b$，保证 $a$ 和 $b$ 拼接起来构成 $2n$ 的排列。\n>\n> 对于 $n$ 的排列 $p$，定义 $S(p)=\\{i|i\\in [1,n]\\land  a_i>b_{p_i}\\}$。\n>\n> 对于每个 $0\\le k\\le n$ 求有多少个 $T\\subseteq \\{1,2,3,\\dots,n\\}$ 使得 $|T|=k$ 且 $\\exist p$ 使得 $S(p)=T$。\n>\n> $1\\le n\\le 5000$。\n\n",
			"content": "\n> 给定 $n$ 和两个长 $n$ 的序列 $a,b$，保证 $a$ 和 $b$ 拼接起来构成 $2n$ 的排列。\n>\n> 对于 $n$ 的排列 $p$，定义 $S(p)=\\{i|i\\in [1,n]\\land  a_i>b_{p_i}\\}$。\n>\n> 对于每个 $0\\le k\\le n$ 求有多少个 $T\\subseteq \\{1,2,3,\\dots,n\\}$ 使得 $|T|=k$ 且 $\\exist p$ 使得 $S(p)=T$。\n>\n> $1\\le n\\le 5000$。\n\n\n首先将 $a,b$ 排序，枚举 $k$，则 $T$ 中的元素一定从小到大依次匹配 $b_{[1,k]}$，$T$ 外的元素一定从小到大依次匹配 $b_{[k+1,n]}$。\n\n刻画一个 $T$ 合法的条件：\n\n1. 对于 $T$ 中的第 $i$ 小元素 $x$，要满足 $a_x>b_i$；\n2. 对于不在 $T$ 中的第 $i$ 小元素 $x$，要满足 $a_x<b_{m+i-1}$；\n\n条件 $1$ 让我们从前往后 dp，条件 $2$ 则让我们从后往前 dp。这导致它们放在一起 dp 会变成 $O(n^3)$。\n\n发动注意力：\n\n- $a$ 开头的一些元素无论如何都不会违反条件 $2$：$\\exist k_2,\\forall 1\\le i\\le k_2,a_i<b_{k+1}$\n- $a$ 结尾的一些元素无论如何都不会违反条件 $1$：$\\exist k_1,\\forall k_1\\le i\\le n,a_i>b_k$\n\n注意到有 $k_2\\ge k_1-1$，那么做完了，$a_{[1,k_2]}$ 从前往后 dp，$a_{[k_2+1,n]}$ 从后往前 dp，卷起来即可。\n\n时间复杂度 $O(n^2)$，代码如下：\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nnamespace Exber\n{\n\n#define p 998244353\n\ninline void add(int &x,int y)\n{\n\tx+=y;\n\tif(x>=p) x-=p;\n}\n\nconst int S=5005;\n\nint n,a[S],b[S];\nint f[S][S],g[S][S];\nint ans[S];\n\nint main()\n{\n\t// freopen(\"test.in\",\"r\",stdin);\n\t// freopen(\"test.out\",\"w\",stdout);\n\tios::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\tfor(int i=1;i<=n;i++) cin>>b[i];\n\tsort(a+1,a+n+1),sort(b+1,b+n+1);\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=i-1;j++)\n\t\t{\n\t\t\tint x=f[i-1][j];\n\t\t\tif(x==0) continue;\n\t\t\tif(a[i]>b[j+1]) add(f[i][j+1],x);\n\t\t\tadd(f[i][j],x);\n\t\t}\n\tg[n+1][0]=1;\n\tfor(int i=n;i>=1;i--)\n\t\tfor(int j=0;j<=n-i;j++)\n\t\t{\n\t\t\tint x=g[i+1][j];\n\t\t\tif(x==0) continue;\n\t\t\tif(a[i]<b[n-j]) add(g[i][j+1],x);\n\t\t\tadd(g[i][j],x);\n\t\t}\n\tfor(int k=0;k<=n;k++)\n\t{\n\t\tint k2=0;\n\t\tif(k==n) k2=n;\n\t\telse while(k2<n&&a[k2+1]<b[k+1]) k2++;\n\t\tfor(int i=0;i<=k;i++)\n\t\t\tif((n-k2)-(k-i)>=0)\n\t\t\t\tadd(ans[k],1ll*f[k2][i]*g[k2+1][(n-k2)-(k-i)]%p);\n\t}\n\tint q;\n\tcin>>q;\n\tfor(int i=1;i<=q;i++)\n\t{\n\t\tint l,r;\n\t\tcin>>l>>r;\n\t\tint res=0;\n\t\tfor(int i=l;i<=r;i++) add(res,ans[i]);\n\t\tcout<<res<<'\\n';\n\t}\n\treturn 0;\n}\n\n}\n\nint main(){return Exber::main();}\n```\n\n",
			"tags": [{"name":"做题记录"},{"name":"结论"}],
			"title": "P12558 [UOI 2024] Heroes and Monsters 做题记录",
			"link": "https://exber.qzz.io/post/P12558%20%5BUOI%202024%5D%20Heroes%20and%20Monsters%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2026-01-14 21:09:24"
		},
	
		{
			"abstract": "> 给定 $n,k$，求有多少个 $n$ 个点的有标号简单无向图的最小点覆盖大小为 $k$，**对 $2$ 取模**。\n>\n> $T$ 组数据，$1\\le T\\le 2^{14}$，$1\\le n<2^{14}$，$0\\le k<n$。\n",
			"content": "> 给定 $n,k$，求有多少个 $n$ 个点的有标号简单无向图的最小点覆盖大小为 $k$，**对 $2$ 取模**。\n>\n> $T$ 组数据，$1\\le T\\le 2^{14}$，$1\\le n<2^{14}$，$0\\le k<n$。\n\n\n首先根据最小点覆盖等于 $n$ 减最大独立集，转为数最大独立集大小为 $n-k$ 的图。\n\n构造双射，考虑点 $1$ 和点 $2$，若其邻点集合 $N(1),N(2)$ 满足 $N(1)\\cup\\{1,2\\}\\not= N(2)\\cup \\{1,2\\}$，那么可以交换点 $1$ 和点 $2$ 的连边。由于我们可以根据 $N(1)\\cup\\{1,2\\}$ 的大小判断该图是否已经交换过 $1,2$，故这样的双射是合法的。\n\n接下来考虑边 $(1,2)$：\n\n- 若其存在，则 $1$ 和 $2$ 中最多选一个。由于它们邻点相同，故可以直接删掉点 $1$；\n- 若其不存在，则 $1$ 和 $2$ 要么都选要么都不选。由于它们邻点相同，故可以直接合并为一个大小为 $2$ 的点；\n\n那么不妨将所有点按照大小（初始均为 $1$）排序，每次考虑最靠前的两个大小相等（假设为 $x$）的点，则它们的邻点集合必须相同。那么它们要么删掉一个，要么合并为一个大小为 $2x$ 的点（相当于两个大点之间连一个二分完全图）。\n\n这个过程可以不断进行，直到最后剩下的点大小两两不同。假设最后剩下的点集为 $S=\\{2^{a_1},2^{a_2},\\dots,2^{a_m}\\}$，其中 $0\\le a_1<a_2<a_3<\\dots<a_m$，那么每个大点内部的连边都考虑完了，现在仅需考虑这 $m$ 个大点之间的连边。\n\n注意到点的大小是 $2$ 的次幂且两两不同，故一定是按照 $a_i$ 从大往小考虑每个点，贪心地能选就选。那么假设最后有 $x$ 个点没选则方案数会有 $2^{\\binom{x}{2}}$ 的因子，故最多有 $1$ 个点没选上；假设没选上的点为 $2^x$，那么 $x$ 和 $2^{a_1}$ 之间的边可选可不选，故 $x$ 只能是 $a_1$。\n\n所以 $S$ 能贡献到最大独立集大小为 $\\sum\\limits_{1\\le i\\le m} 2^{a_i}$ 和 $\\sum\\limits_{2\\le i\\le m} 2^{a_i}$ 的情况。\n\n接下来考虑怎么求 $f_{n,S}$ 表示 $n$ 个点生产集合 $S$ 的方案数 $\\text{mod }2$ 的结果。在这里 $S$ 是二进制数，即为 $\\sum 2^{a_i}$\n\n考虑这样一个生成 $S$ 的方式：每次加入一个大小为 $1$ 的新点，并不断合并直到无法合并。\n\n那么加入最后一个点带来的影响即为产生了 $2^{a_1}$：\n\n- 若 $2^{a_1}$ 这个点原来不存在，那么 $2^{[0,a_1-1]}$ 原来均存在，加入这个点把它们合并掉了：从 $f_{n-1,S-1}$ 转移；\n- 若 $2^{a_1}$ 这个点原来存在那么 $2^{[0,a_1-1]}$ 原来均存在，加入这个点合并掉了它们并删掉了一个 $2^{a_1}$：从 $f_{n-1,S+2^{a_1}-1}$ 转移；\n\n初始值为 $f_{0,0}=1$，时间复杂度 $O(n^2)$。\n\n使用 bitset 优化空间，代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <bitset>\n\nusing namespace std;\n\nconst int S=1<<14;\n\nbitset<S> f[S],g[S];\n\nint main()\n{\n\tf[0][0]=1,g[0][0]=1;\n\tfor(int i=1;i<S;i++)\n\t{\n\t\tfor(int j=1;j<=i;j++)\n\t\t{\n\t\t\tif(f[i-1][j-1]!=f[i-1][j+(j&-j)-1]) f[i][j]=1;\n\t\t\tif(f[i][j]) g[i].flip(j),g[i].flip(j^(j&-j));\n\t\t}\n\t}\n\tios::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tint T;\n\tcin>>T;\n\twhile(T-->0)\n\t{\n\t\tint n,k;\n\t\tcin>>n>>k;\n\t\tcout<<(int)g[n][n-k]<<'\\n';\n\t}\n\treturn 0;\n}\n/*\n如果有大于一个 大小>=2 的连通块，那么：\n\t考虑最大编号前两大的连通块，考虑交换它们之中编号最小的点 x,y\n累了\n依次考虑 (1,2) (3,4) (5,6) (...,...)\n所以每一对中点的出边（除去之间的连边）要相同\n那么这些对可以缩起来\n这样不断缩，每一层剩下的那个点也可以并入下一层\n每一层剩下那个点不能并入下一层\n* 把点覆盖变成独立集：最小点覆盖 = n-最大独立集\n* 连了边相当于留在上一层\n\n*/\n```\n",
			"tags": [{"name":"做题记录"},{"name":"DP"},{"name":"组合计数"},{"name":"结论"}],
			"title": "P11613 [PA 2016] 覆盖 Pokrycia 做题记录",
			"link": "https://exber.qzz.io/post/P11613%20%5BPA%202016%5D%20%E8%A6%86%E7%9B%96%20Pokrycia%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2026-01-04 15:48:18"
		},
	
		{
			"abstract": "> 给定长度分别为 $n,m$ 的字符串 $a,b$，$q$ 次询问，每次给出 $l_a,r_a,l_b,r_b$，查询 $a_{[l_a,r_a]}$ 和 $b_{[l_b,r_b]}$ 的 LCS（最长公共子序列）的长度。\n>\n> $1\\le n,m\\le 3000$，$1\\le q\\le 10^5$，字符集为小写字母（做法与字符集大小无关）。\n",
			"content": "> 给定长度分别为 $n,m$ 的字符串 $a,b$，$q$ 次询问，每次给出 $l_a,r_a,l_b,r_b$，查询 $a_{[l_a,r_a]}$ 和 $b_{[l_b,r_b]}$ 的 LCS（最长公共子序列）的长度。\n>\n> $1\\le n,m\\le 3000$，$1\\le q\\le 10^5$，字符集为小写字母（做法与字符集大小无关）。\n\n\n考虑 LCS 的 $O(n^2)$ DP 求法：状态 $(i,j)$ 表示分别考虑完前两个序列的前 $i,j$ 个字符。\n\n建立 $n\\times m$ 的网格图，将其转移关系建边：\n\n- $(i,j)\\to (i,j+1)$，$(i,j)\\to(i+1,j)$，边权均为 $0$；\n- 若 $a_i=b_j$ 则有边 $(i,j)\\to (i+1,j+1)$，边权为 $1$；\n\n则单次询问的答案即为 $(l_a,l_b)$ 到 $(r_a+1,r_b+1)$ 的最长路。不妨把 $(x,y)$ 到 $(i,j)$ 的最长路记为 $d((x,y),(i,j))$。\n\n对于这种网格图最短/长路的问题，不妨考虑分治，每次横着切一刀，处理 $l_a\\le mid\\le r_a+1$ 的询问：由于这些询问对应的路径一定经过 $(mid,*)$，所以可以通过枚举这 $m$ 个点，计算出它们和其他点之间的最长路来处理询问。\n\n接下来的问题是怎么快速维护这 $m$ 个点和其他点之间的最长路，先来观察性质：\n\n> **性质 1**\n>\n> $0\\le d((mid,i),(x,y))- d((mid,i),(x,y-1))\\le 1$\n>\n> $0\\le d((mid,i),(x,y))- d((mid,i),(x-1,y))\\le 1$\n\n> **性质 2**\n>\n> $\\exist f_{x,y}$ 满足 $d((mid,i),(x,y))- d((mid,i),(x,y-1))=1-[i\\le f_{x,y}]$\n>\n> $\\exist g_{x,y}$ 满足 $d((mid,i),(x,y))- d((mid,i),(x-1,y))=[i\\le g_{x,y}]$\n\n那么显然 $\\forall i$ 有 $f_{mid,y}=i-1,g_{mid,y}=0$，观察到 $f_{x,y}$ 和 $g_{x,y}$ 可以互相转移：\n\n- 若 $a_{x-1}=b_{y-1}$ 则：\n  - $f_{x,y}=g_{x,y-1}$；\n  - $g_{x,y}=f_{x-1,y}$；\n- 否则：\n  - $f_{x,y}=\\max(f_{x-1,y},g_{x,y-1})$；\n  - $g_{x,y}=\\min(f_{x-1,y},g_{x,y-1})$；\n\n这样就可以在 $O((R-L+1)\\times m)$ 的复杂度内为当前分治区间 $[L,R]$ 求出 $[L,R]\\times [1,m]$ 的 $f,g$，接下来就可以根据 $g$ 做到每个询问 $O(m)$ 回答。\n\n那么总复杂度 $O(nm\\log n+qm)$，代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nconst int S=3005,MS=100005,inf=1e8;\n\nint n,m,q;\nchar a[S],b[S];\nvector<int> que[S<<2];\nshort f[S][S],g[S][S];\nshort c[S];\nshort al[MS],ar[MS],bl[MS],br[MS];\nshort ans[MS];\n\nvoid ins(int u,int l,int r,int L,int R,int id)\n{\n\tint mid=l+r>>1;\n\tif(L<=mid&&mid<=R) return que[u].push_back(id),void();\n\tif(R<=mid) ins(u<<1,l,mid,L,R,id);\n\telse ins(u<<1|1,mid+1,r,L,R,id);\n}\n\nvoid slove(int u,int l,int r)\n{\n\tif(l==r) return;\n\tint mid=l+r>>1;\n\tslove(u<<1,l,mid),slove(u<<1|1,mid+1,r);\n\tif(que[u].empty()) return;\n\t// down\n\tf[1][mid]=0,g[1][mid]=0;\n\tfor(int i=mid+1;i<=r;i++) f[1][i]=g[1][i]=0;\n\tfor(int j=2;j<=m+1;j++)\n\t{\n\t\tf[j][mid]=j-1,g[j][mid]=0;\n\t\tfor(int i=mid+1;i<=r;i++)\n\t\t{\n\t\t\tif(a[i-1]==b[j-1])\n\t\t\t\tf[j][i]=g[j-1][i],\n\t\t\t\tg[j][i]=f[j][i-1];\n\t\t\telse\n\t\t\t\tf[j][i]=max(g[j-1][i],f[j][i-1]),\n\t\t\t\tg[j][i]=min(g[j-1][i],f[j][i-1]);\n\t\t}\n\t}\n\t// up\n\tf[m+1][mid]=m+2,g[m+1][mid]=m+2;\n\tfor(int i=mid-1;i>=l;i--) f[m+1][i]=g[m+1][i]=m+2;\n\tfor(int j=m;j>=1;j--)\n\t{\n\t\tf[j][mid]=j+1,g[j][mid]=m+2;\n\t\tfor(int i=mid-1;i>=l;i--)\n\t\t{\n\t\t\tif(a[i]==b[j])\n\t\t\t\tf[j][i]=g[j+1][i],\n\t\t\t\tg[j][i]=f[j][i+1];\n\t\t\telse\n\t\t\t\tf[j][i]=min(g[j+1][i],f[j][i+1]),\n\t\t\t\tg[j][i]=max(g[j+1][i],f[j][i+1]);\n\t\t}\n\t}\n\t// calc\n\tfor(int id:que[u])\n\t{\n\t\tint val=mid-al[id];\n\t\tfor(int i=bl[id];i<=br[id];i++) c[i]=0;\n\t\tfor(int i=mid+1;i<=ar[id];i++)\n\t\t{\n\t\t\tint p=g[br[id]][i];\n\t\t\tif(p>=bl[id]) c[p]++;\n\t\t}\n\t\tfor(int i=mid-1;i>=al[id];i--)\n\t\t{\n\t\t\tint p=g[bl[id]][i]-1;\n\t\t\tif(p<=br[id]) c[p]--;\n\t\t\telse val--;\n\t\t}\n\t\tc[br[id]+1]=val; \n\t\tfor(int i=br[id];i>=bl[id];i--) ans[id]=max(ans[id],c[i]+=c[i+1]);\n\t}\n}\n\nint main()\n{\n\tios::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tcin>>n>>m>>q;\n\tcin>>a>>b;\n\tfor(int i=n;i>=1;i--) a[i]=a[i-1];\n\tfor(int i=m;i>=1;i--) b[i]=b[i-1];\n\tfor(int i=1;i<=q;i++)\n\t{\n\t\tcin>>al[i]>>ar[i]>>bl[i]>>br[i];\n\t\tar[i]++,br[i]++;\n\t\tins(1,1,n+1,al[i],ar[i],i);\n\t}\n\tslove(1,1,n+1);\n\tfor(int i=1;i<=q;i++) cout<<ans[i]<<'\\n';\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"结论"},{"name":"DP"}],
			"title": "P9109 [PA 2020] Tekstówka 做题记录",
			"link": "https://exber.qzz.io/post/P9109%20%5BPA%202020%5D%20Tekst%C3%B3wka%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2026-01-04 08:51:04"
		},
	
		{
			"abstract": "> 给定 $n,k,q$ 和一个长 $n$ 的序列 $a$，$q$ 次询问，每次给定一个区间 $[l,r]$，令序列 $b=a_{[l,r]}$，询问以下问题的答案：\n>\n> - 从 $b$ 中选出若干个（可以不选）长度为 $k$ 的不交区间，求它们覆盖的位置的 $b_i$ 的和的最大值；\n>\n> $1\\le k\\le n\\le 3\\times10^5$，$1\\le q\\le 3\\times 10^5$，$|a_i|\\le 10^9$。\n",
			"content": "> 给定 $n,k,q$ 和一个长 $n$ 的序列 $a$，$q$ 次询问，每次给定一个区间 $[l,r]$，令序列 $b=a_{[l,r]}$，询问以下问题的答案：\n>\n> - 从 $b$ 中选出若干个（可以不选）长度为 $k$ 的不交区间，求它们覆盖的位置的 $b_i$ 的和的最大值；\n>\n> $1\\le k\\le n\\le 3\\times10^5$，$1\\le q\\le 3\\times 10^5$，$|a_i|\\le 10^9$。\n\n\n考虑只有一次询问怎么做。可以设 $f_{i}$ 表示 $b_{[1,i]}$ 的答案，有转移：\n$$\n\\left(f_i+\\sum\\limits_{j\\in[i,i+k-1]} b_j\\right)\\to f_{i+k}\\\\\nf_i\\to f_{i+1}\n$$\n相当于构造一个 $n+1$ 个点的图，存在边：\n\n- $i\\to i+1$，边权为 $0$；\n- $i\\to i+k$，边权为 $\\sum\\limits_{j\\in[i,i+k-1]} a_j$；\n\n每次询问求 $l$ 到 $r+1$ 的最长路。\n\n接下来使用人类智慧，发现加入 $0$ 号点后，这个图每 $k$ 个点分一行画出来长这样：\n\n![](../post-images/1767058873814.png)\n\n那么使用分治求最长路，每次在长边的中间切开，用中间的点处理跨过中线的询问。\n\n注意由于存在从 $(i,k-1)\\to (i+1,0)$ 的边，故在第一次竖着切的时候还要用第一列的点处理询问，并且此时要处理所有询问。这种情况由于每个询问只有一次，所以复杂度还是对的。\n\n时间复杂度 $O(n\\sqrt n)$，代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int S=1000005;\nconst ll inf=1e17;\n\nint n,k,q;\nll a[S],sm[S];\nint lb[S],rb[S];\nll df[S],dt[S];\nll ans[S];\n\ninline void tmax(ll &x,ll y){x=max(x,y);}\n\nvoid slove(int lx,int rx,int ly,int ry,vector<int> &que)\n{\n\tif(que.empty()) return;\n\tint n=rx-lx+1,m=ry-ly+1;\n\tauto idx=[&](int x,int y){return x*m+y;};\n\tauto pos=[&](int x,int y){return (lx+x)*k+(ly+y);};\n\tauto calc=[&](int x,int y){\n\t\tfor(int i=0;i<n*m;i++) df[i]=dt[i]=-inf;\n\t\tdf[idx(x,y)]=dt[idx(x,y)]=0;\n\t\tfor(int i=n-1;i>=0;i--)\n\t\t\tfor(int j=m-1;j>=0;j--)\n\t\t\t{\n\t\t\t\tint u=idx(i,j);\n\t\t\t\tif(i-1>=0) tmax(df[idx(i-1,j)],df[u]+a[pos(i-1,j)]);\n\t\t\t\tif(j-1>=0) tmax(df[idx(i,j-1)],df[u]);\n\t\t\t\tif(ly==0&&ry==k-1&&i-1>=0&&j==0)\n\t\t\t\t\ttmax(df[idx(i-1,m-1)],df[u]);\n\t\t\t}\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int j=0;j<m;j++)\n\t\t\t{\n\t\t\t\tint u=idx(i,j);\n\t\t\t\tif(i+1<n) tmax(dt[idx(i+1,j)],dt[u]+a[pos(i,j)]);\n\t\t\t\tif(j+1<m) tmax(dt[idx(i,j+1)],dt[u]);\n\t\t\t\tif(ly==0&&ry==k-1&&i+1<n&&j==m-1)\n\t\t\t\t\ttmax(dt[idx(i+1,0)],dt[u]);\n\t\t\t}\n\t};\n\tif(m>n) // col\n\t{\n\t\tint mid=m/2-1;\n\t\tvector<int> vx,vy,pre;\n\t\tfor(int id:que)\n\t\t{\n\t\t\tint sy=lb[id]%k-ly;\n\t\t\tint ey=rb[id]%k-ly;\n\t\t\tint mny=min(sy,ey),mxy=max(sy,ey);\n\t\t\tif(mxy<=mid) vx.push_back(id);\n\t\t\telse if(mny>mid) vy.push_back(id);\n\t\t\tif((mny<=mid&&mxy>mid)||(ly==0&&ry==k-1)) pre.push_back(id);\n\t\t}\n\t\tif(!pre.empty())\n\t\t{\n\t\t\tauto upd=[&](){\n\t\t\t\tfor(int id:pre)\n\t\t\t\t{\n\t\t\t\t\tint sx=lb[id]/k-lx,sy=lb[id]%k-ly;\n\t\t\t\t\tint ex=rb[id]/k-lx,ey=rb[id]%k-ly;\n\t\t\t\t\ttmax(ans[id],df[idx(sx,sy)]+dt[idx(ex,ey)]);\n\t\t\t\t}\n\t\t\t};\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tcalc(i,mid),upd();\n\t\t\t\tif(ly==0&&ry==k-1) calc(i,m-1),upd();\n\t\t\t}\n\t\t}\n\t\tslove(lx,rx,ly,ly+mid,vx);\n\t\tslove(lx,rx,ly+mid+1,ry,vy);\n\t}\n\telse // row\n\t{\n\t\tint mid=n/2-1;\n\t\tvector<int> vx,vy,pre;\n\t\tfor(int id:que)\n\t\t{\n\t\t\tint sx=lb[id]/k-lx;\n\t\t\tint ex=rb[id]/k-lx;\n\t\t\tint mnx=min(sx,ex),mxx=max(sx,ex);\n\t\t\tif(mxx<=mid) vx.push_back(id);\n\t\t\telse if(mnx>mid) vy.push_back(id);\n\t\t\telse pre.push_back(id);\n\t\t}\n\t\tif(!pre.empty())\n\t\t{\n\t\t\tauto upd=[&](){\n\t\t\t\tfor(int id:pre)\n\t\t\t\t{\n\t\t\t\t\tint sx=lb[id]/k-lx,sy=lb[id]%k-ly;\n\t\t\t\t\tint ex=rb[id]/k-lx,ey=rb[id]%k-ly;\n\t\t\t\t\ttmax(ans[id],df[idx(sx,sy)]+dt[idx(ex,ey)]);\n\t\t\t\t}\n\t\t\t};\n\t\t\tfor(int i=0;i<m;i++) calc(mid,i),upd();\n\t\t}\n\t\tslove(lx,lx+mid,ly,ry,vx);\n\t\tslove(lx+mid+1,rx,ly,ry,vy);\n\t}\n}\n\nint main()\n{\n\tios::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tcin>>n>>k>>q;\n\tfor(int i=1;i<=n;i++) cin>>a[i],sm[i]=sm[i-1]+a[i];\n\tfor(int i=1;i<=n-k+1;i++) a[i]=sm[i+k-1]-sm[i-1];\n\tfor(int i=n-k+2;i<=n;i++) a[i]=0;\n\tvector<int> all;\n\tfor(int i=1;i<=q;i++)\n\t{\n\t\tcin>>lb[i]>>rb[i];\n\t\trb[i]++;\n\t\tall.push_back(i);\n\t}\n\tslove(0,(n+1)/k,0,k-1,all);\n\tfor(int i=1;i<=q;i++) cout<<ans[i]<<'\\n';\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"图论"},{"name":"结论"},{"name":"小技巧"}],
			"title": "P9040 [PA 2021] Desant 2 做题记录",
			"link": "https://exber.qzz.io/post/P9040%20%5BPA%202021%5D%20Desant%202%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2025-12-30 09:27:04"
		},
	
		{
			"abstract": "> 给定两个长度均为 $n$ 的字符串 $A$ 和 $B$ 还有一个正整数 $c$，每次操作可以选择以下一种进行：\n>\n> 1. 选择一个位置 $1\\le i\\le n$，将 $A_i$ 修改为任意字符，花费 $1$ 的代价；\n> 2. 选择两个字符 $x,y$，将 $A_i=x$ 的 $A_i$ 全部修改为 $y$，花费 $c$ 的代价；\n>\n> 求将 $A$ 变为 $B$ 的最小代价。\n>\n> $1\\le c\\le n\\le 10^6$，**字符集为小写字母**。\n",
			"content": "> 给定两个长度均为 $n$ 的字符串 $A$ 和 $B$ 还有一个正整数 $c$，每次操作可以选择以下一种进行：\n>\n> 1. 选择一个位置 $1\\le i\\le n$，将 $A_i$ 修改为任意字符，花费 $1$ 的代价；\n> 2. 选择两个字符 $x,y$，将 $A_i=x$ 的 $A_i$ 全部修改为 $y$，花费 $c$ 的代价；\n>\n> 求将 $A$ 变为 $B$ 的最小代价。\n>\n> $1\\le c\\le n\\le 10^6$，**字符集为小写字母**。\n\n\n不难发现，1 类操作一定是在所有 2 类操作之后进行的。\n\n那么有一个初步的想法是每种字母最多进行 $1$ 次 1 类操作，故可以对于每种字母 $x$，求出其最终变为字母 $y$ 的代价 $V_{x,y}=c\\times [x\\not=y]+\\sum\\limits_{i}[A_i\\not=x]$，然后每种字母求出 $V_{x,*}$ 的最小值加起来。\n\n可是这样会出现问题。具体的，若 $V_{x,*}$ 中最小值是 $V_{x,y}$，那么连接有向边 $x\\to y$。则图肯定是基环树森林，此时每个连通块相对独立，考察每个连通块的形态：\n\n- 若基环是自环，即一棵树，则可以按照深度从小到大依次操作每个点。此时贪心算的贡献是对的；\n- 若连通块是基环树，即基环大小 $\\ge 2$ 且外面有点 $u$ 连到基环上形成类似环上 $x\\to y\\to z$，环外有 $u\\to x$ 的情况，则可以先一次操作把 $u$ 变到 $x$，这样 $u$ 的位置就空出来了。此时贪心算的贡献也是对的；\n- 否则连通块是一个大小 $\\ge 2$ 的环，此时只能先操作完树和基环树的连通块，借用它们的叶子“中转”一次。故不能所有连通块都是环或者自环。此时贪心算的贡献少了一个 $c$；\n\n考虑利用一下这个贪心得到的图 $T$。注意到若最优解对应的图 $G$ 中存在一个 $T$ 中没有的环 $r$，那么 $r$ 中一定有某个点 $u$ 满足其选择的出点 $v$ 的代价 $V_{u,v}$ 不是 $V_{u,*}$ 中最小的。那么将 $u$ 的出点改回 $T$ 中的那个（假设是 $x$）不仅会减少代价，还会断开这个新环，并且由于给 $x$ 连上了一条链，所以也不会新增环。\n\n所以 $G$ 中一定不会存在 $T$ 中没有的环。\n\n接下来就简单了，状压记录 $T$ 中的每个大小 $\\ge 2$  的环（包括基环树的基环）是否还未断开或形成基环树，转移考虑每次加入的点 $i$ 的连边情况即可。\n\n最后统计答案需要枚举还剩哪些环需要多一次中转操作，加上额外的代价即可。注意特判没有可供中转的点的情况。\n\n时间复杂度 $O(\\sum^22^{\\frac{\\sum}{2}})$，其中 $\\sum$ 是字符集大小（即 $26$），代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nconst int S=1000005,VS=26;\nconst int inf=1e8;\n\nint n,c;\nchar a[S],b[S];\nint ct[VS][VS],res[VS][VS];\nint to[VS],vis[VS];\nint tot,idx[VS];\nint f[2][1<<(VS/2)];\n\ninline void tmin(int &x,int y)\n{\n\tx=min(x,y);\n}\n\nint main()\n{\n\tios::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tcin>>n>>c;\n\tcin>>a>>b;\n\tfor(int i=n;i>=1;i--) a[i]=a[i-1]-'a',b[i]=b[i-1]-'a';\n\tfor(int i=1;i<=n;i++) ct[a[i]][b[i]]++;\n\tfor(int i=0;i<VS;i++)\n\t{\n\t\tint all=0;\n\t\tfor(int j=0;j<VS;j++) all+=ct[i][j];\n\t\tfor(int j=0;j<VS;j++) res[i][j]=c*(i!=j)+all-ct[i][j];\n\t}\n\tfor(int i=0;i<VS;i++)\n\t{\n\t\tint v=0;\n\t\tfor(int j=0;j<VS;j++) if(res[i][j]<res[i][v]) v=j;\n\t\t// if(v!=i) cout<<i<<' '<<v<<'\\n';\n\t\tto[i]=v;\n\t}\n\tfor(int i=0;i<VS;i++) vis[i]=-1;\n\tfor(int i=0;i<VS;i++)\n\t\tif(vis[i]==-1)\n\t\t{\n\t\t\tint u=i;\n\t\t\twhile(vis[u]==-1) vis[u]=i,u=to[u];\n\t\t\tif(vis[u]==i&&to[u]!=u)\n\t\t\t{\n\t\t\t\tidx[u]=++tot;\n\t\t\t\tint x=to[u];\n\t\t\t\twhile(x!=u) idx[x]=tot,x=to[x];\n\t\t\t}\n\t\t}\n\tfor(int s=0;s<(1<<tot);s++) f[0][s]=inf;\n\tf[0][0]=0;\n\tfor(int i=0;i<VS;i++)\n\t{\n\t\tint u=i&1,v=u^1;\n\t\tfor(int s=0;s<(1<<tot);s++) f[v][s]=inf;\n\t\tfor(int s=0;s<(1<<tot);s++)\n\t\t{\n\t\t\tint x=f[u][s];\n\t\t\tfor(int j=0;j<VS;j++)\n\t\t\t{\n\t\t\t\tint ns;\n\t\t\t\tif(idx[i]!=0)\n\t\t\t\t{\n\t\t\t\t\tif(j==to[i]) ns=s;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tns=s|(1<<idx[i]-1);\n\t\t\t\t\t\tif(idx[j]!=0) ns|=(1<<idx[j]-1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(idx[j]==0) ns=s;\n\t\t\t\t\telse ns=s|(1<<idx[j]-1);\n\t\t\t\t}\n\t\t\t\ttmin(f[v][ns],x+res[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tbool flg=true;\n\tfor(int i=0;i<VS;i++) flg&=(idx[i]!=0);\n\tint ans=inf;\n\tfor(int s=flg;s<(1<<tot);s++)\n\t\ttmin(ans,f[VS&1][s]+c*(tot-__builtin_popcount(s)));\n\tcout<<ans<<'\\n';\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"贪心"},{"name":"结论"}],
			"title": "P6700 [PA 2015 Final] Edycja 做题记录",
			"link": "https://exber.qzz.io/post/P6700%20%5BPA%202015%20Final%5D%20Edycja%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2025-12-30 09:24:52"
		},
	
		{
			"abstract": "> 给定 $n,p$，求有多少个 $\\{1,2,3,\\dots,n\\}$ 的子集 $S$，满足 $\\forall 1\\le x\\le n,\\exist T\\subseteq S,x=\\sum\\limits_{y\\in T} y$，对给定正整数 $p$ 取模。\n>\n> 也就是求有多少个子集 $S$ 满足其 01 背包可以表示出 $[1,n]$ 中的所有数。\n>\n> $1\\le n\\le 5\\times 10^5,2\\le p\\le 1.01\\times 10^9$，**时限 $3$ s**。\n",
			"content": "> 给定 $n,p$，求有多少个 $\\{1,2,3,\\dots,n\\}$ 的子集 $S$，满足 $\\forall 1\\le x\\le n,\\exist T\\subseteq S,x=\\sum\\limits_{y\\in T} y$，对给定正整数 $p$ 取模。\n>\n> 也就是求有多少个子集 $S$ 满足其 01 背包可以表示出 $[1,n]$ 中的所有数。\n>\n> $1\\le n\\le 5\\times 10^5,2\\le p\\le 1.01\\times 10^9$，**时限 $3$ s**。\n\n\n首先有一个显然的充要条件：将 $S$ 中元素排序后，$S_i\\le 1+\\sum\\limits_{j<i} S_j$。\n\n那么直接得到了 $O(n^2)$ 做法：设 $f_{i,j}$ 表示考虑了 $[1,i]$，当前 $\\min\\left(\\sum\\limits_{x\\in S} x,n\\right)=j$ 的方案数，转移是简单的。\n\n问题是这个做法没有优化前途。\n\n考虑容斥，钦定 $i$ 作为最小的不能被表示的数，那么 $T=\\{x|x\\in S,x<i\\}$ 要满足 $\\sum\\limits_{x\\in T} x=i-1$ 且 $T$ 能表示出 $[1,i-1]$ 中的所有数。\n\n那么只要求出 $f_i$ 表示有多少个 $T\\subseteq \\{1,2,3,\\dots n\\}$ 满足 $\\sum\\limits_{x\\in T} x=i$ 且其可以表示 $[1,i]$ 中的所有数。\n\n考虑容斥计算 $f_i$，先算出 $\\sum\\limits_{x\\in T} x=i$ 的 $T$ 的个数。再枚举一个 $0\\le j<i$，钦定无法表示 $j+1$，那么 $f_j$ 对 $f_i$ 的贡献为 $-f_j\\times g_{j+2,i}$，其中 $g_{j+2,i}$ 表示有多少个 $T'\\subseteq \\{j+2,j+3,\\dots,i\\}$ 满足 $\\sum\\limits_{x\\in T'}x=i-j$。\n\n继续，容易发现当 $j> \\lfloor\\frac{i-2}{2}\\rfloor=\\frac{i}{2}-1$ 则 $j+j+2>i$，那么此时 $g_{j+2,i}=0$。故可以倍增计算 $f_i$。\n\n现在问题变成如何求 $f_i$ 的初值以及 $g_{j+2,i}$。\n\n先来考虑 $f_i$ 的初值，即求有多少个 $T\\subseteq\\{1,2,3,\\dots,i\\}$ 满足 $\\sum\\limits_{x\\in T} x=i$。这是一个经典问题，即互异拆分数：\n\n> 考虑暴力 dp，设 $f_{i,j}$ 表示考虑完 $[1,i]$，现在总和为 $j$。这样做是 $O(n^2)$ 的。\n>\n> 考虑 Ferrers 图，即总共有 $i$ 个点，每行点数递减，一行表示 $T$ 中的一个数：\n>\n> ```\n> .......\n> .....\n> ...\n> .\n> ```\n>\n> 这个暴力 dp 相当于逐行加点，而注意到由于要求互异，即每行的点数不同，所以行数是 $O(\\sqrt i)$ 的。那么可以考虑逐列加点：\n>\n> - 设 $f_{i,j}$ 表示当前列有 $i$ 个点，总共加入了 $j$ 个点；\n>\n> 那么这样 dp 就变成了 $O(n\\sqrt n)$ 的。\n\n那么跑一遍该 dp 即可得到 $f_i$ 的初值，而不难发现并不用显式求出 $g_{j+2,i}$，仅需将前一半的计算完成的 $f$ 作为初值跑该 dp 即可。具体实现看代码。\n\n那么时间复杂度为 $T(n)=O(n\\sqrt n)+T(\\frac{n}{2})=O(n\\sqrt n)$，代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nconst int BS=1005,S=500005;\n\nint n,p;\nint f[S],g[S];\n\ninline void add(int &x,int y)\n{\n\tx+=y;\n\tif(x>=p) x-=p;\n}\n\nvoid slove(int n)\n{\n\tif(n==1) return;\n\tint m=n/2;\n\tslove(m);\n\tfor(int i=0;i<=n;i++) g[i]=0;\n\tfor(int i=BS-3;i>=1;i--)\n\t{\n\t\tfor(int j=n;j>=i;j--) g[j]=g[j-i];\n\t\tfor(int j=0;j<i;j++) g[j]=0;\n\t\tfor(int j=0;j<=m&&j+(j+2)*i<=n;j++)\n\t\t\tadd(g[j+(j+2)*i],p-f[j]);\n\t\tfor(int j=i;j<=n;j++) add(g[j],g[j-i]);\n\t}\n\tfor(int i=m+1;i<=n;i++) add(f[i],g[i]);\n}\n\nint main()\n{\n\tios::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tcin>>n>>p;\n\tfor(int i=BS-3;i>=1;i--)\n\t{\n\t\tfor(int j=n;j>=i;j--) f[j]=f[j-i];\n\t\tfor(int j=0;j<i;j++) f[j]=0;\n\t\tadd(f[i],1);\n\t\tfor(int j=i;j<=n;j++) add(f[j],f[j-i]);\n\t}\n\tf[0]=1;\n\tslove(n);\n\tint ans=1;\n\tfor(int i=1;i<=n;i++) ans=1ll*ans*2%p;\n\tfor(int i=n,pw2=1;i>=1;i--,pw2=1ll*pw2*2%p)\n\t\tadd(ans,p-1ll*pw2*f[i-1]%p);\n\tcout<<ans<<'\\n';\n\treturn 0;\n}\n/*\n相当于背包覆盖所有点\n相当于 a[i]<=(\\sum a[1,i])+1\n考虑容斥，数不合法的序列\n最多有 log 个位置违法\n* n sqrt n\n* 考虑互异分拆数的 n sqrt n 做法，记录 f[i][sm] 表示这一列还有 i 个点，和为 sm\n\tf[i][sm]->f[i][sm+i] or f[i-1][sm+i]\n容斥，考虑枚举爆掉的点前一个位置的和\nso hard\n*/\n```\n",
			"tags": [{"name":"做题记录"},{"name":"DP"},{"name":"组合计数"},{"name":"结论"}],
			"title": "P8340 [AHOI2022] 山河重整 做题记录",
			"link": "https://exber.qzz.io/post/P8340%20%5BAHOI2022%5D%20%E5%B1%B1%E6%B2%B3%E9%87%8D%E6%95%B4%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2025-11-21 21:20:32"
		},
	
		{
			"abstract": "",
			"content": "### 基本思想\n\n对于存在负权边的图，如果想跑 dijkstra，可以：\n\n- 为每个点 $u$ 设置一个势能 $h_u$；\n- 将边权为 $w$ 的边 $u\\to v$ 的边权改为 $w+h_u-h_v$，这里要求选择的 $h$ 可以使得新图中所有边边权非负；\n- 在新图中跑 dijkstra，最终 $x\\to y$ 的实际最短路为 $dis_{x,y}-h_x+h_y$；\n\n不难发现，对于 $h$ 的要求是：对于每条边 $(u\\to v,w)$，满足 $w+h_u-h_v\\ge 0$，也就是 $h_v\\le h_u+w$。\n\n注意到这个限制和最短路很像。那么直接在原图上随便找一个点 $s$，跑一次 SPFA 求出其到其他点的最短路 $dis_u$，并将 $h_u$ 设置成 $dis_u$ 即可。\n\n但是可能随便找的 $s$ 到不了所有点，所以还有一种做法是建立一个超级源点 $s'$，从其向所有其它点连权值为 $0$ 的有向边，从这个点跑最短路即可。\n\n### Johnson 全源最短路\n\n使用这种方法，建立超级源点 $s'$，跑一遍 SPFA 求出势能，再跑 $n$ 轮 dijkstra。\n\n时间复杂度 $O(nm+nm\\log n)$。\n\n### Primal-Dual 原始对偶求费用流\n\n考虑从源点 $s$ 开始跑 SPFA，将其到每个点的最短路设为势能 $h$。\n\n这样第一轮增广可以顺利跑 dijkstra。但问题是在增广时可能会删掉一些边，并增加对应的反向的负权边。\n\n注意到修改的边 $(u\\to v,w)$ 一定在 $s\\to v$ 的最短路上，那么考虑设 $d_i$ 为新图（将 $w$ 变为 $w+h_u-h_v$ 后的图）中 $s\\to i$ 的最短路，则结论是将下一轮每个点的势能 $h_i$ 修改为 $h_i+d_i$ 即可。\n\n证明考虑对于原来的边，相当于在新图上再设置一次势能，显然边权依旧非负。\n\n而对于新加的反向负权边 $(u\\leftarrow v,-w)$，由于原来的正向边 $(u\\to v,w)$ 一定在 $s\\to v$ 的最短路上，故有 $d_u+(w+h_u-h_v)=d_v$，那么有 $(h_u+d_u)-(h_v+d_v)=-w$，所以 $-w+(h_v+d_v)-(h_u+d_u)=0$，那么在下一轮的新图上这条反向边的权值变为了 $0$，边权非负。\n\n这样就可以保证费用流的时间复杂度是 $O(nm+fm\\log n)$，其中 $f$ 为最大流。不过网络流模型的图一般卡不掉每次跑 SPFA 的 dinic。\n",
			"tags": [{"name":"学习笔记"},{"name":"网络流"},{"name":"图论"},{"name":"小技巧"}],
			"title": "Johnson & dijkstra 跑费用流 学习笔记",
			"link": "https://exber.qzz.io/post/Johnson%20%26%20dijkstra%20%E8%B7%91%E8%B4%B9%E7%94%A8%E6%B5%81%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2025-11-21 20:16:20"
		},
	
		{
			"abstract": "> 给定一张 $n$ 个点 $m$ 条边的 DAG，每条边 $u_i\\to v_i$ 都满足 $u_i<v_i$。\n>\n> 点有五种类型：\n>\n> 1. 无特殊事件；\n> 2. 走到这里会获得一个二元组 $(a,b)$；\n> 3. 走到这里可以选择一个之前获得的二元组，将其的 $a$ 增加 $x$；\n> 4. 走到这里可以选择一个之前获得的二元组，将其的 $b$ 增加 $x$；\n> 5. 走到这里会获得一个数 $w$；\n>\n> 你要从点 $1$ 走到点 $n$，保证点 $1$ 和点 $n$ 是 $1$ 类点。\n>\n> 走到点 $n$ 时可以选择一个之前获得的二元组，将其的 $b$ 乘上 $10^9$。\n>\n> 最大化最终获得的所有二元组的 $a\\times b$ 的和加上获得的数 $w$ 的和。\n>\n> $1\\le n\\le 200$，$1\\le m\\le \\min(\\frac{n(n-1)}{2},2000)$，$1\\le a,b,x\\le 200$，$1\\le w\\le 10^6$。\n",
			"content": "> 给定一张 $n$ 个点 $m$ 条边的 DAG，每条边 $u_i\\to v_i$ 都满足 $u_i<v_i$。\n>\n> 点有五种类型：\n>\n> 1. 无特殊事件；\n> 2. 走到这里会获得一个二元组 $(a,b)$；\n> 3. 走到这里可以选择一个之前获得的二元组，将其的 $a$ 增加 $x$；\n> 4. 走到这里可以选择一个之前获得的二元组，将其的 $b$ 增加 $x$；\n> 5. 走到这里会获得一个数 $w$；\n>\n> 你要从点 $1$ 走到点 $n$，保证点 $1$ 和点 $n$ 是 $1$ 类点。\n>\n> 走到点 $n$ 时可以选择一个之前获得的二元组，将其的 $b$ 乘上 $10^9$。\n>\n> 最大化最终获得的所有二元组的 $a\\times b$ 的和加上获得的数 $w$ 的和。\n>\n> $1\\le n\\le 200$，$1\\le m\\le \\min(\\frac{n(n-1)}{2},2000)$，$1\\le a,b,x\\le 200$，$1\\le w\\le 10^6$。\n\n\n下文设 $V=200$。\n\n这个最后乘 $10^9$ 的操作其实相当于先最大化 $a\\times b$ 的最大值，再最大化 $\\sum a\\times b$。\n\n考虑枚举这个最大的 $(a,b)$ 是点 $u$ 处加入的，那么 $u\\to n$ 路径上的 $(+x,0)$ 和 $(0,+x)$ 一定都操作到它的头上。这部分的贡献可以简单 dp 算出：\n\n- 设 $f_{u,a}=(b,w)$ 表示从 $u$ 出发走到 $n$ 且 $(+x,0)$ 操作的和为 $(+a,0)$ 时，$(0,+x)$ 操作的和最大为 $(0,+b)$，在此前提下其余贡献（$+w$ 和其它二元组的 $+a\\times b$）最大为 $w$；\n\n现在问题在于计算 $1\\to u$ 的最大贡献。\n\n不难发现，点 $u$ 的二元组 $(a_u,b_u)$ 若在点 $v$ 处被操作了 $(+x_v,0)$，那么 $u\\to v$ 路径上的所有 $(+x_v,0)$ 都应该操作到 $u$ 头上。所以一个二元组一旦不再成为 $(+x,0)$ 的目标，那么它之后就再也不会成为 $(+x,0)$ 的目标了。$(0,+x)$ 同理。\n\n所以现在有一个 $O(n^3V^2)$ 的 dp：\n\n- 设 $f_{u,a,b,0/1}$ 表示从 $1$ 走到了 $u$，当前 $(0,+x)$ 操作的目标二元组是 $(a,*)$，当前 $(+x,0)$ 操作的目标二元组是 $(*,b)$，这两个二元组是否来自同一个点（是否是二元组 $(a,b)$）；\n\n转移只需要考虑新加入的二元组是否会干掉 $(a,*)$ 和 $(*,b)$ 或者两个都干掉。\n\n进一步，如果 $a>V$ 且 $b>V$，那么该状态一定是 $f_{u,a,b,1}$，即对应二元组为 $(a,b)$。那么 $u\\to n$ 路径上的 $(+x,0)$ 和 $(0,+x)$ 一定都会操作到它头上，所以这个二元组可以看作是最后 $a\\times b$ 最大的那个，即我们在钦定 $(a_u,b_u)$ 作为 $a\\times b$ 最大的那个二元组计算答案时已经算过这种情况。\n\n所以有 $\\min(a,b)\\le V$，而注意到 $a$ 和 $b$  在转移过程中不会减少，所以可以把一维开到 $V$。不妨假定 $a\\le V$，这样交换 $a,b$ 再做一次即可。\n\n那么这个 dp 被优化到了 $O(n^2V^2)$。\n\n继续。考虑二元组的贡献形如 $(a+\\sum x)\\times (b+\\sum x)$，我们这个 dp 算贡献的方式是加入一个元素就算一次它和当前另一边的贡献，所以两边的总和都要记录。\n\n注意到根据之前的性质，有 $a+\\sum x\\le V$，那么不妨直接钦定左边 $a+\\sum x$ 的值，将算贡献的方式改为每次加入一个右边的元素 $z$（$b$ 或 $(0,+x)$）时贡献 $(a+\\sum x)\\times z$，相当于将 $(+x,0)$ 操作“预支”出去。再根据一个二元组 $(a,b)$ 一定是在路径的一个区间内成为 $(+x,0)$ 操作的目标，故每个时刻只有最多一个二元组的债还未偿还。\n\n那么有 dp：\n\n- 设 $f_{u,a,k}$ 表示从 $1$ 走到了 $u$，当前 $(a+\\sum x)$ 为 $a$，还欠了 $k$ 的债；\n\n转移是简单的，时间复杂度 $O((n+m)V^2)$。\n\n注意要特判没有 $1$ 类点的情况，代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int S=205,MUL=1000000000;\nconst ll inf=1e17;\n\nint n,m;\nint tp[S],a[S],b[S];\nvector<int> g[S],rg[S];\nll f[S][S][S],res[S];\npair<ll,ll> h[S][S*S];\n\ntemplate<typename T>\ninline void tmax(T &x,T y){x=max(x,y);}\n\ninline void doit()\n{\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=S-3;j++)\n\t\t\tfor(int k=0;k<=S-3;k++) f[i][j][k]=-inf;\n\tf[1][0][0]=0;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int v:g[i])\n\t\t\tfor(int j=0;j<=S-3;j++)\n\t\t\t\tfor(int k=0;k<=S-3;k++)\n\t\t\t\t{\n\t\t\t\t\tll u=f[i][j][k];\n\t\t\t\t\tif(u<0) continue;\n\t\t\t\t\tif(tp[v]==0) tmax(f[v][j][k],u);\n\t\t\t\t\tif(tp[v]==1)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmax(f[v][max(j,a[v])][k],u+a[v]*b[v]);\n\t\t\t\t\t\tif(k==0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor(int x=a[v];x<=S-3;x++)\n\t\t\t\t\t\t\t\ttmax(f[v][max(j,x)][x-a[v]],u+x*b[v]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(tp[v]==2) tmax(f[v][j][max(0,k-a[v])],u);\n\t\t\t\t\tif(tp[v]==3) tmax(f[v][j][k],u+j*b[v]);\n\t\t\t\t\tif(tp[v]==4) tmax(f[v][j][k],u+a[v]);\n\t\t\t\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=S-3;j++) tmax(res[i],f[i][j][0]);\n}\n\nint main()\n{\n\tios::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcin>>tp[i];\n\t\tif(tp[i]==0) continue;\n\t\tif(tp[i]==1) cin>>a[i]>>b[i];\n\t\tif(tp[i]==2) cin>>a[i];\n\t\tif(tp[i]==3) cin>>b[i];\n\t\tif(tp[i]==4) cin>>a[i],b[i]=a[i];\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tg[x].push_back(y);\n\t\trg[y].push_back(x);\n\t}\n\tfor(int i=1;i<=n;i++) res[i]=-inf;\n\tdoit();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tswap(a[i],b[i]);\n\t\tif(tp[i]==2||tp[i]==3) tp[i]=2+3-tp[i];\n\t}\n\tdoit();\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=S*S-3;j++) h[i][j]=make_pair(-inf,-inf);\n\th[n][0]=make_pair(0,0);\n\tfor(int i=n;i>=1;i--)\n\t\tfor(int v:rg[i])\n\t\t\tfor(int j=0;j<=S*S-3;j++)\n\t\t\t{\n\t\t\t\tpair<ll,ll> u=h[i][j];\n\t\t\t\tif(u.first<0) continue;\n\t\t\t\tif(tp[v]==0) tmax(h[v][j],u);\n\t\t\t\tif(tp[v]==1)\n\t\t\t\t\ttmax(h[v][j],make_pair(u.first,u.second+a[v]*b[v]));\n\t\t\t\tif(tp[v]==2&&j+a[v]<=S*S-3)\n\t\t\t\t\ttmax(h[v][j+a[v]],u);\n\t\t\t\tif(tp[v]==3)\n\t\t\t\t\ttmax(h[v][j],make_pair(u.first+b[v],u.second));\n\t\t\t\tif(tp[v]==4)\n\t\t\t\t\ttmax(h[v][j],make_pair(u.first,u.second+a[v]));\n\t\t\t}\n\tll ans=0;\n\tfor(int i=1;i<=n;i++)\n\t\tif(tp[i]==1)\n\t\t\tfor(int j=0;j<=S*S-3;j++)\n\t\t\t{\n\t\t\t\tif(h[i][j].first<0) continue;\n\t\t\t\tll pre=res[i]+h[i][j].second-a[i]*b[i]*2;\n\t\t\t\tll val=(a[i]+j)*(b[i]+h[i][j].first);\n\t\t\t\ttmax(ans,pre+val*MUL);\n\t\t\t}\n\tfor(int i=0;i<=S-3;i++) tmax(ans,f[n][i][0]);\n\tcout<<ans<<'\\n';\n\treturn 0;\n}\n/*\n给一条路径怎么做\n每次是选择另一边最大的那个加上吗？好像不是 fake\n不过我还是可以记录两个点表示 +a 操作和 +b 操作的目标点 x,y\n一个点退出目标点后就不可能重新变成目标点\n新的目标点只可能是新加入的点或者 x,y\n如果一个点变成了海王，那么不如让它存活区间的所有增加操作都操作到他头上\n那么我怎么维护这种情况\n相当于求出 x 到 y 路径上，所有增加操作都操作到 x 头上的最大值\n鉴于我最后那个 *1e9 的操作，首先要最大化乘积最大的\n\n5 1\n4 6\n\n+1e9   0\n  0  +1e9\n  \nI am pig\n\n\t* 目标点的值不可能同时大于 V，这是因为大于 V 必定两点重合，\n\t\t不如把 1e9 放到这里\n\n默认 a 没有大于 V，设 f[i][x][y][0/1] 表示在点 i，\n\t(a,b) 目标点的值分别为 x 和 y，两个目标点是否重合\n转移考虑只有可能是新加入的点替换掉某一个目标点\nn^2V^2\n\n提前算贡献，默认 a 没有大于 V，设 f[i][x][y] 表示在点 i，\n\ta 目标点最终是 x，这个目标点欠了 y 的债务\n\t只有还掉了上一个目标点的债务才能更新目标点\n*/\n```\n",
			"tags": [{"name":"做题记录"},{"name":"DP"},{"name":"结论"}],
			"title": "CF1874G Jellyfish and Inscryption 做题记录",
			"link": "https://exber.qzz.io/post/CF1874G%20Jellyfish%20and%20Inscryption%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2025-11-19 12:54:57"
		},
	
		{
			"abstract": "",
			"content": "### 指针和常量\n\n|        类型        | 指针本身（地址）是否可变 | 指向的内容是否可变 |                 声明方式                 |\n| :----------------: | :----------------------: | :----------------: | :--------------------------------------: |\n|   指向常量的指针   |           可以           |       不可以       |       `const int*` 或 `int const*`       |\n|      常量指针      |          不可以          |        可以        |               `int* const`               |\n| 指向常量的常量指针 |          不可以          |       不可以       | `const int* const` 或 `int* const const` |\n\n```cpp\nint a=1,b=2;\n{\n\tconst int* pt;\n\t// int const* pt; // same\n\tpt=&a;\n\tcout<<(*pt)<<'\\n'; // 1\n\tpt=&b;\n\tcout<<(*pt)<<'\\n'; // 2\n\t// *pt=3; // CE\n}\n{\n\tint* const pt=&a;\n\tcout<<(*pt)<<'\\n'; // 1\n\t*pt=3;\n\tcout<<(*pt)<<' '<<a<<'\\n'; // 3 3\n\t// pt=&b; // CE\n}\n{\n\tconst int* const pt=&a;\n\t// int const* const pt=&a; // same\n\tcout<<(*pt)<<'\\n'; // 1\n\t// *pt=3; // CE\n\t// pt=&b; // CE\n}\n```\n\n当处理下标带偏移量的数组时，可以这样写：\n\n```cpp\nint tf[S*2];\nint* const f=tf+S;\n// f[i] same as tf[S+i]\n```\n\n这样编译器才可以去优化，并且编译行为和直接用 `tf[S+i]` 一致。如果写成 `int* f=tf+S` 的话，编译器会认为指针可能乱飘而优化不彻底。\n",
			"tags": [{"name":"学习笔记"},{"name":"小技巧"}],
			"title": "一些语法技巧",
			"link": "https://exber.qzz.io/post/%E4%B8%80%E4%BA%9B%E8%AF%AD%E6%B3%95%E6%8A%80%E5%B7%A7",
			"date": "2025-11-05 21:52:30"
		},
	
		{
			"abstract": "> 给定 $n,m$ 和一个 $n\\times m$ 的非负整数矩阵 $a$，$a_{i,j}\\in [0,100]$。\n>\n> 根据这个矩阵构造一个二分图，其有 $n$ 个左部点和 $m$ 个右部点，连接第 $i$ 个左部点和第 $j$ 个右部点的无向边 $(i,j)$ 有 $\\frac{a_{i,j}}{100}$ 的概率存在。\n>\n> 求这个二分图的最大匹配大小的期望。\n>\n> $1\\le n,m\\le 9$。\n",
			"content": "> 给定 $n,m$ 和一个 $n\\times m$ 的非负整数矩阵 $a$，$a_{i,j}\\in [0,100]$。\n>\n> 根据这个矩阵构造一个二分图，其有 $n$ 个左部点和 $m$ 个右部点，连接第 $i$ 个左部点和第 $j$ 个右部点的无向边 $(i,j)$ 有 $\\frac{a_{i,j}}{100}$ 的概率存在。\n>\n> 求这个二分图的最大匹配大小的期望。\n>\n> $1\\le n,m\\le 9$。\n\n\n考虑 Hall 定理，一个二分图的最大匹配大小为 $n-\\max\\limits_{S}\\left(|S|-|N(S)|\\right)$，其中 $N(S)$ 是左部点集 $S$ 的邻域。\n\n问题是取到最大值的 $S$ 可能有多个。\n\n勇敢地去考虑代表元，不妨令代表元为 $|S|-|N(S)|$ 最大且 $|S|$ 最小的左部点集 $S$。可以证明这是唯一的：\n\n> 若有两个左部点集 $S,T$ 满足 $|S|-|N(S)|=|T|-|N(T)|$ 且 $|S|=|T|$，则：\n> $$\n> |S|-|N(S)|+|T|-|N(T)|\\le|S\\cap T|-|N(S\\cap T)|+|S\\cup T|-|N(S\\cup T)|\n> $$\n> 这是因为 $|S|+|T|=|S\\cap T|+|S\\cup T|$ 且 $|N(S)|+|N(T)|\\ge|N(S\\cap T)|+|N(S\\cup T)|$。\n>\n> 那么 $S\\cap T$ 和 $S\\cup T$ 中的某一个集合一定能优于 $S$ 和 $T$，矛盾。\n\n那么就可以 dp 了，设 $g_{S,T}$ 表示只考虑左部点集 $S$ 和右部点集 $T$ 的子图时，$N(S)=T$ 且 $S$ 是子图代表元的概率；$f_{S,T}$ 表示只考虑 $S,T$ 的子图时，$N(S)=T$ 且最大匹配大小为 $|S|$ 的概率。\n\n转移考虑容斥，枚举实际的代表元 $S'$，那么 $S-S'$ 和 $T-N(S')$ 的导出子图的最大匹配大小显然为 $|S-S'|$，故有转移：\n$$\nf_{S,T}=h_{S,T}-\\sum\\limits_{S'\\subseteq S,T'\\subseteq T,|S'|+|T'|\\not=0} g_{S',T'}\\times f_{S-S',T-T'}\\times noe_{S',T-T'}\\\\\ng_{S,T}=h_{S,T}-\\sum\\limits_{S'\\subseteq S,T'\\subseteq T,|S'|+|T'|\\not=|S|+|T|,|S'|-|T'|\\ge |S|-|T|} g_{S',T'}\\times f_{S-S',T-T'}\\times noe_{S',T-T'}\n$$\n其中 $h_{S,T}$ 表示只考虑 $S,T$ 的子图时 $N(S)=T$ 的概率，$noe_{S,T}$ 表示 $S,T$ 之间没有边的概率。\n\n计算答案是简单的，枚举整个图的代表元 $S$ 和 $N(\\{1,2,3,\\dots ,n\\}-S)$ 即可。\n\n时间复杂度 $O(3^{n+m})$，代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\n#define p 998244353\n\ninline void add(int &x,int y)\n{\n\tx+=y;\n\tif(x>=p) x-=p;\n}\ninline int qpow(int x,int y)\n{\n\tint res=1;\n\tfor(;y>0;y>>=1,x=1ll*x*x%p) res=y&1?1ll*res*x%p:res;\n\treturn res;\n}\n\nconst int S=15,BS=1<<9;\n\nint n,m,a[S][S];\nint noe[BS][BS],h[BS][BS],f[BS][BS],g[BS][BS];\n\n#define popc(x) __builtin_popcount(x)\n\ninline void slove()\n{\n\tcin>>n>>m;\n\tint iv=qpow(100,p-2);\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<m;j++)\n\t\t\tcin>>a[i][j],a[i][j]=1ll*a[i][j]*iv%p;\n\tfor(int s=0;s<(1<<n);s++)\n\t\tfor(int t=0;t<(1<<m);t++)\n\t\t\tnoe[s][t]=h[s][t]=f[s][t]=g[s][t]=0;\n\tfor(int s=0;s<(1<<n);s++)\n\t\tfor(int t=0;t<(1<<m);t++)\n\t\t{\n\t\t\tnoe[s][t]=1;\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\tfor(int j=0;j<m;j++)\n\t\t\t\t\tif((s>>i&1)&&(t>>j&1))\n\t\t\t\t\t\tnoe[s][t]=1ll*noe[s][t]*(1-a[i][j]+p)%p;\n\t\t}\n\tfor(int s=0;s<(1<<n);s++)\n\t\tfor(int t=0;t<(1<<m);t++)\n\t\t{\n\t\t\th[s][t]=1;\n\t\t\tfor(int j=0;j<m;j++)\n\t\t\t{\n\t\t\t\tif(t>>j&1^1) continue;\n\t\t\t\tint pre=1;\n\t\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\t\tif(s>>i&1) pre=1ll*pre*(1-a[i][j]+p)%p;\n\t\t\t\th[s][t]=1ll*h[s][t]*(1-pre+p)%p;\n\t\t\t}\n\t\t}\n\tfor(int s=0;s<(1<<n);s++)\n\t\tfor(int t=0;t<(1<<m);t++)\n\t\t\tif(popc(s)<=popc(t))\n\t\t\t{\n\t\t\t\tf[s][t]=h[s][t];\n\t\t\t\tfor(int s1=s;;s1=(s1-1)&s)\n\t\t\t\t{\n\t\t\t\t\tfor(int t1=t;;t1=(t1-1)&t)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(s1!=0||t1!=0)\n\t\t\t\t\t\t\tadd(f[s][t],p-1ll*g[s1][t1]*f[s-s1][t-t1]%p\n\t\t\t\t\t\t\t\t\t*noe[s1][t-t1]%p);\n\t\t\t\t\t\tif(t1==0) break;\n\t\t\t\t\t}\n\t\t\t\t\tif(s1==0) break;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tg[s][t]=h[s][t];\n\t\t\t\tfor(int s1=s;;s1=(s1-1)&s)\n\t\t\t\t{\n\t\t\t\t\tfor(int t1=t;;t1=(t1-1)&t)\n\t\t\t\t\t{\n\t\t\t\t\t\tif((s1!=s||t1!=t)\n\t\t\t\t\t\t\t&&popc(s1)-popc(t1)>=popc(s)-popc(t))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tadd(g[s][t],p-1ll*g[s1][t1]*f[s-s1][t-t1]%p\n\t\t\t\t\t\t\t\t\t*noe[s1][t-t1]%p);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(t1==0) break;\n\t\t\t\t\t}\n\t\t\t\t\tif(s1==0) break;\n\t\t\t\t}\n\t\t\t}\n\tint ans=0;\n\tint alln=(1<<n)-1,allm=(1<<m)-1;\n\tfor(int s=0;s<(1<<n);s++)\n\t\tfor(int t=0;t<(1<<m);t++)\n\t\t\tif(popc(s)>popc(t))\n\t\t\t{\n\t\t\t\tint lst=allm-t;\n\t\t\t\tfor(int x=lst;;x=(x-1)&lst)\n\t\t\t\t{\n\t\t\t\t\tadd(ans,1ll*g[s][t]*f[alln-s][x]%p\n\t\t\t\t\t\t\t*noe[s][allm-t]%p*noe[alln-s][lst-x]%p\n\t\t\t\t\t\t\t*(popc(s)-popc(t))%p);\n\t\t\t\t\tif(x==0) break;\n\t\t\t\t}\n\t\t\t}\n\tcout<<(n-ans+p)%p<<'\\n';\n}\n\nint main()\n{\n\tios::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tint T;\n\tcin>>T;\n\twhile(T-->0) slove();\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"组合计数"},{"name":"DP"},{"name":"结论"}],
			"title": "P14170 二分图最大匹配期望 做题记录",
			"link": "https://exber.qzz.io/post/P14170%20%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D%E6%9C%9F%E6%9C%9B%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2025-11-04 20:01:58"
		},
	
		{
			"abstract": "> 如下定义一棵树的海胆度：\n>\n> - 一个单点的海胆度是 $0$；\n> - 一棵树的海胆度是最小的 $k$ 满足删掉其某个节点后剩下的连通块的海胆度都 $\\le k-1$；\n>\n> 给定一棵 $n$ 个点的树，求它的海胆度。\n>\n> $1\\le n\\le 10^5$。\n",
			"content": "> 如下定义一棵树的海胆度：\n>\n> - 一个单点的海胆度是 $0$；\n> - 一棵树的海胆度是最小的 $k$ 满足删掉其某个节点后剩下的连通块的海胆度都 $\\le k-1$；\n>\n> 给定一棵 $n$ 个点的树，求它的海胆度。\n>\n> $1\\le n\\le 10^5$。\n\n相当于找到最小的颜色数 $k$，使得给每个点染 $[1,k]$ 中的颜色，要求任意两个颜色均为 $x$ 的点之间路径上颜色的最大值 $>x$。\n\n考虑这样一个不是很显然的贪心：\n\n- 随便定一个根，自底向上确定每个点的颜色：\n  - 对于点 $u$，其颜色确定为只考虑其子树时的最小的合法颜色；\n\n具体的，每个点维护一个集合 $ban_u$，表示 $u$ 的子树内还未被覆盖的颜色，即所有满足存在 $col_v=x$ 且 $v\\to u$ 链上不存在颜色 $>x$ 的点的 $x$ 组成的集合。\n\n那么 $u$ 儿子的 $ban$ 对 $col_u$ 仅有如下限制：\n\n1. $\\forall v\\in son_u$，$col_u\\not\\in ban_v$\n2. $\\forall v_1,v_2\\in son_u,v_1\\not=v_2$，$col_u>\\max\\limits_{x\\in \\left(ban_{v_1}\\cap ban_{v_2}\\right)} x$\n\n并且确定了 $col_u$ 之后就可以确定 $ban_u=\\{col_u\\}\\cup\\{x|x> col_u,\\exist v\\in son_u,x\\in ban_v\\}$，即所有儿子的 $ban$ 的并加上 $col_u$，再清除 $<col_u$ 的元素。\n\n而显然 $k\\le \\log n$，所以可以用二进制记录 $ban$，使用 `__builtin` 的位运算即可做到 $O(n)$。\n\n<details><summary>贪心证明</summary><p>\n\n> 取一个巨大的位权 $B$。对于一个集合 $S$，设 $V(S)=\\sum\\limits_{x\\in S}B^x$。\n>\n> 那么目标是令 $\\max\\limits_uV(ban_u)$ 尽可能小，限制相当于要求 $V(ban_u)>\\sum\\limits_{v\\in son_u}V(ban_v)$，即若某一位的系数 $\\ge 2$ 就需要在更高位填 $1$。\n>\n> 由于我们只能在 $\\sum\\limits_{v\\in son_u}V(ban_v)$ 的为 $0$ 的那些位中填一个 $1$ 并将后面的所有位置为 $0$，故这样贪心可以使得 $V(ban_u)$ 最小。\n>\n> 相当于证明了一个大颜色对子树外的影响大于任意个小颜色对子树外的影响。\n\n</p></details>\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nconst int S=100005;\n\nint n;\nvector<int> g[S];\nint f[S],ans;\n\nvoid dfs(int u,int fa)\n{\n\tint d=0;\n\tfor(int v:g[u]) d+=(v!=fa);\n\tif(d==0) f[u]=1;\n\telse\n\t{\n\t\tint ban=0,big=0;\n\t\tfor(int v:g[u])\n\t\t\tif(v!=fa)\n\t\t\t{\n\t\t\t\tdfs(v,u);\n\t\t\t\tbig|=ban&f[v];\n\t\t\t\tban|=f[v];\n\t\t\t}\n\t\tint t;\n\t\tif(big==0) t=0;\n\t\telse t=32-__builtin_clz(big);\n\t\tint tmp=ban;\n\t\ttmp>>=t;\n\t\ttmp^=(1<<20)-1;\n\t\tint res=__builtin_ctz(tmp)+t;\n\t\tans=max(ans,res);\n\t\tf[u]=((1<<res)|ban)>>res<<res;\n\t}\n}\n\nint main()\n{\n\tios::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tcin>>n;\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tdfs(1,0);\n\tcout<<ans<<'\\n';\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"结论"},{"name":"贪心"}],
			"title": "AGC009D Uninity 做题记录",
			"link": "https://exber.qzz.io/post/AGC009D%20Uninity%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2025-10-28 08:34:32"
		},
	
		{
			"abstract": "> 对于一个长 $m$ 的 $01$ 序列 $a_{[1,m]}$，定义变换 $f$：\n>\n> - $f(a)_i=\\left(\\sum\\limits_{j\\le i}a_j\\right)\\text{ mod 2}$；\n>\n> 也就是做一次异或意义下的前缀和。\n>\n> 对于两个长 $m$ 的序列 $a,b$，定义 $g(a,b)$ 为：\n>\n> - 至少对 $a$ 做多少次变换 $f$ 才能令 $\\forall i,a_i=b_i$，如果无论做多少次变换都不可能，那么 $g(a,b)$ 为 $0$；\n>\n> 现在给定 $n$ 个长 $m$ 的序列 $a_{[1,n]}$，求 $\\sum\\limits_{i<j}g(a_i,a_j)$，对 $998244353$ 取模。\n>\n> $1\\le n\\times m\\le 10^6$，$a_{i,j}\\in \\{0,1\\}$。\n",
			"content": "> 对于一个长 $m$ 的 $01$ 序列 $a_{[1,m]}$，定义变换 $f$：\n>\n> - $f(a)_i=\\left(\\sum\\limits_{j\\le i}a_j\\right)\\text{ mod 2}$；\n>\n> 也就是做一次异或意义下的前缀和。\n>\n> 对于两个长 $m$ 的序列 $a,b$，定义 $g(a,b)$ 为：\n>\n> - 至少对 $a$ 做多少次变换 $f$ 才能令 $\\forall i,a_i=b_i$，如果无论做多少次变换都不可能，那么 $g(a,b)$ 为 $0$；\n>\n> 现在给定 $n$ 个长 $m$ 的序列 $a_{[1,n]}$，求 $\\sum\\limits_{i<j}g(a_i,a_j)$，对 $998244353$ 取模。\n>\n> $1\\le n\\times m\\le 10^6$，$a_{i,j}\\in \\{0,1\\}$。\n\n\n对于一个序列 $a$，若其首位非 $1$ 则可以将首位删去，故下文默认 $a_{1}=1$。\n\n不难发现，做 $k$ 次前缀和后 $a_i$ 对 $a_j$ 的贡献是 $\\binom{k}{j-i}\\text{ mod }2$。而根据 Lucas 定理，这个东西等于 $[j-i\\subseteq k]$。\n\n故 $a$ 的最小正周期 $T$ 为最小的 $\\ge |a|$ 的 $2^x$。\n\n对于两个序列 $a,b$，考虑如何判断 $a$ 能否到达 $b$。这类问题可以考虑代表元，只需找到 $a$ 和 $b$ 各自所在的环上的字典序最小的序列 $a_{\\min},b_{\\min}$ 并判断它们是否相等就行了。进一步，由于显然 $|a|=|b|$，那么它们的周期 $T$ 相等，只需找出 $a\\to a_{\\min}$ 和 $b\\to b_{\\min}$ 的步数 $ta,tb$，则：\n$$\ng(a,b)=\n\\begin{cases}\nta-tb & ta\\le tb\\\\\nT-ta+tb & ta>tb\n\\end{cases}\n$$\n那么对于每个序列 $a_i$ 求出 $a_{\\min}$，$T$ 和 $ta_i$ 后可以用树状数组简单计算答案。\n\n现在来考虑 $a_{\\min}$ 怎么求。根据 Lucas 定理，可以发现做 $2^k$ 次前缀和其实相当于做一次隔 $2^k$ 位的前缀和，即 $a_i$ 贡献到 $a_{i+2^k}$。\n\n那么考虑从低往高确定 $ta_i$ 二进制的每一位，假设考虑到 $[2^k]ta_i$，则对于 $a_{1+2^k}$：\n\n- $>k$ 的那些位影响不到它；\n- $<k$ 的那些位对它的贡献已经确定了，假设影响为 $u$；\n\n那么由于要最小化字典序，故可以确定 $[2^k]ta_i=a_{1+2^k}\\oplus u\\oplus 1$。\n\n故这样扫一遍就可以确定 $ta_i$，从而确定 $a_{\\min}$。\n\n之后的部分都是简单的，时间复杂度 $O(nm\\log n)$。\n",
			"tags": [{"name":"做题记录"},{"name":"结论"},{"name":"贪心"}],
			"title": "ARC184E Accumulating Many Times 做题记录",
			"link": "https://exber.qzz.io/post/ARC184E%20Accumulating%20Many%20Times%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2025-10-27 10:49:55"
		},
	
		{
			"abstract": "> 有一个 $n$ 个点的带权有向图，刚开始：\n>\n> - $\\forall 1\\le i<n$ 存在边 $i\\to i+1$，边权为 $0$，这些边**不可删除**；\n> - $\\forall 1\\le i<j\\le n$，存在边 $i\\to j$，边权为 $-1$；\n> - $\\forall 1\\le i<j\\le n$，存在边 $j\\to i$，边权为 $1$；\n>\n> 给定 $n\\times n$ 的**正整数**矩阵 $A$，删除**可删除的** $i\\to j$ 的有向边的代价为 $A_{i,j}$，求最小的代价使得图中不存在负环。\n>\n> $1\\le n\\le 500$。\n",
			"content": "> 有一个 $n$ 个点的带权有向图，刚开始：\n>\n> - $\\forall 1\\le i<n$ 存在边 $i\\to i+1$，边权为 $0$，这些边**不可删除**；\n> - $\\forall 1\\le i<j\\le n$，存在边 $i\\to j$，边权为 $-1$；\n> - $\\forall 1\\le i<j\\le n$，存在边 $j\\to i$，边权为 $1$；\n>\n> 给定 $n\\times n$ 的**正整数**矩阵 $A$，删除**可删除的** $i\\to j$ 的有向边的代价为 $A_{i,j}$，求最小的代价使得图中不存在负环。\n>\n> $1\\le n\\le 500$。\n\n#### 做法 1\n\n> **性质**\n>\n> 对于一条 $x\\to y$ 的负边，若其最后没有删除，则显然 $\\forall i\\le x,y\\le j$ 的负边 $i\\to j$ 都不会被删除。\n\n所以最终负边肯定形如：\n\n- 将序列划分为若干个区间和一些孤立点；\n- 一个区间中的点向后面区间中的所有点连负边，孤立点不连负边；\n\n然后正边就不能跨越一整个区间。\n\n那么不难发现将孤立点并入旁边的某个区间是不劣的，因为这不会影响正边的连法，还会减少删边的代价。\n\n所以直接设 $f_{i,j}$ 表示考虑了前 $i$ 个点，上一个区间是 $[j,i]$ 的最小代价，转移直接考虑枚举下一个区间 $[i+1,r]$ 然后用前缀和计算代价即可。\n\n复杂度 $O(n^3)$。\n\n#### 做法 2\n\n> **性质**\n>\n> 一个从 $1$ 可以到达任意点的图不存在负环，当且仅当存在从 $1$ 到任意点 $i$ 的最短路 $d_i$ 存在。\n\n那么考虑 $d_i$ 的限制：\n\n- $d_i\\ge d_{i+1}$，这是因为存在边权为 $0$ 的边 $i\\to i+1$；\n- 对于一条负边 $i\\to j$，$d_i-1\\ge d_j$；\n- 对于一条正边 $j\\to i$，$d_i\\le d_j+1$；\n\n那么划分出若干个区间满足内部的 $d$ 相等，则后面部分和第一个做法一样了。\n\n复杂度 $O(n^3)$。\n",
			"tags": [{"name":"做题记录"},{"name":"结论"},{"name":"图论"},{"name":"DP"}],
			"title": "AGC036D Negative Cycle 做题记录",
			"link": "https://exber.qzz.io/post/AGC036D%20Negative%20Cycle%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2025-10-24 19:26:28"
		},
	
		{
			"abstract": "> 有 $n$ 个人在一条数轴上，第 $i$ 个人位于 $X_i$。\n>\n> 每个人手中有一个烟花，每一个烟花可以燃烧 $T$ 秒。**（可加强到每个人烟花燃烧时间不同）**\n>\n> 第 $0$ 秒时，第 $k$ 个人的烟花开始燃烧。\n>\n> 人们可以在数轴上以相同的速度 $s$ 奔跑（即每秒奔跑 $s$ 个单位）。当两个人位于同一个位置，并且某一个人手中的烟花是点燃状态且另一个人手中的烟花未点燃，那么他们可以**选择是否**传火，即点燃另一个人手中的烟花。\n>\n> 求最小的非负整数 $s$ 使得所有人的烟花都可以被点燃。\n>\n> $1\\le n\\le 10^5$，$0\\le X_i,T\\le 10^9$，$X_i\\le X_{i+1}$。\n",
			"content": "> 有 $n$ 个人在一条数轴上，第 $i$ 个人位于 $X_i$。\n>\n> 每个人手中有一个烟花，每一个烟花可以燃烧 $T$ 秒。**（可加强到每个人烟花燃烧时间不同）**\n>\n> 第 $0$ 秒时，第 $k$ 个人的烟花开始燃烧。\n>\n> 人们可以在数轴上以相同的速度 $s$ 奔跑（即每秒奔跑 $s$ 个单位）。当两个人位于同一个位置，并且某一个人手中的烟花是点燃状态且另一个人手中的烟花未点燃，那么他们可以**选择是否**传火，即点燃另一个人手中的烟花。\n>\n> 求最小的非负整数 $s$ 使得所有人的烟花都可以被点燃。\n>\n> $1\\le n\\le 10^5$，$0\\le X_i,T\\le 10^9$，$X_i\\le X_{i+1}$。\n\n\n对于刚开始只有 $k$ 点燃的一段时间，显然在 $k$ 遇到第一个人之前它的方向不变，且两边的人都往中间跑。不妨假设 $k$ 向右跑，那么可以看作是 $[1,k]$ 这些人不动，$[k+1,n]$ 这些人以 $2s$ 的速度向左跑；$k$ 向左跑同理。\n\n而当 $k$ 和第一个人相遇后，显然不用急着传火。这个人会跟着 $k$，直到 $k$ 的烟花烧完的那一刻再传火。证明考虑如果这两人同向是显然的，异向的话假设这个人是 $k+1$，则相当于 $[1,k]$ 不动 $[k+1,n]$ 以 $2s$ 的速度向左。那么由于 $[1,k-1]$ 不动所以第 $k+1$ 个人早点去点燃它们还不如等到 $k$ 燃尽了再去。\n\n所以有结论：\n\n> 每个时刻，至多只有一个人手中的烟花是点燃的，且所有人一定一直在奔跑。\n\n那么设 $a_i=X_{k-i+1}-X_{k-i},b_i=X_{k+i}-X_{k+i-1}$ 即左右两边的间隔序列，那么问题转化为打怪兽（双序列拓展版）：\n\n>有一个变量 $x$，刚开始 $x=2sT$。\n>\n>每次可以选择 $a_1$ 或者 $b_1$，假设选择的数为 $w$，则要求 $x\\ge w$，并且令 $x:=x-w+2sT$ 后在对应的序列中删去 $w$。\n>\n>求最小的非负整数 $s$ 使得两个序列可以被删空。\n\n那么二分，转化为判定问题。接下来有两种做法：\n\n#### 01 on Tree 做法\n\n考虑打怪兽（每个怪兽贡献 $-a+b$，要求 $x>a$）的结论：\n\n- 先打 $a\\le b$ 的怪兽，按照 $a$ 从小到大打；\n- 再打 $a>b$ 的怪兽，按照 $b$ 从大到小打；\n\n两部分之间的顺序和第一部分很好理解，第二部分证明可以考虑倒着做。\n\n这个相当于是树上打怪兽，要求要先打完祖先的怪兽才能打这个点上的。那么对于一个点 $u$，若按照这个顺序其排名比 $fa_u$ 靠前，则打完 $fa_u$ 一定马上就会打 $u$。所以可以将 $u$ 和 $fa_u$ 合并。\n\n那么可以按照这个顺序维护一个最小堆，每次取出堆顶 $u$，如果 $u$ 是根则打它并将它删掉，否则合并它和它的父亲。\n\n这样做单次 check 复杂度 $O(n\\log n)$，总复杂度 $O(n\\log^2n)$。\n\n#### 贪心做法\n\n考虑不断对于两个序列找到最小的正收益（$\\sum 2sT-a_i\\ge0$）的前缀，如果当前不能获取任何一个正收益则死了，否则获取正收益并干掉这个前缀，直到两个序列都不存在正收益的前缀。\n\n这样可以得知获取完正收益后变量 $x$ 的值 $val$。\n\n接下来倒过来做，考虑找出剩下的怪兽至少要求 $x$ 是多少（$del$）才能打完。那么每次找到最小的正收益（$\\sum a_i-2sT\\ge 0$）的后缀，取两个序列的后缀中对 $del$ 改变最小的那个干掉。而由于不存在 $\\sum 2sT-a_i\\ge 0$ 的前缀，所以不断干掉正收益的后缀一定能把两个序列都删空。\n\n最后判断是否 $val\\ge del$ 即可。\n\n这样做单次 check 复杂度 $O(n)$，总复杂度 $O(n\\log n)$。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int S=100005;\nconst ll inf=2e9,INF=9e18;\n\nint n,k;\nll m;\nll pos[S];\nint ka,kb;\nll a[S],b[S];\n\ninline bool chk(ll x)\n{\n\tll ad=m*x*2;\n\tll val=ad;\n\tint la=1,lb=1;\n\t{// first\n\t\tauto fndr=[&](ll a[],int l,int len){\n\t\t\tll mxa=0;\n\t\t\tll sma=0,smb=0;\n\t\t\tfor(int i=l;i<=len;i++)\n\t\t\t{\n\t\t\t\tmxa=max(mxa,a[i]+sma-smb);\n\t\t\t\tsma+=a[i],smb+=ad;\n\t\t\t\tif(sma<=smb) return make_pair(mxa,i);\n\t\t\t}\n\t\t\treturn make_pair(INF,-1);\n\t\t};\n\t\tauto va=fndr(a,la,ka),vb=fndr(b,lb,kb);\n\t\twhile(1)\n\t\t{\n\t\t\tbool fl=false;\n\t\t\tif(val>=va.first)\n\t\t\t{\n\t\t\t\twhile(la<=va.second) val-=a[la++],val+=ad;\n\t\t\t\tva=fndr(a,la,ka);\n\t\t\t\tfl=true;\n\t\t\t}\n\t\t\tif(val>=vb.first)\n\t\t\t{\n\t\t\t\twhile(lb<=vb.second) val-=b[lb++],val+=ad;\n\t\t\t\tvb=fndr(b,lb,kb);\n\t\t\t\tfl=true;\n\t\t\t}\n\t\t\tif(!fl) break;\n\t\t}\n\t\tif(va.first!=INF||vb.first!=INF) return false;\n\t}\n\t// if(x==1)\n\t// {\n\t\t// printf(\"%d/%d %d/%d\\n\",la,ka,lb,kb);\n\t\t// printf(\"%lld\\n\",val);\n\t// }\n\tll del=0;\n\t{// second\n\t\tint ra=ka,rb=kb;\n\t\tauto fndl=[&](ll a[],int r,int l){\n\t\t\tll mxa=0;\n\t\t\tll sma=0,smb=0;\n\t\t\tfor(int i=r;i>=l;i--)\n\t\t\t{\n\t\t\t\tmxa=max(mxa,ad+sma-smb);\n\t\t\t\tsma+=ad,smb+=a[i];\n\t\t\t\tif(sma<=smb) return make_pair(mxa,i);\n\t\t\t}\n\t\t\treturn make_pair(INF,-1);\n\t\t};\n\t\tauto va=fndl(a,ra,la),vb=fndl(b,rb,lb);\n\t\twhile(ra>=la||rb>=lb)\n\t\t{\n\t\t\tif(vb.first>va.first)\n\t\t\t{\n\t\t\t\tdel=max(del,va.first);\n\t\t\t\twhile(ra>=va.second) del-=ad,del+=a[ra--];\n\t\t\t\tva=fndl(a,ra,la);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdel=max(del,vb.first);\n\t\t\t\twhile(rb>=vb.second) del-=ad,del+=b[rb--];\n\t\t\t\tvb=fndl(b,rb,lb);\n\t\t\t}\n\t\t}\n\t}\n\treturn val>=del;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tcin>>n>>k>>m;\n\tfor(int i=1;i<=n;i++) cin>>pos[i];\n\t{\n\t\tbool fl=true;\n\t\tfor(int i=1;i<=n&&fl;i++) fl&=(pos[i]==pos[1]);\n\t\tif(fl) return cout<<\"0\\n\",0;\n\t}\n\tfor(int i=k-1;i>=1;i--) a[++ka]=pos[i+1]-pos[i];\n\tfor(int i=k+1;i<=n;i++) b[++kb]=pos[i]-pos[i-1];\n\tll lb=1,rb=inf,res=-1;\n\twhile(lb<=rb)\n\t{\n\t\tll mid=lb+rb>>1;\n\t\tif(chk(mid)) res=mid,rb=mid-1;\n\t\telse lb=mid+1;\n\t}\n\tcout<<res<<'\\n';\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"结论"},{"name":"贪心"}],
			"title": "AT_joisc2017_c 手持ち花火 (Sparklers) 做题记录",
			"link": "https://exber.qzz.io/post/AT_joisc2017_c%20%E6%89%8B%E6%8C%81%E3%81%A1%E8%8A%B1%E7%81%AB%20%28Sparklers%29%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2025-10-17 10:46:23"
		},
	
		{
			"abstract": "",
			"content": "### 前向扩散\n\n#### 定义\n\n考虑这样一个过程，对于一张图片 $x_0$，我们不断为其增加噪声：（注意这表示对图片中每个像素点的每个颜色通道归一化到 $[-1,1]$ 后的值同时进行操作）\n$$\nx_t\\sim\\sqrt{\\alpha_t}\\times x_{t-1}+\\sqrt{\\beta_t}\\times \\mathcal{N}(0,1)\n$$\n其中 $\\mathcal{N}(0,1)$ 表示均值为 $0$，方差为 $1$ 的正态分布（标准正态分布），则相当于 $x_t$ 从均值为 $\\sqrt\\alpha_t\\times x_{t-1}$，方差为 $\\beta_t$ 的正态分布中抽样。\n\n其中 $\\alpha_t$ 和 $\\beta_t$ 是人为设置的超参数，应有 $\\beta_t\\approx0$，保证每一步加入的噪声比较少。\n\n我们的目标是，在足够多轮后（例如 $T=1000$），使得可以近似 $x_T\\sim \\mathcal{N}(0,1)$。这样就可以从标准正态分布随机采样一个 $x_T$，再一步一步倒回来得到 $x_0$。\n\n注意前向扩散过程中方差 $\\sigma^2_t$ 的变化：\n$$\n\\sigma^2_{t}=\\alpha_t\\times\\sigma^2_{t-1}+\\beta_t\n$$\n我们希望 $\\sigma^2_T\\approx 1$。不妨假定 $\\sigma^2_0=1$（这可以通过对数据集进行标准化保证），也就是说我们希望扩散完成后方差依然为 $1$，则为了保证扩散过程中的稳定性，不妨对于所有 $t$，都保证 $\\sigma_t^2=1$。\n\n那么代入：\n$$\n1=\\alpha_t+\\beta_t\n$$\n故一般保证 $\\alpha_t+\\beta_t=1$。\n\n#### 一步到位\n\n考虑 $x_{t}$ 和 $x_{t-2}$ 的关系：\n$$\n\\begin{aligned}\nx_t&\\sim\\sqrt{\\alpha_t}\\times x_{t-1}+\\sqrt{\\beta_t}\\times \\mathcal{N}(0,1)\\\\\n&\\sim\\sqrt{\\alpha_t}\\times\\left(\\sqrt{\\alpha_{t-1}}\\times x_{t-2}+\\sqrt{\\beta_{t-1}}\\times \\mathcal{N}(0,1)\\right)+\\sqrt{\\beta_t}\\times \\mathcal{N}(0,1)\\\\\n&\\sim\\sqrt{\\alpha_t\\alpha_{t-1}}\\times x_{t-2}+\\underbrace{\\sqrt{\\alpha_t\\beta_{t-1}}\\times \\mathcal{N}(0,1)}_{\\text{方差为 }\\alpha_t\\beta_{t-1}\\text{ }的正态分布}+\\underbrace{\\sqrt{\\beta_t}\\times \\mathcal{N}(0,1)}_{\\text{方差为 }\\beta_{t}\\text{ }的正态分布}\\\\\n\\end{aligned}\n$$\n由正态分布的叠加性，对于两个相互独立的正态分布，有 $\\mathcal{N}(\\mu_1,\\sigma^2_1)+\\mathcal{N}(\\mu_2,\\sigma^2_2)=\\mathcal{N}(\\mu_1+\\mu_2,\\sigma^2_1+\\sigma^2_2)$，所以有：\n$$\n\\underbrace{\\sqrt{\\alpha_t\\beta_{t-1}}\\times \\mathcal{N}(0,1)}_{\\text{方差为 }\\alpha_t\\beta_{t-1}\\text{ }的正态分布}+\\underbrace{\\sqrt{\\beta_t}\\times \\mathcal{N}(0,1)}_{\\text{方差为 }\\beta_{t}\\text{ }的正态分布}=\\underbrace{\\sqrt{\\alpha_t\\beta_{t-1}+\\beta_t}\\times \\mathcal{N}(0,1)}_{\\text{方差为 }\\alpha_t\\beta_{t-1}+\\beta_{t}\\text{ }的正态分布}\n$$\n而由于 $\\alpha_t+\\beta_t=1$，故：\n$$\n\\begin{aligned}\n\\alpha_t\\beta_{t-1}+\\beta_t&=\\alpha_t(1-\\alpha_{t-1})+1-\\alpha_t\\\\\n&=\\alpha_t-\\alpha_t\\alpha_{t-1}+1-\\alpha_t\\\\\n&=1-\\alpha_t\\alpha_{t-1}\n\\end{aligned}\n$$\n所以：\n$$\nx_t\\sim\\sqrt{\\alpha_t\\alpha_{t-1}}\\times x_{t-2}+\\sqrt{1-\\alpha_t\\alpha_{t-1}}\\times \\mathcal{N}(0,1)\n$$\n以此类推，有：\n$$\nx_t\\sim \\sqrt{\\underbrace{\\alpha_t\\alpha_{t-1}\\dots\\alpha_1}_{\\text{记为 }\\bar\\alpha_t}}\\times x_0+ \\sqrt{\\underbrace{1-\\alpha_t\\alpha_{t-1}\\dots\\alpha_1}_{\\text{记为 }\\bar\\beta_t}}\\times\\mathcal{N}(0,1)\n$$\n\n### 反向生成\n\n#### 预测什么\n\n为了实现反向生成，我们需要预测每一步加入的噪声 $\\epsilon_t\\sim \\mathcal{N}(0,1)$，从而根据 $x_t$ 推出 $x_{t-1}$：\n$$\nx_{t}=\\sqrt{\\alpha_t}\\times x_{t-1}+\\sqrt{\\beta_t}\\times \\epsilon\\\\\nx_{t-1}=\\frac{1}{\\sqrt{\\alpha_t}}\\times \\left(x_{t}-\\sqrt{\\beta_t}\\times\\epsilon\\right)\n$$\n对比下面两条式子：\n$$\nx_t\\sim \\sqrt{\\alpha_t}\\times \\left(\\sqrt{\\bar\\alpha_{t-1}}\\times x_0+\\sqrt{\\bar\\beta_{t-1}}\\times \\mathcal{N}(0,1)\\right) + \\sqrt{\\beta_t}\\times \\epsilon_1\\\\\nx_t\\sim \\sqrt{\\bar\\alpha_t}\\times x_0+\\sqrt{\\bar\\beta_t}\\times \\epsilon_2\n$$\n第一条是直接训练模型去拟合每一步加入的噪声，第二条是训练模型去拟合一步到位的噪声。\n\n不难发现，根据第一条去训练就需要每次采样 $x_0,t$ 和两个服从 $\\mathcal{N}(0,1)$ 的随机变量，比下面那一条多一个需要采样的变量，故较难收敛，训练起来更加费时费力。\n\n所以不妨直接训练模型去拟合一步到位的噪声 $\\epsilon_2$，即每次训练：\n\n- 采样 $x_0,t$，再从 $\\mathcal{N}(0,1)$ 采样一个 $\\epsilon$；\n- 计算 $x_t=\\sqrt{\\bar\\alpha_t}\\times x_0+\\sqrt{\\bar\\beta_t}\\times \\epsilon$；\n- 根据模型的输出 $M(x_t,t)$ 和 $\\epsilon$ 的差异，进行反向传播，更新参数；\n\n那么根据 $x_t\\sim \\sqrt{\\bar\\alpha_t}\\times x_0+\\sqrt{\\bar\\beta_t}\\times \\epsilon$，我们可以得知：\n$$\nx_0=\\frac{1}{\\sqrt{\\bar\\alpha_t}}\\times\\left(x_t-\\sqrt{\\bar\\beta_t}\\times M(x_t,t)\\right)\n$$\n但是直接一步到位去预测 $x_0$ 是不现实的，下面来推导一下怎么根据 $M(x_t,t)$ 的输出得到每一步加入的噪声 $\\epsilon_t$。\n\n#### 逐步逆向\n\n令：\n\n- $P(x_t|x_0)$ 为已知原图为 $x_0$，第 $t$ 步扩散结果等于 $x_t$ 的概率；\n- $P(x_{t-1},x_t|x_0)$ 为已知原图为 $x_0$，第 $t-1$ 步扩散结果等于 $x_{t-1}$ 且第 $t$ 步扩散结果等于 $x_t$ 的概率；\n- $P(x_t|x_{t-1},x_0)$ 为已知第 $t-1$ 步扩散结果等于 $x_{t-1}$ 且原图等于 $x_0$ 的前提下，第 $t$ 步扩散结果等于 $x_{t}$ 的概率，$P(x_{t-1}|x_{t},x_0)$ 同理。\n\n那么只要求出 $P(x_{t-1}|x_{t},x_0)$，我们就能代入 $x_t$ 和模型预测的 $x_0$，依据这个关于 $x_{t-1}$ 的概率密度函数直接采样得到 $x_{t-1}$。\n\n根据贝叶斯公式，有：\n$$\nP(x_{t-1}|x_{t},x_0)=\\frac{P(x_{t-1},x_t|x_0)}{P(x_{t}|x_0)}=\\frac{P(x_t|x_{t-1},x_0)\\times P(x_{t-1}|x_0)}{P(x_{t}|x_0)}\n$$\n根据之前的定义，有：\n\n- $P(x_t|x_{t-1},x_0)$：$x_t\\sim \\mathcal{N}(\\sqrt{\\alpha_t}x_{t-1},\\beta_t)$；\n- $P(x_{t-1}|x_0)$：$x_{t-1}\\sim\\mathcal{N}(\\sqrt{\\bar\\alpha_{t-1}}x_{0},\\bar\\beta_{t-1})$；\n- $P(x_{t}|x_0)$：$x_{t}\\sim\\mathcal{N}(\\sqrt{\\bar\\alpha_t}x_{0},\\bar\\beta_t)$；\n\n由于正态分布 $\\mathcal{N}(\\mu,\\sigma^2)$ 的概率密度函数（抽样得到 $x$ 的概率）为 $\\exp\\left(-\\frac{1}{2}\\times \\frac{(x-\\mu)^2}{\\sigma^2}\\right)$，故 $P(x_{t-1}|x_{t},x_0)$ 等于：\n$$\n\\exp\\left(-\\frac{1}{2}\\times \\left(\\frac{\\left(x_t-\\sqrt{\\alpha_t}x_{t-1}\\right)^2}{\\beta_t}+\\frac{\\left(x_{t-1}-\\sqrt{\\bar\\alpha_{t-1}}x_0\\right)^2}{\\bar\\beta_{t-1}}-\\frac{\\left(x_{t}-\\sqrt{\\bar\\alpha_{t}}x_0\\right)^2}{\\bar\\beta_t}\\right)\\right)\n$$\n对 $-\\frac{1}{2}\\times(\\dots)$ 里的东西变形，注意到我们只关心和 $x_{t-1}$ 有关的项（常数不影响后续的配方）：\n$$\n\\frac{\\left(x_t-\\sqrt{\\alpha_t}x_{t-1}\\right)^2}{\\beta_t}+\\frac{\\left(x_{t-1}-\\sqrt{\\bar\\alpha_{t-1}}x_0\\right)^2}{\\bar\\beta_{t-1}}-\\frac{\\left(x_{t}-\\sqrt{\\bar\\alpha_{t}}x_0\\right)^2}{\\bar\\beta_t}\\\\\n\\frac{x_t^2-2\\sqrt{\\alpha_t}x_tx_{t-1}+\\alpha_tx_{t-1}^2}{\\beta_t}+\\frac{x_{t-1}^2-2\\sqrt{\\bar\\alpha_{t-1}}x_{t-1}x_0+\\bar\\alpha_{t-1}x_0^2}{\\bar\\beta_{t-1}}\\\\\n\\frac{-2\\sqrt{\\alpha_t}x_t}{\\beta_t}\\times x_{t-1}+\\frac{\\alpha_t}{\\beta_t}\\times x_{t-1}^2+\\frac{1}{\\bar\\beta_{t-1}}\\times x_{t-1}^2+\\frac{-2\\sqrt{\\bar\\alpha_{t-1}}x_0}{\\bar\\beta_{t-1}}\\times x_{t-1}\\\\\n\\left(\\frac{\\alpha_t}{\\beta_t}+\\frac{1}{\\bar\\beta_{t-1}}\\right)\\times x_{t-1}^2-2\\left(\\frac{\\sqrt{\\alpha_t}x_t}{\\beta_t}+\\frac{\\sqrt{\\bar\\alpha_{t-1}}x_0}{\\bar\\beta_{t-1}}\\right)\\times x_{t-1}\\\\\n$$\n接下来对其进行配方，使其变为 $\\frac{(x_{t-1}-\\mu)^2}{\\sigma^2}$ 的形式，则：\n$$\n\\frac{(x_{t-1}-\\mu)^2}{\\sigma^2}=\\frac{x_{t-1}^2-2\\mu x_{t-1}+\\mu^2}{\\sigma^2}\\\\\n\\frac{1}{\\sigma^2}\\times x_{t-1}^2-2\\frac{\\mu}{\\sigma^2}\\times x_{t-1}\n$$\n所以：\n$$\n\\sigma^2=\\frac{1}{\\frac{\\alpha_t}{\\beta_t}+\\frac{1}{\\bar\\beta_{t-1}}}\\\\\n=\\frac{\\beta_t\\bar\\beta_{t-1}}{\\alpha_t\\bar\\beta_{t-1}+\\beta_t}\\\\\n=\\frac{\\beta_t\\bar\\beta_{t-1}}{\\alpha_t-\\bar\\alpha_{t}+1-\\alpha_t}\\\\\n=\\frac{\\beta_t\\bar\\beta_{t-1}}{\\bar\\beta_t}\\\\\n\\mu=\\left(\\frac{\\sqrt{\\alpha_t}x_t}{\\beta_t}+\\frac{\\sqrt{\\bar\\alpha_{t-1}}x_0}{\\bar\\beta_{t-1}}\\right)\\times \\sigma^2\\\\\n=\\frac{\\bar\\beta_{t-1}\\sqrt{\\alpha_t}x_t+\\beta_t\\sqrt{\\bar\\alpha_{t-1}}x_0}{\\beta_t\\bar\\beta_{t-1}}\\times \\frac{\\beta_t\\bar\\beta_{t-1}}{\\bar\\beta_t}\\\\\n=\\frac{\\bar\\beta_{t-1}\\sqrt{\\alpha_t}x_t+\\beta_t\\sqrt{\\bar\\alpha_{t-1}}x_0}{\\bar\\beta_t}\n$$\n注意到方差与模型的预测无关，所以也有人说 DDPM 就是在预测每一步的均值。\n\n根据模型的预测，将 $x_0$ 代入：\n$$\n\\begin{aligned}\n\\mu&=\\frac{\\bar\\beta_{t-1}\\sqrt{\\alpha_t}x_t+\\beta_t\\sqrt{\\bar\\alpha_{t-1}}x_0}{\\bar\\beta_t}\\\\\n&=\\frac{\\bar\\beta_{t-1}\\sqrt{\\alpha_t}x_t+\\beta_t\\sqrt{\\bar\\alpha_{t-1}}\\frac{1}{\\sqrt{\\bar\\alpha_t}}\\left(x_t-\\sqrt{\\bar\\beta_t}M(x_t,t)\\right)}{\\bar\\beta_t}\\\\\n&=\\frac{\\bar\\beta_{t-1}\\sqrt{\\alpha_t}x_t+\\frac{\\beta_t\\sqrt{\\bar\\alpha_{t-1}}}{\\sqrt{\\bar\\alpha_t}}x_t-\\frac{\\beta_t\\sqrt{\\bar\\alpha_{t-1}}\\sqrt{\\bar\\beta_t}}{\\sqrt{\\bar\\alpha_t}}M(x_t,t)}{\\bar\\beta_t}\\\\\n&=\\frac{\\bar\\beta_{t-1}\\sqrt{\\alpha_t}\\sqrt{\\bar\\alpha_t}+\\beta_t\\sqrt{\\bar\\alpha_{t-1}}}{\\sqrt{\\bar\\alpha_t}\\bar\\beta_t}x_t-\\frac{\\beta_t\\sqrt{\\bar\\alpha_{t-1}}\\sqrt{\\bar\\beta_t}}{\\sqrt{\\bar\\alpha_t}\\bar\\beta_t}M(x_t,t)\\\\\n&=\\frac{\\left(\\bar\\beta_{t-1}\\alpha_t+\\beta_t\\right)\\sqrt{\\bar\\alpha_{t-1}}}{\\sqrt{\\bar\\alpha_t}\\bar\\beta_t}x_t-\\frac{\\beta_t}{\\sqrt{\\alpha_t}\\sqrt{\\bar\\beta_t}}M(x_t,t)\\\\\n&=\\frac{\\left(\\alpha_t-\\bar\\alpha_t+1-\\alpha_t\\right)\\sqrt{\\bar\\alpha_{t-1}}}{\\sqrt{\\bar\\alpha_t}\\bar\\beta_t}x_t-\\frac{\\beta_t}{\\sqrt{\\alpha_t}\\sqrt{\\bar\\beta_t}}M(x_t,t)\\\\\n&=\\frac{1}{\\sqrt{\\alpha_t}}x_t-\\frac{\\beta_t}{\\sqrt{\\alpha_t}\\sqrt{\\bar\\beta_t}}M(x_t,t)\\\\\n&=\\frac{1}{\\sqrt{\\alpha_t}}\\left(x_t-\\frac{\\beta_t}{\\sqrt{\\bar\\beta_t}}M(x_t,t)\\right)\\\\\n\\end{aligned}\n$$\n那么我们就得到了反向过程中每一步的采样公式：\n$$\nx_{t-1}\\sim \\frac{1}{\\sqrt{\\alpha_t}}\\left(x_t-\\frac{\\beta_t}{\\sqrt{\\bar\\beta_t}}M(x_t,t)\\right)+\\sqrt{\\frac{\\beta_t\\bar\\beta_{t-1}}{\\bar\\beta_t}}\\times\\mathcal{N}(0,1)\n$$\n将 $\\beta$ 和 $\\bar\\beta$ 展开就得到了原论文中的形式：\n$$\nx_{t-1}\\sim \\frac{1}{\\sqrt{\\alpha_t}}\\left(x_t-\\frac{1-\\alpha_t}{\\sqrt{1-\\bar\\alpha_t}}M(x_t,t)\\right)+\\sqrt{\\beta_t\\times \\frac{1-\\bar\\alpha_{t-1}}{1-\\bar\\alpha_{t}}}\\times\\mathcal{N}(0,1)\n$$\n\n### 实现细节\n\n#### 超参设置\n\n##### Liner Schedule\n\n原论文中 $T=1000$，$\\beta_t=10^{-4}+\\frac{t}{T}\\times (0.02-10^{-4})$，即 $\\beta_t$ 从 $10^{-4}$ 线性递增到 $0.02$。\n\n这样设置符合直觉，毕竟 $t$ 越大 $x_t$ 就越接近随机噪声，对 $x_t$ 的破坏量 $\\beta_t$ 就可以相应地增大。而经计算可得 $\\bar\\alpha_{T}\\approx 4\\times 10^{-5}$，符合 $x_T$ 的分布接近 $\\mathcal{N}(0,1)$ 的需求。\n\n##### Cosine Schedule\n\n观察 Liner Schedule 的 $\\bar\\alpha_t$ 的曲线就会发现，似乎后面有很多步都是没用的，前一半扩散得太快：\n\n![](../post-images/1756524136510.png)\n\n所以后来提出了一种改进方法，设置 $\\bar a_t=\\cos\\left(\\frac{\\frac{t}{T}+\\epsilon}{1+\\epsilon}\\times \\frac{\\pi}{2}\\right)^2$，其中 $\\epsilon$ 是为了稳定数值引入的极小量，一般设置为 $10^{-3}$：（图中蓝色曲线）\n![](../post-images/1756525465639.png)\n\n实验表明，这样设置超参数可以利用好后面的扩散进程，效果更好。\n\n实际应用中，一般令 $f(t)=\\cos\\left(\\frac{\\frac{t}{T}+\\epsilon}{1+\\epsilon}\\times \\frac{\\pi}{2}\\right)^2$，$\\bar\\alpha_t=\\frac{f(t)}{f(0)}$，并将 $\\alpha_t$ 裁剪到 $[\\epsilon,1-\\epsilon]$，其中 $\\epsilon$ 一般设置为 $10^{-3}$。\n\n#### 模型及损失函数选取\n\n对于这种输入和输出张量形状相同的任务，一般选用 U-Net 模型。而由于模型是在预测一个服从正态分布的变量，故输出应较为接近 $0$，故可用 $\\text{MSE}$（均方误差）损失函数。\n\n需要注意的是，时间步 $t$ 也要输入模型中，一般是以 Transformer 中三角函数位置编码的形式嵌入进 U-Net 中的。\n\n这里给出对于 $32\\times 32$ 的三通道图片的 U-Net 结构：\n\n![](../post-images/1756527052285.png)\n\n其中 DownBlock 和 UpBlock 结构一样：（TimeEmbedding 即为和 Transformer 中位置编码一样的三角函数编码，经过一个简单的多层感知机（MLP）变换后的结果）\n\n![](../post-images/1756527212193.jpg)\n\nMiddleBlock 则是一个对称的结构，不过其实也可以贪方便直接使用 DownBlock 替代掉：\n\n![](../post-images/1756527299162.jpg)\n\n激活函数则一般使用 SiLU 这种一阶导平滑连续的函数，增强其在 $0$ 附近的表达能力（实测 ReLU 和 Leaky_ReLU 效果都不太好）。\n\n这是一个小小的 Demo，使用了[自己的 C++ 机器学习库](https://github.com/Rebxe/network.h)、[开源库 stb](https://github.com/nothings/stb) 和 [C++ 图形库 EasyX](easyx.cn)，实现了生成指定类型的手写数字：\n\n<details><summary><code>U_NET.h</code></summary><p>\n\n```cpp\n#pragma once\n\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <fstream>\n#include <random>\n#include <ctime>\n#include <vector>\n\n#include \"./network_h/network.h\"\n\nusing namespace std;\n\nusing namespace network;\n\nconst dim_t Batch_Size = 32;\nconst dim_t time_dim = 256, emb_dim = 32, model_dim = 64;\n\ninline void time_embedding(dim_t t, dim_t dim, float* out)\n{\n\tfor (dim_t i = 0; i < dim; i++)\n\t{\n\t\tfloat wk = pow(10000, -(i / 2 * 2) / (float)dim);\n\t\tif (i & 1 ^ 1) out[i] = sin(wk * t);\n\t\telse out[i] = cos(wk * t);\n\t}\n}\n\nclass BLOCK : public OP_Base\n{\npublic:\n\tFC* fc1, * fc2; // time_liner & type_liner\n\tCONV* c0, * c1, * c2, * c3;\n\tGN* gn1, * gn2, * gn3;\n\tBLOCK(OP_Base* fap, dim_t d, dim_t d2, dim_t h, dim_t w) :OP_Base(fap)\n\t{\n\t\tif (d != d2) c0 = get<CONV>(af::dim4{ h,w,d,0 }, make_pair(3, 3), d2, make_pair(1, 1), make_pair(1, 1));\n\t\telse c0 = NULL;\n\t\tfc1 = get<FC>(time_dim, d2), fc2 = get<FC>(emb_dim, d2);\n\t\tc1 = get<CONV>(af::dim4{ h,w,d,0 }, make_pair(3, 3), d2, make_pair(1, 1), make_pair(1, 1));\n\t\tgn1 = get<GN>(2, d2, 32, true);\n\t\tc2 = get<CONV>(af::dim4{ h,w,d2,0 }, make_pair(3, 3), d2, make_pair(1, 1), make_pair(1, 1));\n\t\tgn2 = get<GN>(2, d2, 32, true);\n\t\tc3 = get<CONV>(af::dim4{ h,w,d2,0 }, make_pair(3, 3), d2, make_pair(1, 1), make_pair(1, 1));\n\t\tgn3 = get<GN>(2, d2, 32, true);\n\t}\n\tval4d* operator()(val4d* x, val4d* time_emb, val4d* type_emb)\n\t{\n\t\tval4d* y;\n\t\tif (c0 != NULL) y = (*c0)(x), y = silu(y, true);\n\t\telse y = x;\n\t\t// add time_emb\n\t\tx = (*c1)(x), x = silu(x, true);\n\t\ttime_emb = (*fc1)(time_emb), time_emb = silu(time_emb, true);\n\t\tx = add(x, tile(time_emb, af::dim4{ x->dims(0),x->dims(1),1,1 }));\n\t\tx = (*gn1)(x);\n\t\t// add type_emb\n\t\tx = (*c2)(x), x = silu(x, true);\n\t\ttype_emb = (*fc2)(type_emb), type_emb = silu(type_emb, true);\n\t\tx = add(x, tile(type_emb, af::dim4{ x->dims(0),x->dims(1),1,1 }));\n\t\tx = (*gn2)(x);\n\t\t// add short cut\n\t\tx = (*c3)(x), x = silu(x, true);\n\t\tx = add(x, y);\n\t\tx = (*gn3)(x);\n\t\treturn x;\n\t}\n};\n\nclass DOWN :public OP_Base\n{\npublic:\n\tCONV* c;\n\tGN* gn;\n\tDOWN(OP_Base* fap, dim_t d, dim_t h, dim_t w) :OP_Base(fap)\n\t{\n\t\tc = get<CONV>(af::dim4{ h,w,d,0 }, make_pair(4, 4), d * 2, make_pair(2, 2), make_pair(1, 1));\n\t\tgn = get<GN>(2, d * 2, 32, true);\n\t}\n\tval4d* operator()(val4d* x)\n\t{\n\t\tx = (*c)(x), x = silu(x, true), x = (*gn)(x);\n\t\treturn x;\n\t}\n};\n\nclass UP :public OP_Base\n{\npublic:\n\tCONV* c1, *c2;\n\tGN* gn1, * gn2;\n\tUP(OP_Base* fap, dim_t d, dim_t h, dim_t w) :OP_Base(fap)\n\t{\n\t\tc1 = get<CONV>(af::dim4{ h * 2,w * 2,d,0 }, make_pair(3, 3), d, make_pair(1, 1), make_pair(1, 1));\n\t\tgn1 = get<GN>(2, d, 32, true);\n\t\tc2 = get<CONV>(af::dim4{ h * 2,w * 2,d,0 }, make_pair(3, 3), d / 2, make_pair(1, 1), make_pair(1, 1));\n\t\tgn2 = get<GN>(2, d / 2, 32, true);\n\t}\n\tval4d* operator()(val4d* x)\n\t{\n\t\tx = upsample(x, { 2,2 });\n\t\tx = (*c1)(x), x = silu(x, true), x = (*gn1)(x);\n\t\tx = (*c2)(x), x = silu(x, true), x = (*gn2)(x);\n\t\treturn x;\n\t}\n};\n\nclass U_NET : public OP_Base\n{\npublic:\n\t/****Time Embedding****/\n\tFC* fc0, * fc1;\n\n\t/****Type Embedding****/\n\tEMBEDDING* emb;\n\n\n\t/****In****/\n\tCONV* c0;\n\n\t/****Encoder****/\n\tBLOCK* down_b[3][2];\n\tDOWN* down[3];\n\n\t/****Middle*****/\n\tBLOCK* mid[3];\n\n\t/****Decoder****/\n\tUP* up[3];\n\tBLOCK* up_b[3][2];\n\n\t/****Out*****/\n\tCONV* c1;\n\n\tfloat in[Batch_Size * 1 * 32 * 32];\n\tfloat ftime_emb[Batch_Size * time_dim];\n\tdim_t in_t[Batch_Size], in_type[Batch_Size];\n\tval4d* out;\n\n\tU_NET() :OP_Base(NULL)\n\t{\n\t\t// Time Embedding\n\t\tfc0 = get<FC>(time_dim, time_dim * 4), fc1 = get<FC>(time_dim * 4, time_dim);\n\t\t// Type Embedding\n\t\temb = get<EMBEDDING>(10, 1, emb_dim);\n\t\t// U-Net\n\t\tc0 = get<CONV>(af::dim4{ 32,32,1,0 }, make_pair(3, 3), model_dim, make_pair(1, 1), make_pair(1, 1));\n\t\tdim_t d = model_dim, h = 32, w = 32;\n\t\tfor (int i = 0; i < 3; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 2; j++) down_b[i][j] = get<BLOCK>(d, d, h, w);\n\t\t\tdown[i] = get<DOWN>(d, h, w);\n\t\t\td *= 2, h /= 2, w /= 2;\n\t\t}\n\t\tfor (int i = 0; i < 3; i++) mid[i] = get<BLOCK>(d, d, h, w);\n\t\tfor (int i = 0; i < 3; i++)\n\t\t{\n\t\t\tup[i] = get<UP>(d, h, w);\n\t\t\th *= 2, w *= 2, d /= 2;\n\t\t\tfor (int j = 0; j < 2; j++) up_b[i][j] = get<BLOCK>(d * 2, d, h, w);\n\t\t}\n\t\tc1 = get<CONV>(af::dim4{ h,w,d,0 }, make_pair(1, 1), 1, make_pair(1, 1), make_pair(0, 0), make_pair(1, 1), Init_Xavier);\n\t}\n\tinline void forward()\n\t{\n\t\tinit_forward();\n\t\tdim_t n = eval ? 1 : Batch_Size;\n\t\tval4d* time_emb, * type_emb;\n\t\t{\n\t\t\tfor (int i = 0; i < n; i++) time_embedding(in_t[i], time_dim, ftime_emb + i * time_dim);\n\t\t\taf::dim4 emb_s = af::dim4{ 1,1,time_dim,n };\n\t\t\ttime_emb = tmp<val4d>(emb_s);\n\t\t\ttime_emb->data() = af::array(emb_s, ftime_emb);\n\t\t\ttime_emb = (*fc0)(time_emb), time_emb = silu(time_emb, true);\n\t\t\ttime_emb = (*fc1)(time_emb), time_emb = silu(time_emb, true);\n\t\t}\n\t\t{\n\t\t\ttype_emb = (*emb)(n, in_type);\n\t\t}\n\t\taf::dim4 ins = { 32,32,1,eval ? 1 : Batch_Size };\n\t\tval4d* x = tmp<val4d>(ins);\n\t\tx->data() = af::array(ins, in);\n\t\tx = (*c0)(x);\n\t\tvector<val4d*> que;\n\t\tfor (int i = 0; i < 3; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 2; j++)\n\t\t\t{\n\t\t\t\tx = (*down_b[i][j])(x, time_emb, type_emb);\n\t\t\t\tque.push_back(x);\n\t\t\t}\n\t\t\tx = (*down[i])(x);\n\t\t}\n\t\tfor (int i = 0; i < 3; i++) x = (*mid[i])(x, time_emb, type_emb);\n\t\tfor (int i = 0; i < 3; i++)\n\t\t{\n\t\t\tx = (*up[i])(x);\n\t\t\tfor (int j = 0; j < 2; j++)\n\t\t\t{\n\t\t\t\tx = (*up_b[i][j])(concat({ x,que.back() }, 2), time_emb, type_emb);\n\t\t\t\tque.pop_back();\n\t\t\t}\n\t\t}\n\t\tx = (*c1)(x), x = tanh(x, true);\n\t\tout = x;\n\t}\n};\n\nclass WARMUP_COSINE\n{\nprivate:\n\tint t, tot_t;\n\tdouble preres;\npublic:\n\tdouble mnl, mxl;\n\tint WarmUp;\n\tdouble T_MAX, T_MLT;\n\tbool REPET;\n\npublic:\n\tvoid save(ofstream& ouf)\n\t{\n\t\twritf(ouf, mnl), writf(ouf, mxl);\n\t\twritf(ouf, WarmUp);\n\t\twritf(ouf, T_MAX), writf(ouf, T_MLT);\n\t\twritf(ouf, REPET);\n\t\twritf(ouf, t), writf(ouf, tot_t);\n\t\twritf(ouf, preres);\n\t}\n\tvoid load(ifstream& inf)\n\t{\n\t\treadf(inf, mnl), readf(inf, mxl);\n\t\treadf(inf, WarmUp);\n\t\treadf(inf, T_MAX), readf(inf, T_MLT);\n\t\treadf(inf, REPET);\n\t\treadf(inf, t), readf(inf, tot_t);\n\t\treadf(inf, preres);\n\t}\n\npublic:\n\tWARMUP_COSINE(double LLRT, double RLRT, int MAX_T, bool REP = true, int WUP = 0, double MLT_T = 1)\n\t{\n\t\tmnl = LLRT, mxl = RLRT, T_MAX = MAX_T, T_MLT = MLT_T, WarmUp = WUP;\n\t\tREPET = REP;\n\t\tt = tot_t = 0;\n\t\tpreres = WUP == 0 ? mxl : mnl;\n\t}\n\tdouble get() { return preres; }\n\tvoid step()\n\t{\n\t\ttot_t++;\n\t\tif (tot_t <= WarmUp)\n\t\t{\n\t\t\tpreres += (mxl - mnl) / (double)WarmUp;\n\t\t\treturn;\n\t\t}\n\t\tif (t > T_MAX) return;\n\t\tpreres = mnl + (1 / (double)2) * (mxl - mnl) * (1 + cos(t / (double)T_MAX * acos(-1)));\n\t\tt++;\n\t\tif (REPET && t == T_MAX + 1) t = 0, T_MAX *= T_MLT;\n\t}\n};\n```\n\n</p></details>\n\n<details><summary><code>main.cpp</code></summary><p>\n\n```cpp\n#define NDEBUG\n\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <fstream>\n#include <random>\n#include <ctime>\n#include <cmath>\n#include <sstream>\n#include <chrono>\n#include <io.h>\n#include <conio.h>\n\nusing namespace std;\n\n#include \"./U_NET.h\"\n\n#include \"stb_image.h\"\n#include \"stb_image_write.h\"\n\n#include <easyx.h>\n\nconst int tot_dat = 60000;\nconst int T = 1000;\nconst int save_t = 500;\nconst float grad_l = -1, grad_r = 1;\nconst float lrt_l = 0.00001, lrt_r = 0.0005;\nconst int total_batch = 10000, warm_up = 100;\n\nmt19937 rndgen(time(NULL));\nfloat a[T + 5], b[T + 5], a_[T + 5];\nfloat dat[tot_dat][1 * 32 * 32];\nint type[tot_dat];\nU_NET brn;\nADAM opt(brn.parameter(), lrt_l, 0.9, 0.999, 0.01);\nWARMUP_COSINE lrt_gen(lrt_l, lrt_r, total_batch, false, warm_up);\n\nvoid loaddata(string imgpath, string anspath)\n{\n\tFILE* fimg = fopen(imgpath.c_str(), \"rb\");\n\tFILE* fans = fopen(anspath.c_str(), \"rb\");\n\tif (fimg == NULL)\n\t{\n\t\tputs(\"加载图片数据失败\\n\");\n\t\tsystem(\"pause\");\n\t\texit(1);\n\t}\n\tif (fans == NULL)\n\t{\n\t\tputs(\"加载答案数据失败\\n\");\n\t\tsystem(\"pause\");\n\t\texit(1);\n\t}\n\tfseek(fimg, 16, SEEK_SET);\n\tfseek(fans, 8, SEEK_SET);\n\tunsigned char* img = new unsigned char[28 * 28];\n\tfor (int cas = 0; cas < tot_dat; cas++)\n\t{\n\t\tfread(img, 1, 28 * 28, fimg);\n\t\tfor (int i = 0; i < 32 * 32; i++) dat[cas][i] = -1;\n\t\tfor (int i = 0; i < 28 * 28; i++)\n\t\t{\n\t\t\tint x = i / 28, y = i % 28;\n\t\t\tdat[cas][(x + 2) * 32 + (y + 2)] = img[i] / (float)255 * 2 - 1;\n\t\t}\n\t\tunsigned char num;\n\t\tfread(&num, 1, 1, fans);\n\t\ttype[cas] = num;\n\t}\n\tdelete[] img;\n\tfclose(fimg), fclose(fans);\n}\ninline void putimg(int sx, int sy, float* a) // put a 64*64 img\n{\n\tfor (int i = 0; i < 32; i++)\n\t{\n\t\tfor (int j = 0; j < 32; j++)\n\t\t{\n\t\t\tfor (int k = 0; k < 2; k++)\n\t\t\t{\n\t\t\t\tfor (int l = 0; l < 2; l++)\n\t\t\t\t{\n\t\t\t\t\tputpixel(sx + j * 2 + k, sy + i * 2 + l, RGB(\n\t\t\t\t\t\t(a[i * 32 + j] + 1) / 2 * 255,\n\t\t\t\t\t\t(a[i * 32 + j] + 1) / 2 * 255,\n\t\t\t\t\t\t(a[i * 32 + j] + 1) / 2 * 255));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void init()\n{\n\t// Liner schedule\n\t/*\n\tfloat bl = 1e-4, br = 0.02;\n\tfor (int i = 1; i <= T; i++)\n\t{\n\t\tb[i] = bl + (float)(i - 1) / (T - 1) * (br - bl);\n\t\ta[i] = 1 - b[i];\n\t}\n\ta_[1] = a[1];\n\tfor (int i = 2; i <= T; i++) a_[i] = a_[i - 1] * a[i];\n\t*/\n\t\n\t// Cosine schedule\n\tfloat pi = acos(-1), eps = 1e-3;\n\tauto f = [&](int t) {return (float)pow(cos(((float)t / T + eps) / (1 + eps) * pi / 2), 2); };\n\ta[1] = (std::min)((std::max)(f(1) / f(0), eps), 1 - eps);\n\tfor (int i = 2; i <= T; i++) a[i] = (std::min)((std::max)(f(i) / f(i - 1), eps), 1 - eps);\n\tfor (int i = 1; i <= T; i++) b[i] = 1 - a[i];\n\ta_[1] = a[1];\n\tfor (int i = 2; i <= T; i++) a_[i] = a_[i - 1] * a[i];\n}\n\nfloat x0[1 * 32 * 32], noise[Batch_Size * 1 * 32 * 32];\n\nfloat train()\n{\n\tuniform_int_distribution<int> rndid(0, tot_dat - 1);\n\tuniform_int_distribution<int> rndt(1, T);\n\tnormal_distribution<float> n(0, 1);\n\tfor (int bs = 0; bs < Batch_Size; bs++)\n\t{\n\t\tint id = rndid(rndgen);\n\t\tint ad = bs * 1 * 32 * 32;\n\t\tfor (int i = 0; i < 1 * 32 * 32; i++) x0[i] = dat[id][i];\n\t\tfor (int i = 0; i < 1 * 32 * 32; i++) noise[ad + i] = n(rndgen);\n\t\tint t = rndt(rndgen);\n\t\tbrn.in_t[bs] = t;\n\t\tbrn.in_type[bs] = type[id];\n\t\tfor (int i = 0; i < 1 * 32 * 32; i++) brn.in[ad + i] = sqrt(a_[t]) * x0[i] + sqrt(1 - a_[t]) * noise[ad + i];\n\t}\n\tbrn.forward();\n\topt.clear_grad();\n\tfloat loss = MSEloss(brn.out, af::array({ 32,32,1,Batch_Size }, noise));\n\tbrn.out->backward();\n\tfor (auto t : brn.parameter()) *t.second = (af::max)((af::min)(*t.second, grad_r), grad_l); // grad_clip\n\topt.lrt = lrt_gen.get();\n\topt.step(), lrt_gen.step();\n\treturn loss;\n}\n\nunsigned char tmp[32][32], res[1 * 32 * 32];\n\ninline void work(int type, int sx, int sy)\n{\n\tnormal_distribution<float> n(0, 1);\n\tfor (int i = 0; i < 1 * 32 * 32; i++) brn.in[i] = n(rndgen);\n\tfor (int i = T; i >= 1; i--)\n\t{\n\t\tbrn.in_t[0] = i;\n\t\tbrn.in_type[0] = type;\n\t\tbrn.forward();\n\t\tfloat* out = brn.out->data().host<float>();\n\t\tfor (int j = 0; j < 1 * 32 * 32; j++)\n\t\t{\n\t\t\tbrn.in[j] = 1 / sqrt(a[i]) * (brn.in[j] - b[i] / sqrt(1 - a_[i]) * out[j])\n\t\t\t\t+ (i > 1 ? sqrt((1 - a_[i - 1]) / (1 - a_[i]) * b[i]) * n(rndgen) : 0);\n\t\t\tbrn.in[j] = max((float)-1, min((float)1, brn.in[j]));\n\t\t}\n\t\taf::freeHost(out);\n\t\tif (i % 1 == 0)\n\t\t{\n\t\t\tputimg(sx, sy, brn.in);\n\t\t\twstringstream ssm;\n\t\t\tssm << \"T = \" << i - 1 << \"   \";\n\t\t\touttextxy(80, 180, ssm.str().c_str());\n\t\t}\n\t}\n}\n\nvoid load(int idx)\n{\n\tstringstream ssm;\n\tssm << idx << \".ai\";\n\tifstream inf(ssm.str(), ios::in | ios::binary);\n\tbrn.load(inf);\n\topt.load(inf);\n\tlrt_gen.load(inf);\n\tinf.close();\n}\n\nvoid save(int idx)\n{\n\tstringstream ssm;\n\tssm << idx << \".ai\";\n\tofstream ouf(ssm.str(), ios::out | ios::binary);\n\tbrn.save(ouf);\n\topt.save(ouf);\n\tlrt_gen.save(ouf);\n\touf.close();\n}\n\nint main()\n{\n\tinit();\n\tprintf(\"模式选择：\\n\");\n\tprintf(\"[1] 训练\\n\");\n\tprintf(\"[2] 运行\\n\");\n\tint op;\n\tscanf(\"%d\", &op);\n\tif (op == 1)\n\t{\n\t\tsystem(\"cls\");\n\t\tstring imgpath = \"../../../../data/MNIST/\";\n\t\t//string imgpath = \"./data/\";\n\t\tprintf(\"图片文件夹：%s\\n\\n\", imgpath.c_str());\n\t\tloaddata(imgpath + \"img\", imgpath + \"ans\");\n\t\tprintf(\"模式选择：\\n\");\n\t\tprintf(\"[1] 重新训练\\n\");\n\t\tprintf(\"[2] 读取并继续训练（自动填充 ai 路径）\\n\");\n\t\tint op;\n\t\tscanf(\"%d\", &op);\n\t\tsystem(\"cls\");\n\t\tint idx;\n\t\tif (op == 1) idx = 0;\n\t\telse\n\t\t{\n\t\t\tprintf(\"断点 id：\\n\");\n\t\t\tscanf(\"%d\", &idx);\n\t\t\tload(idx);\n\t\t\tsystem(\"cls\");\n\t\t}\n\t\tinitgraph(256, 256, EX_SHOWCONSOLE);\n\t\tputimg(48, 48, dat[0]);\n\t\tbrn.set_eval(false);\n\t\tfor (int tme = idx + 1;; tme++)\n\t\t{\n\t\t\tauto start = std::chrono::high_resolution_clock::now();\n\t\t\tprintf(\"%d th loss: %f\\tlearning rate: %f\\n\", tme, train(), opt.lrt);\n\t\t\tauto stop = std::chrono::high_resolution_clock::now();\n\t\t\tauto duration = std::chrono::duration_cast<std::chrono::milliseconds>(stop - start).count();\n\t\t\tprintf(\"Time use: %d ms\\n\\n\", (int)duration);\n\t\t\tif (_kbhit())\n\t\t\t{\n\t\t\t\tchar ch;\n\t\t\t\twhile (_kbhit()) ch = _getch();\n\t\t\t\tif (ch == 27)\n\t\t\t\t{\n\t\t\t\t\tsave(tme);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (ch == 't')\n\t\t\t\t{\n\t\t\t\t\tprintf(\"输入一个 [0,9] 中的整数：\");\n\t\t\t\t\tint x;\n\t\t\t\t\tcin >> x;\n\t\t\t\t\tbrn.set_eval(true);\n\t\t\t\t\twork(x, 48, 48);\n\t\t\t\t\touttextxy(80, 180, L\"Finished\");\n\t\t\t\t\tbrn.set_eval(false);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tme % save_t == 0) save(tme);\n\t\t}\n\t}\n\telse\n\t{\n\t\tsystem(\"cls\");\n\t\tprintf(\"ai 文件路径：\\n\");\n\t\tstring path;\n\t\tcin >> path;\n\t\tifstream inf(path, ios::in | ios::binary);\n\t\tbrn.load(inf);\n\t\tinf.close();\n\t\tinitgraph(640, 256, EX_SHOWCONSOLE);\n\t\tbrn.set_eval(true);\n\t\tfor (int i = 0; i < 10; i++)\n\t\t{\n\t\t\twstringstream ssm;\n\t\t\tssm << i;\n\t\t\touttextxy(30 + i * 64, 80, ssm.str().c_str());\n\t\t\twork(i, i * 64, 0);\n\t\t}\n\t\tsystem(\"pause\");\n\t}\n\treturn 0;\n}\n```\n\n</p></details>\n\n这是训练了 14876 个 Batch 后的生成效果：\n\n![](../post-images/1756566255301.jpg)\n",
			"tags": [{"name":"机器学习"},{"name":"数学"}],
			"title": "生成式扩散模型初探 —— DDPM 学习笔记",
			"link": "https://exber.qzz.io/post/%E7%94%9F%E6%88%90%E5%BC%8F%E6%89%A9%E6%95%A3%E6%A8%A1%E5%9E%8B%E5%88%9D%E6%8E%A2%20%E2%80%94%E2%80%94%20DDPM%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2025-08-30 11:21:16"
		},
	
		{
			"abstract": "> 给定一棵 $n$ 个点的有根树，每个节点上有一个 $0/1$ 权值。\n>\n> 你需要以这样的方式生成一个序列：\n>\n> - 每次选择一个没有父节点（或者父节点已被删除）的点删除，将其上的权值放到序列的末尾；\n>\n> 请求出所有可能序列中逆序对数的最小值。\n>\n> $1\\le n\\le 2\\times 10^5$。\n",
			"content": "> 给定一棵 $n$ 个点的有根树，每个节点上有一个 $0/1$ 权值。\n>\n> 你需要以这样的方式生成一个序列：\n>\n> - 每次选择一个没有父节点（或者父节点已被删除）的点删除，将其上的权值放到序列的末尾；\n>\n> 请求出所有可能序列中逆序对数的最小值。\n>\n> $1\\le n\\le 2\\times 10^5$。\n\n考虑这样刻画树的拓扑序：\n\n- 每次找到相邻的两个（段）元素，将它们合并成一个（段）元素；\n\n体现在树上就是每次找到一个连通块，将其与其根的父亲所在的连通块合并。\n\n在本题中，考虑一个点（连通块）的两个儿子 $a,b$，设其中的 $0$ 和 $1$ 个数分别为 $c0_a,c1_a$ 和 $c0_b,c1_b$，则 $a$ 排在 $b$ 前面的代价为 $c1_a\\times c0_b$，$b$ 排在 $a$ 前面的代价则为 $c1_b\\times c0_a$，故 $a$ 排在前面更优当且仅当 $\\frac{c1_a}{c0_a}$ 更小。\n\n那么开一个优先队列，每次取出 $\\frac{c1}{c0}$ 最小的连通块和其根的父亲所在的连通块合并即可。\n\n这样做是对的基于一个结论：\n\n> 考虑以任意一点 $u$ 为根的子树，其内部的点在全局最优方案中的顺序和子树内局部最优方案中的顺序相同。\n\n具体证明可以归纳，不过理解起来很简单。\n\n时间复杂度 $O(n\\log n)$，代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <queue>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int S=200005;\n\nstruct node\n{\n\tint c0,c1,id;\n\tinline bool operator<(const node& y)const\n\t{\n\t\tif(1ll*c1*y.c0==1ll*y.c1*c0) return id>y.id;\n\t\treturn 1ll*c1*y.c0>1ll*y.c1*c0;\n\t}\n\tinline bool operator==(const node& y)const\n\t{\n\t\treturn c0==y.c0&&c1==y.c1&&id==y.id;\n\t}\n};\n\nint n,fat[S],a[S],c0[S],c1[S];\nint fa[S];\npriority_queue<node> q,deq;\n\nint fnd(int x){return fa[x]==x?x:fa[x]=fnd(fa[x]);}\n\ninline void push(node x){q.push(x);}\ninline void del(node x){deq.push(x);}\ninline bool empty(){return q.size()<=deq.size();}\ninline node pop()\n{\n\twhile(!deq.empty()&&q.top()==deq.top()) q.pop(),deq.pop();\n\tnode res=q.top();\n\tq.pop();\n\treturn res;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tcin>>n;\n\tfor(int i=2;i<=n;i++) cin>>fat[i];\n\tfor(int i=1;i<=n;i++) cin>>a[i],c0[i]=(a[i]==0),c1[i]=(a[i]==1);\n\tfor(int i=1;i<=n;i++) fa[i]=i;\n\tfor(int i=2;i<=n;i++) push(node{c0[i],c1[i],i});\n\tll ans=0;\n\twhile(!empty())\n\t{\n\t\tnode t=pop();\n\t\tint u=fnd(t.id),rt=fnd(fat[u]);\n\t\tif(rt!=1) del(node{c0[rt],c1[rt],rt});\n\t\tans+=1ll*c1[rt]*c0[u];\n\t\tc0[rt]+=c0[u],c1[rt]+=c1[u];\n\t\tfa[u]=rt;\n\t\tif(rt!=1) push(node{c0[rt],c1[rt],rt});\n\t}\n\tcout<<ans<<'\\n';\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"结论"},{"name":"贪心"}],
			"title": "AGC023F 01 on Tree 做题记录",
			"link": "https://exber.qzz.io/post/AGC023F%2001%20on%20Tree%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2025-07-03 20:32:52"
		},
	
		{
			"abstract": "> 有 $n$ 个商品和 $m$ 种颜色，第 $i$ 个物品颜色为 $a_i$，价格为 $c_i$。\n>\n> 对于一个购买物品的方案 $S\\subseteq\\{1,2,3,\\dots,n\\}$，定义其价格为 $\\sum\\limits_{i\\in S}a_i$。\n>\n> 一个方案合法当且仅当：\n>\n> - 对于第 $j$ 种颜色，购买的该种颜色的商品的个数必须要在区间 $[l_j,r_j]$ 中；\n>\n> 对于所有合法的方案，将其按照价格升序排序后，对于 $i\\in [1,k]$，求出第 $i$ 种合法方案的价格（合法方案数不足 $i$ 则输出 $-1$）。\n>\n> $1\\le n,m,k\\le 2\\times 10^5$，$1\\le a_i\\le m$，$1\\le c_i\\le 10^9$，$0\\le l_i\\le r_i\\le n$。\n",
			"content": "> 有 $n$ 个商品和 $m$ 种颜色，第 $i$ 个物品颜色为 $a_i$，价格为 $c_i$。\n>\n> 对于一个购买物品的方案 $S\\subseteq\\{1,2,3,\\dots,n\\}$，定义其价格为 $\\sum\\limits_{i\\in S}a_i$。\n>\n> 一个方案合法当且仅当：\n>\n> - 对于第 $j$ 种颜色，购买的该种颜色的商品的个数必须要在区间 $[l_j,r_j]$ 中；\n>\n> 对于所有合法的方案，将其按照价格升序排序后，对于 $i\\in [1,k]$，求出第 $i$ 种合法方案的价格（合法方案数不足 $i$ 则输出 $-1$）。\n>\n> $1\\le n,m,k\\le 2\\times 10^5$，$1\\le a_i\\le m$，$1\\le c_i\\le 10^9$，$0\\le l_i\\le r_i\\le n$。\n\n\n对于这种题，一种思路是考虑第 $i$ 小和第 $i+1$ 小的方案间的差异，不过这种思路在本题行不通。\n\n还有一种思路是考虑设计一种转移顺序，使得每种方案都可以被简单表示，每种方案的后继方案只有 $O(1)$ 个，转移到每种方案的路径唯一，且转移路径上方案的代价单调。这其实相当于隐式建出一个包含所有方案的 DAG，满足：\n\n- 每个点代表一种方案，且可以用 $O(1)$ 的信息量存储；\n- 入度为 $0$ 的点是最优方案 $x$；\n- 每个点的出点都比它劣；\n- 从 $x$ 到每个点的路径有且仅有一条；\n- 每个点的出点个数只有 $O(1)$ 个；\n\n这样就可以用优先队列来 $O(k\\log k)$ 求解第 $[1,k]$ 优的方案，即每次取出优先队列中的最优方案，将其所有后继方案加入优先队列。\n\n#### Part 1：$m=1,l=r$\n\n先给 $a$ 升序排序。注意到最优方案显然是选择前 $l$ 个，次优方案则是将第 $l$ 个选择的物品往后推一位（即用 $c_{l+1}$ 替代 $c_l$）。\n\n观察到对于一段连续的选择的 $c_{[lb,rb]}$，将 $c_{i\\in [lb,rb]}$ 替换为 $c_j$（$rb<j$）显然不如将 $c_{rb}$ 替换为 $c_j$，所以得到一个方案的路径一定形如：\n\n- 将第 $x$ 个选择的物品往后推若干位，但不能越过第 $x+1$ 个选择的物品（初始 $x=l$）；\n- 令 $x\\to x-1$；\n\n不难发现，第 $i+1$ 个物品若没有往后推过，则第 $i$ 个物品无法往后推，故可以让 $x$ 减一的时候顺便将该物品往后推一位，这样就只用考虑当前物品往后推一位的情况，出点个数就对了。\n\n则可以这样设计 DAG：\n\n- 每个点为四元组 $(sm,p,i,rb)$，表示代价为 $sm$，当前 $x=p+1$，第 $x$ 个选择的物品是 $c_i$，第 $x+1$ 个选择的物品是 $c_{rb}$；\n\n- 最优方案为 $(\\sum_{i\\le l}c_i,l-1,l,\\infin)$；\n\n- 点 $(sm,p,i,rb)$ 的出点为：\n\n  - $(sm-c_i+c_{i+1},p,i+1,rb)$（要求 $i+1<rb$）；\n\n  - $(sm-c_p+c_{p+1},p-1,p+1,i)$（要求 $p+1<i$）；\n\n#### Part 2：$m=1,l\\le r$\n\n当 $p=i-1$，$i<r$ 且 $rb=\\infin$ 时加入出点 $(sm+c_{i+1},i,i+1,\\infin)$ 即可。\n\n#### Part 3：All\n\n不妨将每种颜色看成黑盒，即设 $a_{i,j}$ 表示颜色 $i$ 的第 $j$ 小方案的代价，那么状态可以看作一个长 $m$ 的序列 $b$，其代价为 $\\sum\\limits_{1\\le i\\le m}a_{i,b_i}$，最优状态为 $\\{1,1,1,\\dots,1\\}$。不难发现可以这样设计转移使得路径唯一：\n\n- 将 $b_x$ 加一（不能超过颜色 $x$ 的总方案数，初始 $x=1$）；\n- 将 $x$ 加一；\n\n但是这样后继状态数太多了。\n\n注意到，将颜色按照 $a_{i,2}-a_{i,1}$ 升序排序即可避免这个问题，本质上是将一个点 $u$ 的所有出点按照代价从小到大排序后连成一条链，这样 $u$ 就只需要连代价最小的出点。\n\n这样设计 DAG：\n\n- 每个点为三元组 $(sm,i,ct)$，表示代价为 $sm$，当前 $x=i$，$b_x=ct$；\n- 特判掉最优方案，从次优方案 $(a_{1,2}+\\sum_{2\\le i\\le m}a_{i,1},1,2)$ 开始；\n- $(sm,i,ct)$ 的出点为：\n  - $(sm-a_{i,ct}+a_{i,ct+1},i,ct+1)$（要求 $a_{i,ct+1}$ 存在）；\n  - $(sm-a_{i+1,1}+a_{i+1,2},i+1,2)$（要求 $i<m$）；\n  - $(sm-a_{i,2}+a_{i,1}-a_{i+1,1}+a_{i+1,2},i+1,2)$（要求 $i<m$ 且 $ct=2$）；\n\n最后一种出点相当于撤销了 $i$ 的一次操作，即通过两次实现“跳过颜色 $i$”这个操作。由于按照 $a_{i,2}-a_{i,1}$ 升序排序，故这样做是对的。\n\n时间复杂度 $O(n\\log n)$，实现起来要特判只有一种方案的颜色。\n\n代码如下：\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int S=200005,inf=1e8;\n\nint n,m,k;\nvector<ll> a[S];\nint lb[S],rb[S];\npriority_queue<pair<ll,pair<int,pair<int,int> > > > que[S];\nvector<ll> vec[S];\nvector<pair<ll,int> > idx;\npriority_queue<pair<ll,pair<int,int> > > q;\n\ninline void insnxt(int id,ll pre,int p,int i,int nxt)\n{\n\tint r=rb[id];\n\tauto &c=a[id];\n\tif(i>0&&i<c.size()&&i+1<nxt)\n\t\tque[id].emplace(-(pre-c[i-1]+c[i]),make_pair(p,make_pair(i+1,nxt)));\n\tif(p>0&&p+1<i)\n\t\tque[id].emplace(-(pre-c[p-1]+c[p]),make_pair(p-1,make_pair(p+1,i)));\n\tif(p==i-1&&i<r&&nxt==inf)\n\t\tque[id].emplace(-(pre+c[i]),make_pair(i,make_pair(i+1,inf)));\n}\ninline void init(int id)\n{\n\tll sm=0;\n\tfor(int i=0;i<lb[id];i++) sm+=a[id][i];\n\tvec[id].push_back(sm);\n\tinsnxt(id,sm,lb[id]-1,lb[id],inf);\n}\ninline bool getnxt(int id)\n{\n\tif(que[id].empty()) return false;\n\tauto t=que[id].top();\n\tque[id].pop();\n\tvec[id].push_back(-t.first);\n\tinsnxt(id,-t.first,t.second.first,t.second.second.first,t.second.second.second);\n\treturn true;\n}\ninline ll getrk(int id,int rk)\n{\n\twhile(vec[id].size()<rk) if(!getnxt(id)) return -1;\n\treturn vec[id][rk-1];\n}\n\ninline void insnxt(ll pre,int i,int ct)\n{\n\tint id=idx[i].second;\n\tif(getrk(id,ct+1)!=-1)\n\t\tq.emplace(-(pre-getrk(id,ct)+getrk(id,ct+1)),make_pair(i,ct+1));\n\tif(i+1<idx.size())\n\t\tq.emplace(-(pre-getrk(idx[i+1].second,1)+getrk(idx[i+1].second,2)),make_pair(i+1,2));\n\tif(ct==2&&i+1<idx.size())\n\t\tq.emplace(-(pre-getrk(id,2)+getrk(id,1)-getrk(idx[i+1].second,1)+getrk(idx[i+1].second,2)),make_pair(i+1,2));\n}\n\nint main()\n{\n\tios::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tcin>>n>>m>>k;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\ta[x].push_back(y);\n\t}\n\tfor(int i=1;i<=m;i++) cin>>lb[i]>>rb[i];\n\tfor(int i=1;i<=m;i++) sort(a[i].begin(),a[i].end());\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\t// printf(\"[%d %d]\\n\",lb[i],rb[i]);\n\t\t// for(int x:a[i]) cout<<x<<' ';cout<<'\\n';\n\t\trb[i]=min(rb[i],(int)a[i].size());\n\t\tif(lb[i]>rb[i])\n\t\t{\n\t\t\tfor(int i=1;i<=k;i++) cout<<\"-1\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\tll sm=0;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tinit(i);\n\t\tsm+=getrk(i,1);\n\t\tif(getrk(i,2)!=-1) idx.emplace_back(getrk(i,2)-getrk(i,1),i);\n\t}\n\t// for(int i=1;i<=m;i++)\n\t// {\n\t\t// for(int j=1;j<=10;j++) cout<<getrk(i,j)<<' ';\n\t\t// cout<<'\\n';\n\t// }\n\tsort(idx.begin(),idx.end());\n\tif(idx.size()>0)\n\t{\n\t\tint id=idx[0].second;\n\t\tq.emplace(-(sm-getrk(id,1)+getrk(id,2)),make_pair(0,2));\n\t}\n\tcout<<sm<<'\\n';\n\tfor(int i=1;i<=k-1;i++)\n\t{\n\t\tif(q.empty()) cout<<\"-1\\n\";\n\t\telse\n\t\t{\n\t\t\tauto t=q.top();\n\t\t\tq.pop();\n\t\t\tcout<<(-t.first)<<'\\n';\n\t\t\tinsnxt(-t.first,t.second.first,t.second.second);\n\t\t}\n\t}\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"贪心"},{"name":"结论"},{"name":"小技巧"}],
			"title": "P6646 [CCO 2020] Shopping Plans 做题记录",
			"link": "https://exber.qzz.io/post/P6646%20%5BCCO%202020%5D%20Shopping%20Plans%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2025-06-27 18:23:21"
		},
	
		{
			"abstract": "",
			"content": "某些数据结构只支持【修改】和【撤销最后一次修改】这两种操作，即本质是一个操作栈。此时需要使用一些技巧来实现双端队列和双指针。\n\n### 双栈模拟双端队列\n\n适用于信息可以快速合并的可撤销数据结构。例如用栈维护每个元素到栈底的最大/最小值。\n\n<details><summary>做法</summary><p>\n\n> 这里以窗口长度为 $k$，维护后缀最大值的位置（比 $[j+1,i]$ 中的所有数都大的位置）的 dp 值的最大值为例。\n>\n> 维护底对底的两个单调栈：\n>\n> ![](../post-images/1691808251754.png)\n>\n> 两个栈都维护每个元素到栈底之间所有元素的 dp 值的最大值。\n>\n> 后面的栈像普通单调栈一样正常插入删除，前面的栈若栈顶超出了窗口范围则删除栈顶。\n>\n> 若某一个栈空了则重构，把另一个栈的所有元素拿出来，把一半放入原来为空的栈。\n>\n> 这样做的时间复杂度是 $O(n)$ 的，考虑每次重构都是某一边被删空了才会进行，设重构后左边的栈有 $k$ 个元素，则本次重构时间复杂度为 $O(k)$，而若要进行下一次重构，则一定会执行 $O(k)$ 次删除操作，所以重构的时间复杂度和删除的时间复杂度是一样的，均为 $O(n)$。\n>\n> 例题：\n>\n> - [【2023成都集训模拟赛04】op](../【2023成都集训模拟赛04】op 做题记录/)\n\n</p></details>\n\n### 单栈模拟双指针\n\n适用于信息不能快速合并的可撤销数据结构。例如可撤销并查集。\n\n例如给定边序列，对每个 $l$ 求最小的 $r$ 使得区间 $[l,r]$ 中的边能让整个图连通。\n\n<details><summary>做法</summary><p>\n\n> 双指针移动过程中，修改操作直接进行（在操作栈顶压入操作）。对于删除操作，则暴力弹栈（撤销）并将弹出的操作暂存到一个数组 $b$ 中，直到栈顶为想要删除的操作。此时弹栈，然后再弹出栈顶 $|b|$ 个元素（不足 $|b|$ 个则弹空），并将这些元素也加入 $b$。最后将 $b$ 中元素按照编号排序，再从大到小依次压入栈中。\n\n</p></details>\n\n<details><summary>复杂度证明</summary><p>\n\n> 考虑每个时刻栈底到栈顶都形如若干段下降段。\n>\n> 由于每次删除的是最小值，故执行删除操作时，一个下降段要么被完全跳过，要么被删掉靠近栈顶的第一个元素。而一个下降段若被完全跳过，则其会在排序中和其它下降段融合，故其长度至少翻倍，故这部分的时间复杂度是 $O(n\\log n)$ 的；而删除靠近栈顶的第一个元素这个操作只会进行总共 $n$ 次，故这部分的时间复杂度是 $O(n)$ 的。\n>\n> 所以总复杂度是 $O(n\\log n)$，算上排序和可撤销数据结构的复杂度即为 $O(n\\log ^2n+n\\log nM)$，其中假定可撤销数据结构的单次操作（修改、撤销）的复杂度为 $O(M)$。\n\n</p></details>\n\n<details><summary>参考代码</summary><p>\n\n```cpp\nint top,sta[S],b[S];\ninline void push(int x)\n{\n\twork(x);\n\tsta[++top]=x;\n}\ninline void pop(int x)\n{\n\tint cnt=0;\n\twhile(sta[top]!=x) undo(),b[++cnt]=sta[top--];\n\tundo(),top--;\n\tfor(int i=1,len=cnt;i<=len&&top>0;i++) undo(),b[++cnt]=sta[top--];\n\tsort(b+1,b+cnt+1);\n\tfor(int i=cnt;i>=1;i--) work(b[i]),sta[++top]=b[i];\n}\n```\n\n</p></details>\n",
			"tags": [{"name":"学习笔记"},{"name":"数据结构"},{"name":"小技巧"}],
			"title": "栈模拟队列学习笔记",
			"link": "https://exber.qzz.io/post/%E6%A0%88%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2025-06-20 09:04:35"
		},
	
		{
			"abstract": "",
			"content": "> 对于所有长 $n$，总和为 $m$ 的序列 $a$，求 $\\prod\\limits_{i=1}^n a_i$ 的和。\n\n<details><summary>做法</summary><p>\n\n相当于有 $m$ 个洞，被 $n-1$ 个隔板分开，每个区域中要选一个洞放球。\n\n那么相当于在 $m+n-1$ 个物品中选 $2n-1$ 个物品，其中第奇数个物品是球，第偶数个物品是隔板，故答案是 $\\binom{m+n-1}{2n-1}$。\n\n</p></details>\n",
			"tags": [{"name":"学习笔记"},{"name":"小技巧"},{"name":"组合计数"},{"name":"结论"}],
			"title": "一些组合意义技巧",
			"link": "https://exber.qzz.io/post/%E4%B8%80%E4%BA%9B%E7%BB%84%E5%90%88%E6%84%8F%E4%B9%89%E6%8A%80%E5%B7%A7",
			"date": "2025-06-19 21:45:06"
		},
	
		{
			"abstract": "> 对于一个长 $n$ 的正整数序列 $A$，定义一个长 $m$ 的，值域 $[1,n]$ 的正整数序列 $b$ 关于 $A$ 是好的当且仅当：\n>\n> - 从前往后遍历 $b$，遍历到 $i$ 时：\n>   1. 需要满足 $A_{b_i}=\\min\\limits_{j=1}^n\\{A_j\\}$；\n>   2. 将 $A_{b_i}$ 增加 $1$；\n>\n> 现给定 $n,m$ 和序列 $b$，你需要构造一个长 $n$ 的字典序最小的正整数序列 $A$，使得 $b$ 关于 $A$ 是好的，或报告无解。\n>\n> $1\\le n,m\\le 3\\times 10^5$。\n",
			"content": "> 对于一个长 $n$ 的正整数序列 $A$，定义一个长 $m$ 的，值域 $[1,n]$ 的正整数序列 $b$ 关于 $A$ 是好的当且仅当：\n>\n> - 从前往后遍历 $b$，遍历到 $i$ 时：\n>   1. 需要满足 $A_{b_i}=\\min\\limits_{j=1}^n\\{A_j\\}$；\n>   2. 将 $A_{b_i}$ 增加 $1$；\n>\n> 现给定 $n,m$ 和序列 $b$，你需要构造一个长 $n$ 的字典序最小的正整数序列 $A$，使得 $b$ 关于 $A$ 是好的，或报告无解。\n>\n> $1\\le n,m\\le 3\\times 10^5$。\n\n\n考虑操作的过程，不难发现相当于不断把最小值的位置抬上去，所以操作时序列 $A$ 的最小值一定是单调不降的。\n\n考虑按照操作时 $A$ 的最小值将 $b$ 分段，不难发现一个分段方式合法（存在对应的 $A$）当且仅当：\n\n- 每一段中的数互不相同；\n- 除了最后一段外，第 $i$ 段的数构成的集合包含第 $i-1$ 段的数构成的集合；\n\n第二个限制也相当于要求每一段 $[l,r]$ 中的数的集合包含 $b_{[1,l-1]}$ 中的数的集合。\n\n显然若一段以 $i$ 开头，则下一段的开头应该在一个区间内，设其为 $[l_i,r_i]$。显然 $\\forall j<i$ 都有 $l_j\\le l_i,r_j\\le r_i$，那么可以双指针求出 $l_i$ 和 $r_i$。\n\n接下来可以从后往前扫，求出 $f_i$ 表示若某一段以 $i$ 开头的话，$b_{[i,n]}$ 能否完成合法的分段。\n\n那么若 $f_1=0$ 就无解。\n\n然后从前往后贪心，显然每一段肯定都是越长越好，所以每次贪心找到 $j\\in [l_i,r_i],f_j=1$ 的最大的 $j$，分出段 $[i,j-1]$ 即可，注意这也相当于 $j\\in[1,r_i]$，故做前缀最大值即可。\n\n最后扫一遍即可求出答案，注意不在 $b$ 中出现的位置也要填数。\n\n最后一段要特殊处理，时间复杂度 $O(n+m)$。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <map>\n#include <vector>\n\nusing namespace std;\n\nconst int S=300005;\n\nint n,m,a[S];\nint ct[S];\nint lb[S],rb[S];\nbool flg[S];\nint sm[S],mx[S];\nbool vis[S];\nint ans[S];\n\nint main()\n{\n\tios::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tcin>>n>>m;\n\tfor(int i=1;i<=m;i++) cin>>a[i];\n\tct[a[1]]=1;\n\tlb[1]=2;\n\tfor(int i=2,j=1;i<=m;i++)\n\t{\n\t\tct[a[i-1]]--;\n\t\twhile(j<=m&&ct[a[i-1]]==0) ct[a[++j]]++;\n\t\tif(j==m+1) lb[i]=-1;\n\t\telse lb[i]=j+1;\n\t}\n\tfor(int i=1;i<=n;i++) ct[i]=0;\n\tct[a[1]]=1;\n\tfor(int i=1,j=1;i<=m;i++)\n\t{\n\t\tct[a[i-1]]--;\n\t\twhile(j<m&&ct[a[j+1]]==0) ct[a[++j]]++;\n\t\trb[i]=j+1;\n\t}\n\tfor(int i=1;i<=n;i++) ct[i]=0;\n\tint L=m;\n\tflg[m+1]=true;\n\tfor(int i=m;i>=1;i--)\n\t{\n\t\tif(++ct[a[i]]==2) break;\n\t\tflg[i]=true;\n\t\tL=i;\n\t}\n\tsm[m+1]=1;\n\tfor(int i=m;i>=1;i--)\n\t{\n\t\tif(lb[i]!=-1&&lb[i]<=rb[i])\n\t\t\tflg[i]|=(sm[lb[i]]-sm[rb[i]+1]>0);\n\t\tsm[i]=flg[i]+sm[i+1];\n\t}\n\tif(!flg[1]) return cout<<\"-1\\n\",0;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tmx[i]=mx[i-1];\n\t\tif(flg[i]) mx[i]=i;\n\t}\n\tint p=1,t=0;\n\twhile(p<L)\n\t{\n\t\tint np=mx[rb[p]];\n\t\tt++;\n\t\tfor(int i=p;i<np;i++)\n\t\t\tif(!vis[a[i]]) ans[a[i]]=t,vis[a[i]]=true;\n\t\tp=np;\n\t}\n\tif(p<=m)\n\t{\n\t\tt++;\n\t\tfor(int i=p;i<=m;i++)\n\t\t\tif(!vis[a[i]]) ans[a[i]]=t,vis[a[i]]=true;\n\t}\n\tfor(int i=1;i<=n;i++) if(!vis[i]) ans[i]=t;\n\tfor(int i=1;i<=n;i++) cout<<ans[i]<<' ';cout<<'\\n';\n\treturn 0;\n}\n/*\n求出 i 为某一段开头时下一段开头所在的区间 [l_i,r_i]\n那么 l[i] <= l[i+1]\n\tr[i] <= r[i+1]\n然后我肯定想每一段长度构成的序列的字典序最大\n那么处理出每一个点能不能到终点即可？\n*/\n```\n",
			"tags": [{"name":"做题记录"},{"name":"结论"},{"name":"构造"}],
			"title": "ARC130E Increasing Minimum 做题记录",
			"link": "https://exber.qzz.io/post/ARC130E%20Increasing%20Minimum%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2025-06-07 17:02:28"
		},
	
		{
			"abstract": "> 给定一个 $n\\times n$ 的 01 矩阵 $A$，和两个长 $n$ 的非负整数数组 $ca,cb$。请构造两个长 $n$ 的 01 数组 $fa,fb$，满足：\n>\n> - $\\forall i\\in [1,n]$ 都有 $ca_i=\\sum\\limits_{1\\le j\\le n} A_{i,j}\\oplus fa_i\\oplus fb_j$；\n> - $\\forall j\\in [1,n]$ 都有 $cb_j=\\sum\\limits_{1\\le i\\le n} A_{i,j}\\oplus fa_i\\oplus fb_j$；\n>\n> $1\\le n\\le 1000$，$0\\le ca_i,cb_i<\\frac{n}{4}$。\n",
			"content": "> 给定一个 $n\\times n$ 的 01 矩阵 $A$，和两个长 $n$ 的非负整数数组 $ca,cb$。请构造两个长 $n$ 的 01 数组 $fa,fb$，满足：\n>\n> - $\\forall i\\in [1,n]$ 都有 $ca_i=\\sum\\limits_{1\\le j\\le n} A_{i,j}\\oplus fa_i\\oplus fb_j$；\n> - $\\forall j\\in [1,n]$ 都有 $cb_j=\\sum\\limits_{1\\le i\\le n} A_{i,j}\\oplus fa_i\\oplus fb_j$；\n>\n> $1\\le n\\le 1000$，$0\\le ca_i,cb_i<\\frac{n}{4}$。\n\n\n怎么这么笨。\n\n关键步骤：先通过列翻转将第一行变成 $0$。\n\n不难发现，将 $fa$ 和 $fb$ 全部取反不影响合法性，所以可以钦定 $fa_1=0$。接下来由于 $ca_1<\\frac{n}{4}$，所以列翻转次数（$\\sum\\limits_i fb_i$）也 $<\\frac{n}{4}$。\n\n那么对于一行 $i$，若此时 $\\frac{n}{2}\\le \\sum\\limits_{j}A_{i,j}$ 则一定有 $fa_i=1$，否则一定有 $fa_i=0$。\n\n故 $fa$ 就确定了，那么 $fb$ 也可以直接确定了。\n\n再判一下合法性即可。\n\n时间复杂度 $O(n^2)$，代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=1005;\n\nint n;\nchar a[S][S];\nint cnta[S],cntb[S];\nint ra[S],rb[S];\n\ninline void slove()\n{\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcin>>a[i];\n\t\tfor(int j=n;j>=1;j--) a[i][j]=a[i][j-1]-'0';\n\t}\n\tfor(int i=1;i<=n;i++) cin>>cntb[i];\n\tfor(int i=1;i<=n;i++) cin>>cnta[i];\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tra[i]=a[1][i];\n\t\tfor(int j=1;j<=n;j++) a[j][i]^=ra[i];\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint cnt=0;\n\t\tfor(int j=1;j<=n;j++) cnt+=a[i][j];\n\t\trb[i]=cnt>=(n+1)/2;\n\t\tfor(int j=1;j<=n;j++) a[i][j]^=rb[i];\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint cnt=0;\n\t\tfor(int j=1;j<=n;j++) cnt+=a[j][i];\n\t\tbool fl=cnt!=cnta[i];\n\t\tra[i]^=fl;\n\t\tfor(int j=1;j<=n;j++) a[j][i]^=fl;\n\t}\n\tbool fl=true;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint cnt=0;\n\t\tfor(int j=1;j<=n;j++) cnt+=a[j][i];\n\t\tfl&=cnt==cnta[i];\n\t\tcnt=0;\n\t\tfor(int j=1;j<=n;j++) cnt+=a[i][j];\n\t\tfl&=cnt==cntb[i];\n\t}\n\tif(!fl) cout<<\"No\\n\";\n\telse\n\t{\n\t\tcout<<\"Yes\\n\";\n\t\tfor(int i=1;i<=n;i++) cout<<rb[i];cout<<'\\n';\n\t\tfor(int i=1;i<=n;i++) cout<<ra[i];cout<<'\\n';\n\t}\n}\n\nint main()\n{\n\tios::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tint T;\n\tcin>>T;\n\twhile(T-->0) slove();\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"结论"}],
			"title": "ARC199A Flip Row or Col 2 做题记录",
			"link": "https://exber.qzz.io/post/ARC199A%20Flip%20Row%20or%20Col%202%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2025-06-04 18:59:40"
		},
	
		{
			"abstract": "> 给定正整数 $n$，求有多少个 $\\{1,2,3,\\dots,n\\}$ 的子集 $S$，满足对于任意 $[1,n]$ 中的正整数 $x$，都存在一个或两个 $S$ 的子集 $T$ 满足 $x=\\sum\\limits_{y\\in T}y$。对 $998244353$ 取模。\n>\n> $1\\le n\\le 1500$。\n",
			"content": "> 给定正整数 $n$，求有多少个 $\\{1,2,3,\\dots,n\\}$ 的子集 $S$，满足对于任意 $[1,n]$ 中的正整数 $x$，都存在一个或两个 $S$ 的子集 $T$ 满足 $x=\\sum\\limits_{y\\in T}y$。对 $998244353$ 取模。\n>\n> $1\\le n\\le 1500$。\n\n\n相当于用 $S$ 中的数做 01 背包后背包数组中 $[1,n]$ 每个位置的值都是 $1$ 或者 $2$。\n\n考虑从小到大加入 $S$ 中的数，每次相当于将背包数组整体往后移位再对位相加。那么如果某一时刻出现了 $>1$ 个连续非 $0$ 段，则它们之间的 $0$ 就再也无法被覆盖到了。故每个时刻背包数组中非 $0$ 的位置一定是一个前缀，且该前缀长度是 $S$ 中所有数的和再 $+1$（$b$ 的下标从 $0$ 开始）。\n\n那么设背包数组为 $b$，$S$ 中数的和为 $sm$，则一定有 $b_x=b_{sm-x}$。\n\n考虑第一次让 $b$ 中出现 $2$ 的数 $a$，此前加入的数一定都是 $2$ 的次幂。设 $len$ 为最小的 $2^x$ 满足 $len>a$，则此时 $b$ 一定形如：\n$$\n\\underset{\\text{$a$ 个 $1$}}{\\underbrace{11\\dots1}}\\underset{\\text{$len-a$ 个 $2$}}{\\underbrace{22\\dots2}}\\underset{\\text{$a$ 个 $1$}}{\\underbrace{11\\dots1}}\n$$\n接下来每次操作新产生的 $2$ 都来自于最后一段 $1$ 和第一段 $1$ 的叠合，直到 $b_{[0,n]}$ 都非 $0$，此时显然只能再操作最多一次。问题是这一次操作中第一段 $1$ 叠合的可能不再是最后一段 $1$。\n\n观察到 $b$ 的性质很好（是回文串且砍掉最后一次操作叠合出的中间那段后，两边也是回文串），考虑建树，去掉开头的 $a$ 个 $1$ 后，每次操作叠合出的中间段（长度范围 $[a,2a]$）作为节点，向左右两边最后一次操作对应的节点连边。叶子节点对应 $len-a$ 个 $2$（第一次出现 $2$ 的操作）。\n\n这样我们就可以枚举是在哪个节点处爆 $[0,n]$，按层做背包即可统计答案。\n\n复杂度：\n\n- 枚举 $a$ 带来一个 $O(n)$；\n- 一共有 $O(\\frac{n}{a})$ 个节点；\n- 每个节点处需要做背包，复杂度是 $O(n\\ln n)$ 的（$\\ln$ 来自于调和级数）;\n- 所以总复杂度为 $\\sum\\limits_{a}O(\\frac{n}{a}\\times n\\ln n)$，即 $O(n^2\\ln^2n)$。\n\n实现起来有很多细节，要考虑好每种情况的贡献应该算在什么节点上。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int S=1505,BS=10;\n\n#define p 998244353\n\nint n;\nll siz[BS+5];\nint g[S],tmp[BS+5][S];\nint ans;\n\ninline void add(int &x,int y)\n{\n\tx+=y;\n\tif(x>=p) x-=p;\n}\n\nvoid dfs(int a,int len,int hei,int cnt,ll sm)\n{\n\tif(sm>n+1) return;\n\tif(hei>1)\n\t{\n\t\t{// left\n\t\t\tmemcpy(tmp[hei],g,sizeof(g));\n\t\t\tif(cnt>1)\n\t\t\t{\n\t\t\t\tint ml=cnt-1;\n\t\t\t\tfor(int i=n+1;i>=0;i--)\n\t\t\t\t{\n\t\t\t\t\tfor(int j=a;j<=a*2&&i+j*ml<=n+1;j++)\n\t\t\t\t\t\tadd(g[i+j*ml],g[i]);\n\t\t\t\t\tg[i]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdfs(a,len,hei-1,(cnt-1)*2+1,sm);\n\t\t\tmemcpy(g,tmp[hei],sizeof(g));\n\t\t}\n\t\tif(sm+a+siz[hei-1]<=n+1)\n\t\t{// right\n\t\t\tmemcpy(tmp[hei],g,sizeof(g));\n\t\t\tint ml=cnt;\n\t\t\tfor(int i=n+1;i>=0;i--)\n\t\t\t{\n\t\t\t\tfor(int j=a;j<=a*2&&i+j*ml<=n+1;j++)\n\t\t\t\t\tadd(g[i+j*ml],g[i]);\n\t\t\t\tg[i]=0;\n\t\t\t}\n\t\t\tdfs(a,len,hei-1,cnt*2,sm+a+siz[hei-1]);\n\t\t\tmemcpy(g,tmp[hei],sizeof(g));\n\t\t}\n\t}\n\tif(a+sm+siz[hei-1]>n+1) return;\n\tmemcpy(tmp[hei],g,sizeof(g));\n\tll ml=(cnt-1)*2+1;\n\tfor(int i=hei-1;i>=1;i--,ml*=2)\n\t{\n\t\tint lb,rb;\n\t\tif(i>1) lb=a,rb=a*2;\n\t\telse lb=rb=len-a;\n\t\tfor(int j=n+1;j>=0;j--)\n\t\t{\n\t\t\tfor(int k=lb;k<=rb&&j+k*ml<=n+1;k++)\n\t\t\t\tadd(g[j+k*ml],g[j]);\n\t\t\tg[j]=0;\n\t\t}\n\t}\n\tif(hei>1) // not leaf\n\t{\n\t\tfor(int i=0;i<n+1-a;i++)\n\t\t\tfor(int x=a;x<=a*2&&a+i+x*(cnt-1)<n+1;x++)\n\t\t\t{\n\t\t\t\tint pos=a+i+x*(cnt-1);\n\t\t\t\tint c1=x-a;\n\t\t\t\tif(pos+x<n+1) continue;\n\t\t\t\tif(cnt==1&&pos+c1>n+1) break;\n\t\t\t\tadd(ans,g[i]);\n\t\t\t\tint r1=0;\n\t\t\t\tif(cnt==1)\n\t\t\t\t{\n\t\t\t\t\tif(pos+x-c1<n+1)\n\t\t\t\t\t\tr1=n+1-(pos+x-c1)-(x==a*2);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(pos+c1>=n+1) r1=n+1-pos;\n\t\t\t\t\telse if(x==a*2) r1=min(n+1-pos,a);\n\t\t\t\t\telse if(pos+x-c1<n+1) r1=n+1-(pos+x-c1);\n\t\t\t\t}\n\t\t\t\tadd(ans,1ll*r1*g[i]%p);\n\t\t\t}\n\t}\n\telse\n\t{\n\t\tint ad=a+(len-a)*(cnt-1);\n\t\tfor(int i=0;i<n+1-ad;i++)\n\t\t{\n\t\t\tint pre=i+ad;\n\t\t\tint x=len-a;\n\t\t\tif(pre+x<n+1) continue;\n\t\t\tadd(ans,g[i]);\n\t\t}\n\t}\n\tmemcpy(g,tmp[hei],sizeof(g));\n}\n\nint main()\n{\n\tios::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tcin>>n;\n\tans=1;\n\tfor(int a=1;a<=n+1;a++)\n\t{\n\t\tint len=1;\n\t\twhile(len<=a) len<<=1;\n\t\tif(len==a*2) continue;\n\t\tsiz[1]=len-a;\n\t\tfor(int i=2;i<=BS;i++) siz[i]=siz[i-1]*2+a;\n\t\tg[0]=1;\n\t\tint lst=ans;\n\t\tdfs(a,len,BS,1,0);\n\t\t// for(int i=1;i<=BS-3;i++)\n\t\t// {\n\t\t\t// int lst=ans;\n\t\t\t// dfs(a,len,i,1,0);\n\t\t\t// if(ans>lst) printf(\"%d: %d\\n\",i,ans-lst);\n\t\t// }\n\t\t// printf(\">> %d %d %d : %d\\n\",a,len-a,a,ans-lst);\n\t}\n\tcout<<ans<<'\\n';\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"组合计数"},{"name":"DP"},{"name":"结论"}],
			"title": "ARC143F Counting Subsets 做题记录",
			"link": "https://exber.qzz.io/post/ARC143F%20Counting%20Subsets%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2025-06-04 11:26:24"
		},
	
		{
			"abstract": "> 给定一棵 $n$ 个点的以 $1$ 为根的有根树，点 $u$ 有权值 $a_i$ 和 $b_i$。定义树合法当且仅当每个点 $u$ 都满足其子树内 $a_i$ 的 $\\text{mex}$ 为 $b_i$。\n>\n> 有些 $b_u=-1$ 表示点 $u$ 没有限制，还有些 $a_u=-1$ 表示 $a_u$ 可以在 $[0,n]$ 中任选。求有多少种给所有 $a_u=-1$ 的 $a_u$ 赋值的方案使得树是合法的，对 $10^9+7$ 取模。\n>\n> $1\\le n\\le 5000$，$-1\\le a_u,b_u\\le n$。\n",
			"content": "> 给定一棵 $n$ 个点的以 $1$ 为根的有根树，点 $u$ 有权值 $a_i$ 和 $b_i$。定义树合法当且仅当每个点 $u$ 都满足其子树内 $a_i$ 的 $\\text{mex}$ 为 $b_i$。\n>\n> 有些 $b_u=-1$ 表示点 $u$ 没有限制，还有些 $a_u=-1$ 表示 $a_u$ 可以在 $[0,n]$ 中任选。求有多少种给所有 $a_u=-1$ 的 $a_u$ 赋值的方案使得树是合法的，对 $10^9+7$ 取模。\n>\n> $1\\le n\\le 5000$，$-1\\le a_u,b_u\\le n$。\n\n\n首先设 $mx_u$ 表示 $u$ 子树内 $b$ 的最大值，则若 $b_u\\not=-1$ 且 $b_u<mx_u$ 那么一定无解。\n\n刚开始设的状态是 $f_{u,0/1,i}$ 表示 $u$ 的子树，确定 $\\le mx_u$ 的 $a$ 都填完了，是否有 $=mx_u$ 的 $a$，$> mx_u$ 的还未确定的 $a$ 有 $i$ 个的方案数，可是这样由于有容斥所以我不会优化，只能做到 $O(n^3)$。\n\n考虑设 $vis_{u,i}$ 表示 $u$ 子树内 $i$ 是否确定出现，则一个数 $x$ 确定出现当且仅当子树内有某个 $a_v=x$ 或 $x<mx_u$。\n\n设 $f_{u,0/1,i}$ 表示 $u$ 的子树，（$a$ 中）确定出现过的数都填完了，是否有 $=mx_u$ 的数，共填了 $i$ **种**未确定出现过的数，且这 $i$ 种数的大小顺序还未确定的方案数。\n\n考虑合并子树的过程，首先对于 $vis_{u,x}=1,vis_{v,x}=0$ 的数 $x$，$v$ 子树中可能有一种未确定出现过的数为 $x$，所以滚一次背包；对于 $vis_{u,x}=0,vis_{v,x}=1$ 的数同理。\n\n接下来要处理两颗子树中都未出现过，但相同的数，也是直接滚背包，即看一下 $v$ 子树中未确定出现的数是否有一种和 $u$ 子树中第 $i$ 种未确定的数相同。\n\n做完这些处理之后直接卷积即可，注意滚背包的时候要乘系数，即从 $i$ 种数中选一种出来配对，系数为 $i$。\n\n最后再把 $vis$ 合并一下。\n\n但是考虑已经合并进 $u$ 的某个儿子 $v$，在合并新的儿子 $v'$ 时，$mx_v$ 这个数比较特殊，即使 $vis_{u,mx_v}=0,vis_{v',mx_v}=1$ 也不能有 $v$ 子树中未确定出现过的数“雪藏”在这里，而我们的状态中并未记录相关信息。所以需要将儿子按照 $mx_v$ 从大到小的顺序合并。\n\n最后若 $b_u\\not=-1$ 则要将 $\\text{mex}$ 推上去，即选一些未确定的数出来填了。\n\n时间复杂度就是树上背包的复杂度，即 $O(n^2)$。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nconst int S=5005;\n\n#define p 1000000007\n\nint fra[S],C[S][S];\nint n,a[S],b[S],fa[S];\nbool vis[S][S];\nvector<int> son[S];\nint tu[S],tv[S],tmp[S],h[2][S],th[2][S];\nint siz[S],f[S][2][S];\n\ninline void add(int &x,int y)\n{\n\tx+=y;\n\tif(x>=p) x-=p;\n}\n\nint main()\n{\n\tfor(int i=0;i<=S-3;i++)\n\t{\n\t\tfra[i]=(i==0?1:1ll*fra[i-1]*i%p);\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<=i;j++)\n\t\t\tC[i][j]=(C[i-1][j]+C[i-1][j-1])%p;\n\t}\n\tios::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\tfor(int i=1;i<=n;i++) cin>>b[i];\n\tfa[1]=0;\n\tfor(int i=2;i<=n;i++) cin>>fa[i],son[fa[i]].push_back(i);\n\tfor(int u=n;u>=1;u--)\n\t{\n\t\tsort(son[u].begin(),son[u].end(),[&](int x,int y){return b[x]>b[y];});\n\t\tint lb=-1;\n\t\tfor(int v:son[u]) lb=max(lb,b[v]);\n\t\tsiz[u]=1;\n\t\tmemset(h,0,sizeof(h));\n\t\tif(a[u]!=-1) vis[u][a[u]]=true,h[a[u]==lb][0]=1;\n\t\telse\n\t\t{\n\t\t\th[0][1]=1;\n\t\t\tif(lb!=-1) h[1][0]=1;\n\t\t}\n\t\tfor(int v:son[u])\n\t\t{\n\t\t\tauto doit=[&](int id,int vt,bool has){\n\t\t\t\tmemcpy(tu,h[id],sizeof(h[id]));\n\t\t\t\tmemset(tv,0,sizeof(tv));\n\t\t\t\tif(vt&1) for(int i=0;i<=siz[v];i++) add(tv[i],f[v][0][i]);\n\t\t\t\tif(vt&2) for(int i=0;i<=siz[v];i++) add(tv[i],f[v][1][i]);\n\t\t\t\tmemset(tmp,0,sizeof(tmp));\n\t\t\t\tif(lb!=-1&&!has&&vis[v][lb]) return;\n\t\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\t\tif(i==lb)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(vt==3&&has&&!vis[v][i])\n\t\t\t\t\t\t\tfor(int j=1;j<=siz[v];j++) tv[j-1]=1ll*tv[j]*j%p,tv[j]=0;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(vis[u][i]==vis[v][i]) continue;\n\t\t\t\t\t\tif(!vis[u][i])\n\t\t\t\t\t\t\tfor(int j=1;j<=siz[u];j++) add(tu[j-1],1ll*tu[j]*j%p);\n\t\t\t\t\t\tif(!vis[v][i]&&i!=b[v])\n\t\t\t\t\t\t\tfor(int j=1;j<=siz[v];j++) add(tv[j-1],1ll*tv[j]*j%p);\n\t\t\t\t\t}\n\t\t\t\tfor(int i=0;i<=siz[u];i++)\n\t\t\t\t{\n\t\t\t\t\tfor(int j=0;j<=siz[v];j++)\n\t\t\t\t\t\tadd(tmp[i+j],1ll*tu[i]*tv[j]%p);\n\t\t\t\t\tfor(int j=1;j<=siz[v];j++)\n\t\t\t\t\t\tadd(tv[j-1],1ll*tv[j]*j%p);\n\t\t\t\t}\n\t\t\t};\n\t\t\tmemset(th,0,sizeof(th));\n\t\t\tif(lb==-1||b[v]!=lb)\n\t\t\t{\n\t\t\t\tif(lb==-1||!vis[u][lb])\n\t\t\t\t{// 0->0\n\t\t\t\t\tdoit(0,3,false);\n\t\t\t\t\tfor(int i=0;i<=siz[u]+siz[v];i++) add(th[0][i],tmp[i]);\n\t\t\t\t}\n\t\t\t\tif(lb!=-1)\n\t\t\t\t{// 0->1\n\t\t\t\t\tdoit(0,3,true);\n\t\t\t\t\tfor(int i=0;i<=siz[u]+siz[v];i++) add(th[1][i],tmp[i]);\n\t\t\t\t}\n\t\t\t\t{// 1->1\n\t\t\t\t\tdoit(1,3,false);\n\t\t\t\t\tfor(int i=0;i<=siz[u]+siz[v];i++) add(th[1][i],tmp[i]);\n\t\t\t\t\tdoit(1,3,true);\n\t\t\t\t\tfor(int i=0;i<=siz[u]+siz[v];i++) add(th[1][i],tmp[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(lb==-1||!vis[u][lb])\n\t\t\t\t{// 0->0\n\t\t\t\t\tdoit(0,1,false);\n\t\t\t\t\tfor(int i=0;i<=siz[u]+siz[v];i++) add(th[0][i],tmp[i]);\n\t\t\t\t}\n\t\t\t\tif(lb!=-1)\n\t\t\t\t{// 0->1\n\t\t\t\t\tdoit(0,2,true);\n\t\t\t\t\tfor(int i=0;i<=siz[u]+siz[v];i++) add(th[1][i],tmp[i]);\n\t\t\t\t}\n\t\t\t\t{// 1->1\n\t\t\t\t\tdoit(1,1,false);\n\t\t\t\t\tfor(int i=0;i<=siz[u]+siz[v];i++) add(th[1][i],tmp[i]);\n\t\t\t\t\tdoit(1,2,true);\n\t\t\t\t\tfor(int i=0;i<=siz[u]+siz[v];i++) add(th[1][i],tmp[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemcpy(h,th,sizeof(h));\n\t\t\tfor(int i=0;i<=n;i++) vis[u][i]|=vis[v][i];\n\t\t\tsiz[u]+=siz[v];\n\t\t}\n\t\tif(b[u]==lb)\n\t\t\tfor(int i=0;i<=siz[u];i++) f[u][0][i]=h[0][i];\n\t\telse if(b[u]==-1)\n\t\t\tfor(int i=0;i<=siz[u];i++)\n\t\t\t\tadd(f[u][0][i],h[0][i]),\n\t\t\t\tadd(f[u][1][i],h[1][i]);\n\t\telse\n\t\t{\n\t\t\tint cnt=0;\n\t\t\tfor(int i=lb+1;i<b[u];i++) cnt+=!vis[u][i];\n\t\t\tif(vis[u][lb])\n\t\t\t\tfor(int i=cnt;i<=siz[u];i++)\n\t\t\t\t\tadd(f[u][0][i-cnt],1ll*h[0][i]*C[i][cnt]%p*fra[cnt]%p),\n\t\t\t\t\tadd(f[u][0][i-cnt],1ll*h[1][i]*C[i][cnt]%p*fra[cnt]%p);\n\t\t\telse\n\t\t\t\tfor(int i=cnt;i<=siz[u];i++)\n\t\t\t\t\tadd(f[u][0][i-cnt],1ll*h[lb!=-1][i]*C[i][cnt]%p*fra[cnt]%p);\n\t\t}\n\t\tif(b[u]!=-1&&vis[u][b[u]]) return cout<<\"0\\n\",0;\n\t\tb[u]=max(b[u],lb);\n\t\tfor(int i=0;i<b[u];i++) vis[u][i]=true;\n\t}\n\tint cnt=n-b[1];\n\tfor(int i=b[1]+1;i<=n;i++) cnt-=vis[1][i];\n\tint ans=0;\n\tfor(int i=0;i<=siz[1];i++)\n\t\tadd(ans,1ll*(f[1][0][i]+f[1][1][i])*C[cnt][i]%p*fra[i]%p);\n\tcout<<ans<<'\\n';\n\treturn 0;\n}\n/*\nvis[u][i]=1 且 vis[v][i]=0 的怎么合并\nf[u][i] 表示 u 子树，填完了必定出现的值，有 i 种未确定的未出现的值\n\t - que1：这 i 种值顺序确定好了吗\n\t\t没确定好\n*/\n```\n",
			"tags": [{"name":"做题记录"},{"name":"DP"},{"name":"组合计数"}],
			"title": "【第七届图灵杯高级组】A. 棋无常树 做题记录",
			"link": "https://exber.qzz.io/post/%E3%80%90%E7%AC%AC%E4%B8%83%E5%B1%8A%E5%9B%BE%E7%81%B5%E6%9D%AF%E9%AB%98%E7%BA%A7%E7%BB%84%E3%80%91A.%20%E6%A3%8B%E6%97%A0%E5%B8%B8%E6%A0%91%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2025-05-31 11:00:43"
		},
	
		{
			"abstract": "> 给定一个长 $n$ 的序列 $a$ 和 $m$ 个区间 $[l_i,r_i]$，你要重排 $a$ 的元素，使得序列 $b_i=\\max\\limits_{j\\in[l_i,r_i]} a_j$ 的字典序最大，输出字典序最大的序列 $b$。\n>\n> $1\\le n,m\\le 10^5$，$1\\le a_i\\le n$，$1\\le l_i\\le r_i\\le n$。\n",
			"content": "> 给定一个长 $n$ 的序列 $a$ 和 $m$ 个区间 $[l_i,r_i]$，你要重排 $a$ 的元素，使得序列 $b_i=\\max\\limits_{j\\in[l_i,r_i]} a_j$ 的字典序最大，输出字典序最大的序列 $b$。\n>\n> $1\\le n,m\\le 10^5$，$1\\le a_i\\le n$，$1\\le l_i\\le r_i\\le n$。\n\n\n考虑贪心，若 $a$ 互不相同，则可以从大到小考虑每个 $a_i$：\n\n- 在区间序列上从前往后扫，维护 $b_j=a_i$ 的区间集合 $S$。扫到一个 $b_j$ 尚未确定的区间 $[l_j,r_j]$ 时，若加入当前区间后 $S$ 中所有区间还有交，则令 $b_j=a_i$，并向 $S$ 加入当前区间；\n\n而 $a$ 可能有重复元素，故需要稍微修改一下贪心。依旧是从大到小考虑 $[1,n]$ 中的每个数 $x$，设 $x$ 在 $a$ 中出现了 $cnt$ 次：\n\n- 在区间序列上从前往后扫，维护 $b_j=x$ 的区间集合 $S$。扫到一个 $b_j$ 尚未确定的区间 $[l_j,r_j]$ 时，若加入当前区间后 $S$ **可以划分成 $cnt$ 个子集并满足每个子集**中所有区间有交，则令 $b_j=a_i$，并向 $S$ 加入当前区间；\n\n不难发现只要每次准确地找到 $b_j=x$ 的那些位置，均摊时间复杂度就是对的。所以现在问题变为对于一个 $x$，如何快速找到所有 $b_j=x$ 的位置 $j$，并将它们删去。\n\n先考虑怎么判定一个区间集合 $S$ 是否合法（能被划分为 $cnt$ 个有交子集），这其实等价于判断能否选 $cnt$ 个点使得 $S$ 中区间均包含至少一个点。这是一个经典贪心：\n\n- 将 $S$ 中区间按右端点排序后从前往后扫，同时维护最后一个选择的点 $x$；\n- 若当前区间 $[l,r]$ 满足 $l>x$，那么在 $r$ 处额外选择一个点，令 $x=r$；\n\n注意到这个贪心实际上能求出第 $i$ 个点的最大位置 $rb_i$，而按 $l$ 排序反过来贪心一次能求出第 $i$ 个点的最小位置 $lb_i$。故有一个结论：\n\n> 区间 $[l,r]$ 能加入区间集合 $S$ 当且仅当其和 $S$ 导出的某个 $[lb_i,rb_i]$ 有交。\n\n并且这些区间还是两两不交的：如果两个区间相交，则在它们的交中放一个点就可以了，不用在两个区间中都点。\n\n那么考虑求出一段合法的前缀 $[l_1,r_1],[l_2,r_2],\\dots,[l_k,r_k]$，此时要么 $b$ 确定完了，要么我们就确定了 $S$ 导出的这 $cnt$ 个区间。接下来就可以通过线段树不断找到编号最小的和这些区间有交的区间。\n\n这一步不能直接二分，因为单次 `check` 复杂度是 $O(k\\log k)$ 的。考虑经典技巧，先倍增确定出 $k\\in [2^p,2^{p+1})$，再在 $[2^p,2^{p+1})$ 中二分 $k$。这样由于最终至少删除前 $2^p$ 个区间，故复杂度是对的，即均摊 $O(m\\log m)$。\n\n现在问题变为不断找到编号最小的合法区间，将其加入 $S$ 中，并维护这 $cnt$ 个区间。\n\n考虑若区间 $[l_i,r_i]$ 完全包含了某个区间 $[lb_j,rb_j]$，则 $[l_i,r_i]$ 无论如何一定能加入 $S$。这是因为 $[lb_j,rb_j]$ 在之后只会缩减。并且这样的区间显然不会对这 $cnt$ 个 $[lb_j,rb_j]$ 造成影响。故可以使用一棵线段树维护 $l_i\\le lb_j$ 的最大 $r_i$ 及对应的编号 $i$，每次 $[lb_j,rb_j]$ 改变的时候都不断找到完全包含它的区间，将它们删掉。\n\n那么现在只需要找到 $\\exist j,l_i\\in [lb_j,rb_j]$ 和 $\\exist j,r_i\\in [lb_j,rb_j]$ 的最小的 $i$ 即可，这也可以通过线段树和 `set` 简单维护。\n\n接下来需要考虑加入一个区间 $[l,r]$ 对这 $cnt$ 个区间的影响：\n\n- 若 $\\exist j,l\\in [lb_j,rb_j]$，则显然只会影响到 $lb_{[1,j]}$。而注意到一个区间的左端点只会在一段区间的时间内成为某一个 $lb_j$，故直接暴力修改就是对的。这里还要开一棵线段树找到 $S$ 中右端点 $< x$ 的区间的最大左端点；\n- 若 $\\exist j,r\\in [lb_j,rb_j]$，则显然只会影响到 $rb_{[j,cnt]}$，同上，暴力修改即可；\n\n故总时间复杂度 $O(n\\log n)$（认为 $n,m$ 同阶），代码如下：\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nconst int S=100005;\n\nint n,m,a[S];\nint lb[S],rb[S],nxt[S],pre[S];\nint mn[S<<2],mx[S<<2];\nset<int> idl[S],idr[S];\nset<pair<int,int> > str[S];\nint mnr[S],mxl[S],ans[S];\n\ninline int calc(int p,int len)\n{\n\tvector<pair<int,int> > vec;\n\tfor(int i=1,u=p;i<=len;i++,u=nxt[u])\n\t\tvec.emplace_back(rb[u],lb[u]);\n\tsort(vec.begin(),vec.end());\n\tint x=0,res=0;\n\tfor(auto t:vec)\n\t\tif(x<t.second) x=t.first,res++; \n\treturn res;\n}\ninline void gets(int p,int len,vector<pair<int,int> > &res)\n{\n\tvector<pair<int,int> > vec;\n\tfor(int i=1,u=p;i<=len;i++,u=nxt[u])\n\t\tvec.emplace_back(rb[u],lb[u]);\n\tsort(vec.begin(),vec.end());\n\tint x=0;\n\tfor(auto t:vec)\n\t\tif(x<t.second) res.emplace_back(0,x=t.first);\n\tvec.clear();\n\tfor(int i=1,u=p;i<=len;i++,u=nxt[u])\n\t\tvec.emplace_back(lb[u],rb[u]);\n\tsort(vec.begin(),vec.end(),greater<pair<int,int> >());\n\tx=n+1;\n\tint pos=res.size()-1;\n\tfor(auto t:vec)\n\t\tif(x>t.second) res[pos--].first=x=t.first;\n}\n\ninline void upda(int u)\n{\n\tint ls=u<<1,rs=u<<1|1;\n\tmn[u]=min(mn[ls],mn[rs]);\n\tmx[u]=rb[mx[ls]]>rb[mx[rs]]?mx[ls]:mx[rs];\n}\ninline void initu(int u,int p)\n{\n\tmn[u]=m+1;\n\tif(!idl[p].empty()) mn[u]=min(mn[u],*idl[p].begin());\n\tif(!idr[p].empty()) mn[u]=min(mn[u],*idr[p].begin());\n\tmx[u]=0;\n\tif(!str[p].empty()) mx[u]=str[p].rbegin()->second;\n}\nvoid build(int u,int l,int r)\n{\n\tif(l==r) return initu(u,l),void();\n\tint mid=l+r>>1;\n\tbuild(u<<1,l,mid),build(u<<1|1,mid+1,r);\n\tupda(u);\n}\nvoid updp(int u,int l,int r,int p)\n{\n\tif(l==r) return initu(u,l),void();\n\tint mid=l+r>>1;\n\tif(p<=mid) updp(u<<1,l,mid,p);\n\telse updp(u<<1|1,mid+1,r,p);\n\tupda(u);\n}\nint quelr(int u,int l,int r,int L,int R,int &rmx)\n{\n\tif(l>R||r<L) return m+1;\n\tif(l>=L&&r<=R) return rmx=rb[rmx]>rb[mx[u]]?rmx:mx[u],mn[u];\n\tint mid=l+r>>1,res=m+1;\n\tif(L<=mid) res=min(res,quelr(u<<1,l,mid,L,R,rmx));\n\tif(R>=mid+1) res=min(res,quelr(u<<1|1,mid+1,r,L,R,rmx));\n\treturn res;\n}\n\ninline void delp(int p)\n{\n\tnxt[pre[p]]=nxt[p];\n\tpre[nxt[p]]=pre[p];\n\tidl[lb[p]].erase(p),idr[rb[p]].erase(p);\n\tstr[lb[p]].erase(make_pair(rb[p],p));\n\tupdp(1,1,n,lb[p]),updp(1,1,n,rb[p]);\n}\n\nnamespace seg2\n{\n\tint mn[S<<2];\n\tinline void upda(int u){mn[u]=min(mn[u<<1],mn[u<<1|1]);}\n\tint quelr(int u,int l,int r,int L,int R)\n\t{\n\t\tif(l>R||r<L) return n+1;\n\t\tif(l>=L&&r<=R) return mn[u];\n\t\tint mid=l+r>>1,res=n+1;\n\t\tif(L<=mid) res=min(res,quelr(u<<1,l,mid,L,R));\n\t\tif(R>=mid+1) res=min(res,quelr(u<<1|1,mid+1,r,L,R));\n\t\treturn res;\n\t}\n\tvoid updp(int u,int l,int r,int p,int x)\n\t{\n\t\tif(l==r) return mn[u]=x,void();\n\t\tint mid=l+r>>1;\n\t\tif(p<=mid) updp(u<<1,l,mid,p,x);\n\t\telse updp(u<<1|1,mid+1,r,p,x);\n\t\tupda(u);\n\t}\n}\nnamespace seg3\n{\n\tint mx[S<<2];\n\tinline void upda(int u){mx[u]=max(mx[u<<1],mx[u<<1|1]);}\n\tint quelr(int u,int l,int r,int L,int R)\n\t{\n\t\tif(l>R||r<L) return 0;\n\t\tif(l>=L&&r<=R) return mx[u];\n\t\tint mid=l+r>>1,res=0;\n\t\tif(L<=mid) res=max(res,quelr(u<<1,l,mid,L,R));\n\t\tif(R>=mid+1) res=max(res,quelr(u<<1|1,mid+1,r,L,R));\n\t\treturn res;\n\t}\n\tvoid updp(int u,int l,int r,int p,int x)\n\t{\n\t\tif(l==r) return mx[u]=x,void();\n\t\tint mid=l+r>>1;\n\t\tif(p<=mid) updp(u<<1,l,mid,p,x);\n\t\telse updp(u<<1|1,mid+1,r,p,x);\n\t\tupda(u);\n\t}\n}\n\nint main()\n{\n\tios::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\tfor(int i=1;i<=m;i++) cin>>lb[i]>>rb[i];\n\tfor(int i=1;i<=m;i++) nxt[i]=i+1,pre[i]=i-1;\n\tnxt[0]=1;\n\tsort(a+1,a+n+1,greater<int>());\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tidl[lb[i]].insert(i),idr[rb[i]].insert(i);\n\t\tstr[lb[i]].emplace(rb[i],i);\n\t}\n\tbuild(1,1,n);\n\tfor(int i=1;i<=(S<<2)-3;i++) seg2::mn[i]=n+1,seg3::mx[i]=0;\n\tfor(int i=1;i<=n;i++) mnr[i]=n+1;\n\tint prem=m;\n\tfor(int i=1;i<=n&&prem>0;)\n\t{\n\t\tint cnt=0;\n\t\twhile(i+cnt<=n&&a[i+cnt]==a[i]) cnt++;\n\t\tint len=1;\n\t\twhile(len*2<=prem&&calc(nxt[0],len*2)<=cnt) len*=2;\n\t\tint l=len+1,r=min(prem,len*2);\n\t\twhile(l<=r)\n\t\t{\n\t\t\tint mid=l+r>>1;\n\t\t\tif(calc(nxt[0],mid)<=cnt) len=mid,l=mid+1;\n\t\t\telse r=mid-1;\n\t\t}\n\t\tvector<pair<int,int> > seg;\n\t\tgets(nxt[0],len,seg);\n\t\tset<int> st;\n\t\tvector<int> del;\n\t\tauto work=[&](int p)\n\t\t{\n\t\t\tdel.push_back(p);\n\t\t\tmnr[lb[p]]=min(mnr[lb[p]],rb[p]);\n\t\t\tmxl[rb[p]]=max(mxl[rb[p]],lb[p]);\n\t\t\tseg2::updp(1,1,n,lb[p],mnr[lb[p]]);\n\t\t\tseg3::updp(1,1,n,rb[p],mxl[rb[p]]);\n\t\t\tans[p]=a[i];\n\t\t\tdelp(p);\n\t\t\tprem--;\n\t\t};\n\t\tauto fndid=[&](int x)\n\t\t{\n\t\t\tint p=upper_bound(seg.begin(),seg.end(),make_pair(x,n+1))-seg.begin()-1;\n\t\t\tbool inx=(p>=0&&seg[p].second>=x);\n\t\t\treturn inx?p:-1;\n\t\t};\n\t\tauto ins=[&](int i)\n\t\t{\n\t\t\tint rmx=0;\n\t\t\t// printf(\"ins %d\\n\",quelr(1,1,n,seg[i].first,seg[i].second,rmx));\n\t\t\tst.insert(quelr(1,1,n,seg[i].first,seg[i].second,rmx));\n\t\t};\n\t\tauto doit=[&](pair<int,int> x){\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tint rmx=0;\n\t\t\t\tquelr(1,1,n,1,x.first,rmx);\n\t\t\t\tif(rb[rmx]>=x.second)\n\t\t\t\t{\n\t\t\t\t\tint p=rmx;\n\t\t\t\t\twork(p);\n\t\t\t\t\tint pl=fndid(lb[p]),pr=fndid(rb[p]);\n\t\t\t\t\tif(pl!=-1) ins(pl);\n\t\t\t\t\tif(pr!=-1) ins(pr);\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t};\n\t\tauto updrb=[&](int id)\n\t\t{\n\t\t\tfor(int i=id;i<seg.size();i++)\n\t\t\t{\n\t\t\t\tint nr=seg2::quelr(1,1,n,i==0?1:seg[i-1].second+1,n);\n\t\t\t\tif(nr==seg[i].second)\n\t\t\t\t{\n\t\t\t\t\tins(i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tseg[i].second=nr;\n\t\t\t\tins(i);\n\t\t\t\tdoit(seg[i]);\n\t\t\t}\n\t\t};\n\t\tauto updlb=[&](int id)\n\t\t{\n\t\t\tfor(int i=id;i>=0;i--)\n\t\t\t{\n\t\t\t\tint nl=seg3::quelr(1,1,n,1,i+1==seg.size()?n:seg[i+1].first-1);\n\t\t\t\tif(nl==seg[i].first)\n\t\t\t\t{\n\t\t\t\t\tins(i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tseg[i].first=nl;\n\t\t\t\tins(i);\n\t\t\t\tdoit(seg[i]);\n\t\t\t}\n\t\t};\n\t\t// printf(\"%d: \",a[i]);\n\t\t// for(auto t:seg) printf(\"[%d %d] \",t.first,t.second);\n\t\t// printf(\"\\n\");\n\t\tfor(int i=1;i<=len;i++) work(nxt[0]);\n\t\tfor(auto t:seg) doit(t);\n\t\tfor(int i=0;i<seg.size();i++) ins(i);\n\t\twhile(!st.empty())\n\t\t{\n\t\t\tint p=*st.begin();\n\t\t\t// printf(\"pop %d\\n\",p);\n\t\t\tif(p==m+1||ans[p]!=0)\n\t\t\t\tst.erase(p);\n\t\t\telse\n\t\t\t{\n\t\t\t\tst.erase(p);\n\t\t\t\tint pl=fndid(lb[p]),pr=fndid(rb[p]);\n\t\t\t\t// printf(\"> %d: [%d %d] (%d %d)\\n\",\n\t\t\t\t\t// p,lb[p],rb[p],pl,pr);\n\t\t\t\tif(pl==-1&&pr==-1) continue;\n\t\t\t\twork(p);\n\t\t\t\tif(pl!=-1) updlb(pl);\n\t\t\t\tif(pr!=-1) updrb(pr);\n\t\t\t\t// for(auto t:seg) printf(\"[%d %d] \",t.first,t.second);\n\t\t\t\t// printf(\"\\n\");\n\t\t\t}\n\t\t}\n\t\tfor(int p:del)\n\t\t{\n\t\t\tmnr[lb[p]]=n+1;\n\t\t\tmxl[rb[p]]=0;\n\t\t\tseg2::updp(1,1,n,lb[p],mnr[lb[p]]);\n\t\t\tseg3::updp(1,1,n,rb[p],mxl[rb[p]]);\n\t\t}\n\t\ti+=cnt;\n\t}\n\tfor(int i=1;i<=m;i++) cout<<ans[i]<<'\\n';\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"贪心"},{"name":"结论"}],
			"title": "P11983 [JOIST 2025] 展览会 3 做题记录",
			"link": "https://exber.qzz.io/post/P11983%20%5BJOIST%202025%5D%20%E5%B1%95%E8%A7%88%E4%BC%9A%203%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2025-05-27 20:43:18"
		},
	
		{
			"abstract": "> 给定一个长 $n$ 的序列 $a$ 和一个正整数 $k$，求所有满足 $S\\subseteq \\{1,2,3,\\dots,n\\}$ 且 $\\forall i\\in S,i+1\\not\\in S$ 的集合 $S$ 的 $\\sum\\limits_{i\\in S}a_i$ 的和，对 $998244353$ 取模。\n>\n> $2\\le n\\le 3\\times 10^5$，$1\\le k\\le \\lceil\\frac{n}{2}\\rceil$。\n",
			"content": "> 给定一个长 $n$ 的序列 $a$ 和一个正整数 $k$，求所有满足 $S\\subseteq \\{1,2,3,\\dots,n\\}$ 且 $\\forall i\\in S,i+1\\not\\in S$ 的集合 $S$ 的 $\\sum\\limits_{i\\in S}a_i$ 的和，对 $998244353$ 取模。\n>\n> $2\\le n\\le 3\\times 10^5$，$1\\le k\\le \\lceil\\frac{n}{2}\\rceil$。\n\n\n首先考虑怎么算方案数，显然可以使用插板法，则长 $n$ 的链上大小为 $k$ 的独立集共有 $f(n,k)=\\binom{n-k+1}{k}$ 个。\n\n考虑拆贡献计算总和，那么相当于要枚举一个位置 $i$ 并钦定 $a_i$ 在独立集中。\n\n注意到链不好做，人类智慧地考虑环的情况，即令 $a_1$ 和 $a_n$ 也不能同时选，那么此时随便钦定一个 $i$ 必选的方案数都是 $f(n-3,k-1)$。\n\n不过我们算少了 $a_1$ 和 $a_n$ 同时选的情况。对于 $a_1$ 和 $a_n$，它们在少算的情况中的总贡献为 $(a_1+a_n)\\times f(n-4,k-2)$；而对于 $a_{[3,n-2]}$，它们少算的贡献相当于 $a'=a_{[3,n-2]},k'=k-2$ 的子问题，递归即可。\n\n不难发现，每次计算都是 $O(1)$ 的，而最多递归 $n$ 次，所以复杂度为 $O(n)$。\n\n边界情况要特判，代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=300005;\n\n#define p 998244353\n\ninline int qpow(int x,int y)\n{\n\tint res=1;\n\tfor(;y>0;y>>=1,x=1ll*x*x%p) res=y&1?1ll*res*x%p:res;\n\treturn res;\n}\ninline void add(int &x,int y)\n{\n\tx+=y;\n\tif(x>=p) x-=p;\n}\n\nint fra[S],inv[S];\nint n,k,d,a[S],s[S];\n\ninline int C(int n,int m)\n{\n\tif(n<0||m<0||n<m) return 0;\n\treturn 1ll*fra[n]*inv[n-m]%p*inv[m]%p;\n}\ninline int f(int n,int k){return C(n-k+1,k);}\n\nint calc(int l,int r,int k)\n{\n\tif(k<=0) return 0;\n\tif(r<=l+1) return k!=1?0:(s[r]-s[l-1]+p)%p;\n\tif(r==l+2)\n\t{\n\t\tif(k==1) return (s[r]-s[l-1]+p)%p;\n\t\tif(k==2) return (a[l]+a[r])%p;\n\t\treturn 0;\n\t}\n\tint res=0;\n\tres=1ll*(s[r]-s[l-1]+p)*f(r-l+1-3,k-1)%p;\n\tadd(res,1ll*(a[l]+a[r])*f(r-l+1-4,k-2)%p);\n\tadd(res,calc(l+2,r-2,k-2));\n\treturn res;\n}\n\nint main()\n{\n\tfra[0]=1;\n\tfor(int i=1;i<=S-3;i++) fra[i]=1ll*fra[i-1]*i%p;\n\tinv[S-3]=qpow(fra[S-3],p-2);\n\tfor(int i=S-3;i>=1;i--) inv[i-1]=1ll*inv[i]*i%p;\n\tios::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tcin>>n>>k>>d;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\tfor(int i=1;i<=n;i++) s[i]=a[i],add(s[i],s[i-1]);\n\tcout<<calc(1,n,k)<<'\\n';\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"组合计数"}],
			"title": "ARC120F Wine Thief 做题记录",
			"link": "https://exber.qzz.io/post/ARC120F%20Wine%20Thief%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2025-05-27 19:54:49"
		},
	
		{
			"abstract": "> 对于一个长 $n$ 的序列 $a$，你可以选择一个满足 $a_i=i$ 且 $i<n$ 的位置 $i$ 并删除 $a_i$ 和 $a_{i+1}$，删除后两边会拼接。\n>\n> 给定一个长 $n$ 的序列 $a$，求最多能进行多少次上述操作。\n>\n> $1\\le n\\le 800$，$1\\le a_i\\le n$。\n",
			"content": "> 对于一个长 $n$ 的序列 $a$，你可以选择一个满足 $a_i=i$ 且 $i<n$ 的位置 $i$ 并删除 $a_i$ 和 $a_{i+1}$，删除后两边会拼接。\n>\n> 给定一个长 $n$ 的序列 $a$，求最多能进行多少次上述操作。\n>\n> $1\\le n\\le 800$，$1\\le a_i\\le n$。\n\n\n不会 *2600。\n\n删除的过程不好刻画，考虑某个位置 $a_i$ 和与它一起被删去的位置 $a_j$（$i<j$），显然 $a_{[i+1,j-1]}$ 都要被删去，且它们一定先于 $(a_i,a_j)$ 被删去。\n\n这启发我们设计状态：$f_{l,r}$ 表示完全删除 $a_{[l,r]}$ 至少需要在 $[1,l-1]$ 中执行多少次删除操作。\n\n转移考虑枚举和 $a_l$ 一起删去的 $a_k$。显然 $l<a_l$ 或者 $l\\not\\equiv a_l\\pmod 2$ 则 $a_l$ 就无法被删去，否则设 $v=\\frac{l-a_l}{2}$。由于 $a_l$ 和 $a_k$ 一起删除，所以 $a_{[l+1,k-1]}$ 前面最多能执行 $v$ 次操作，故要求 $f_{l+1,k-1}\\le v$，此时有 $\\max(v,f_{k+1,r}-\\frac{k-l+1}{2})\\to f_{l,r}$。\n\n边界为 $f_{i+1,i}=0$。\n\n求答案是简单的，设 $g_i$ 表示 $a_{[1,i]}$ 中最多执行多少次操作，利用 $f$ 转移即可。\n\n时间复杂度 $O(n^3)$，代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=805,inf=1e8;\n\nint n,a[S];\nint f[S][S],g[S];\n\ninline void slove()\n{\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\tfor(int i=0;i<=n;i++) f[i+1][i]=0;\n\tfor(int len=2;len<=n;len+=2)\n\t\tfor(int l=1;l<=n-len+1;l++)\n\t\t{\n\t\t\tint r=l+len-1;\n\t\t\tf[l][r]=inf;\n\t\t\tif(l>=a[l]&&(l-a[l]&1^1))\n\t\t\t{\n\t\t\t\tint val=(l-a[l])/2;\n\t\t\t\tfor(int k=l+1;k<=r;k+=2)\n\t\t\t\t\tif(f[l+1][k-1]<=val)\n\t\t\t\t\t{\n\t\t\t\t\t\tint pre=max(\n\t\t\t\t\t\t\tval,\n\t\t\t\t\t\t\tf[k+1][r]-(k-l+1)/2\n\t\t\t\t\t\t);\n\t\t\t\t\t\tf[l][r]=min(f[l][r],pre);\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\tg[0]=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tg[i]=g[i-1];\n\t\tfor(int j=i-1;j>=1;j-=2)\n\t\t\tif(g[j-1]>=f[j][i]) g[i]=max(g[i],g[j-1]+(i-j+1)/2);\n\t}\n\tcout<<g[n]<<'\\n';\n}\n\nint main()\n{\n\tios::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tint T;\n\tcin>>T;\n\twhile(T-->0) slove();\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"DP"}],
			"title": "CF1987F2 Interesting Problem (Hard Version) 做题记录",
			"link": "https://exber.qzz.io/post/CF1987F2%20Interesting%20Problem%20%28Hard%20Version%29%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2025-05-26 19:54:52"
		},
	
		{
			"abstract": "> 给定一个 $n$ 的排列 $a$，$q$ 次询问，每次查询 $a_{[l_i,r_i]}$ 的 LIS 长度。\n>\n> $1\\le n\\le 10^5$，$1\\le q\\le 10^6$。\n",
			"content": "> 给定一个 $n$ 的排列 $a$，$q$ 次询问，每次查询 $a_{[l_i,r_i]}$ 的 LIS 长度。\n>\n> $1\\le n\\le 10^5$，$1\\le q\\le 10^6$。\n\n\n考虑求序列 $b$ 的 LIS 长度的经典贪心算法：\n\n> 维护一个集合 $S$，从前往后遍历 $b$ 的每个元素 $b_i$：\n>\n> - 找到最小的 $x\\in S,x\\ge b_i$；\n> - 若找到了则从 $S$ 中删掉 $x$，找不到就不管；\n> - 将 $b_i$ 加入 $S$；\n>\n> 最终 $|S|$ 即为 LIS 长度。\n\n原理是最长反链等于最小链覆盖。\n\n设 $S_{[l,r]}$ 对表示 $b=a_{[l,r]}$ 执行上面的过程最终得到的 $S$。\n\n观察发现，$S_{[l+1,r]}\\subseteq S_{[l,r]}$，并且 $|S_{[l+1,r]}|$ 和 $|S_{[l,r]}|$ 最多相差 $1$，即最多会新插入一个数。\n\n证明考虑在前面插入一个数后原来 $S$ 中的数肯定不会消失（消失只能是因为被后面的数顶掉），而最多在链覆盖中增加一条链（$S$ 中最多插入一个数）。\n\n那么考虑扫描线，$r$ 从左到右扫描的同时维护每个数 $x$ 在 $l\\in[1,r]$ 的多少个 $S_{[l,r]}$ 中出现了，记为 $cnt_x$。注意到 $x$ 肯定是出现在 $S_{[[1,cnt_x],r]}$ 这个前缀的集合中，那么区间 $[l_i,r_i]$ 答案就是 $r$ 扫到 $r_i$ 时 $cnt_x\\ge l_i$ 的 $x$ 的个数。\n\n考虑 $r\\to r+1$ 对 $cnt$ 的影响，相当于从 $a_{r+1}$ 开始在值域上往后遍历，将前缀最大值的位置 $p_{1},p_2,p_3,\\dots,p_k$ 找出来，然后将 $cnt'_{p_1}:= 0,cnt'_{p_2}:=cnt_{p_1},\\dots,cnt'_{p_k}:=cnt_{p_{k-1}}$，然后令 $cnt'_{a_{r+1}}:=i$。\n\n这其实是 [AT_joisc2016_h 回転寿司](https://www.luogu.com.cn/problem/AT_joisc2016_h) 的 $l=a_{r+1},r=n,A=0$ 版本，最后多一步将 $cnt_{a_{r+1}}$ 改为 $i$。而求答案可以用树状数组维护每个 $y$ 在 $cnt$ 数组中出现过 $ct_y$ 次，那么单步扫描线相当于将 $ct_{i}$ 加一，然后将结束后的 $A'$ 的 $ct_{A'}$ 减一。\n\n做法考虑分块，假设块长为 $B$。\n\n对于整块，一个数进入一个块后出来的数显然只和这个块的最大值有关系，那么每个块开个大根堆，每次若 $A$ 比堆顶小则交换一下 $A$ 和堆顶。\n\n对于散块，简单分讨可以发现对于两次对整块的修改 $x,y$，先做 $A=x$ 再做 $A=y$ 和先做 $A=y$ 再做 $A=x$ 的结果是一样的，所以不妨钦定是从小到大操作。具体的，把对整块的操作存进一个小根堆，然后从左往右遍历块内的 $a_i$，若 $a_i$ 比堆顶大，那么就交换 $a_i$ 和堆顶。这样就可以在 $O(B\\log n)$ 的复杂度重构某个块，从而暴力进行散块的修改。\n\n那么总复杂度为 $O(\\frac{n^2}{B}\\log n+nB\\log n)$，所以 $B$ 应取 $\\sqrt n$。不过由于修改整块常数较小（只用进行至多一次交换堆顶操作），所以 $B$ 可以开小一点。\n\n回到本题，再用树状数组维护 $ct$ 即可做到 $O(n\\sqrt n\\log n+q\\log n)$，也可以用修改 $O(\\sqrt n)$ 查询 $O(1)$ 的前缀和分块做到 $O(n\\sqrt n\\log n+q)$。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <queue>\n\nusing namespace std;\n\ntemplate<typename T>\ninline void read(T &x)\n{\n\tx=0;\n\tT w=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9') w=(c=='-'?-w:w),c=getchar();\n\twhile(c>='0'&&c<='9') x=x*10+(c^48),c=getchar();\n\tx*=w;\n}\n\nconst int S=100005,BS=150,QS=1000005;\n\nint n,q;\nint a[S],c[S];\nint lb[S/BS+5],rb[S/BS+5];\npriority_queue<int> b[S/BS+5],que[S/BS+5];\nvector<pair<int,int> > vec[S];\nint tr[S],ans[QS];\n\ninline void dwntag(int u)\n{\n\tif(que[u].empty()) return;\n\tint l=lb[u],r=rb[u];\n\tfor(int i=l;i<=r;i++)\n\t{\n\t\tint x=-que[u].top();\n\t\tif(c[i]>x)\n\t\t{\n\t\t\tswap(c[i],x);\n\t\t\tque[u].pop();\n\t\t\tque[u].push(-x);\n\t\t}\n\t}\n\twhile(!que[u].empty()) que[u].pop();\n}\n\ninline void rebuild(int u)\n{\n\tint l=lb[u],r=rb[u];\n\twhile(!b[u].empty()) b[u].pop();\n\tfor(int i=l;i<=r;i++) b[u].push(c[i]);\n}\n\ninline int doit(int l,int x)\n{\n\tint ul=(l-1)/BS+1;\n\tif(rb[ul]==n)\n\t{\n\t\tdwntag(ul);\n\t\tfor(int i=l;i<=n;i++) if(c[i]>x) swap(c[i],x);\n\t\trebuild(ul);\n\t\treturn x;\n\t}\n\tdwntag(ul);\n\tfor(int i=l;i<=rb[ul];i++) if(c[i]>x) swap(c[i],x);\n\trebuild(ul);\n\tfor(int i=ul+1;i<=(n-1)/BS+1;i++)\n\t{\n\t\tint mx=b[i].top();\n\t\tif(mx>x)\n\t\t{\n\t\t\tque[i].push(-x);\n\t\t\tswap(mx,x);\n\t\t\tb[i].pop();\n\t\t\tb[i].push(mx);\n\t\t}\n\t}\n\treturn x;\n}\n\ninline void addtr(int p,int x){for(int i=p;i<=n;i+=i&-i) tr[i]+=x;}\ninline int quetr(int p)\n{\n\tint res=0;\n\tfor(int i=p;i>=1;i-=i&-i) res+=tr[i];\n\treturn res;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tread(n),read(q);\n\tfor(int i=1;i<=n;i++) read(a[i]);\n\tfor(int i=1;i<=n;i+=BS)\n\t{\n\t\tint u=(i-1)/BS+1;\n\t\tlb[u]=(u-1)*BS+1,rb[u]=min(u*BS,n);\n\t\trebuild(u);\n\t}\n\tfor(int i=1;i<=q;i++)\n\t{\n\t\tint l,r;\n\t\tread(l),read(r);\n\t\tvec[r].emplace_back(l,i);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint del=doit(a[i],0);\n\t\tint u=(a[i]-1)/BS+1;\n\t\tdwntag(u);\n\t\tc[a[i]]=i;\n\t\trebuild(u);\n\t\tif(del!=0) addtr(n-del+1,-1);\n\t\taddtr(n-i+1,1);\n\t\tfor(auto t:vec[i]) ans[t.second]=quetr(n-t.first+1);\n\t}\n\tfor(int i=1;i<=q;i++) cout<<ans[i]<<'\\n';\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"数据结构"},{"name":"结论"},{"name":"分块"}],
			"title": "P2075 区间 LIS 做题记录",
			"link": "https://exber.qzz.io/post/P2075%20%E5%8C%BA%E9%97%B4%20LIS%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2025-05-13 15:42:06"
		},
	
		{
			"abstract": "",
			"content": "### 异或哈希\n\n常用于快速判断两个集合是否相等。\n\n给每种元素设置一个随机的 `unsigned long long` 哈希值，每个集合的哈希值是其元素的哈希值的异或和。\n\n例题：\n\n- [P8819 [CSP-S 2022] 星战](https://www.luogu.com.cn/problem/P8819)\n- 【2025暑期ACM04】图计算\n\n### Schwartz-Zippel 定理\n\n> 对于一个域 $F$（通常为 $\\text{mod}\\, p$ 域，其中 $p$ 为大质数）下的 $m$ 元 $n$ 次多项式 $f(x_1,x_2,\\dots,x_m)$，若每个 $x_i$ 均在 $F$ 中独立等概率随机，则 $f(x_1,x_2,\\dots,x_m)=0$ 的概率 $\\le \\frac{n}{|F|}$。\n\n感性理解，一元的情况下 $f$ 有 $n$ 个根，显然。\n\n这个东西十分实用，常用于检验各种东西是否为 $0$（例如通过行列式快速检验积和式是否为 $0$）。\n\n例题：\n\n- [P10102 [GDKOI2023 提高组] 矩阵](https://www.luogu.com.cn/problem/P10102)\n\n### 最大团的经典随机算法\n\n随机一个加点顺序，按照这个顺序加点。若加进去后还是团则加进去，否则不加。这个东西实际上很难卡。\n\n### 出现次数大于一半，每次随机化可以缩小一半错误率\n\n例题：[CF364D Ghd](https://www.luogu.com.cn/problem/CF364D)\n\n<details><summary>题解</summary><p>\n\n> 至少一半的数的因数，这启发我们想到随机化。\n>\n> 具体的，每次随机一个 $i$，那么 $a_i$ 出现在是答案的倍数的集合中的概率是 $\\frac{1}{2}$，枚举 $a_i$ 的每一个因子作为答案判断是否可行，如可行则贡献给全局答案。\n>\n> 单次时间复杂度 $O(10^6)$，随机 $10$ 次可将错误率缩减到 $\\frac{1}{1024}$，如果不是特别脸黑就可以通过本题。\n</p></details>\n\n练习：[CF1305F Kuroni and the Punishment](https://www.luogu.com.cn/problem/CF1305F)\n\n### 颜色随机映射\n\n处理类似于颜色两两不同的限制时，可以选取一个较小的 $m$ 并将颜色随机映射到 $[1,m]$，这样假设需要有 $k$ 个两两不同的颜色则正确率是 $\\frac{m!}{(m-k)!m^k}$ 的。\n\n例题：[CF2003F Turtle and Three Sequences](https://www.luogu.com.cn/problem/CF2003F)\n",
			"tags": [{"name":"学习笔记"},{"name":"小技巧"},{"name":"概率、期望"}],
			"title": "一些随机化技巧",
			"link": "https://exber.qzz.io/post/%E4%B8%80%E4%BA%9B%E9%9A%8F%E6%9C%BA%E5%8C%96%E6%8A%80%E5%B7%A7",
			"date": "2025-04-15 16:18:28"
		},
	
		{
			"abstract": "> 对于两个字符串 $A,B$，若能将 $A$ 的一个后缀整体移动到 $A$ 的前面则称它们是循环同构的。\n>\n> 给定一个长 $n$ 的字符串，求最大的 $L$ 使得 $S_{[1,L]}$ 和 $S_{[n-L+1,n]}$ 是循环同构的。\n>\n> $1\\le n\\le 10^6$。\n",
			"content": "> 对于两个字符串 $A,B$，若能将 $A$ 的一个后缀整体移动到 $A$ 的前面则称它们是循环同构的。\n>\n> 给定一个长 $n$ 的字符串，求最大的 $L$ 使得 $S_{[1,L]}$ 和 $S_{[n-L+1,n]}$ 是循环同构的。\n>\n> $1\\le n\\le 10^6$。\n\n\n第一步就没想到。\n\n考虑两个串循环同构当且仅当一个串是 $AB$ 而另一个串是 $BA$，故有 $S=ABCBA$。\n\n那么枚举 $A$ 的长度，然后问题就变成求头尾都去掉 $x$ 个字符后的 border。\n\n设 $f_i$ 表示头尾都去掉 $i$ 个字符后的 border，那么显然有 $f_{i+1}\\ge f_i-2$，那么 $i$ 从大往小每次暴力往前跑找到第一个合法即可，实现注意需要双哈希。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int S=1000005;\nconst int bse=31,p1=1000000007,p2=998244353;\n\nint n;\nchar a[S];\nint pw1[S],pw2[S];\nint h1[S],h2[S];\n\ninline int cal1(int l,int r)\n{\n\treturn (h1[r]-1ll*pw1[r-l+1]*h1[l-1]%p1+p1)%p1;\n}\n\ninline int cal2(int l,int r)\n{\n\treturn (h2[r]-1ll*pw2[r-l+1]*h2[l-1]%p2+p2)%p2;\n}\n\ninline bool chk(int l,int r,int k)\n{\n\tif(k==0) return true;\n\treturn cal1(l,l+k-1)==cal1(r-k+1,r)&&\n\t\t   cal2(l,l+k-1)==cal2(r-k+1,r);\n}\n\nint main()\n{\n\tscanf(\"%d%s\",&n,a+1);\n\tpw1[0]=pw2[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tpw1[i]=1ll*pw1[i-1]*bse%p1;\n\t\tpw2[i]=1ll*pw2[i-1]*bse%p2;\n\t\th1[i]=(1ll*h1[i-1]*bse+a[i]-'a'+1)%p1;\n\t\th2[i]=(1ll*h2[i-1]*bse+a[i]-'a'+1)%p2;\n\t}\n\tint ans=0;\n\tfor(int l=n/2,r=n/2+1+(n&1),len=0;l>=1;l--,r++)\n\t{\n\t\tif(chk(1,n,l)) ans=max(ans,l+len);\n\t\tif(len+2<=(r-l+1)/2&&chk(l,r,len+2)) len+=2;\n\t\telse if(len+1<=(r-l+1)/2&&chk(l,r,len+1)) len++;\n\t\twhile(!chk(l,r,len)) len--;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"字符串"},{"name":"结论"}],
			"title": "P3546 [POI2012] PRE-Prefixuffix 做题记录",
			"link": "https://exber.qzz.io/post/P3546%20%5BPOI2012%5D%20PRE-Prefixuffix%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2025-04-14 19:25:41"
		},
	
		{
			"abstract": "> 给定三个长 $n$ 的序列 $A,B,C$，找到一个符合以下条件且大小最大的集合 $S$：\n>\n> - 其能被这样生成：对于每个 $i\\in [1, n]$，向 $S$ 中加入 $A_i$ 或者 $B_i$；\n> - 其能被这样生成：对于每个 $i\\in [1, n]$，向 $S$ 中加入 $A_i$ 或者 $C_i$；\n>\n> 需要输出方案。\n>\n> $1\\le n\\le 5000$，$1\\le A_i,B_i,C_i\\le 10000$。\n",
			"content": "> 给定三个长 $n$ 的序列 $A,B,C$，找到一个符合以下条件且大小最大的集合 $S$：\n>\n> - 其能被这样生成：对于每个 $i\\in [1, n]$，向 $S$ 中加入 $A_i$ 或者 $B_i$；\n> - 其能被这样生成：对于每个 $i\\in [1, n]$，向 $S$ 中加入 $A_i$ 或者 $C_i$；\n>\n> 需要输出方案。\n>\n> $1\\le n\\le 5000$，$1\\le A_i,B_i,C_i\\le 10000$。\n\n\n考虑弱化限制，如果给每次操作增加一个“什么都不做”的选项，那么可以直接跑最大流。\n\n具体的，可以建四排点，所有边流量都是 $1$：（图来自 [Schi2oid 的题解](https://www.luogu.com.cn/article/5znb548p)）\n\n![](../post-images/1744589972041.png)\n\n这样做的问题是跑完最大流后有可能存在某些第二排或者倒数第二排的点实际上什么都没做，即它们对应的出边/入边中没有点被流经。不妨称这些点为“空点”。\n\n考虑不断跑流的过程中什么时候会增加新的“空点” $u$，先来考虑 $u$ 在第二排的情况（在倒数第二排同理）。显然不可能同时退掉 $u$ 的两个出点，故一定是退掉了 $u$ 的一个出点 $x$。\n\n那么退流之前 $S\\to u$ 的边肯定没满流，否则 $u$ 流向了 $x$，这次退流一定会经过 $u$，则 $u$ 不会变成“空点”。\n\n那么一定可以将 $S\\to ...\\to x$ 这一段路径直接换成 $S\\to u\\to x$，这样增广路的长度必定会变短，而 $u$ 将不再是“空白点”。\n\n所以每次找最短的增广路去增广就一定不会使“空白点”变多。\n\n注意到 dinic 每次找的增广路就是最短的，所以先钦定每次都选择 $A_i$，再跑 dinic 即可。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <queue>\n\nusing namespace std;\n\nconst int S=300005,V=10000,inf=1e8;\n\nint n,A[S],B[S],C[S];\nint vis[S],idx[S];\nint esum=1,to[S],c[S],nxt[S],h[S];\nint s,t;\nint dep[S],cur[S];\n\ninline void added(int x,int y,int w)\n{\n\tto[++esum]=y;\n\tc[esum]=w;\n\tnxt[esum]=h[x];\n\th[x]=esum;\n}\n\ninline void add(int x,int y,int w)\n{\n\tadded(x,y,w),added(y,x,w^1);\n}\n\ninline bool bfs()\n{\n\tfor(int i=s;i<=t;i++) dep[i]=0,cur[i]=h[i];\n\tqueue<int> q;\n\tdep[s]=1;\n\tq.push(s);\n\twhile(!q.empty())\n\t{\n\t\tint u=q.front();\n\t\tq.pop();\n\t\tfor(int i=h[u];i;i=nxt[i])\n\t\t{\n\t\t\tint v=to[i],w=c[i];\n\t\t\tif(w>0&&dep[v]==0)\n\t\t\t{\n\t\t\t\tdep[v]=dep[u]+1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn dep[t]>0;\n}\n\nint dfs(int u,int w)\n{\n\tif(u==t) return w;\n\tint sum=0;\n\tfor(int &i=cur[u];i;i=nxt[i])\n\t{\n\t\tif(c[i]==0) continue;\n\t\tint v=to[i];\n\t\tif(dep[v]!=dep[u]+1) continue;\n\t\tint r=dfs(v,min(c[i],w));\n\t\tc[i]-=r;\n\t\tc[i^1]+=r;\n\t\tw-=r;\n\t\tsum+=r;\n\t\tif(w==0) break;\n\t}\n\tif(sum==0) dep[u]=0;\n\treturn sum;\n}\n\ninline int dinic()\n{\n\tint res=0;\n\twhile(bfs()) res+=dfs(s,inf);\n\treturn res;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&A[i]);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&B[i]);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&C[i]);\n\ts=0,t=n*2+V*2+1;\n\tint res=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x=1;\n\t\tif(vis[A[i]]==0)\n\t\t{\n\t\t\tvis[A[i]]=1;\n\t\t\tres++;\n\t\t\tx=0;\n\t\t}\n\t\tadd(s,i,x);\n\t\tadd(n+i,t,x);\n\t\tadd(i,n*2+A[i],x);\n\t\tadd(i,n*2+B[i],1);\n\t\tadd(n*2+V+A[i],n+i,x);\n\t\tadd(n*2+V+C[i],n+i,1);\n\t}\n\tfor(int i=1;i<=V;i++) add(n*2+i,n*2+V+i,vis[i]^1),idx[i]=esum;\n\tres+=dinic();\n\tprintf(\"%d\\n\",res);\n\tfor(int i=1;i<=V;i++) if(c[idx[i]]>0) printf(\"%d \",i);\n\tprintf(\"\\n\");\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"结论"},{"name":"图论"},{"name":"网络流"}],
			"title": "ARC156F Make Same Set 做题记录",
			"link": "https://exber.qzz.io/post/ARC156F%20Make%20Same%20Set%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2025-04-14 08:19:26"
		},
	
		{
			"abstract": "",
			"content": "本文大量参考袁方舟的论文《浅谈杨氏矩阵在信息学竞赛中的应用》。\n\n### Part 1 定义\n\n##### 定义 1.1（拆分）\n\n> 定义正整数 $n$ 的拆分 $\\lambda_{[1,k]}=\\{\\lambda_{1},\\lambda_{2},\\dots,\\lambda_{k}\\}$，其需要满足：\n>\n> - $\\forall 1\\le i\\le k$，都有 $\\lambda_i\\in \\N^+$；\n> - $n=\\sum \\limits_{i=1}^k \\lambda_i$；\n> - $\\forall 1\\le i<k$，都有 $\\lambda_i\\ge \\lambda_{i+1}$；\n\n##### 定义 1.2（杨图）\n\n> 对于一个 $n$ 的拆分 $\\lambda_{[1,k]}$，定义其对应的杨图为一个 $k$ 行的阶梯状网格图，满足第 $i$ 行有 $\\lambda_i$ 个格子。\n>\n> 例如这是 $\\lambda_{[1,8]}=\\{9,9,7,3,3,3,3,1\\}$ 对应的杨图：\n>\n> ![](../post-images/1743473047241.png)\n\n##### 定义 1.3.1（标准杨表）\n\n>将 $[1,n]$ 填入 $\\lambda_{[1,k]}$ 对应杨图的格子中，满足**每行严格递增**且**每列严格递增**。\n>\n>例如：\n>\n>![](../post-images/1743473424383.png)\n\n不难发现一个标准杨表的任意子表（选若干行若干列取交点，类比子矩阵）都是标准杨表。\n\n##### 定义 1.3.2（半标准杨表）\n\n> 允许数字重复的杨表，满足**每行不严格递增**且**每列严格递增**。\n\n于标准杨表相同，一个半标准杨表的任意子表都是半标准杨表。\n\n##### 定义 1.3.3（斜杨图）\n\n> 对于 $n$ 的拆分 $\\lambda_{[1,k_1]}$ 和 $m$ 的拆分 $\\mu_{[1,k_2]}$，若 $k_2\\le k_1$ 且 $\\forall 1\\le i\\le k_2$ 均有 $\\mu_i\\le \\lambda_i$，那么定义斜杨图 $\\lambda/\\mu$ 为 $\\lambda$ 对应的杨图扣掉 $\\mu$ 对应的杨图得到的网格图：\n>\n> ![](../post-images/1743474042120.jpg)\n>\n> 类似地，定义标准斜杨表和半标准斜杨表。\n\n同前文，子表仍满足对应性质。\n\n### Part 2 RSK 算法和 RS 双射\n\nRSK 算法构建了排列和有序标准杨表对间的双射——RS 双射。\n\n##### 算法 2.1.1（RSK 行插入算法）\n\n> 对于一个标准杨表 $S$，定义插入一个未在 $S$ 中出现的数 $x$ 的算法 $S\\leftarrow x$：\n>\n> 1. 若 $S$ 为空，则在 $S$ 中加入 $x$，插入结束；\n> 2. 找到 $S_{1,*}$（第一行）中第一个 $> x$ 的数 $S_{1,i}$：\n>    - 若找不到则在 $S_{1,*}$ 右端加入 $x$，插入结束；\n>    - 若找到了，则用 $x$ 顶替掉 $S_{1,i}$，递归向子表 $S_{\\ge 2,*}$（即删掉第一行）中行插入原来的 $S_{1,i}$；\n>\n> 一个例子：\n>\n> ![](../post-images/1743476323464.png)\n\n对于行插入，不难发现一些性质：\n\n- $S\\leftarrow x$ 过程中顶替掉的数字的列号单调不增；\n- $S\\leftarrow x$ 是标准杨表；\n\n类似地，定义列插入算法：\n\n##### 算法 2.1.2（RSK 列插入算法）\n\n> 对于一个标准杨表 $S$，定义列插入 $x$ 算法 $x\\rightarrow S$（需保证 $x$ 未在 $S$ 中出现）：\n>\n> 1. 若 $S$ 为空，则在 $S$ 中加入 $x$，插入结束；\n> 2. 找到 $S_{*,1}$（第一列）中第一个 $> x$ 的数 $S_{i,1}$：\n>    - 若找不到则在 $S_{*,1}$ 下端加入 $x$，插入结束；\n>    - 若找到了，则用 $x$ 顶替掉 $S_{i,1}$，递归向子表 $S_{*,\\ge 2}$（即删掉第一列）中行插入原来的 $S_{i,1}$；\n\n其具有和行插入类似的性质。\n\n接下来定义行删除算法：\n\n##### 算法 2.2.1（RSK 行删除算法）\n\n> 对于一个标准杨表 $S$，定义行删除 $S_{s,t}$ 的算法，要求 $(s,t)$ 是 $S$ 的一个“边角”：\n>\n> 1. 令 $x=S_{s,t}$，删去格子 $(s,t)$，令当前行 $i=s-1$；\n>    - 若 $i=0$ 则删除结束；\n>    - 否则\n>      1. 找到 $S_{i,*}$ 中最后一个 $<x$ 的数 $S_{i,j}$，根据标准杨表的性质，这样的数必定存在；\n>      2. 交换 $S_{i,j}$ 和 $x$，令 $i:=i-1$，回到第一步；\n>\n> 一个例子：\n>\n> ![](../post-images/1743476379829.png)\n\n不难发现行删除是行插入的逆操作，具体的，行删除每次替换掉的数恰好是行插入每次顶替掉的数。\n\n类似定义列删除算法。\n\n类似地，定义半标准杨表中的行插入和列插入算法，行插入算法不变，列插入算法仅需在顶替数字的时候更改为找到第一个 $\\ge x$ 的数。而半标准杨表中的行删除或列删除算法也是类似的，显然也和对应的插入算法互逆。\n\n接下来我们定义一个排列到标准杨表对的双射：\n\n##### 定义 2.1.1（RS 双射）\n\n> 对于一个排列 $p_{[1,n]}$，定义标准杨表对 $(P_{p},Q_{p})$，其中 $P_p=((\\dots((p_1\\leftarrow p_2)\\leftarrow p_3)\\leftarrow\\dots)\\leftarrow p_n)$，即依次行插入 $p_{1},p_2,\\dots,p_n$ 得到的标准杨表。而 $Q_p$ 为一个形状和 $P_p$ 相同的标准杨表，但 $Q_p$ 中 $(i,j)$ 上的数表示该格子是在第几次行插入中被创建的。\n>\n> 显然 $P_p$ 和 $Q_p$ 都是标准杨表。\n>\n> RS 双射指出，排列 $p_{[1,n]}$ 和有序标准杨表对 $(P_p,Q_p)$ 一一对应，即有：\n> $$\n> n!=\\sum\\limits_{|S|=n}count^2(S)\n> $$\n> 其中 $S$ 为杨图，$count(S)$ 表示该杨图对应的标准杨表个数。\n\n证明考虑显然 $p$ 可以唯一确定 $(P_p,Q_p)$，而由于行删除是行插入的逆操作，故可以根据 $Q_p$ 记录的信息不断对 $P_p$ 执行行删除，从而求出 $p$。故该映射为双射。\n\n### Part 3 矩阵、递增坐标序列和半标准杨表\n\n##### 定义 3.1（递增坐标序列）\n\n> 对于两个二维坐标 $(a,b),(c,d)$，定义 $(a,b)\\le (c,d)$ 当且仅当 $a<c$ 或 $a=c,b\\le d$（即 `pair<int,int>` 的比较）。\n>\n> 定义一个递增坐标序列 $\\{(u_1,v_1),(u_2,v_2),\\dots,(u_k,v_k)\\}$ 需要满足 $\\forall 1\\le i<k$ 都有 $(u_i,v_i)\\le (u_{i+1},v_{i+1})$。\n\n不难发现排列就是 $(u_i,v_i)=(i,p_i)$ 的递增坐标序列。\n\n对于递增坐标序列 $a$，我们可以重定义一下 RS 双射，改为 $P_a$ 由依次行插入 $v_i$ 得到，而 $Q_a$ 的格子 $(i,j)$ 上填入新增该格子对应的插入操作 $(u_i,v_i)$ 的 $u_i$：\n\n![](../post-images/1743478296154.jpg)\n\n显然 $P_a$ 和 $Q_a$ 都是半标准杨表。\n\n那么仍然有双射 $a\\leftrightarrow (P_a,Q_a)$，即递增坐标序列和半标准杨表对构成双射。\n\n接下来，考虑定义递增坐标序列的逆：\n\n##### 定义 3.1.1（递增坐标序列的逆）\n\n> 对于一个递增坐标序列 $a_{[1,k]}=\\{(u_i,v_i)\\}$，定义其逆为 $a^{-1}_{[1,k]}$ 为 $\\{(v_i,u_i)\\}$ 递增排序后的结果。\n>\n> 显然 $a^{-1}$ 也是递增坐标序列。\n\n考虑更加形象地描述递增坐标序列和其逆。定义递增坐标序列和（无限）矩阵之间的双射：\n\n##### 定义 3.2（递增坐标序列和矩阵）\n\n> 对于一个递增坐标序列 $a$，其对应的矩阵 $A$ 满足 $A_{i,j}$ 为 $(i,j)$ 在 $a$ 中的出现次数。\n>\n> 不难发现这是一个双射。\n\n根据这个定义，不难发现 $a^{-1}$ 对应的矩阵为 $A^T$，即 $A$ 的转置。\n\n由此，可以进一步导出一个结论：\n\n##### 定理 3.1\n\n> 对于一个递增坐标序列 $a$，有：\n> $$\n> (P_a,Q_a)=(Q_{a^{-1}},P_{a^{-1}})\n> $$\n\n证明考虑在矩阵 $A$ 上定义 $(P_A,Q_A)$ 为其对应递增坐标序列 $a=\\{(u_i,v_i)\\}$ 的 $(P_a,Q_a)$。\n\n接下来先假设 $A_{i,j}\\in \\{0,1\\}$，考虑 $P_A$ 和 $Q_A$ 的第一行，下文暂时省略下标 $A$。\n\n注意到插入过程相当于从上到下从左往右逐个位置扫描 $A$，若扫到 $A_{i,j}=1$ 则插入 $(i,j)$。\n\n考虑 $P_{1,1}$ 的变化，不难发现它刚开始为 $v_1$，之后每次遇到一个 $<P_{1,1}$ 的 $v_i$ 都会更新 $P_{1,1}:=v_i$，在矩阵上则形如从最高最左的 $1$ 开始往左下的一条链。而 $P_{1,2}$ 的变化也是类似的，相当于删掉 $P_{1,1}$ 对应链上的元素后递归下去。$P_{1,>2}$ 也都是类似的：\n\n![](../post-images/1743483065512.jpg)\n\n上图中红色、蓝色和绿色分别为 $P_{1,1}$、$P_{1,2}$ 和 $P_{1,3}$ 对应的链。\n\n不妨按照时间顺序定义链的头尾，那么 $P_{1,*}$ 就是其对应链链尾 $(i,j)$ 的列坐标 $j$。\n\n接下来考虑 $Q$ 的第一行，显然 $Q_{1,*}$ 就是 $P_{1,*}$ 对应链链头 $(i,j)$ 的行坐标 $i$。\n\n![](../post-images/1743483641110.jpg)\n\n不难发现转置后每条链都会恰好反向，即链头和链尾交换，且每个点的行列坐标互换了。所以转置后 $P_{1,*}$ 和 $Q_{1,*}$ 恰好交换了。\n\n接下来考虑 $P_{2,*}$ 和 $Q_{2,*}$（第二行），我们首先考察哪些元素会往 $P_{\\ge 2,*}$ 这个子表中插入，然后试着套用第一行的思路。\n\n不难发现，往 $P_{\\ge 2,*}$ 插入的元素一定是被从第一行顶下来的，而每条长 $k$ 的链的前 $k-1$ 个元素都会被后一个元素顶下来。具体的，对于一条链 $(u_1,v_1),(u_2,v_2),\\dots,(u_k,v_k)$，被顶下去的元素为 $v_{[1,k-1]}$。\n\n而由于 $Q$ 中记录的是插入时的 $u_i$，所以 $v_i$ 被顶下去相当于向 $(P_{\\ge 2,*},Q_{\\ge 2,*})$ 插入 $(u_{i+1},v_i)$，那么该链对 $(P_{\\ge 2,*},Q_{\\ge 2,*})$ 的影响相当于插入了 $(u_2,v_1),(u_3,v_2),\\dots,(u_k,v_{k-1})$，在矩阵上表现为相邻两个点的“角落”：\n\n![](../post-images/1743489746338.jpg)\n\n那么设这些“角落”对应的矩阵为 $M$，显然 $(P_{\\ge 2,*},Q_{\\ge 2,*})=(P_M,Q_M)$，而 $A^T$ 对应的“角落”显然是 $M^T$，那么归纳证明即可。\n\n而存在 $A_{i,j}>1$ 的情况也是类似的，可以通过将 $u_i$ 重标号转化为 $A_{i,j}\\in\\{0,1\\}$ 的情况。\n\n#### Part 3.1 对称矩阵和对合排列\n\n当 $A_{i,j}=A_{j,i}$ 即 $A=A^T$ 时，我们称 $A$ 为对称矩阵。\n\n那么显然 $P_A=Q_A$，故对称矩阵和半标准杨表构成双射。\n\n接下来还有一个不那么显然的结论：\n\n- $A$ 对应的每条链 $(u_1,v_1),(u_2,v_2),\\dots,(u_k,v_k)$ 都是回文的；\n\n证明较为简单。\n\n而对合排列就是满足 $p_{p_i}=i$ 的排列，即置换环大小 $\\in \\{1,2\\}$。显然对合排列对应的矩阵 $A$ 满足 $A=A^T$ 且其每行每列都只有一个 $1$。故对合排列和标准杨表构成双射。\n\n那么这就导出了标准杨表个数公式：\n\n##### 定理 3.1.1（标准杨表个数公式）\n\n> 定义大小为 $n$ 的标准杨表个数为 $f_n$，则有：\n> $$\n> f_n=\\begin{cases}1&n=1\\\\2&n=2\\\\f_{n-1}+(n-1)f_{n-2}&n\\ge 3\\\\\\end{cases}\n> $$\n\n这个式子相当于枚举 $n$ 是自环还是和别人配对。\n\n### Part 4 杨表与 LIS\n\nLIS：最长上升子序列\n\nLDS：最长下降子序列\n\n本节仅讨论排列（元素不重复的序列）的情况，对于元素有重复的序列，可以通过重标号使得其元素不重复。\n\n##### 定理 4.1\n\n> 一个排列 $p$ 的 LIS 长度为 $P_p$ 第一行的长度。\n\n证明考虑 $P_p$ 第一行的变化相当于经典的使用二分 $O(n\\log n)$ 求 LIS 的过程。\n\n值得注意的是，$P_p$ 的第一行并不一定就是 $p$ 的 LIS 本身，故不能用杨表做 LIS 划分之类的问题。\n\n##### 引理 4.2\n\n> 对于一个杨表 $S$ 和两个元素 $x,y$，有 $x\\rightarrow (S\\leftarrow y)=(x\\rightarrow S)\\leftarrow y$。\n>\n> 定义杨表 $S$ 的转置 $S^T$ 为交换 $S$ 的行列后得到的杨表，则 $S\\leftarrow x=\\left(x\\rightarrow S^T\\right)^T$，列插入同理。\n\n第一点证明是简单的，考虑插入过程中顶替掉的格子形成的路径，显然行插入的路径是斜向左下的，而列插入的路径是斜向右上的，然后分讨一下 $x,y$ 间大小关系即可。\n\n而第二点是显然的。\n\n由此引理，我们得以导出 $P_p$ 和 $P_{p^R}$ 间的关系。\n\n##### 定理 4.2\n\n> 对于一个排列 $p$，定义 $p^R$ 为其头尾翻转形成的排列（$p^R_i=p_{n-i+1}$）。\n>\n> 那么有 $P_p=P_{p_R}^T$。\n>\n> 注意该定理对 $Q$ 不成立。\n\n![](../post-images/1743492871709.jpg)\n\n证明考虑归纳，$|p|=2$ 时显然成立。\n\n对于 $n=|p|>2$ 的情况，有：\n$$\n\\begin{aligned}\nP_p&=P_{p_{[1,n-1]}}\\leftarrow p_n\\\\\n&=P^T_{p_{[1,n-1]}^R}\\leftarrow p_n\\\\\n&=\\left(p_1\\rightarrow P^T_{p_{[2,n-1]}^R}\\right)\\leftarrow p_n\\\\\n&=p_1\\rightarrow \\left(P^T_{p_{[2,n-1]}^R}\\leftarrow p_n\\right)\\\\\n&=p_1\\rightarrow \\left(P_{p_{[2,n-1]}}\\leftarrow p_n\\right)\\\\\n&=p_1\\rightarrow P_{p_{[2,n]}}\\\\\n&=p_1\\rightarrow P^T_{p^R_{[2,n]}}\\\\\n&=P^T_{p^R}\\\\\n\\end{aligned}\n$$\n故成立。\n\n该定理还有一个拓展：\n\n##### 定理 4.2.1（$O(n\\sqrt n\\log n)$ 求杨表）\n\n> 定义 $p^-_i=-p_i$，$P_p=-P_{p^-}^T$。\n\n证明方法类似。\n\n根据这个定理，我们得以在线地快速求出一个排列 $p$ 的 $(P,Q)$。具体的，对于一个大小为 $n$ 的杨表中的格子 $(x,y)$，一定有 $x\\le \\sqrt n$ 或 $y\\le \\sqrt n$，故仅需求出其前 $\\sqrt n$ 行和前 $\\sqrt n$ 列再并起来即可。\n\n前 $\\sqrt n$ 行是简单的，暴力插入即可。而对于前 $\\sqrt n$ 列，应用该定理后相当于插入 $-p_i$ 得到的杨表的前 $\\sqrt  n$ 行，故也可以维护。\n\n那么总复杂度是 $O(n\\sqrt n\\log n)$ 的。\n\n##### 定理 4.3\n\n> 一个排列 $p$ 的 LDS 长度为 $P_p$ 第一列的高度。\n\n根据定理 4.2，$p^R$ 的 LIS 长度为 $P_p$ 第一列的高度，而显然 $p^R$ 的 LIS 是由 $p$ 的 LDS 翻转得到的，故成立。\n\n#### Part 4.1 最长 k-LIS 子序列\n\n##### 定义 4.1.1（k-LIS 序列和 k-LDS 序列）\n\n> 定义一个序列为 k-LIS 序列当且仅当其 LIS 长度不超过 $k$。\n>\n> 同理定义 k-LDS 序列。\n\n显然最长 1-LIS 就是原序列的 LDS，即杨表第一列的高度。\n\n这引导我们作出猜想：\n\n##### 定理 4.1.1（最长 k-LIS 子序列长度）\n\n> 对于排列 $p$：\n>\n> - 最长 k-LIS 子序列长度为 $P_p$ 前 $k$ 列的高度和；\n>\n> - 最长 k-LDS 子序列长度为 $P_p$ 前 $k$ 行的长度和；\n\n懒得证了，感性理解一下，去看论文吧。\n\n例题：[P3774 [CTSC2017] 最长上升子序列](https://www.luogu.com.cn/problem/P3774)\n\n### Part 5 钩子公式\n\n接下来回答一个一直悬而未决的问题：\n\n> 对于一个大小为 $n$ 的杨图 $\\lambda$，其有多少个对应的标准杨表？\n\n##### 定理 5.1（钩子公式）\n\n> 对于一个杨图 $S$，定义 $h_{(i,j)}$ 为 $S_{i,j}$ 右方的格子的个数加上其下方的格子的个数再 $+1$ 的值（$(i,>j)+(>i,j)+(i,j)$，形如一个钩子），则该 $S$ 对应的标准杨表共有 $\\frac{n!}{\\prod h_{(i,j)}}$ 种。\n\n##### 证明 5.1（钩子公式）\n\n考虑归纳。\n\n$n=1$ 时显然成立，现在假设对于 $[1,n-1]$ 均成立，来证明对于 $n$ 成立。\n\n显然 $n$ 填入的位置一定是“边角”，并且一个杨图挖掉边角后还是杨图。\n\n那么设 $X_i=(a_i,b_i)$ 为 $\\lambda$ 从上往下第 $i$ 个边角的位置，$\\mu^{(i)}$ 为 $\\lambda$ 挖掉 $X_i$ 后得到的 $n-1$ 的杨图，则我们要证明：（$m$ 是边角的个数）\n$$\n\\frac{n!}{\\prod h^\\lambda_{(i,j)}}=\\sum\\limits_{i=1}^m\\frac{(n-1)!}{\\prod h^{\\mu^{(i)}}_{(i,j)}}\n$$\n也即：\n$$\n\\sum\\limits_{i=1}^m\\frac{\\prod h^\\lambda_{(i,j)}}{\\prod h^{\\mu^{(i)}}_{(i,j)}}=n\n$$\n接下来，我们只考虑 $\\lambda$ 的杨图。定义 $ct_{(i,j)}=i-j$，并且对于 $i\\in [0,m]$ 定义 $Y_i=(a_i,b_{i+1})$，并定义 $a_0=b_0=b_{m+1}=0$，$X_0=(0,0)$：\n\n![](../post-images/1743338462828.png)\n\n再令 $D_{(i,j)}$ 和 $R_{(i,j)}$ 为从 $(i,j)$ 开始不停往下走和往右走最终到达的格子，那么有 $h_{(i,j)}=ct_{D_{(i,j)}}-ct_{R_{(i,j)}}+1$。\n\n令 $x_{i}=ct_{X_i},y_i=ct_{Y_i}$，则有：\n$$\n\\sum\\limits_{i=0}^m x_i=\\sum\\limits_{i=0}^m y_i\n$$\n这是因为 $x_i=a_i-b_i,y_i=a_i-b_{i+1}$，$b$ 错位抵消后仅剩 $b_{m+1}-b_0=0$。\n\n接下来考虑证明：\n$$\n\\sum\\limits_{i=1}^m\\frac{\\prod h^\\lambda_{(i,j)}}{\\prod h^{\\mu^{(i)}}_{(i,j)}}=-\\sum\\limits_{i=1}^m\\frac{\\prod\\limits_{j=0}^m(x_i-y_j)}{\\prod\\limits_{j=1,j\\not=i}^m(x_i-x_j)}\n$$\n\n<details><summary>证明</summary><p>\n\n> 考虑添加边角 $X_i$ 的影响 $\\frac{\\prod h^\\lambda_{(i,j)}}{\\prod h^{\\mu^{(i)}}_{(i,j)}}$，显然只会影响到 $(a_i,*)$ 和 $(b_i,*)$。\n>\n> 对于同一列的影响，实际上只有 $L_j=(a_j,b_i)$（$1\\le j<i$）和 $M_j=(a_j+1,b_i)$（$0\\le j<i$）这些格子对这个分数有贡献：（其它的都会错位相消）\n>\n> ![](../post-images/1743405435001.png)\n>\n> 更具体的，只有 $M_j$ 会对分子造成影响，且只有 $L_j$ 会对分母造成影响。\n>\n> 注意到：（考虑 $X_i$ 和 $Y_i$ 的位置）\n> $$\n> h^{\\lambda}_{M_j}=h^{\\lambda}_{(a_j+1,b_i)}=ct_{D_{(a_j+1,b_i)}}-ct_{R_{(a_j+1,b_i)}}+1=x_i-y_j\\\\\n> h^{\\mu^{(i)}}_{L_j}=h^{\\lambda}_{(a_j,b_i)}-1=ct_{D_{(a_j,b_i)}}-ct_{R_{(a_j,b_i)}}=x_i-x_j\\\\\n> $$\n> 相似的，对于同一行的影响，有 $L_j=(a_i,b_j)$（$i< j\\le m$），$M_j=(a_i,b_{j+1}+1)$（$i\\le j\\le m$），且：\n> $$\n> h^{\\lambda}_{M_j}=y_j-x_i\\\\\n> h^{\\mu^{(i)}}_{L_j}=x_j-x_i\\\\\n> $$\n> 那么有：\n> $$\n> \\begin{aligned}\n> \\frac{\\prod h^\\lambda_{(i,j)}}{\\prod h^{\\mu^{(i)}}_{(i,j)}}&=\\frac{\\prod\\limits h^{\\lambda}_{M_j}}{\\prod h^{\\mu(i)}_{L_j}}\\\\\n> &=\\frac{\\prod\\limits_{0\\le j<i} (x_i-y_j)\\prod\\limits_{i\\le j\\le m}(y_j-x_i)}{\\prod\\limits_{1\\le j<i}(x_i-x_j)\\prod\\limits_{i<j\\le m}(x_j-x_i)}\\\\\n> &=-\\frac{\\prod\\limits_{j=0}^m(x_i-y_j)}{\\prod\\limits_{j=1,j\\not=i}^m(x_i-x_j)}\n> \\end{aligned}\n> $$\n> 证毕。\n\n</p></details>\n\n然后我们将证明：\n$$\n-\\sum\\limits_{i=1}^m\\frac{\\prod\\limits_{j=0}^m(x_i-y_j)}{\\prod\\limits_{j=1,j\\not=i}^m(x_i-x_j)}=-\\frac{1}{2}\\sum\\limits_{i=0}^m x_i^2-y_i^2\n$$\n\n<details><summary>证明</summary><p>\n\n> 注意到这个式子很像拉插，所以不妨设：（不知道怎么想到的）\n> $$\n> P(t)=-\\sum\\limits_{i=1}^m\\frac{\\prod\\limits_{j=0}^m(x_i-y_j)}{\\prod\\limits_{j=1,j\\not=i}^m(x_i-x_j)}\\prod\\limits_{j=1,j\\not=i}^m (t-x_j)\\\\\n> Q(t)=\\prod\\limits_{i=0}^m(t-y_i)\n> $$\n> 那么 $P(t)$ 是 $m-1$ 次多项式，$Q(t)$ 是 $m+1$ 次多项式，我们要求的值就是 $[t^{m-1}]P(t)$。\n>\n> 注意到 $P(t)+Q(t)$ 在 $t=x_i$（$i\\not=0$）时为 $0$，且 $x_i$ 互不相同（每斜行恰好有一个边角），且 $[t^{m+1}](P(t)+Q(t))=1$，故存在 $\\alpha$ 使得：\n> $$\n> P(t)+Q(t)=(t+\\alpha)\\prod\\limits_{i=1}^m(t-x_i)\n> $$\n> 那么：\n> $$\n> \\begin{aligned}\n> P(t)&=(t+\\alpha)\\prod\\limits_{i=1}^m(t-x_i)-\\prod\\limits_{i=0}^m(t-y_i)\\\\\n> &=\\left(\\alpha-\\sum\\limits_{i=1}^m x_i+\\sum\\limits_{i=0}^m y_i\\right)t^m+\\left(-\\alpha\\sum\\limits_{i=1}^mx_i+\\sum\\limits_{1\\le i<j\\le m}x_ix_j-\\sum\\limits_{0\\le i<j\\le m}y_iy_j\\right)t^{m-1}+\\dots\n> \\end{aligned}\n> $$\n> 根据之前的结论，有：\n> $$\n> \\sum\\limits_{i=0}^m x_i=\\sum\\limits_{i=0}^m y_i\n> $$\n> 且 $x_0=0$，那么 $\\sum\\limits_{i=0}^m y_i-\\sum\\limits_{i=1}^m x_i=0$，所以 $\\alpha=0$。\n>\n> 故 $[t^{m-1}]P(t)=\\sum\\limits_{1\\le i<j\\le m}x_ix_j-\\sum\\limits_{0\\le i<j\\le m}y_iy_j=\\sum\\limits_{0\\le i<j\\le m}x_ix_j-y_iy_j$。\n>\n> 继续：\n> $$\n> \\begin{aligned}\n> \\sum\\limits_{0\\le i<j\\le m}x_ix_j-y_iy_j&=\\frac{1}{2}\\left(\\left(\\sum\\limits_{i=0}^m x_i\\right)^2-\\sum\\limits_{i=0}^m x_i^2-\\left(\\sum\\limits_{i=0}^m y_i\\right)^2+\\sum\\limits_{i=0}^m y_i^2\\right)\\\\\n> &=\\frac{1}{2}\\sum\\limits_{i=0}^{m}y_i^2-x_i^2\\\\\n> &=-\\frac{1}{2}\\sum\\limits_{i=0}^{m}x_i^2-y_i^2\\\\\n> \\end{aligned}\n> $$\n> 证毕。\n\n</p></details>\n\n那么代入 $x_i=a_i-b_i$ 和 $y_i=a_i-b_{i+1}$，有：\n$$\n\\begin{aligned}\n-\\frac{1}{2}\\sum\\limits_{i=0}^{m}x_i^2-y_i^2&=-\\frac{1}{2}\\sum\\limits_{i=0}^m(a_i-b_i)^2-(a_i-b_{i+1})^2\\\\\n&=-\\frac{1}{2}\\sum\\limits_{i=0}^m a_i^2-2a_ib_i+b_i^2-a_i^2-b_{i+1}^2+2a_ib_{i+1}\\\\\n&=-\\frac{1}{2}\\sum\\limits_{i=0}^m -2a_ib_i+b_i^2+2a_ib_{i+1}-b_{i+1}^2\\\\\n&=-\\frac{1}{2}\\left(b_0^2-b_{m+1}^2+\\sum\\limits_{i=0}^m2a_i(b_{i+1}-b_i)\\right)\\\\\n&=\\sum\\limits_{i=0}^m a_ib_{i+1}-a_ib_i\n\\end{aligned}\n$$\n注意到这个实际上相当于将杨图竖着划分成很多个长方形加起来，结果就是杨图的面积，故：\n$$\nn=\\sum\\limits_{i=0}^m a_ib_{i+1}-a_ib_i\n$$\n即证毕。\n",
			"tags": [{"name":"学习笔记"},{"name":"数学"},{"name":"组合计数"}],
			"title": "杨表学习笔记",
			"link": "https://exber.qzz.io/post/%E6%9D%A8%E8%A1%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2025-04-01 10:03:55"
		},
	
		{
			"abstract": "> 给定 $n$ 个单调不降的数组，初始计数器 $sum=0$。你需要进行 $k$ 次操作，每次选择某个数组的第一个未被删除的元素 $x$，将 $sum$ 加上 $x$，然后将 $x$ 从这个数组中删去。最大化 $sum$。\n>\n> $1\\le n,k\\le 3000$，所有数组长度之和不超过 $10^6$，值域 $[0,10^8]$。\n",
			"content": "> 给定 $n$ 个单调不降的数组，初始计数器 $sum=0$。你需要进行 $k$ 次操作，每次选择某个数组的第一个未被删除的元素 $x$，将 $sum$ 加上 $x$，然后将 $x$ 从这个数组中删去。最大化 $sum$。\n>\n> $1\\le n,k\\le 3000$，所有数组长度之和不超过 $10^6$，值域 $[0,10^8]$。\n\n首先最多只有一个数组不是全选的，因为若存在两个数组 $a,b$ 不是全选，假设选择了 $a_{[1,x]}$ 和 $b_{[1,y]}$，则一定有 $a_{x+1}<b_y$，否则可以撤销 $y$ 选 $x+1$，那么由于 $a_x<a_{x+1},a_y<a_{y+1}$ 故一定有 $a_x<b_{y+1}$，所以此时撤销 $x$ 选 $y+1$ 是优的，矛盾。\n\n那么问题变成了扣掉一个物品的 01 背包，这个是经典问题，可以做到 $O(nk\\log n)$。具体的，考虑类似线段树一样分治，处理区间 $[l,r]$ 的时候先加入 $[l,mid]$ 中的物品，递归右半边；再撤销掉 $[l,mid]$ 中的物品（通过开桶记录加入前的状态实现），递归左半边。这样递归到单点的时候就求出了答案。\n\n时间复杂度是 $T(n)=O(nk)+2T(\\frac{n}{2})=O(nk\\log n)$ 的。\n",
			"tags": [{"name":"做题记录"},{"name":"贪心"},{"name":"结论"},{"name":"小技巧"}],
			"title": "CF1442D Sum 做题记录",
			"link": "https://exber.qzz.io/post/CF1442D%20Sum%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2025-02-19 16:12:28"
		},
	
		{
			"abstract": "> 有一棵 $n$ 个点的树，每个点上有一个二叉搜索树。\n>\n> 然后依次进行 $m$ 次操作：\n>\n> - `1 u v x`：在 $u\\to v$ 路径上每个点的二叉搜索树中插入元素 $x$，即 $\\forall p\\in \\{u\\to v\\}$ 执行 $\\text{insert}(rt_p,x)$：\n>\n>   ```cpp\n>   void insert(int&p,int x){\n>       if(!p) return p=x,void();\n>       if(x<p) insert(ch[p][0],x);\n>       else insert(ch[p][1],x);\n>   }\n>   ```\n>\n> - `0 u w`：在点 $u$ 上的二叉搜索树中执行 $\\text{ask}(rt_u,w)$，求其返回值：\n>\n>   ```cpp\n>   long long ask(int p,int x){\n>       if(x==p) return x;\n>       if(x<p) return ch[p][0]?ask(ch[p][0])+p:p;\n>       else return ch[p][1]?ask(ch[p][1])+p:p;\n>   }\n>   ```\n> \n> $1\\le n,m,x,w\\le 2\\times 10^5$，每次 $1$ 操作的 $x$ 互不相同。\n",
			"content": "> 有一棵 $n$ 个点的树，每个点上有一个二叉搜索树。\n>\n> 然后依次进行 $m$ 次操作：\n>\n> - `1 u v x`：在 $u\\to v$ 路径上每个点的二叉搜索树中插入元素 $x$，即 $\\forall p\\in \\{u\\to v\\}$ 执行 $\\text{insert}(rt_p,x)$：\n>\n>   ```cpp\n>   void insert(int&p,int x){\n>       if(!p) return p=x,void();\n>       if(x<p) insert(ch[p][0],x);\n>       else insert(ch[p][1],x);\n>   }\n>   ```\n>\n> - `0 u w`：在点 $u$ 上的二叉搜索树中执行 $\\text{ask}(rt_u,w)$，求其返回值：\n>\n>   ```cpp\n>   long long ask(int p,int x){\n>       if(x==p) return x;\n>       if(x<p) return ch[p][0]?ask(ch[p][0])+p:p;\n>       else return ch[p][1]?ask(ch[p][1])+p:p;\n>   }\n>   ```\n> \n> $1\\le n,m,x,w\\le 2\\times 10^5$，每次 $1$ 操作的 $x$ 互不相同。\n\n\n先考虑单点怎么做，直接维护二叉搜索树中每个点的父亲即可，一个点 $x$ 的父亲是其插入时前驱和后继中插入时间较晚的那个。\n\n接下来考虑链，一个朴素的想法是差分，问题变为维护加入/删除某次操作后二叉搜索树的形态。\n\n使用超强注意力，用二元组 $(a,b)$ 记录点 $a$ 的插入时间是 $b$，那么注意到 $a\\in [1,x]$ 的点和 $a\\in [x,m]$ 的点是独立的。具体的，对于 $a\\in [1,x]$ 的点，可以这样判断它们中哪些是 $(x,i)$ 的祖先：\n\n- 将这些点按照 $a$ 从大到小排序；\n- 令 $t=i$，依次遍历排好序后的每个点 $(a,b)$：\n  - 若 $b<t$ 则其为 $(x,i)$ 祖先，答案加上 $a$，令 $t=b$；\n  - 否则其非 $(x,i)$ 祖先；\n\n对于 $a\\in [x,m]$ 的点是一样的，将从大到小排序改为从小到大排序即可。\n\n那么问题转化为区间中 $a$ 的前缀/后缀最小值的 $b$ 的和，直接楼房重建线段树即可 $O(n\\log ^2n)$ 维护。\n\n现在考虑树，不难发现和链是基本一样的，线段树合并即可。\n\n时间复杂度 $O(n\\log ^2 n)$，代码如下：\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\n\n/*\ninsert/delete pot\nquery [l,r] premin sum or sufmin sum\n*/\nnamespace seg\n{\n\tconst int TS=30000005,inf=1e8;\n\tint cnt,ls[TS],rs[TS];\n\tint mn[TS];\n\tll sml[TS],smr[TS];\n\tinline void init(){mn[0]=inf;}\n\tll quesml(int u,int l,int r,int k) // premin(<k) sum\n\t{\n\t\tif(u==0||mn[u]>=k) return 0;\n\t\tif(l==r) return mn[u]<k?sml[u]:0;\n\t\tint mid=l+r>>1;\n\t\tif(mn[ls[u]]<k) return quesml(ls[u],l,mid,k)+sml[u]-sml[ls[u]];\n\t\telse return quesml(rs[u],mid+1,r,k);\n\t}\n\tll quesmr(int u,int l,int r,int k) // sufmin(<k) sum\n\t{\n\t\tif(u==0||mn[u]>=k) return 0;\n\t\tif(l==r) return mn[u]<k?smr[u]:0;\n\t\tint mid=l+r>>1;\n\t\tif(mn[rs[u]]<k) return smr[u]-smr[rs[u]]+quesmr(rs[u],mid+1,r,k);\n\t\telse return quesmr(ls[u],l,mid,k);\n\t}\n\tinline void upda(int u,int l,int r)\n\t{\n\t\tint mid=l+r>>1;\n\t\tint sl=ls[u],sr=rs[u];\n\t\tmn[u]=min(mn[sl],mn[sr]);\n\t\tsml[u]=sml[sl]+quesml(sr,mid+1,r,mn[sl]);\n\t\tsmr[u]=quesmr(sl,l,mid,mn[sr])+smr[sr];\n\t}\n\tvoid updp(int &u,int l,int r,int p,int x,int val)\n\t{\n\t\tif(u==0) u=++cnt;\n\t\tif(l==r) return mn[u]=x,sml[u]=smr[u]=val,void();\n\t\tint mid=l+r>>1;\n\t\tif(p<=mid) updp(ls[u],l,mid,p,x,val);\n\t\telse updp(rs[u],mid+1,r,p,x,val);\n\t\tupda(u,l,r);\n\t}\n\tint merge(int x,int y,int l,int r)\n\t{\n\t\tif(x==0||y==0) return x+y;\n\t\tif(l==r)\n\t\t{\n\t\t\tmn[x]=min(mn[x],mn[y]);\n\t\t\tsml[x]=max(sml[x],sml[y]);\n\t\t\tsmr[x]=sml[x];\n\t\t\treturn x;\n\t\t}\n\t\tint mid=l+r>>1;\n\t\tls[x]=merge(ls[x],ls[y],l,mid);\n\t\trs[x]=merge(rs[x],rs[y],mid+1,r);\n\t\tupda(x,l,r);\n\t\treturn x;\n\t}\n\tvoid quesmllr(int u,int l,int r,int L,int R,int &k,ll &res)\n\t{\n\t\tif(u==0||l>R||r<L) return;\n\t\tif(l>=L&&r<=R)\n\t\t{\n\t\t\tres+=quesml(u,l,r,k);\n\t\t\tk=min(k,mn[u]);\n\t\t\treturn;\n\t\t}\n\t\tint mid=l+r>>1;\n\t\tif(L<=mid) quesmllr(ls[u],l,mid,L,R,k,res);\n\t\tif(R>=mid+1) quesmllr(rs[u],mid+1,r,L,R,k,res);\n\t}\n\tvoid quesmrlr(int u,int l,int r,int L,int R,int &k,ll &res)\n\t{\n\t\tif(u==0||l>R||r<L) return;\n\t\tif(l>=L&&r<=R)\n\t\t{\n\t\t\tres+=quesmr(u,l,r,k);\n\t\t\tk=min(k,mn[u]);\n\t\t\treturn;\n\t\t}\n\t\tint mid=l+r>>1;\n\t\tif(R>=mid+1) quesmrlr(rs[u],mid+1,r,L,R,k,res);\n\t\tif(L<=mid) quesmrlr(ls[u],l,mid,L,R,k,res);\n\t}\n}\n\nconst int S=200005,BS=25;\n\nint n,m;\nvector<int> g[S];\nint dep[S],fat[S][BS];\nvector<pair<int,int> > vec[S];\nint tot,b[S],val[S],rt[S];\nll ans[S];\n\nvoid dfs(int u,int fa)\n{\n\tdep[u]=dep[fa]+1;\n\tfat[u][0]=fa;\n\tfor(int i=1;i<=BS-3;i++) fat[u][i]=fat[fat[u][i-1]][i-1];\n\tfor(int v:g[u]) if(v!=fa) dfs(v,u);\n}\n\ninline int quelca(int x,int y)\n{\n\tif(dep[x]<dep[y]) swap(x,y);\n\tfor(int i=BS-3;i>=0;i--) if(dep[fat[x][i]]>=dep[y]) x=fat[x][i];\n\tif(x==y) return x;\n\tfor(int i=BS-3;i>=0;i--)\n\t{\n\t\tif(fat[x][i]!=fat[y][i])\n\t\t{\n\t\t\tx=fat[x][i];\n\t\t\ty=fat[y][i];\n\t\t}\n\t}\n\treturn fat[x][0];\n}\n\nvoid dfs2(int u,int fa)\n{\n\tfor(int v:g[u])\n\t{\n\t\tif(v==fa) continue;\n\t\tdfs2(v,u);\n\t\trt[u]=seg::merge(rt[u],rt[v],1,tot);\n\t}\n\tfor(auto t:vec[u])\n\t{\n\t\tint x=t.first,y=t.second;\n\t\tif(y==-1)\n\t\t{\n\t\t\tint k=x;\n\t\t\tseg::quesmrlr(rt[u],1,tot,1,val[x],k,ans[x]);\n\t\t\tk=x;\n\t\t\tseg::quesmllr(rt[u],1,tot,val[x],tot,k,ans[x]);\n\t\t\tk=x;\n\t\t\tll del=0;\n\t\t\tseg::quesmllr(rt[u],1,tot,val[x],val[x],k,del);\n\t\t\tans[x]-=del;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(x==1) seg::updp(rt[u],1,tot,val[y],y,b[val[y]]);\n\t\t\telse seg::updp(rt[u],1,tot,val[y],seg::inf,0);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tios::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tcin>>n>>m;\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tdfs(1,0);\n\tvector<int> queid;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint op,x,y;\n\t\tcin>>op>>x>>y;\n\t\tif(op==1)\n\t\t{\n\t\t\tint w;\n\t\t\tcin>>w;\n\t\t\tint l=quelca(x,y);\n\t\t\tvec[x].emplace_back(1,i);\n\t\t\tvec[y].emplace_back(1,i);\n\t\t\tvec[fat[l][0]].emplace_back(-1,i);\n\t\t\tb[++tot]=val[i]=w;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvec[x].emplace_back(i,-1);\n\t\t\tb[++tot]=val[i]=y;\n\t\t\tqueid.push_back(i);\n\t\t}\n\t}\n\tsort(b+1,b+tot+1);\n\ttot=unique(b+1,b+tot+1)-b-1;\n\tfor(int i=1;i<=m;i++) val[i]=lower_bound(b+1,b+tot+1,val[i])-b;\n\tseg::init();\n\tdfs2(1,0);\n\tfor(int x:queid) cout<<ans[x]<<'\\n';\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"结论"},{"name":"数据结构"}],
			"title": "【PR15】二叉搜索树 做题记录",
			"link": "https://exber.qzz.io/post/%E3%80%90PR15%E3%80%91%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2025-02-17 20:34:59"
		},
	
		{
			"abstract": "> 有 $n$ 个人在一个长 $L$ 的环上，第 $i$ 个人位于坐标 $a_i$ 处。你要选择 $k$ 个关键点，最小化每个人到最近的关键点的距离的和。输出方案。\n>\n> $1\\le k\\le n\\le 2\\times 10^5$，$1\\le L\\le 10^{12}$。\n",
			"content": "> 有 $n$ 个人在一个长 $L$ 的环上，第 $i$ 个人位于坐标 $a_i$ 处。你要选择 $k$ 个关键点，最小化每个人到最近的关键点的距离的和。输出方案。\n>\n> $1\\le k\\le n\\le 2\\times 10^5$，$1\\le L\\le 10^{12}$。\n\n\n首先注意到最近关键点相同的人一定位于区间内，故问题可以转化为将人划分为若干个区间，区间 $[l,r]$ 代价为 $\\sum\\limits_{l\\le i\\le r} \\left|a_i-a_{\\lfloor\\frac{l+r}{2}\\rfloor}\\right|$，最小化代价和。\n\n考虑链的情况怎么做，由于 $[l,r]$ 和 $[l+1,r-1]$ 的中位数相同，故区间代价 $w_{l,r}$ 满足四边形不等式。\n\n那么这是蒙日矩阵最短路问题，直接 wqs 二分 + 二分队列优化转移即可，复杂度 $O(n\\log V\\log n)$。\n\n接下来发扬人类智慧，先随便找个位置（假定为 $1$ 前）将环断开，求出此时的最优解的分界点 $a$。那么对于环上的最优解 $b$，一定有 $b_i$ 在区间 $[a_{i-1},a_i]$ 中：\n\n![](../post-images/1738931906708.png)\n\n证明考虑若不是这种情况则一定 有某段红色区间包含两个蓝色端点 且 有某段蓝色区间包含两个红色端点，那么根据相交优于包含，我们可以调整这两处（绿色线），使得这两个方案的代价之和减小（变为紫色和棕色线）：\n\n![](../post-images/1738932268343.png)\n\n由于此时某条线仍然是从 $1$ 处断开的方案，故要么 $a$ 不是从 $1$ 处断开的最优方案，要么 $b$ 不是环上的最优方案，矛盾。\n\n根据这个性质，对于某个 $x\\in [1,a_1]$，求出从 $x+1$ 处断开的最优方案（起始点在 $x$ 的最优方案）$c_x$，则一定有 $c_{[1,x-1],i}\\in [a_{i-1},c_{x,i}]$ 且 $c_{[x+1,a_1],i}\\in[c_{x,i},a_{i}]$：\n\n![](../post-images/1738933032705.png)\n\n那么考虑分治，每次求出 $mid$ 为起始点的最小方案，往两边递归。求最小方案使用分治优化转移，这样每一层都会遍历整个环，复杂度 $O(n\\log^2 n)$。\n\n但是还有一个问题，每一层可能会多一些点。具体的，注意到每次求一个起始点的最小方案至少是 $O(k)$ 的，而若选择的区间长度为 $l$ 则分治底层要跑 $l$ 次，复杂度至少是 $O(lk)$。所以还需要找到最短的区间进行分治，这样底层复杂度就是 $O(\\frac{n}{k}\\times k)=O(n)$ 的，正确。\n\n总时间复杂度 $O(n\\log V\\log n+n\\log ^2n)$，代码如下：\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int S=200005;\nconst ll inf=1e18;\n\nint n,k;\nll L,a[S*2],sm[S*2];\nll tmp[S];\nll ans;\nvector<int> res;\n\ninline ll getsm(int l,int r){return sm[r]-sm[l-1];}\n\ninline ll calc(int l,int r)\n{\n\tif(l>r) r+=n;\n\tint m=l+r>>1;\n\t// printf(\"[%d %d %d] %lld %lld %lld\\n\",l,m,r,a[m],getsm(l,m),getsm(m+1,r));\n\treturn a[m]*(m-l+1)-getsm(l,m)+\n\t\t   getsm(m+1,r)-a[m]*(r-m);\n}\n\nnamespace wqs\n{\n\tll f[S];\n\tint ctl[S],ctr[S];\n\tint hed,til,q[S],ql[S],qr[S];\n\tinline bool cmp(int i1,int i2,int j,bool sml) // i1<i2\n\t{\n\t\tll x1=f[i1]+calc(i1+1,j);\n\t\tll x2=f[i2]+calc(i2+1,j);\n\t\tif(x1!=x2) return x1<x2;\n\t\tif(sml) return ctl[i1]<ctl[i2];\n\t\telse return ctr[i1]>ctr[i2];\n\t}\n\tvoid get(ll k,bool sml)\n\t{\n\t\tfor(int i=1;i<=n;i++) f[i]=inf;\n\t\tif(sml) for(int i=1;i<=n;i++) ctl[i]=1e8;\n\t\telse for(int i=1;i<=n;i++) ctr[i]=-1e8;\n\t\tf[0]=0;\n\t\t(sml?ctl:ctr)[0]=0;\n\t\thed=1,til=0;\n\t\tq[++til]=0,ql[til]=1,qr[til]=n;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\twhile(qr[hed]<i) hed++;\n\t\t\tint j=q[hed];\n\t\t\tf[i]=f[j]+calc(j+1,i)-k;\n\t\t\t// printf(\"%d: %d\\n\",i,j);\n\t\t\t(sml?ctl:ctr)[i]=(sml?ctl:ctr)[j]+1;\n\t\t\tif(qr[hed]==i) hed++;\n\t\t\telse ql[hed]=i+1;\n\t\t\twhile(hed<=til&&cmp(i,q[til],ql[til],sml)) til--;\n\t\t\tif(hed>til) q[++til]=i,ql[til]=i+1,qr[til]=n;\n\t\t\telse\n\t\t\t{\n\t\t\t\tint lb=ql[til],rb=qr[til],res=rb;\n\t\t\t\twhile(lb<=rb)\n\t\t\t\t{\n\t\t\t\t\tint mid=lb+rb>>1;\n\t\t\t\t\tif(!cmp(i,q[til],mid,sml)) res=mid,lb=mid+1;\n\t\t\t\t\telse rb=mid-1;\n\t\t\t\t}\n\t\t\t\tint rr=qr[til];\n\t\t\t\tqr[til]=res;\n\t\t\t\tif(res<n) q[++til]=i,ql[til]=res+1,qr[til]=n;\n\t\t\t}\n\t\t}\n\t}\n\tinline vector<int> slove()\n\t{\n\t\tll lb=-inf,rb=0,res=0;\n\t\twhile(lb<=rb)\n\t\t{\n\t\t\tll mid=lb+rb>>1;\n\t\t\tget(mid,false);\n\t\t\tif(ctr[n]>=k) res=mid,rb=mid-1;\n\t\t\telse lb=mid+1;\n\t\t}\n\t\tget(res,true);\n\t\tget(res,false);\n\t\tvector<int> vec;\n\t\tvec.push_back(n);\n\t\tfor(int i=n-1,lst=n,tk=k-1;i>=1;i--)\n\t\t{\n\t\t\t// printf(\"%lld %lld %d [%d %d]\\n\",\n\t\t\t\t// f[i]+calc(i+1,lst)-res,f[lst],tk,ctl[i],ctr[i]);\n\t\t\tif(f[i]+calc(i+1,lst)-res==f[lst]&&ctl[i]<=tk&&tk<=ctr[i])\n\t\t\t{\n\t\t\t\t// printf(\">> %d\\n\",i);\n\t\t\t\tvec.push_back(i);\n\t\t\t\tlst=i;\n\t\t\t\ttk--;\n\t\t\t}\n\t\t}\n\t\treverse(vec.begin(),vec.end());\n\t\treturn vec;\n\t}\n}\n\nnamespace slove\n{\n\tll f[S];\n\tint lst[S*2],idx[S];\n\tvoid get(int l,int r,int kl,int kr)\n\t{\n\t\tif(l>r) return;\n\t\tint mid=l+r>>1,p=kl;\n\t\tf[mid]=inf;\n\t\tfor(int i=kl;i<=kr;i++)\n\t\t{\n\t\t\tll pre=f[i]+calc(i+1,mid);\n\t\t\tif(pre<f[mid]) f[mid]=pre,p=i;\n\t\t}\n\t\tlst[mid]=p;\n\t\tif(l==r) return;\n\t\tget(l,mid-1,kl,p),get(mid+1,r,p,kr);\n\t}\n\tvoid slove(vector<pair<int,int> > &seq)\n\t{\n\t\tint l0=seq[0].first,r0=seq[0].second;\n\t\tif(l0>r0) return;\n\t\t// for(auto x:seq) printf(\"[%d %d] \",x.first,x.second);\n\t\t// printf(\"\\n\");\n\t\tint mid=l0+r0>>1;\n\t\tf[mid]=0;\n\t\tfor(int i=1;i<k;i++)\n\t\t{\n\t\t\tint l,r;\n\t\t\tif(i==1) l=r=mid;\n\t\t\telse l=seq[i-1].first,r=seq[i-1].second;\n\t\t\tint pl=seq[i].first,pr=seq[i].second;\n\t\t\tif(r==pl)\n\t\t\t{\n\t\t\t\tget(pl+1,pr,l,r);\n\t\t\t\tf[pl]=inf;\n\t\t\t\tfor(int j=l;j<=r-1;j++)\n\t\t\t\t{\n\t\t\t\t\tll pre=f[j]+calc(j+1,pl);\n\t\t\t\t\tif(pre<f[pl]) f[pl]=pre,lst[n+pl]=j;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse get(pl,pr,l,r);\n\t\t}\n\t\tfor(int i=k-1;i>=1;i--)\n\t\t{\n\t\t\tint pl=seq[i].first,pr=seq[i].second;\n\t\t\tfor(int j=pl;j<=pr;j++) idx[j]=i+1;\n\t\t}\n\t\tidx[mid]=1;\n\t\tll premn=inf;\n\t\tint p=0;\n\t\tfor(int i=seq[k-1].first;i<=seq[k-1].second;i++)\n\t\t{\n\t\t\tll pre=f[i]+calc(i+1,mid);\n\t\t\tif(pre<premn) premn=pre,p=i;\n\t\t}\n\t\t// printf(\"%lld\\n\",premn);\n\t\tvector<int> vec;\n\t\tint tk=k;\n\t\tvec.push_back(p);\n\t\twhile(p!=mid)\n\t\t{\n\t\t\tif(idx[p]!=tk) p=lst[n+p];\n\t\t\telse p=lst[p];\n\t\t\ttk--;\n\t\t\tvec.push_back(p);\n\t\t\t// printf(\">> %d\\n\",p);\n\t\t}\n\t\treverse(vec.begin(),vec.end());\n\t\t// printf(\"]]]] \");\n\t\t// for(int x:vec) printf(\"%d \",x);\n\t\t// printf(\"\\n\");\n\t\tif(premn<ans)\n\t\t{\n\t\t\tans=premn;\n\t\t\tres=vec;\n\t\t}\n\t\tif(l0==r0) return;\n\t\tvector<pair<int,int> > s1,s2;\n\t\ts1.emplace_back(l0,mid-1);\n\t\ts2.emplace_back(mid+1,r0);\n\t\tfor(int i=1;i<k;i++)\n\t\t{\n\t\t\tint l=seq[i].first,r=seq[i].second,m=vec[i];\n\t\t\ts1.emplace_back(l,m);\n\t\t\ts2.emplace_back(m,r);\n\t\t}\n\t\tslove(s1),slove(s2);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d%lld\",&n,&k,&L);\n\tfor(int i=1;i<=n;i++) scanf(\"%lld\",&a[i]),a[i+n]=L+a[i];\n\tfor(int i=1;i<=n*2;i++) sm[i]=sm[i-1]+a[i];\n\tif(k==1)\n\t{\n\t\tll ans=inf,res=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tll pre=calc(i,i+n-1);\n\t\t\tif(pre<ans) ans=pre,res=a[i+i+n-1>>1];\n\t\t}\n\t\tif(res>=L) res-=L;\n\t\tprintf(\"%lld\\n%lld\\n\",ans,res);\n\t\treturn 0;\n\t}\n\tvector<int> pot=wqs::slove();\n\t// rotate\n\tint mnd=n,mnp=0;\n\tfor(int i=0;i<k;i++)\n\t{\n\t\tint pre=(pot[(i+1)%k]-pot[i]+n)%n;\n\t\tif(pre<mnd) mnd=pre,mnp=i;\n\t}\n\t// for(int x:pot) printf(\"%d \",x);\n\t// printf(\"\\n\");\n\t// printf(\">> %d\\n\",mnd);\n\tint beg=pot[mnp]+1;\n\tfor(int i=beg;i<=n;i++) tmp[i-beg+1]=a[i];\n\tfor(int i=1;i<beg;i++) tmp[n-beg+1+i]=L+a[i];\n\tfor(int i=1;i<=n;i++) a[i]=tmp[i],a[i+n]=L+a[i];\n\tfor(int i=1;i<=n*2;i++) sm[i]=sm[i-1]+a[i];\n\tfor(int i=0;i<k;i++) pot[i]=(pot[i]-beg+1-1+n)%n+1;\n\tsort(pot.begin(),pot.end());\n\t// for(int i=1;i<=n;i++) printf(\"%lld \",a[i]);\n\t// printf(\"\\n\");\n\t// for(int x:pot) printf(\"%d \",x);\n\t// printf(\"\\n\");\n\t// printf(\"%lld\\n\",calc(1,3)+calc(4,5));\n\tvector<pair<int,int> > seq;\n\tfor(int i=0,lst=1;i<k;i++)\n\t{\n\t\tseq.emplace_back(lst,pot[i]);\n\t\tlst=pot[i];\n\t}\n\tpot=wqs::slove();\n\tans=0;\n\tfor(int i=0,lst=0;i<k;i++) ans+=calc(lst+1,pot[i]),lst=pot[i];\n\tres=pot;\n\t// printf(\"pot0: %d\\n\",pot[0]);\n\t// for(int x:pot) printf(\"%d \",x);\n\t// printf(\"\\n\");\n\t// if(pot[0]>n/k) printf(\"ERR\");\n\t// if(n==200000&&L==1000000000000ll) return 0;\n\tslove::slove(seq);\n\tprintf(\"%lld\\n\",ans);\n\tvector<ll> tmp;\n\tfor(int i=0;i<k;i++)\n\t{\n\t\tint lb=res[(i-1+k)%k]+1,rb=res[i];\n\t\tif(lb>rb) rb+=n;\n\t\ttmp.push_back(a[lb+rb>>1]%L);\n\t}\n\tsort(tmp.begin(),tmp.end());\n\tfor(ll x:tmp) printf(\"%lld \",x);\n\tprintf(\"\\n\");\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"结论"}],
			"title": "QOJ2211 IOI Problem Revised 做题记录",
			"link": "https://exber.qzz.io/post/QOJ2211%20IOI%20Problem%20Revised%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2025-02-07 20:38:21"
		},
	
		{
			"abstract": "> 定义一个长 $n$ 的正整数序列是好的，当且仅当对于每一个出现过的 $k$（$k>1$），其最后一次出现前 $k-1$ 出现过。\n>\n> 给定 $n$，对于每个 $i\\in[1,n]$ 求所有好序列中 $i$ 的出现次数和，对 $998244353$ 取模。\n>\n> $1\\le n\\le 5000$。\n",
			"content": "> 定义一个长 $n$ 的正整数序列是好的，当且仅当对于每一个出现过的 $k$（$k>1$），其最后一次出现前 $k-1$ 出现过。\n>\n> 给定 $n$，对于每个 $i\\in[1,n]$ 求所有好序列中 $i$ 的出现次数和，对 $998244353$ 取模。\n>\n> $1\\le n\\le 5000$。\n\n\n首先显然好序列的值域是从 $1$ 开始的某个前缀。\n\n不知道怎么想到的，存在好序列到 $n$ 的排列的类似反链和最小链覆盖的双射：（题解说是打表发现答案总和是 $n!\\times n$）\n\n- 序列 $a$ 到排列 $p$：从 $1$ 开始遍历每个值，将其在 $a$ 中的出现位置从后往前加入排列 $p$ 中；\n- 排列 $p$ 到序列 $a$：$a_{p_i}=1+\\sum\\limits_{j=1}^{i-1}[p_j<p_{j+1}]$；\n\n那么对于每个数 $i$，$a_j=i$ 的方案数就是 $f_{i,j-1}\\times \\binom{n}{j}\\times (n-j)!$，其中 $f_{i,j}$ 为长 $i$ 的有 $j$ 个 $a_{k}<a_{k+1}$ 的位置的排列个数，这个可以 $O(n^2)$ 递推出来（考虑插入 $i+1$ 的影响）。\n\n总时间复杂度 $O(n^2)$。\n",
			"tags": [{"name":"做题记录"},{"name":"结论"},{"name":"组合计数"}],
			"title": "CF1349F1 Slime and Sequences (Easy Version)",
			"link": "https://exber.qzz.io/post/CF1349F1%20Slime%20and%20Sequences%20%28Easy%20Version%29",
			"date": "2025-01-08 11:41:47"
		},
	
		{
			"abstract": "> 给定一个长 $n$，值域 $[0,n]$ 的序列 $m$，求有多少个 $n$ 的排列 $p$，满足 $\\forall r\\le m_l$ 的 $p_{[l,r]}$ 不构成 $[l,r]$ 的排列。对 $10^9+7$ 取模。\n>\n> $1\\le n\\le 200$。\n",
			"content": "> 给定一个长 $n$，值域 $[0,n]$ 的序列 $m$，求有多少个 $n$ 的排列 $p$，满足 $\\forall r\\le m_l$ 的 $p_{[l,r]}$ 不构成 $[l,r]$ 的排列。对 $10^9+7$ 取模。\n>\n> $1\\le n\\le 200$。\n\n\n为什么有一大堆题解都没提到第二次容斥？注意力太强了。\n\n钦定 $\\sum m_l-l+1$ 个区间的一个区间子集 $S$ 使得 $\\forall [l,r]\\in S$，$p_{[l,r]}$ 构成排列，容斥系数为 $(-1)^{|S|}$。\n\n若两个区间 $[l_1,r_1]$ 和 $[l_2,r_2]$ 有交但不是包含关系，不妨假设 $l_1<l_2\\le r_1<r_2$，则 $p_{[l_2,r_1]}$ 构成排列，同理 $p_{[l_1,l_2-1]}$ 和 $p_{[r_1+1,r_2]}$ 也构成排列。并且这是双射的，若 $p_{[l_1,l_2-1]}$、$p_{[l_2,r_1]}$ 和 $p_{[r_1+1,r_2]}$ 均构成排列，则 $p_{[l_1,r_1]}$ 和 $p_{[l_2,r_2]}$ 构成排列。\n\n那么这两个区间可以拆成三个区间。\n\n所以现在 $S$ 需要满足内部区间包含或相离，套路地使用树形结构描述，每个区间对应一个节点，其儿子是被之包含的若干个极长区间。则每个点的方案数是区间内散点的数量的阶乘。\n\n问题在于容斥系数，若一个点 $[l_u,r_u]$ 有一些儿子区间是相邻的，即 $r_i=l_{i+1}-1$，则容斥系数不显然。因为我们要计算的是在 $[l_u,r_u]$ 中选若干个（假设选了 $k$ 个）满足 $r\\le m_l$ 的子区间 $[l,r]$ 使得它们不断拆开能恰好得到 $u$ 的所有儿子区间，所有这样方案的 $(-1)^k$ 的和，不妨称这些区间为原始区间。\n\n考虑继续容斥，对于每个连续段分别考虑，我们的目标是将容斥系数放到每个儿子区间上。假设当前连续段是 $[r_0+1,r_1][r_1+1,r_2][r_2+1,r_3]\\dots[r_{k-1}+1,r_k]$，显然仅需满足每个儿子区间都被某个原始区间包含，且所有原始区间的左端点 $\\in \\{r_i+1|0\\le i<k\\}$，右端点 $\\in \\{r_i|1\\le i\\le k\\}$。\n\n那么钦定 $t$ 个儿子区间不被任何原始区间包含，容斥系数为 $(-1)^t$。考虑剩下任选的方案数，不难发现，若没有任何合法的原始区间可选，则方案数为 $1$，否则方案数就是 $\\sum\\limits_{i=0}^k\\binom{k}{i}(-1)^i=0$，其中 $k$ 为可选的原始区间个数。\n\n而由于原始区间是形如 $[l,[l,m_l]]$ 这样的，故这相当于要求除去钦定的儿子区间外，剩余的儿子区间都满足 $r>m_l$，而钦定的儿子区间则每个贡献 $-1$ 的系数，这对于多个连续段的情况依然是成立的。\n\n那么考虑对于一个儿子区间 $[l,r]$，若 $r>m_l$ 则其会贡献 $-1+1=0$ 的系数（钦定是 $-1$，未被钦定则是 $1$），故 $u$ 的所有儿子区间都必须满足 $r\\le m_l$，并会带来 $-1$ 的系数。\n\n那么考虑区间 dp，设 $f_{l,r}$ 表示区间 $[l,r]$ 的子树的答案；$g_{l,r,k}$ 表示区间 $[l,r]$ 内且散点个数为 $k$ 时儿子的 $f$ 的乘积（计算了容斥系数但未计算 $k!$ 的系数），转移 $O(n^4)$ 即可。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=205;\n\n#define p 1000000007\n\nint fra[S];\nint n,a[S];\nint g[S][S][S],f[S][S];\n\ninline void add(int &x,int y)\n{\n\tx+=y;\n\tif(x>=p) x-=p;\n}\n\nint main()\n{\n\tfra[0]=1;\n\tfor(int i=1;i<=S-3;i++) fra[i]=1ll*fra[i-1]*i%p;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tif(a[1]==n) return puts(\"0\"),0;\n\tfor(int i=0;i<=n;i++) g[i+1][i][0]=1;\n\tfor(int len=1;len<=n;len++)\n\t{\n\t\tfor(int l=1;l<=n-len+1;l++)\n\t\t{\n\t\t\tint r=l+len-1;\n\t\t\tfor(int k=0;k<=len;k++)\n\t\t\t{\n\t\t\t\tfor(int x=r;x>=l+1;x--)\n\t\t\t\t\tif(r<=a[x])\n\t\t\t\t\t\tadd(g[l][r][k],\n\t\t\t\t\t\t\tp-1ll*g[l][x-1][k]*f[x][r]%p);\n\t\t\t\tif(k>0) add(g[l][r][k],g[l][r-1][k-1]);\n\t\t\t}\n\t\t\tfor(int k=0;k<=len;k++)\n\t\t\t\tadd(f[l][r],1ll*fra[k]*g[l][r][k]%p);\n\t\t\tif(r<=a[l]) add(g[l][r][0],p-f[l][r]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",f[1][n]);\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"结论"},{"name":"容斥"},{"name":"组合计数"},{"name":"DP"}],
			"title": "CF1874F Jellyfish and OEIS 做题记录",
			"link": "https://exber.qzz.io/post/CF1874F%20Jellyfish%20and%20OEIS%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2025-01-07 16:34:54"
		},
	
		{
			"abstract": "> 求所有由 $m$ 种不同字符组成，长度为 $n$ 的字符串有多少种不同的后缀数组，其中第 $i$ 种字符至多出现 $c_i$ 次。对 $10^9+7$ 取模。\n>\n> $1\\le n,m\\le 500$。\n",
			"content": "> 求所有由 $m$ 种不同字符组成，长度为 $n$ 的字符串有多少种不同的后缀数组，其中第 $i$ 种字符至多出现 $c_i$ 次。对 $10^9+7$ 取模。\n>\n> $1\\le n,m\\le 500$。\n\n\n理解能力太差，直觉太弱。\n\n考虑不等式链：\n$$\n\\begin{cases}rk_{sa_i+1}<rk_{sa_{i+1}+1}&S_{sa_i}\\le S_{sa_{i+1}}\\\\otherwise&S_{sa_i}<S_{sa_{i+1}}\\end{cases}\n$$\n所有满足不等式链的字符串的后缀数组都是 $sa$，而判断一个不等式链是否合法（有一个满足输入条件的字符串满足该不等式链）是简单的，仅需贪心：\n\n- 对于 $\\le $，尽量让其变为 $=$，实在不行再让其变为 $<$；\n\n具体的，设 $<$ 将 $sa$ 分成了 $m$ 段，第 $i$ 段长度为 $a_i$，贪心：\n\n- 从 $1$ 开始填字符，假设当前填到了字符 $j$，是第 $i$ 段，则：\n  - 若 $c_j\\ge a_i$，则 $i\\leftarrow i+1,j\\leftarrow j+1$；\n  - 否则 $a_i\\leftarrow a_i-c_j,j\\leftarrow j+1$；\n\n我们现在构建了 后缀数组 到 不等式链 的 **映射**，并且可以判断一个不等式链是否合法。\n\n但是不同的后缀数组有可能映射到相同的不等式链（$[1,2,3]$ 和 $[3,1,2]$），所以这是**映射**而不是**单射**。\n\n那么问题就变为计算**有多少个后缀数组可以映射到某一个不等式链**。\n\n但是直接去对一个不等式链计数后缀数组似乎是困难的，主要是后缀数组到不等式链的映射太奇怪了。\n\n那么考虑抛弃题目限制，对于一个不等式链 $p$，构建一个满足其限制的 字符集大小最小的 **后缀排序后的字符串**（应用 $sa$ 对应的变换之后的）。显然是 $a_1$ 个 $1$，$a_2$ 个 $2$ 这样依次拼接形成的字符串，不妨记其为 $str(p)$，不难发现这是一个 **单射**。\n\n那么**对于满足后缀排序后等于 $str(p)$ 的不同的原字符串，它们对应的后缀数组一定不同**。\n\n> 反证法，若两个不同字符串对应的后缀数组相同，则对应的不等式链也相同，故 $str(p)$ 也相同。而又由于后缀数组相同，故 $sa$ 的逆变换相同，原来的字符串相同，矛盾.\n\n所以 $p$ 对应的后缀数组的个数 不多于 $str(p)$ 对应的原字符串的个数 $h(p)$。而显然有 $h(p)=\\frac{n!}{\\prod\\limits_i a_i!}$。\n\n考虑 $h(p)$ 算多了什么，即计算这些原字符串对应的后缀数组有多少个对应的不等式链不是 $p$。那么有可能某些 $<$ 变为了 $\\le $ 或者某些 $\\le $ 变为了 $<$。注意到 $\\le $ 变为 $<$ 是不可能的，因为这会使得 $str(p)$ 不再合法，故仅有可能是某些 $<$ 变为了 $\\le $。\n\n考虑容斥，钦定若干个 $<$ 变为 $\\le $。其实就是合并了一些相邻的段，而注意到 $<$ 变为 $\\le$ 的极大集合为 $S$ 的情况会被它所有子集算到，故若钦定 $k$ 个则容斥系数为 $(-1)^{k}$。\n\n现在我们需要将原来的限制（有关每种字符数量的）加上。\n\n那么考虑边 dp 边容斥，具体的，贪心判断不等式链合法性的过程最终会得到一个字符串，这个字符串和合法的不等式链是**双射**的，所以不妨对这个字符串 dp。\n\n设 $f_{i,j,k}$ 表示填了 $[1,i]$ 这些字符，目前字符串长度为 $j$，末尾（未处理贡献的）段长度为 $k$。那么有 $f_{0,0,0}=1$，答案为 $n!\\times \\sum\\limits_{i}f_{i,n,0}$。\n\n考虑转移：\n\n- 填完 $c_{i+1}$ 还不够填满这一段：$f_{i,j,k}\\to f_{i+1,j+c_{i+1},k+c_{i+1}}$；\n- 填了 $x$ 个 $i+1$ 后分段了（出现了 $<$）：$f_{i,j,k}\\times \\frac{1}{(k+x)!}\\to f_{i+1,j+x,0}$；\n- 填了 $x$ 个 $i+1$ 后碰到了一个钦定从 $<$ 变来的 $\\le $（原本要分段，但是钦定不分段）：$f_{i,j,k}\\times (-1)\\to f_{i+1,j+x,k+x}$；\n\n注意到由于转移中 $1\\le x\\le c_{i+1}$，故第三个转移和第一个转移抵消了：\n\n- $f_{i,j,k}\\times \\frac{1}{(k+x)!}\\to f_{i+1,j+x,0}$，$1\\le x\\le c_{i+1}$；\n- $f_{i,j,k}\\times (-1)\\to f_{i+1,j+x,k+x}$，$1\\le x<c_{i+1}$；\n\n前缀和优化即可，时间复杂度 $O(mn^2)$。\n\n具体的：\n$$\n\\begin{aligned}\nf_{i,j,0}&=\\sum\\limits_{x=1}^{c_i} \\sum\\limits_{k} f_{i-1,j-x,k}\\times \\frac{1}{(k+x)!}\\\\\n&=\\sum\\limits_{x} \\frac{1}{x!}\\sum\\limits_{k=x-c_i}^{x-1} f_{i-1,j-x+k,k}\n\\end{aligned}\n$$\n记得特判 $c_i=0$ 的字符。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nconst int S=505;\n\n#define p 1000000007\n\nint fra[S],inv[S];\nint n,m,c[S];\nint sm[S][S],f[2][S][S];\n\ninline void add(int &x,int y)\n{\n\tx+=y;\n\tif(x>=p) x-=p;\n}\n\ninline int qpow(int x,int y)\n{\n\tint res=1;\n\tfor(;y>0;y>>=1,x=1ll*x*x%p) res=y&1?1ll*res*x%p:res;\n\treturn res;\n}\n\nint main()\n{\n\tfra[0]=1;\n\tfor(int i=1;i<=S-3;i++) fra[i]=1ll*fra[i-1]*i%p;\n\tinv[S-3]=qpow(fra[S-3],p-2);\n\tfor(int i=S-3;i>=1;i--) inv[i-1]=1ll*inv[i]*i%p;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++) scanf(\"%d\",&c[i]);\n\tint ans=0;\n\tf[0][0][0]=1;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint u=i&1,v=u^1;\n\t\tmemset(f[u],0,sizeof(f[u]));\n\t\tif(c[i]==0)\n\t\t{\n\t\t\tmemcpy(f[u],f[v],sizeof(f[u]));\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int j=0;j<=n;j++)\n\t\t{\n\t\t\tfor(int k=0;k<=n;k++)\n\t\t\t{\n\t\t\t\tsm[j][k]=f[v][j][k];\n\t\t\t\tif(j>0&&k>0) add(sm[j][k],sm[j-1][k-1]);\n\t\t\t}\n\t\t}\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tfor(int x=1;x<=n&&x<=j;x++)\n\t\t\t{\n\t\t\t\t// x-c_i <= k <= x-1\n\t\t\t\tint lb=max(x-c[i],0),rb=x-1;\n\t\t\t\tint pre=sm[j-x+rb][rb];\n\t\t\t\tif(lb>0) add(pre,p-sm[j-x+lb-1][lb-1]);\n\t\t\t\tadd(f[u][j][0],1ll*inv[x]*pre%p);\n\t\t\t}\n\t\t}\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tfor(int k=1;k<=n;k++)\n\t\t\t{\n\t\t\t\tadd(f[u][j][k],p-sm[j-1][k-1]);\n\t\t\t\tif(j>=c[i]&&k>=c[i])\n\t\t\t\t\tadd(f[u][j][k],sm[j-c[i]][k-c[i]]);\n\t\t\t}\n\t\t}\n\t\tadd(ans,f[u][n][0]);\n\t}\n\tprintf(\"%d\\n\",1ll*fra[n]*ans%p);\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"字符串"},{"name":"结论"},{"name":"DP"},{"name":"组合计数"}],
			"title": "P5417 [CTSC2016] 萨菲克斯·阿瑞 做题记录",
			"link": "https://exber.qzz.io/post/P5417%20%5BCTSC2016%5D%20%E8%90%A8%E8%8F%B2%E5%85%8B%E6%96%AF%C2%B7%E9%98%BF%E7%91%9E%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2025-01-06 22:13:59"
		},
	
		{
			"abstract": "",
			"content": "### 符号规定\n\n- $P(n)$ 为所有 $n$ 阶排列构成的集合；\n- $\\sigma(p)$ 为排列 $p$ 的逆序对个数；\n- $p^{-1}$ 为排列 $p$ 的逆排列，即满足 $p^{-1}_{p_i}=i$；\n- $A^T$ 为矩阵 $A$ 的转置矩阵；\n- $[n]$ 为集合 $\\{1,2,3,\\dots,n\\}$；\n- $\\binom{[n]}{m}$ 为从 $\\{1,2,3,\\dots,n\\}$ 中所有大小为 $m$ 的子集构成的集合；\n\n### 行列式\n\n对于一个 $n\\times n$ 的方阵 $A$，定义其行列式：\n$$\n|A|=\\sum\\limits_{p\\in P(n)} (-1)^{\\sigma(p)}\\prod\\limits_{i=1}^n A_{i,p_i}\n$$\n非方阵的行列式为 $0$。\n\n> 几何意义：线性变换后”体积“的变化量，即原先 $1$ 单位变为 $|A|$ 单位。\n\n#### 行列式的基本性质 & 高斯消元求解\n\n- 若 $A$ 非满秩矩阵，则 $|A|=0$；\n\n  <details><summary>证明</summary><p>\n  \n  > 考虑行列式的几何意义，若 $A$ 非满秩，则变换后的基向量会共线，则”体积“显然为 $0$。\n  \n  </p></details>\n  \n- $|A^T|=|A|$；\n\n- 对于 $A$，将其中的某一行同时乘常数 $k$，则 $|A|$ 也会乘上 $k$；\n\n- 对于 $A$，交换其中的某两行，则 $|A|$ 会变为 $-|A|$；\n\n  <details><summary>证明</summary><p>\n  \n  > 相当于证明交换排列 $p$ 中任意两个不同的数会改变排列逆序对个数的奇偶性。\n  >\n  > 不难发现交换 $p_i$ 和 $p_{i+1}$ 是成立的，而交换 $p_i$ 和 $p_j$（$i<j$）可以看作先将 $p_i$ 一个一个往右交换到 $p_{j}$ 的右边，再将 $p_j$ 一个一个往左交换到 $p_i$ 原来的位置。\n  >\n  > 第一步交换总共需要 $j-i$ 次，第二步则需要 $j-i-1$ 次，而 $2(j-i)-1$ 是一个奇数，所以整个过程逆序对个数奇偶性一定会改变。\n  \n  </p></details>\n  \n- 对于 $A$，将一行乘上常数 $k$ 再整体加到另一行，则 $|A|$ 不变；\n\n  <details><summary>证明</summary><p>\n  \n  > 记新的方阵为 $A'$，假设是将第 $i$ 行加到第 $j$ 行。\n  >\n  > 考虑乘法分配律，将被加的行拆开，则 $|A'|=|A|+k|B|$，其中 $B$ 的第 $j$ 行和第 $i$ 行相同，则显然 $B$ 非满秩，$|B|=0$，得证。\n  \n  </p></details>\n\n那么根据这些基本性质，可以使用高斯消元将方阵的下半消成全 $0$，即 $\\forall j<i,A_{i,j}=0$。\n\n这样显然 $|A|=\\prod\\limits_{i=1}^n A_{i,i}$，因为其它排列必然会存在某个 $i$ 使得 $A_{i,p_i}=0$。\n\n当然将上半消成全 $0$ 也是可以的。\n\n交换两行的时候别忘了变号，时间复杂度 $O(n^3)$。\n\n<details><summary>参考代码</summary><p>\n\n```cpp\ninline int gauss(int n)\n{\n\tint res=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(a[i][i]==0)\n\t\t{\n\t\t\tbool f=false;\n\t\t\tfor(int j=i+1;j<=n;j++)\n\t\t\t{\n\t\t\t\tif(a[j][i]==0) continue;\n\t\t\t\tf=true;\n\t\t\t\tfor(int k=1;k<=n;k++) swap(a[i][k],a[j][k]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(!f) return 0;\n\t\t\tres=p-res;\n\t\t}\n\t\tres=1ll*res*a[i][i]%p;\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tif(a[j][i]==0) continue;\n\t\t\tint ml=1ll*a[j][i]*qpow(a[i][i],p-2)%p;\n\t\t\tfor(int k=1;k<=n;k++) add(a[j][k],p-1ll*ml*a[i][k]%p);\n\t\t}\n\t}\n\treturn res;\n}\n```\n\n</p></details>\n\n#### Cauchy-Binet 定理\n\n> 设 $A$ 是一个 $n\\times m$ 的矩阵，$B$ 是一个 $m\\times n$ 的矩阵，则：\n> $$\n> |AB|=\\begin{cases}\n> 0&m<n\\\\\n> \\sum\\limits_{S\\in \\binom{[m]}{n}} |A_{[n],S}|\\times |B_{S,[n]}| &m\\ge n \n> \\end{cases}\n> $$\n> 第二条的意思是，枚举 $\\{1,2,3,\\dots,m\\}$ 的所有大小为 $n$ 的子集 $S$，将 $1\\le i\\le n,j\\in S$ 的所有 $A_{i,j}$ 拿出来按照原来的顺序组成一个方阵，记为 $A_{[n],S}$，同理定义 $B_{S,[n]}$，求出其行列式的积的和。\n\n\n<details><summary>证明</summary><p>\n\n> 考虑矩阵乘法的本质，有：\n> $$\n> \\begin{aligned}\n> |AB|&=\\sum\\limits_{p\\in P(n)}(-1)^{\\sigma(p)}\\prod\\limits_{i=1}^{n}(AB)_{i,p_i}\\\\\n> &=\\sum\\limits_{p\\in P(n)}(-1)^{\\sigma(p)}\\prod\\limits_{i=1}^{n}\\sum\\limits_{j=1}^m A_{i,j}\\times B_{j,p_i}\\\\\n> &=\\sum\\limits_{p\\in P(n)}(-1)^{\\sigma(p)}\\sum\\limits_{j_1=1}^m\\sum\\limits_{j_2=1}^m\\sum\\limits_{j_3=1}^m\\dots \\sum\\limits_{j_n=1}^m\\prod\\limits_{i=1}^{n}A_{i,j_i}\\times B_{j_i,p_i}\\qquad \\text{(应用乘法分配律)}\\\\\n> &=\\sum\\limits_{j_1=1}^m\\sum\\limits_{j_2=1}^m\\sum\\limits_{j_3=1}^m\\dots \\sum\\limits_{j_n=1}^m\\sum\\limits_{p\\in P(n)}(-1)^{\\sigma(p)}\\prod\\limits_{i=1}^{n}A_{i,j_i}\\prod\\limits_{i=1}^nB_{j_i,p_i}\\\\\n> &=\\sum\\limits_{j_1=1}^m\\sum\\limits_{j_2=1}^m\\sum\\limits_{j_3=1}^m\\dots \\sum\\limits_{j_n=1}^m\\left(\\prod\\limits_{i=1}^{n}A_{i,j_i}\\right)\\sum\\limits_{p\\in P(n)}(-1)^{\\sigma(p)}\\prod\\limits_{i=1}^nB_{j_i,p_i}\\\\\n> \\end{aligned}\n> $$\n> 注意到 $\\sum\\limits_{p\\in P(n)}(-1)^{\\sigma(p)}\\prod\\limits_{i=1}^nB_{j_i,p_i}$ 就是 $|B_{\\{j_i\\},[n]}|$（逆排列逆序对个数不变，即按行描述和按列描述本质相同），而若 $j_i$ 中有重复元素，则其非满秩，行列式为 $0$，故有：\n> $$\n> \\begin{aligned}\n> |AB|&=\\sum\\limits_{S\\in\\binom{[m]}{n}}\\sum\\limits_{q\\in P(n)}\\left(\\prod\\limits_{i=1}^{n}A_{i,S_{q_i}}\\right)\\sum\\limits_{p\\in P(n)}(-1)^{\\sigma(p)}\\prod\\limits_{i=1}^nB_{S_{q_i},p_i}\\\\\n> &=\\sum\\limits_{S\\in\\binom{[m]}{n}}\\sum\\limits_{q\\in P(n)}\\left(\\prod\\limits_{i=1}^{n}A_{i,S_{q_i}}\\right)\\sum\\limits_{p\\in P(n)}(-1)^{\\sigma(p)}\\prod\\limits_{i=1}^nB_{S_i,q^{-1}_{p_i}}\\\\\n> &=\\sum\\limits_{S\\in\\binom{[m]}{n}}\\sum\\limits_{q\\in P(n)}\\left(\\prod\\limits_{i=1}^{n}A_{i,S_{q_i}}\\right)\\sum\\limits_{p\\in P(n)}(-1)^{\\sigma(q^{-1})}(-1)^{\\sigma(p)}\\prod\\limits_{i=1}^nB_{S_i,p_i}\\\\\n> &=\\sum\\limits_{S\\in\\binom{[m]}{n}}\\left(\\sum\\limits_{q\\in P(n)}(-1)^{\\sigma(q)}\\prod\\limits_{i=1}^{n}A_{i,S_{q_i}}\\right)\\sum\\limits_{p\\in P(n)}(-1)^{\\sigma(p)}\\prod\\limits_{i=1}^nB_{S_i,p_i}\\\\\n> &=\\sum\\limits_{S\\in \\binom{[m]}{n}} |A_{[n],S}|\\times |B_{S,[n]}|\n> \\end{aligned}\n> $$\n\n</p></details>\n\n例题：\n\n- [Loj #3409. 「2020-2021 集训队作业」Yet Another Linear Algebra Problem](https://loj.ac/p/3409)\n\n### LGV 引理\n\n> 对于一个带权 DAG $G$，定义如下符号：\n>\n> - 对于一条路径 $p$，$w_{p}$ 为路径上所有边边权的积；\n>\n> - 对于两个点 $u,v$，$e_{u,v}$ 为 $u\\to v$ 的所有路径 $p$ 的 $w_p$ 之和，即 $e_{u,v}=\\sum\\limits_{p\\in\\{u\\to v\\}} w_p$；\n>\n> - 一组由起点集合 $A$ 到终点集合 $B$ （$|A|=|B|$）的不相交路径 $(S,p_i)$：\n>\n>   $|S|=|A|$ 且 $S_i$ 是一条由 $A_i$ 到 $B_{p_i}$ 的路径，其中 $p\\in P(|A|)$，且 $\\forall i\\not=j$，$S_i$ 和 $S_j$ 没有公共点；\n>\n> LGV 引理指出：\n> $$\n> \\left|\\begin{bmatrix}\n> e_{A_1,B_1}&e_{A_1,B_2}&\\dots&e_{A_1,B_n}\\\\\n> e_{A_2,B_1}&e_{A_2,B_2}&\\dots&e_{A_2,B_n}\\\\\n> \\vdots&\\vdots&\\ddots&\\vdots\\\\\n> e_{A_n,B_1}&e_{A_n,B_2}&\\dots&e_{A_n,B_n}\n> \\end{bmatrix}\\right|=\\sum\\limits_{(S,p)}(-1)^{\\sigma(p)}\\prod\\limits_{i=1}^{|A|} w_{S_i}\n> $$\n\n<details><summary>证明</summary><p>\n\n> 考虑行列式的定义，设等号左边的矩阵为 $C$，$|A|=n$，则：\n> $$\n> \\begin{aligned}\n> |C|&=\\sum\\limits_{p\\in P(n)}\\limits (-1)^{\\sigma(p)} \\prod \\limits_{i=1}^n e_{A_i,B_{p_i}}\\\\\n> &=\\sum\\limits_{p\\in P(n)}\\limits (-1)^{\\sigma(p)} \\prod \\limits_{i=1}^n \\sum\\limits_{q\\in \\{A_i\\to B_{p_i}\\}}w_q\\\\\n> &=\\sum\\limits_{p\\in P(n)}\\limits (-1)^{\\sigma(p)}\\sum\\limits_{q_1\\in \\{A_1\\to B_{p_1}\\}}\\sum\\limits_{q_2\\in \\{A_2\\to B_{p_2}\\}}\\dots \\sum\\limits_{q_n\\in\\{A_n\\to B_{p_n}\\}}\\prod\\limits_{i=1}^n w_{q_i}\\\\\n> \\end{aligned}\n> $$\n> 不难发现，由于 $w_{q_i}$ 是路径边权积，所以  $\\prod\\limits_{i=1}^n w_{q_i}$ 实际上相当于 $q_{[1,n]}$ 这些路径经过的可重边集的边权积。\n>\n> 此时若 $q_i$ 与 $q_j$ 有公共点，那么交换它们最后一个公共点后的路径会使得 $\\sigma(p)$ 奇偶性改变，而 $\\prod\\limits_{i=1}^n w_{q_i}$ 并不会变，所以只有 $q_{[1,n]}$ 两两不交才有贡献，那么：\n>\n> $$\n> \\sum\\limits_{p\\in P(n)}\\limits (-1)^{\\sigma(p)}\\sum\\limits_{q_1\\in \\{A_1\\to B_{p_1}\\}}\\sum\\limits_{q_2\\in \\{A_2\\to B_{p_2}\\}}\\dots \\sum\\limits_{q_n\\in\\{A_n\\to B_{p_n}\\}}\\prod\\limits_{i=1}^n w_{q_i}=\\sum\\limits_{(S,p)}(-1)^{\\sigma(p)}\\prod\\limits_{i=1}^{|A|} w_{S_i}\n> $$\n\n</p></details>\n\n#### 应用：求不交路径数量\n\nLGV 引理还可以求出从起点集合 $A$ 到终点集合 $B$ 的不交路径条数，即找到最大的 $k$ 使得存在一个路径集合 $S$ 满足：\n\n- $|S|=k$；\n- $S$ 中每条路径的起点都在 $A$ 中，终点都在 $B$ 中；\n- $S$ 中的路径两两之间没有公共点；\n\n也可以看成将每个点拆成入点和出点之后的最大流。\n\n先来考虑怎么判定其满流，即 $|A|=|B|$ 时判断 $k=|A|$。显然这个相当于给每条边权值设为任意正整数后判断 $\\sum\\limits_{(S,p)}\\prod\\limits_{i=1}^{|A|} w_{S_i}$ 是否非 $0$。\n\n但这是积和式，是个 NP 问题。\n\n所以不妨考虑行列式 $\\sum\\limits_{(S,p)}(-1)^{\\sigma(p)}\\prod\\limits_{i=1}^{|A|} w_{S_i}$，那么此时唯一的问题就是 $(-1)^{\\sigma(p)}$ 可能让后面的贡献抵消了。但是由于 [Schwartz-Zippel 定理](../一些随机化技巧/#schwartz-zippel-定理)，不妨为每条边随机赋一个权值，这样行列式就是 $n$ 次多项式（$n$ 为 DAG 的点数），故在 $\\text{mod }p$ 域下错误率是 $\\frac{n}{p}$ 的，足够小了。\n\n回到原问题，不难发现在随机赋权后就相当于要找到最大的 $k$ 使得存在 $A$ 的一个 $k$ 阶子矩阵满秩。这就相当于求 $A$ 的秩，直接线性基即可。\n\n另外，该方法还可以求正常的流量全为 $1$ 的网络流（不经过重复边），仅需将边拆成点即可。\n\n该方法复杂度是 $O(\\min(|A|,|B|)^2\\times \\max(|A|,|B|))$ 的，适用于 $A$ 和 $B$ 中某个集合很小的情况。\n\n例题：\n\n- [QOJ #61. Cut Cut Cut!](https://qoj.ac/problem/61)\n- [P9041 [PA2021] Fiolki 2](https://www.luogu.com.cn/problem/P9041)\n- [P10698 [SNCPC2024] 最大流](https://www.luogu.com.cn/problem/P10698)\n\n### 矩阵树定理\n\n> 对于 $n$ 个点的简单无向图 $G$，设点 $i$ 的度数为 $d_i$，设 $n\\times n$ 的矩阵 $A$ 满足：\n>\n> $A_{i,j}=\\begin{cases}d_i& i=j\\\\-1&i\\not=j,(i,j)\\in G\\\\0&otherwise\\end{cases}$\n>\n> 设 $M_{i,j}$ 为 $A$ 删去第 $i$ 行第 $j$ 列后的 $(n-1)\\times (n-1)$ 矩阵，则 $G$ 的生成树个数等于 $|M_{i,i}|$，其中 $1\\le i\\le n$。\n\n<details><summary>证明</summary><p>\n\n>设 $G$ 中有 $m$ 条边 $(u_i,v_i)$，定义 $n\\times m$ 的矩阵 $E$ 满足：\n>\n>- $\\forall 1\\le i\\le m$ 都有 $E_{i,u_i}=1,E_{i,v_i}=-1$；\n>- 其它位置 $E_{i,j}=0$；\n>\n>$u_i$ 和 $v_i$ 的顺序没关系，只要一个位置是 $1$ 一个位置是 $-1$ 就行了。\n>\n>不难发现 $A=E\\times E^T$，且设 $F_i$ 为 $E$ 删除第 $i$ 行后的矩阵，则 $M_{i,i}=F_i\\times F^T_i$。\n>\n>那么根据 Cauchy-Binet 定理，有：\n>$$\n>\\begin{aligned}\n>|M_{i,i}|&=|F_i\\times F_i^T|\\\\\n>&=\\sum\\limits_{S\\in\\binom{[m]}{n-1}} |(F_i)_{[n-1],S}|\\times |(F^T_i)_{S,[n-1]}|\\\\\n>&=\\sum\\limits_{S\\in\\binom{[m]}{n-1}} |(F_i)_{[n-1],S}|\\times |(F_i)_{S,[n-1]}^T|\\\\\n>&=\\sum\\limits_{S\\in\\binom{[m]}{n-1}} |(F_i)_{[n-1],S}|^2\\\\\n>\\end{aligned}\n>$$\n>注意到，$S$ 相当于从 $m$ 条边中无序地选取了 $n-1$ 条，那么仅需证明 $S$ 是生成树时 $|(F_i)_{[n-1],S}|=\\pm 1$，否则 $|(F_i)_{[n-1],S}|=0$ 即可。\n>\n>不妨设 $Q=F_1$，尝试对 $Q$ 证明该结论。\n>\n>不难发现，若 $S$ 不是生成树，则其中必定存在环。而对于一个环 $C\\in S$，$C_1$ 对应的列向量一定能被 $C_{>1}$ 对应的列向量依次乘上 $1$ 或 $-1$ 再求和得到（断环为链后只剩下两边的点未被消去），那么 $Q_{[n-1],S}$ 不会是满秩矩阵，故其行列式为 $0$。\n>\n>![](../post-images/1735819161889.png)\n>\n>并且这一条件显然是充要的，因为若没有环则任意一条链两端的点都无法被消去。\n>\n>接下来证明 $|Q|\\in\\{-1,0,1\\}$。由于我们不关心它的符号，所以从行列式的定义出发，$|Q|$ 相当于要给 $S$ 中的每条边选择一个端点，将这 $n-1$ 个端点对应的系数乘起来。\n>\n>由于第 $1$ 行已经被删去，所以 $u_i=1$ 的边都只能选 $v_i$。而由于选点不能重复，所以可以以 $1$ 为根从上至下确定每条边选择的点（儿子），那么选点方案只有一种，故此时 $|Q|\\in\\{-1,1\\}$。 \n>\n>那么 $Q$ 的情况证毕，而对于 $F_i$（$i\\not =1$）都是等价的，其实只是相当于钦定的根不一样。\n\n</p></details>\n\n拓展形式：\n\n> - 无向带边权 $w_{(i,j)}$（计算的是所有生成树边权积的和）：\n>\n>   $A_{i,j}=\\begin{cases}\\sum\\limits_{(i,v)\\in G} w_{(i,v)}& i=j\\\\-w_{(i,j)}&i\\not=j,(i,j)\\in G\\\\0&otherwise\\end{cases}$\n>\n>   证明仅需将 $E$ 改为一个 $\\sqrt{w_{(i,j)}}$，另一个 $-\\sqrt{w_{(i,j)}}$ 即可。\n>\n> - 有向带边权：\n>\n>   - 根向树，根为 $r$：\n>     $$\n>     A_{i,j}=\\begin{cases}\\sum\\limits_{i\\to v\\in G} w_{i\\to v}&i=j\\\\\n>     -w_{i\\to j}&i\\not=j,i\\to j\\in G\\\\\n>     0&otherwise\\end{cases}\n>     $$\n>     根向树边权积的和为 $|M_{r,r}|$。\n>     \n>     证明和无向图情况类似，改变一下 $E$ 的定义：\n>     \n>     - $(E_{out})_{i,j}=\\begin{cases}\\sqrt{w_{e_j}}&e_j=i\\to x\\\\0&otherwise\\end{cases}$\n>     - $(E_{in})_{i,j}=\\begin{cases}\\sqrt{w_{e_j}}&e_j=x\\to i\\\\0&otherwise\\end{cases}$\n>     \n>     则有 $A=E_{out}\\times (E_{out}-E_{in})^T$，后面的步骤套用无向图情况即可。\n>     \n>   - 叶向树，根为 $r$：\n>     $$\n>     A_{i,j}=\\begin{cases}\\sum\\limits_{v\\to i\\in G} w_{v\\to i}&i=j\\\\\n>     -w_{i\\to j}&i\\not=j,i\\to j\\in G\\\\\n>     0&otherwise\\end{cases}\n>     $$\n>     叶向树边权积的和为 $|M_{r,r}|$，证明和根向树类似。\n>\n> 边权只要在同一个域下就行了，例如可以是多项式。\n\n#### 应用：最小生成树计数\n\n考虑 Kruskal 的过程，每次把边权最小的边加入图中，对每个联通块求出生成树个数，然后将整个连通块缩点即可。\n\n例题：\n\n- [P2143 [JSOI2010] 巨额奖金](https://www.luogu.com.cn/problem/P2143)\n\n#### 应用：复杂边权\n\n注意到矩阵树定理做的实际上是：\n$$\n\\sum\\limits_{T}[T\\text{ is a tree}]\\prod\\limits_{e\\in T} w_e\n$$\n那么边权不一定要是数，只要可以在其上定义加法和乘法即可（是个环）。\n\n例如边权可以是多项式、集合幂级数，只需要先做一遍 DFT/FWT 求出点值，再对每个点值分别跑矩阵树，最后合并起来跑 IDFT/IFWT 即可。\n\n例题：\n\n- [P5406 [THUPC2019] 找树](https://www.luogu.com.cn/problem/P5406)\n- [P6624 [省选联考 2020 A 卷] 作业题](https://www.luogu.com.cn/problem/P6624)\n\n### BEST 定理\n\n> 对于一个**存在欧拉回路**的有向图 $G$，其从 $s$ 出发的欧拉回路个数为：\n> $$\n> T(s)\\times d_s!\\times \\prod\\limits_{u\\not=s} (d_u-1)!\n> $$\n> 其中 $T(s)$ 为 $G$ 中以 $s$ 为根的根向树个数，$d_u$ 为 $u$ 的出度（入度等于出度）。\n>\n> 而 $G$ 的所有欧拉回路个数为：\n> $$\n> T(1)\\times \\prod\\limits_{u}(d_u-1)!\n> $$\n\n<details><summary>证明</summary><p>\n\n\n> 先证第一条。\n>\n> 考察除去 $s$ 外每个点最后的一条出边，不难发现这些边不可能成环，因为每次进入一个非 $s$ 的点后一定要离开它，那么这些边构成了一棵根向树。\n>\n> 由此我们构建了一个从欧拉回路到根向树的映射。\n>\n> 而不难发现，由于欧拉回路存在的充要条件是弱联通且每个点度数为偶数，则除去根向树外，每个点的出边可以任意确定走的次序。这是因为无论怎么走，根向树的树边总是最后一个删掉的，图必定一直弱联通，而度数的条件更不用说了。\n>\n> 对于起点 $s$，它没有树边，所以所有出边可以以任意次序走，自然没有 $-1$。\n>\n> 第二条也是同理，先计算出从 $1$ 出发的欧拉回路个数，而由于 $1$ 的出度为 $d_1$，故其在同一条回路中出现了 $d_1$ 次，那么每次出现都可以作为一个起点而将该回路计算一次，故总数需要除掉 $d_1$。\n\n</p></details>\n",
			"tags": [{"name":"学习笔记"},{"name":"数学"},{"name":"图论"},{"name":"组合计数"}],
			"title": "LGV 引理 & 矩阵树定理 & BEST 定理学习笔记",
			"link": "https://exber.qzz.io/post/LGV%20%E5%BC%95%E7%90%86%20%26%20%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86%20%26%20BEST%20%E5%AE%9A%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2025-01-02 19:59:11"
		},
	
		{
			"abstract": "",
			"content": "对于一个凸函数 $f_x$，若其满足如下性质，则可以使用 slope trick 来刻画：\n\n- $f_x$ 是连续的，即定义域为一个区间；\n- $f_x$ 由若干段**首尾相连**的一次函数拼接而成，且这些一次函数的**斜率均为整数**；\n- 设这些一次函数的斜率的极差为 $v$，则 $v$ 很小（$O(v)$ 可接受）；\n\n具体的，不妨设 $f_x$ 为**下凸**函数，且其定义域从 $0$ 开始。\n\n注意到每一段一次函数首尾相连，斜率极差很小，且斜率单调不降。所以可以用 $f_0$、第一段一次函数的斜率 $k_0$ 和斜率增加点的可重集合 $S$ 来刻画 $f$。具体的，若斜率在某个位置 $x$ 增加了 $\\Delta k$，则在 $S$ 中插入 $\\Delta k$ 个 $x$。\n\n例如 $f_{[0,4]}=[1,-1,-3,1,6]$ 这个下凸函数就可以用 $f_0=1,k_0=-2,S=\\{2,2,2,2,2,2,3\\}$ 来描述。\n\n这样刻画的函数性质十分好：\n\n- 加法：直接将 $f_0$ 和 $k_0$ 分别相加，并合并两个可重集 $S$；\n- 求前缀/后缀 min：去掉后面斜率 $>0$ 或者前面斜率 $<0$ 的部分，对应于删除 $S$ 中最大或最小的若干个数；\n- 求全局 min：提取斜率为 $0$ 的部分；\n\n并且很容易刻画和绝对值相关的操作。\n\n实际一般使用堆/平衡树来维护 $S$。\n\n例题：[P3642 [APIO2016] 烟火表演](https://www.luogu.com.cn/problem/P3642)\n",
			"tags": [{"name":"学习笔记"},{"name":"数学"},{"name":"小技巧"}],
			"title": "slope trick 学习笔记",
			"link": "https://exber.qzz.io/post/slope%20trick%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2024-12-22 20:23:50"
		},
	
		{
			"abstract": "> 给定一个长 $n$ 的序列 $a$，定义一个区间 $[l,r]$ 是好的，当且仅当存在某个 $x$ 使得 $2^x=\\sum\\limits_{i=l}^r 2^{a_i}$。求将 $a$ 划分为若干个好的区间的方案数，对 $10^9+7$ 取模。\n>\n> $1\\le n\\le 3\\times 10^5$，$0\\le a_i\\le 10^6$。\n",
			"content": "> 给定一个长 $n$ 的序列 $a$，定义一个区间 $[l,r]$ 是好的，当且仅当存在某个 $x$ 使得 $2^x=\\sum\\limits_{i=l}^r 2^{a_i}$。求将 $a$ 划分为若干个好的区间的方案数，对 $10^9+7$ 取模。\n>\n> $1\\le n\\le 3\\times 10^5$，$0\\le a_i\\le 10^6$。\n\n\n考虑一个好的区间 $[l,r]$ 以及某个 $l\\le m<r$ 的 $m$，设 $x=\\sum\\limits_{i=l}^m 2^{a_i},y=\\sum\\limits_{i=m+1}^r 2^{a_i}$，观察其需要满足的性质：\n\n- $x$ 和 $y$ 的 lowbit 相同；\n- $x$ 和 $y$ 除了 lowbit 外没有位同时为 $1$；\n- $x|y$ 的 $1$ 连续（$|$ 为按位或）；\n\n不难发现这是充要的，并且知道 higbit 最高的那个数就可以反推出另一个数。例如若已知 $x=(101100)_2$ 并且它的 higbit 最高，则 $y$ 必须为 $(010100)_2$。下面不妨假定 $x$ 的 higbit 比 $y$ 的高。\n\n那么考虑 cdq 分治，强制钦定某一边的 higbit 是最高的。注意到这样一定能找出所有区间，并且由于每个 $x$ 唯一对应一个 $y$，且某一边的和一定是互不相同的，所以这样也顺带证明了总区间个数是 $O(n\\log n)$。\n\n具体的，不妨钦定右侧的 higbit 最高，那么从 $mid$ 往 $l$ 枚举，暴力进位并配合异或哈希求出每一个 $y$；再从 $mid+1$ 往 $r$ 枚举，暴力进位的同时维护 higbit 和 lowbit，这样就可以求出当前需要的 $y$，用哈希表找到这个 $y$ 对应的左端点即可。\n\n另一种情况同理。由于每次最多会让总进位次数 $+1$，所以时间复杂度是正确的。\n\n找到所有区间后直接跑 dp 即可。注意需要开一个 vis 数组来去重。\n\n时间复杂度 $O(n\\log n)$，代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <ctime>\n#include <random>\n\nusing namespace std;\n\ntemplate<typename T>\ninline void read(T &x)\n{\n\tx=0;\n\tT w=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9') w=(c=='-'?-w:w),c=getchar();\n\twhile(c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n\tx*=w;\n}\n\ntypedef unsigned long long ull;\n\nconst int S=300005,MS=2000005;\n\n#define p 1000000007\n\nint n,a[S];\nvector<int> lb[S];\nmt19937_64 rnd(time(NULL));\null val[MS],pre[MS];\nbool vis[S];\nint f[S];\n\nnamespace pot\n{\n\tint hb,lb,b[MS];\n\tull hs;\n\tvector<int> tmp;\n\tinline void init()\n\t{\n\t\thb=-1,lb=MS;\n\t\ths=0;\n\t\tfor(int x:tmp) b[x]=0;\n\t\ttmp.clear();\n\t}\n\tinline void ins(int x)\n\t{\n\t\tb[x]++,hs^=val[x];\n\t\ttmp.push_back(x);\n\t\tlb=min(lb,x),hb=max(hb,x);\n\t\twhile(b[x]==2)\n\t\t{\n\t\t\tb[x]=0,b[x+1]++,hs^=val[x+1];\n\t\t\ttmp.push_back(x+1);\n\t\t\tif(x==lb) lb++;\n\t\t\thb=max(hb,x+1);\n\t\t\tx++;\n\t\t}\n\t}\n\tinline ull que()\n\t{\n\t\treturn pre[hb]^pre[lb]^hs;\n\t}\n}\n\nnamespace hsh\n{\n\tconst int pp=1145143;\n\tvector<pair<ull,int> > vec[pp];\n\tvector<int> tmp;\n\tinline void init()\n\t{\n\t\tfor(int x:tmp) vec[x].clear();\n\t\ttmp.clear();\n\t}\n\tinline void ins(ull x,int y)\n\t{\n\t\tint id=x%pp;\n\t\tvec[id].emplace_back(x,y);\n\t\ttmp.push_back(id);\n\t}\n\tinline int que(ull x)\n\t{\n\t\tint id=x%pp;\n\t\tfor(auto t:vec[id]) if(t.first==x) return t.second;\n\t\treturn -1;\n\t}\n}\n\ninline void work(int l,int r)\n{\n\tif(l==r) return lb[r].push_back(l),void();\n\tint mid=l+r>>1;\n\twork(l,mid),work(mid+1,r);\n\tpot::init(),hsh::init();\n\tfor(int i=mid;i>=l;i--)\n\t{\n\t\tpot::ins(a[i]);\n\t\thsh::ins(pot::hs,i);\n\t}\n\tpot::init();\n\tfor(int i=mid+1;i<=r;i++)\n\t{\n\t\tpot::ins(a[i]);\n\t\tint x=hsh::que(pot::que());\n\t\tif(x!=-1) lb[i].push_back(x);\n\t}\n\tpot::init(),hsh::init();\n\tfor(int i=mid+1;i<=r;i++)\n\t{\n\t\tpot::ins(a[i]);\n\t\thsh::ins(pot::hs,i);\n\t}\n\tpot::init();\n\tfor(int i=mid;i>=l;i--)\n\t{\n\t\tpot::ins(a[i]);\n\t\tint x=hsh::que(pot::que());\n\t\tif(x!=-1) lb[x].push_back(i);\n\t}\n}\n\ninline void add(int &x,int y)\n{\n\tx+=y;\n\tif(x>=p) x-=p;\n}\n\nint main()\n{\n\tfor(int i=0;i<=MS-3;i++) val[i]=rnd();\n\tfor(int i=1;i<=MS-3;i++) pre[i]=pre[i-1]^val[i];\n\tread(n);\n\tfor(int i=1;i<=n;i++) read(a[i]);\n\twork(1,n);\n\tf[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int x:lb[i])\n\t\t{\n\t\t\tif(vis[x]) continue;\n\t\t\tvis[x]=true;\n\t\t\tadd(f[i],f[x-1]);\n\t\t}\n\t\tfor(int x:lb[i]) vis[x]=false;\n\t}\n\tprintf(\"%d\\n\",f[n]);\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"结论"}],
			"title": "QOJ 8527 Power Divisions 做题记录",
			"link": "https://exber.qzz.io/post/QOJ%208527%20Power%20Divisions%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2024-12-17 16:40:05"
		},
	
		{
			"abstract": "",
			"content": "> 定义 $n$ 个区间 $[l_i,r_i]$ 构成的序列是好的，当且仅当：\n>\n> - $1\\le l_i\\le r_i\\le n$；\n> - 存在**唯一**的一个 $n$ 的排列 $p$ 使得 $l_i\\le p_i\\le r_i$；\n>\n> 给定 $n,p$，求好的区间序列个数，对素数 $p$ 取模。\n>\n> $1\\le n\\le 5000$，$10^9\\le p\\le 1.01\\times 10^9$。\n\n首先钦定 $p_i=i$，最后答案再乘上 $n!$，那么这样有 $l_i\\le i\\le r_i$。\n\n考虑将 $l_i$ 和 $r_i$ 分开做，那么限制相当于不存在 $i<j$ 使得 $l_j\\le i,r_i\\ge j$，否则就可以交换 $i,j$。\n\n十分智慧地，考虑二维平面。对于每个 $i$，加入线段 $(i,i),(i,r_i)$ 和线段 $(i,i),(l_i,i)$，那么限制转化为这些线段不能在除 $(i,i)$ 外的地方相交。\n\n那么考虑先画出横着的线段，将 $(i,i+1),(i,r_i)$ 下方的区域涂上颜色，竖着的线段的限制就是不能进入被涂色的区域：（图来自 luogu @[隔壁泞2的如心](https://www.luogu.com.cn/user/222901) 的[题解](https://www.luogu.com.cn/article/gaa46uvm)）\n\n![](../post-images/1731661471364.webp)\n\n不难发现，对于最右边的未被涂色的列，则其左侧和右侧是独立的；而若不存在这样的列，最下面一行除了 $(1,1)$ 外一定都被涂色，相当于一个 $n-1$ 的子问题：\n\n![](../post-images/1731661763025.png)\n\n考虑 dp，设 $f_{n}$ 表示大小为 $n$ 的答案，$g_n$ 表示大小为 $n$ 且最下面一行除了 $(1,1)$ 外都被涂色的答案，则有转移：\n$$\ng_{n}=(n-1)\\times g_{n-1}+\\sum\\limits_{i=2}^{n-1}f_{i-1}\\times g_{n-i}\\times i\\times (n-i)\\\\\nf_{n}=g_n+\\sum\\limits_{i=2}^{n}f_{i-1}\\times g_{n-i+1}\\times i\n$$\n$f$ 的转移是枚举最右边的未被涂色的列在哪里；$g$ 的转移则是枚举第 $2$ 行最右边的未被涂色的列在哪里，从而确认 $r_1$ 的最小值。\n\n边界 $f_1=g_1=1$，时间复杂度 $O(n^2)$，代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=5005;\n\nint n,p;\nint g[S],f[S];\n\ninline void add(int &x,int y)\n{\n\tx+=y;\n\tif(x>=p) x-=p;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&p);\n\tg[1]=1,f[1]=1;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tg[i]=1ll*(i-1)*g[i-1]%p;\n\t\tfor(int j=2;j<=i-1;j++)\n\t\t{\n\t\t\tadd(g[i],1ll*f[j-1]*g[i-j]%p*j%p*(i-j)%p);\n\t\t}\n\t\tf[i]=g[i];\n\t\tfor(int j=2;j<=i;j++)\n\t\t{\n\t\t\tadd(f[i],1ll*f[j-1]*g[i-j+1]%p*j%p);\n\t\t}\n\t}\n\tint fra=1;\n\tfor(int i=1;i<=n;i++) fra=1ll*fra*i%p;\n\tprintf(\"%d\\n\",1ll*f[n]*fra%p);\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"组合计数"},{"name":"结论"}],
			"title": "AGC067D Unique Matching 做题记录",
			"link": "https://exber.qzz.io/post/AGC067D%20Unique%20Matching%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2024-11-15 17:04:24"
		},
	
		{
			"abstract": "",
			"content": "杜教筛可以利用狄利克雷卷积求任意函数的前缀和。\n\n假设现在要求函数 $f$ 的前缀和，设 $S(n)=\\sum\\limits_{i=1}^n f(i)$。\n\n接下来开始人类智慧，构造一个函数 $g$，考虑 $f$ 和 $g$ 的狄利克雷卷积的前缀和：\n$$\n\\begin{aligned}\n&\\qquad\\sum\\limits_{i=1}^n(f*g)(i)\\\\\n&=\\sum\\limits_{i=1}^n\\sum\\limits_{d|i}f(i)g\\left(\\frac{i}{d}\\right)\\\\\n&=\\sum\\limits_{i=1}^ng(i)\\sum\\limits_{j=1}^{\\left\\lfloor\\frac{n}{i}\\right\\rfloor}f(j)\\\\\n&=\\sum\\limits_{i=1}^ng(i)S\\left(\\left\\lfloor\\frac{n}{i}\\right\\rfloor\\right)\\\\\n\\end{aligned}\n$$\n接下来考虑：\n$$\n\\begin{aligned}\ng(1)S(n)&=\\sum\\limits_{i=1}^ng(i)S\\left(\\left\\lfloor\\frac{n}{i}\\right\\rfloor\\right)-\\sum\\limits_{i=2}^ng(i)S\\left(\\left\\lfloor\\frac{n}{i}\\right\\rfloor\\right)\\\\\n&=\\sum\\limits_{i=1}^n(f*g)(i)-\\sum\\limits_{i=2}^ng(i)S\\left(\\left\\lfloor\\frac{n}{i}\\right\\rfloor\\right)\\\\\n\\end{aligned}\n$$\n那么只需要选取合适的函数 $g$，使得可以快速计算 $(f*g)$ 的前缀和和 $g$ 的前缀和即可递归计算出 $S(n)$。\n\n实际问题中 $g$ 一般取 $g(x)=x,g(x)=[x=1],g(x)=1,g(x)=\\mu(x),g(x)=\\varphi(x)$ 等积性函数。\n\n具体实现一般预处理尽可能多的 $S(n)$，然后递归记忆化。\n\n具体的，当预处理 $S([1,n^{\\frac{2}{3}}])$ 时递归算 $S(n)$ 的复杂度是 $O(n^{\\frac{2}{3}})$ 的。\n\n记忆化可以用哈希表，但是注意到只需要存 $S\\left(\\left\\lfloor\\frac{n}{x}\\right\\rfloor\\right)$ 的值，而 $\\left\\lfloor\\frac{n}{x}\\right\\rfloor$ 只有 $O(\\sqrt n)$ 个，而 $x\\le \\sqrt n$ 的 $S(x)$ 一般都预处理了，所以可以直接开一个大小为 $\\sqrt n$ 的数组 $a$，将 $S(x)$ 存在 $a_{\\left\\lfloor\\frac{n}{x}\\right\\rfloor}$ 处。\n",
			"tags": [{"name":"学习笔记"},{"name":"数学"},{"name":"数论"}],
			"title": "杜教筛学习笔记",
			"link": "https://exber.qzz.io/post/%E6%9D%9C%E6%95%99%E7%AD%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2024-10-22 21:31:43"
		},
	
		{
			"abstract": "> 给定一个长 $n$ 的序列 $a$，满足 $1 \\leq a_i \\leq n$。\n>\n> 定义函数 $f([l,r])=\\left[\\min\\limits_{i=l}^r a_i,\\max\\limits_{i=l}^r a_i\\right]$，$q$ 次询问，每次给定一个区间 $[l_i,r_i]$，求最少执行多少次变换 $[l,r] \\rightarrow f([l,r])$ 使得 $[l_i,r_i]$ 变成 $[1,n]$，若无法变为 $[1,n]$ 则输出 `-1`。\n>\n> $1\\le n,q\\le 10^5$。\n",
			"content": "> 给定一个长 $n$ 的序列 $a$，满足 $1 \\leq a_i \\leq n$。\n>\n> 定义函数 $f([l,r])=\\left[\\min\\limits_{i=l}^r a_i,\\max\\limits_{i=l}^r a_i\\right]$，$q$ 次询问，每次给定一个区间 $[l_i,r_i]$，求最少执行多少次变换 $[l,r] \\rightarrow f([l,r])$ 使得 $[l_i,r_i]$ 变成 $[1,n]$，若无法变为 $[1,n]$ 则输出 `-1`。\n>\n> $1\\le n,q\\le 10^5$。\n\n\n十分智慧地，有一个结论：\n\n> 对于两个有交的区间 $[x,y],[l,r]$，$f([x,y]\\cup[l,r])=f([x,y])\\cup f([l,r])$。\n\n证明如下：\n\n- 若 $[x,y]\\cup[l,r]$ 内最大最小值同时在 $[x,y]$ 或 $[l,r]$ 中，则结论显然成立；\n- 若最大值在一边而最小值在另一边，由于 $a_{[x,y]}\\in f([x,y])$ 且 $a_{[l,r]}\\in f([l,r])$，则 $a_{[l,r]\\cap[x,y]}\\in f([x,y])$ 且这一段也在 $f([l,r])$ 中，那么 $f([x,y])$ 和 $f([l,r])$ 一定有交，那么结论显然成立。\n\n根据证明，$f([x,y])$ 和 $f([l,r])$ 也是有交的。\n\n那么设变换 $k$ 次的函数为 $f^k$，则对于两个有交的区间 $[x,y],[l,r]$，有结论 $f^k([x,y]\\cup[l,r])=f^k([x,y])\\cup f^k([l,r])$。\n\n那么不妨把区间拆成若干个 $[i,i+1]$，则 $f^{k}([l,r])=f^{k}([l,l+1])\\cup f^{k}([l+1,l+2])\\cup\\dots\\cup f^{k}([r-1,r])$。\n\n那么倍增 $O(n\\log ^2n)$ 预处理出 $f^{2^k}([i,i+1])$ 即可 $O(q\\log n)$ 回答询问。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\ntemplate<typename T>\ninline void read(T &x)\n{\n\tx=0;\n\tT w=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9') w=(c=='-'?-w:w),c=getchar();\n\twhile(c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n\tx*=w;\n}\n\ntypedef long long ll;\n\nconst int S=100005,BS=17,inf=1e8;\n\nint n,q,a[S],mlog[S];\nint mn[BS*2+1][BS+1][S],mx[BS*2+1][BS+1][S];\n\ninline void initst(int id)\n{\n\tfor(int j=1;j<=mlog[n];j++)\n\t{\n\t\tfor(int i=1;i<=n-(1<<j)+1;i++)\n\t\t{\n\t\t\tmn[id][j][i]=min(mn[id][j-1][i],mn[id][j-1][i+(1<<j-1)]);\n\t\t\tmx[id][j][i]=max(mx[id][j-1][i],mx[id][j-1][i+(1<<j-1)]);\n\t\t}\n\t}\n}\n\ninline int quemn(int a[BS][S],int l,int r)\n{\n\tif(l==1&&r==n-1) return 1;\n\tif(l>r) return inf;\n\tint k=mlog[r-l+1];\n\treturn min(a[k][l],a[k][r-(1<<k)+1]);\n}\n\ninline int quemx(int a[BS][S],int l,int r)\n{\n\tif(l==1&&r==n-1) return n;\n\tif(l>r) return -inf;\n\tint k=mlog[r-l+1];\n\treturn max(a[k][l],a[k][r-(1<<k)+1]);\n}\n\nint main()\n{\n\tread(n),read(q);\n\tfor(int i=1;i<=n;i++) read(a[i]);\n\tmlog[0]=-1;\n\tfor(int i=1;i<=n;i++) mlog[i]=mlog[i>>1]+1;\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tmn[0][0][i]=min(a[i],a[i+1]);\n\t\tmx[0][0][i]=max(a[i],a[i+1]);\n\t}\n\tinitst(0);\n\tfor(int s=1;s<=mlog[n]*2;s++)\n\t{\n\t\tfor(int i=1;i<=n-1;i++)\n\t\t{\n\t\t\tmn[s][0][i]=quemn(mn[s-1],mn[s-1][0][i],mx[s-1][0][i]-1);\n\t\t\tmx[s][0][i]=quemx(mx[s-1],mn[s-1][0][i],mx[s-1][0][i]-1);\n\t\t}\n\t\tinitst(s);\n\t}\n\twhile(q-->0)\n\t{\n\t\tint l,r;\n\t\tread(l),read(r);\n\t\tif(l==1&&r==n)\n\t\t{\n\t\t\tputs(\"0\");\n\t\t\tcontinue;\n\t\t}\n\t\tll ans=0;\n\t\tfor(int i=mlog[n]*2;i>=0;i--)\n\t\t{\n\t\t\tint nl=quemn(mn[i],l,r-1),nr=quemx(mx[i],l,r-1);\n\t\t\tif(nl!=1||nr!=n) ans+=1ll<<i,l=nl,r=nr;\n\t\t}\n\t\tans++;\n\t\tint nl=quemn(mn[0],l,r-1),nr=quemx(mx[0],l,r-1);\n\t\tl=nl,r=nr;\n\t\tif(l==1&&r==n) printf(\"%lld\\n\",ans);\n\t\telse puts(\"-1\");\n\t}\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"结论"}],
			"title": "CF1707E Replace 做题记录",
			"link": "https://exber.qzz.io/post/CF1707E%20Replace%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2024-10-16 18:05:55"
		},
	
		{
			"abstract": "> 对于 $n$ 个点的一棵无根树 $T$，定义 $f(T)$：\n>\n> - 若 $n=1$，则 $f(T)=1$；\n> - 否则：\n>   - 对于一条树边 $e$，定义 $T_x(e)$ 和 $T_y(e)$ 为 $T$ 删去 $e$ 后分裂出的两棵树（不管顺序）；\n>   - $f(T)=\\left(\\sum\\limits_{e\\in \\text{edge}(T)} f(T_x(e))\\times f(T_y(e))\\right)\\times \\frac{1}{n}$；\n>\n> 给定一棵 $n$ 个点的无根树 $A$，求 $f(A)\\text{ mod }998244353$ 的值。\n>\n> $2\\le n\\le 5000$。\n",
			"content": "> 对于 $n$ 个点的一棵无根树 $T$，定义 $f(T)$：\n>\n> - 若 $n=1$，则 $f(T)=1$；\n> - 否则：\n>   - 对于一条树边 $e$，定义 $T_x(e)$ 和 $T_y(e)$ 为 $T$ 删去 $e$ 后分裂出的两棵树（不管顺序）；\n>   - $f(T)=\\left(\\sum\\limits_{e\\in \\text{edge}(T)} f(T_x(e))\\times f(T_y(e))\\right)\\times \\frac{1}{n}$；\n>\n> 给定一棵 $n$ 个点的无根树 $A$，求 $f(A)\\text{ mod }998244353$ 的值。\n>\n> $2\\le n\\le 5000$。\n\n\n发现有个 $\\frac{1}{n}$ 不好处理，考虑组合意义。\n\n若删边改成删点，这个 $\\frac{1}{n}$ 就相当于每次等概率随机选择一个点删掉，所以 $f(T)=1$。同理，若乘的是 $\\frac{1}{n-1}$，则 $f(T)$ 也会恒为 $1$。\n\n接下来开始人类智慧：\n\n- 为每条边建一个“边点”，再给“边点”连 $-1$ 个点（可以认为是 $998244353-1$ 个），那么现在点数变成了 $n$，答案即为等概率随机一个 $T$ 的点排列，满足每个”边点“都在其相邻点之前的概率；\n\n这个结论的证明挺显然的，因为若先删掉”边点“相邻的点则树的形态不合法。\n\n接下来考虑把每条边按照点的先后关系定向，则相当于求满足定向关系的概率。发现有的父亲比儿子大，有的父亲比儿子小，不好计算。那么不妨容斥，对于每条向上的边，其可以删掉或者改成向下的边，每个由向上改为向下的边都会贡献 $-1$ 的容斥系数。\n\n那么就可以做了，记录一下从每个点开始的外向树大小，背包即可。\n\n时间复杂度 $O(n^2)$。\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nconst int S=5005,p=998244353;\n\nint n;\nint fra[S],inv[S];\nvector<int> g[S];\nint siz[S],tf[S],f[S][S];\n\ninline int qpow(int x,int y)\n{\n\tint res=1;\n\tfor(;y>0;y>>=1,x=1ll*x*x%p) res=y&1?1ll*res*x%p:res;\n\treturn res; \n}\n\ninline void add(int &x,int y)\n{\n\tx+=y;\n\tif(x>=p) x-=p;\n}\n\nvoid dfs(int u,int fa)\n{\n\tsiz[u]=1;\n\tf[u][1]=1;\n\tfor(int v:g[u])\n\t{\n\t\tif(v==fa) continue;\n\t\tdfs(v,u);\n\t\tfor(int i=1;i<=siz[u]+siz[v];i++) tf[i]=0;\n\t\tfor(int i=1;i<=siz[u];i++)\n\t\t{\n\t\t\tfor(int j=1;j<=siz[v];j++) \n\t\t\t{\n\t\t\t\tint pre=1ll*f[v][j]*inv[j]%p;\n\t\t\t\tadd(tf[i+j],p-1ll*f[u][i]*pre%p);\n\t\t\t\tadd(tf[i],1ll*f[u][i]*pre%p);\n\t\t\t}\n\t\t}\n\t\tsiz[u]+=siz[v];\n\t\tfor(int i=1;i<=siz[u];i++) f[u][i]=tf[i];\n\t}\n\tfor(int i=1;i<=siz[u];i++) f[u][i]=1ll*f[u][i]*inv[i]%p;\n}\n\nint main()\n{\n\tfra[0]=1;\n\tfor(int i=1;i<=S-3;i++) fra[i]=1ll*fra[i-1]*i%p;\n\tinv[S-3]=qpow(fra[S-3],p-2);\n\tfor(int i=S-3;i>=1;i--) inv[i-1]=1ll*inv[i]*i%p;\n\tfor(int i=1;i<=S-3;i++) inv[i]=1ll*inv[i]*fra[i-1]%p;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tdfs(1,0);\n\tint ans=0;\n\tfor(int i=1;i<=n;i++) add(ans,f[1][i]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"结论"},{"name":"构造"},{"name":"组合计数"}],
			"title": "AGC058F Authentic Tree DP 做题记录",
			"link": "https://exber.qzz.io/post/AGC058F%20Authentic%20Tree%20DP%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2024-09-09 15:36:10"
		},
	
		{
			"abstract": "> 给定一个 $n$ 个点 $m$ 条边的无向图，每条边有流量 $w_i$，保证其是一个逆时针从 $1$ 到 $n$ 编号的正 $n$ 边形，且边只会在顶点处相交，求 $n$ 个点两两间的最大流之和，对 $998244353$ 取模。\n>\n> $3\\le n\\le 2\\times 10^5$，$n\\le m\\le 4\\times 10^5$，$0\\le w_i\\le 10^9$。\n",
			"content": "> 给定一个 $n$ 个点 $m$ 条边的无向图，每条边有流量 $w_i$，保证其是一个逆时针从 $1$ 到 $n$ 编号的正 $n$ 边形，且边只会在顶点处相交，求 $n$ 个点两两间的最大流之和，对 $998244353$ 取模。\n>\n> $3\\le n\\le 2\\times 10^5$，$n\\le m\\le 4\\times 10^5$，$0\\le w_i\\le 10^9$。\n\n\n由于这是一个平面图，所以最大流=最小割=对偶图最短路。\n\n具体的，从每个顶点向多边形外面引一条射线，则 $s$ 到 $t$ 的最大流相当于对偶图上两区间的点之间的最短路：\n\n![](../post-images/1724323798893.png)\n\n考虑多边形外圈权值最小的边 $e$ 及其所在的最小环 $c$：\n\n![](../post-images/1724324198021.png)\n\n有一个性质：\n\n- 最短路一定会经过 $c$ 的 $0$ 条或 $2$ 条边；\n- 若最短路经过 $c$ 的 $2$ 条边，则一定可以经过 $e$；\n\n第一条显然，因为有进有出，而且不可能走回头路。\n\n第二条是因为 $e$ 在外围，所以通过更换最短路起点或终点，将最短路经过的 $c$ 上的边换成 $e$ 一定不劣。\n\n那么根据这个性质，我们可以每次找到外围边权最小的边 $e$，将 $w_e$ 加到它所在最小环上的其它边上，然后删掉 $e$。不难发现新图最大流不变。\n\n那么不断进行这样的删边操作，最后图会变成一棵树。而树的最大流=最小割就相当于两点间路径上边权最小值，可以快速计算。\n\n时间复杂度 $O(n\\log n)$。\n\n具体实现可以考虑建出对偶图。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <queue>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int S=200005,p=998244353;\n\nstruct node\n{\n\tint x,y;\n\tll w;\n}ed[S*2];\n\nint n,m;\nvector<pair<int,int> > gg[S];\nset<pair<int,int> > g[S*4];\nbool flg[S*4],vis[S*4];\nvector<node> g2;\nint fa[S],siz[S];\n\nint fnd(int x)\n{\n\treturn fa[x]==x?x:fa[x]=fnd(fa[x]);\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x,y,w;\n\t\tscanf(\"%d%d%d\",&x,&y,&w);\n\t\tif(x>y) swap(x,y);\n\t\ted[i]=(node){x,y,w};\n\t\tgg[x].emplace_back(y,i);\n\t}\n\tfor(int i=1;i<=n;i++) sort(gg[i].begin(),gg[i].end());\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<gg[i].size();j++)\n\t\t{\n\t\t\tint u=gg[i][j].second,rb=gg[i][j].first;\n\t\t\tint v=gg[i][j-1].second,p=gg[i][j-1].first;\n\t\t\tif(i==1&&rb==n)\n\t\t\t{\n\t\t\t\tm++;\n\t\t\t\tg[u].emplace(m,u);\n\t\t\t\tg[m].emplace(u,u);\n\t\t\t}\n\t\t\tg[u].emplace(v,v);\n\t\t\tg[v].emplace(u,v);\n\t\t\twhile(p!=rb)\n\t\t\t{\n\t\t\t\tauto tmp=*gg[p].rbegin();\n\t\t\t\tint v=tmp.second;\n\t\t\t\tp=tmp.first;\n\t\t\t\tg[u].emplace(v,v);\n\t\t\t\tg[v].emplace(u,v);\n\t\t\t}\n\t\t}\n\t}\n\tpriority_queue<pair<ll,int> > q;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif(g[i].size()==1)\n\t\t{\n\t\t\tflg[i]=true;\n\t\t\tint id=g[i].begin()->second;\n\t\t\tq.emplace(-ed[id].w,i);\n\t\t}\n\t}\n\twhile(!q.empty())\n\t{\n\t\tauto t=q.top();\n\t\tq.pop();\n\t\tint u=t.second;\n\t\tif(vis[u]) continue;\n\t\tll w=-t.first;\n\t\tint fa=g[u].begin()->first;\n\t\tfor(auto t:g[fa])\n\t\t{\n\t\t\tint v=t.first,id=t.second;\n\t\t\ted[id].w+=w;\n\t\t\tg[v].erase(make_pair(fa,id));\n\t\t\tif(flg[v])\n\t\t\t{\n\t\t\t\tvis[v]=true;\n\t\t\t\tif(v!=u)\n\t\t\t\t{\n\t\t\t\t\tint x=ed[id].x,y=ed[id].y;\n\t\t\t\t\tll w=ed[id].w;\n\t\t\t\t\tg2.push_back((node){x,y,w});\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tm++;\n\t\t\t\tflg[m]=true;\n\t\t\t\tg[m].emplace(v,id);\n\t\t\t\tg[v].emplace(m,id);\n\t\t\t\tq.emplace(-ed[id].w,m);\n\t\t\t}\n\t\t}\n\t}\n\tsort(g2.begin(),g2.end(),[&](node x,node y){\n\t\treturn x.w>y.w;\n\t});\n\tfor(int i=1;i<=n;i++) fa[i]=i,siz[i]=1;\n\tll ans=0;\n\tfor(auto t:g2)\n\t{\n\t\tint x=fnd(t.x),y=fnd(t.y);\n\t\tll w=t.w;\n\t\tif(x==y) continue;\n\t\tans+=w%p*siz[x]*siz[y]%p;\n\t\tsiz[y]+=siz[x];\n\t\tfa[x]=y;\n\t}\n\tans%=p;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"图论"},{"name":"结论"},{"name":"网络流"}],
			"title": "GYM102471K All Pair Maximum Flow 做题记录",
			"link": "https://exber.qzz.io/post/GYM102471K%20All%20Pair%20Maximum%20Flow%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2024-08-22 18:49:52"
		},
	
		{
			"abstract": "",
			"content": "### Part 1 简介\n\nSnake Oil 方法是一种用于推导组合恒等式的方法，该方法的大体思路为：\n\n1. 对于某个组合求和式，设其参数为 $n$，结果为 $a_n$；\n2. 写出 $a_n$ 的 OGF $f(x)$；\n3. 根据组合求和式展开 $f(x)$，交换求和顺序，根据已有结论推导；\n4. 求出 $f(x)$ 较简单形式后展开成序列；\n\n需要注意的是，一般使用 Snake Oil 方法推导的组合恒等式中求和都是没有上下界的，并且默认当 $n<0$ 或 $m<0$ 或 $n<m$ 时 $\\binom{n}{m}=0$。\n\n### Part 2 经典结论\n\n#### 2.1 公理\n\n##### 2.1.1 行求和\n\n$$\n\\sum\\limits_{k}\\binom{n}{r+k}x^k=x^{-r}(x+1)^n\n$$\n\n##### 2.1.2 列求和\n\n$$\n\\sum\\limits_{k}\\binom{r+k}{n}x^k=\\frac{x^{n-r}}{(1-x)^{n+1}}\n$$\n\n<details><summary>证明</summary><p>\n\n> $$\n> \\begin{aligned}\n> \\frac{x^{n-r}}{(1-x)^{n+1}}&=x^{n-r}(1-x)^{-(n+1)}\\\\\n> &=x^{n-r}\\sum\\limits_{k}\\binom{-(n+1)}{k}(-x)^k\\\\\n> &=x^{n-r}\\sum\\limits_{k}\\frac{\\prod\\limits_{i=1}^k-(n+i)}{k!}(-x)^k\\\\\n> &=x^{n-r}\\sum\\limits_{k}\\frac{\\prod\\limits_{i=1}^k(n+i)}{k!}x^k\\\\\n> &=x^{n-r}\\sum\\limits_{k}\\binom{n+k}{k}x^k\\\\\n> &=x^{n-r}\\sum\\limits_{k}\\binom{n+k}{n}x^k\\\\\n> &=x^{-r}\\sum\\limits_{k}\\binom{n+k}{n}x^{n+k}\\\\\n> &=x^{-r}\\sum\\limits_{k}\\binom{k}{n}x^{k}\\\\\n> &=\\sum\\limits_{k}\\binom{r+k}{n}x^{k}\\\\\n> \\end{aligned}\n> $$\n\n</p></details>\n\n##### 2.1.3 卡特兰\n\n$$\n\\sum\\limits_{k}\\binom{2k}{k}x^k=\\frac{1}{\\sqrt{1-4x}}\\qquad(2.1.3.1)\n$$\n\n$$\n\\sum\\limits_{k}\\frac{1}{k+1}\\binom{2k}{k}x^k=\\frac{1-\\sqrt{1-4x}}{2x}\\qquad(2.1.3.2)\n$$\n\n<details><summary>证明</summary><p>\n\n> 第二条就是卡特兰，证第一条。\n> $$\n> \\begin{aligned}\n> \\sum\\limits_{k}\\binom{2k}{k}x^k&=\\sum\\limits_{k}\\frac{(2k)!}{k!k!}x^k\\\\\n> &=\\sum\\limits_{k}2^k\\frac{(2k-1)!!}{k!}x^k\\\\\n> &=\\sum\\limits_{k}\\frac{(2k-1)!!}{2^kk!}4^kx^k\\\\\n> &=\\sum\\limits_{k}\\frac{(-\\frac{1}{2})\\times (-\\frac{3}{2})\\times \\dots\\times(-\\frac{2k-1}{2})}{k!}(-4)^kx^k\\\\\n> &=\\sum\\limits_{k}\\binom{-\\frac{1}{2}}{k}(-4)^kx^k\\\\\n> &=\\frac{1}{\\sqrt{1-4x}}\\\\\n> \\end{aligned}\n> $$\n\n</p></details>\n\n### Part 3 经典样例\n\n#### 3.1 例 1：左斜求和\n\n$$\na_n=\\sum\\limits_{k}\\binom{k}{n-k}\\qquad(n\\ge 0)\n$$\n\n$$\n\\begin{aligned}\nf(x)&=\\sum\\limits_{n}\\sum\\limits_{k}\\binom{k}{n-k}x^n\\\\\n&=\\sum\\limits_{k}\\sum\\limits_{n}\\binom{k}{n-k}x^n\\\\\n&=\\sum\\limits_{k}x^k\\sum\\limits_{n}\\binom{k}{n}x^n\\\\\n&=\\sum\\limits_{k}x^k(x+1)^k\\\\\n&=\\sum\\limits_{k}(x^2+x)^k\\\\\n&=\\frac{1}{1-x-x^2}\\\\\n\\end{aligned}\n$$\n不难发现这其实是斐波那契的封闭形式，故 $\\sum\\limits_{k}\\binom{k}{n-k}=fib_n$。\n\n#### 3.2 例 2\n\n$$\na_{n,m}=\\sum\\limits_{k}\\binom{n+k}{m+2k}\\binom{2k}{k}\\frac{(-1)^k}{k+1}\\qquad(n,m\\ge 0)\n$$\n\n把 $m$ 看作常数，则：\n$$\n\\begin{aligned}\nf(x)&=\\sum\\limits_{n}x^n\\sum\\limits_{k}\\binom{n+k}{m+2k}\\binom{2k}{k}\\frac{(-1)^k}{k+1}\\\\\n&=\\sum\\limits_{k}(-1)^k\\frac{\\binom{2k}{k}}{k+1}\\sum\\limits_{n}x^n\\binom{n+k}{m+2k}\\\\\n&=\\sum\\limits_{k}(-1)^k\\frac{\\binom{2k}{k}}{k+1}x^{-k}\\sum\\limits_{n}x^{n+k}\\binom{n+k}{m+2k}\\\\\n&=\\sum\\limits_{k}(-1)^k\\frac{\\binom{2k}{k}}{k+1}x^{-k}\\frac{x^{m+2k}}{(1-x)^{m+2k+1}}\\qquad\\text{套用 2.1.2}\\\\\n&=\\sum\\limits_{k}(-1)^k\\frac{\\binom{2k}{k}}{k+1}\\frac{x^{m+k}}{(1-x)^{m+2k+1}}\\\\\n&=\\frac{x^m}{(1-x)^{m+1}}\\sum\\limits_{k}(-1)^k\\frac{\\binom{2k}{k}}{k+1}\\frac{x^k}{(1-x)^{2k}}\\\\\n&=\\frac{x^m}{(1-x)^{m+1}}\\sum\\limits_{k}\\frac{\\binom{2k}{k}}{k+1}\\left(\\frac{-x}{(1-x)^2}\\right)^k\\\\\n&=\\frac{x^m}{(1-x)^{m+1}}\\frac{1-\\sqrt{1-\\frac{-4x}{(1-x)^2}}}{\\frac{-2x}{(1-x)^2}}\\qquad\\text{套用 2.1.3.2}\\\\\n&=\\frac{x^m(1-x)^2\\left(\\sqrt{1+\\frac{4x}{(1-x)^2}}-1\\right)}{2x(1-x)^{m+1}}\\\\\n&=\\frac{x^{m-1}\\left(\\sqrt{\\frac{(1-x)^2+4x}{(1-x)^2}}-1\\right)}{2(1-x)^{m-1}}\\\\\n&=\\frac{x^{m-1}\\left(\\frac{1+x}{1-x}-1\\right)}{2(1-x)^{m-1}}\\\\\n&=\\frac{x^{m-1}\\frac{2x}{1-x}}{2(1-x)^{m-1}}\\\\\n&=\\frac{x^{m}}{(1-x)^m}\n\\end{aligned}\n$$\n展开：\n$$\n\\frac{x^{m}}{(1-x)^m}=x^m\\sum\\limits_{n}\\binom{n+m-1}{m-1}x^n=\\sum\\limits_{n}\\binom{n-1}{m-1}x^n\n$$\n所以：\n$$\na_{n,m}=\\binom{n-1}{m-1}\n$$\n\n#### 3.3 例 3\n\n$$\na_n=\\sum\\limits_{k}(-1)^k\\binom{n-k}{k}y^{n-2k}\\qquad(n\\ge 0)\n$$\n\n$$\n\\begin{aligned}\nf(x)&=\\sum\\limits_{n}x^n\\sum\\limits_{k}(-1)^k\\binom{n-k}{k}y^{n-2k}\\\\\n&=\\sum\\limits_{k}(-1)^k\\sum\\limits_{n}x^n\\binom{n-k}{k}y^{n-2k}\\\\\n&=\\sum\\limits_{k}\\frac{(-1)^k}{y^{2k}}\\sum\\limits_{n}\\binom{n-k}{k}(xy)^n\\\\\n&=\\sum\\limits_{k}\\frac{(-1)^k}{y^{2k}}\\frac{(xy)^{2k}}{(1-xy)^{k+1}}\\\\\n&=\\sum\\limits_{k}\\frac{(-1)^kx^{2k}}{(1-xy)^{k+1}}\\\\\n&=\\sum\\limits_{k}\\frac{1}{1-xy}\\left(\\frac{-x^2}{1-xy}\\right)^k\\\\\n&=\\frac{1}{1-xy}\\sum\\limits_{k}\\left(\\frac{-x^2}{1-xy}\\right)^k\\\\\n\\end{aligned}\n$$\n\n注意到 $k$ 是大于等于 $0$ 的，所以：\n$$\n\\begin{aligned}\nf(x)&=\\frac{1}{1-xy}\\frac{1}{1-\\frac{-x^2}{1-xy}}\\\\\n&=\\frac{1}{1-xy}\\frac{1-xy}{1-xy+x^2}\\\\\n&=\\frac{1}{1-xy+x^2}\n\\end{aligned}\n$$\n使用待定系数法，设：\n$$\n\\frac{1}{1-xy+x^2}=\\frac{1}{(1-ax)(1-bx)}=\\frac{a}{(a-b)(1-ax)}-\\frac{b}{(a-b)(1-bx)}\n$$\n那么有：\n$$\n\\begin{cases}\na+b=y\\\\\nab=1\n\\end{cases}\n$$\n解得：\n$$\n\\begin{cases}\na=\\frac{y+\\sqrt{y^2-4}}{2}\\\\\nb=\\frac{y-\\sqrt{y^2-4}}{2}\\\\\n\\end{cases}\n$$\n那么有：\n$$\na_n=\\frac{1}{\\sqrt{y^2-4}}\\left(\\left(\\frac{y+\\sqrt{y^2-4}}{2}\\right)^{n+1}-\\left(\\frac{y-\\sqrt{y^2-4}}{2}\\right)^{n+1}\\right)\n$$\n\n#### 3.4 例 4\n\n$$\na_n=\\sum\\limits_{k}\\binom{n+k}{2k}2^{n-k}\\qquad(n\\ge 0)\n$$\n\n<details><summary>推导过程</summary><p>\n\n$$\n\\begin{aligned}\nf(x)&=\\sum\\limits_{n}\\sum\\limits_{k}\\binom{n+k}{2k}2^{n-k}x^n\\\\\n&=\\sum\\limits_{k}\\frac{1}{2^k}\\sum\\limits_{n}\\binom{n+k}{2k}(2x)^n\\\\\n&=\\sum\\limits_{k}\\frac{1}{2^k}\\frac{(2x)^{k}}{(1-2x)^{2k+1}}\\qquad\\text{套用2.1.2}\\\\\n&=\\sum\\limits_{k}\\frac{x^{k}}{(1-2x)^{2k+1}}\\\\\n&=\\frac{1}{1-2x}\\sum\\limits_{k}\\frac{x^{k}}{(1-2x)^{2k}}\\\\\n&=\\frac{1}{1-2x}\\sum\\limits_{k}\\frac{x^{k}}{(1-2x)^{2k}}\\\\\n&=\\frac{1}{1-2x}\\frac{1}{1-\\frac{x}{(1-2x)^2}}\\\\\n&=\\frac{1}{1-2x-\\frac{x}{1-2x}}\\\\\n&=\\frac{1-2x}{1-5x+4x^2}\\\\\n&=\\frac{1-2x}{(1-4x)(1-x)}\\\\\n&=\\frac{2}{3(1-4x)}+\\frac{1}{3(1-x)}\n\\end{aligned}\n$$\n\n所以有：\n$$\na_n=\\frac{2}{3}4^n+\\frac{1}{3}=\\frac{2^{2n+1}+1}{3}\n$$\n\n</p></details>\n\n#### 3.5 例 5\n\n$$\na_n=\\sum\\limits_{k}\\binom{n}{k}\\binom{2k}{k}y^k\\qquad (n\\ge 0)\n$$\n\n$$\n\\begin{aligned}\nf(x)&=\\sum\\limits_{n}\\sum\\limits_{k}\\binom{n}{k}\\binom{2k}{k}y^kx^n\\\\\n&=\\sum\\limits_{k}\\binom{2k}{k}y^k\\sum\\limits_{n}\\binom{n}{k}x^n\\\\\n&=\\sum\\limits_{k}\\binom{2k}{k}y^k\\frac{x^k}{(1-x)^{k+1}}\\qquad\\text{套用 2.1.2}\\\\\n&=\\frac{1}{1-x}\\sum\\limits_{k}\\binom{2k}{k}\\left(\\frac{xy}{1-x}\\right)^k\\\\\n&=\\frac{1}{1-x}\\frac{1}{\\sqrt{1-\\frac{4xy}{1-x}}}\\qquad\\text{套用 2.1.3.1}\\\\\n&=\\frac{1}{1-x}\\frac{1-x}{\\sqrt{1-x-4xy}}\\\\\n&=\\frac{1}{\\sqrt{(1-x)(1-x-4xy)}}\\\\\n&=\\frac{1}{\\sqrt{1-x-4xy-x+x^2+4x^2y}}\\\\\n&=\\frac{1}{\\sqrt{1-(4y+2)x+(4y+1)x^2}}\\\\\n\\end{aligned}\n$$\n\n这个式子有一个有趣的拓展：\n\n带入 $y=-\\frac{1}{2}$ 得：\n$$\n\\sum\\limits_{k}\\binom{n}{k}\\binom{2k}{k}\\left(-\\frac{1}{2}\\right)^k=[x^n]\\frac{1}{\\sqrt{1-x^2}}=[x^n]\\sum\\limits_{k}\\binom{2k}{k}\\left(\\frac{x}{2}\\right)^{2k}\\qquad (n\\ge 0)\n$$\n那么：\n$$\n\\sum\\limits_{k}\\binom{n}{k}\\binom{2k}{k}\\left(-\\frac{1}{2}\\right)^k=\\begin{cases}\\binom{n}{\\frac{n}{2}}&n\\text{ mod }2=0\\\\0&n\\text{ mod }2=1\\end{cases}\\qquad (n\\ge 0)\n$$\n\n#### 3.6 例 6：下降幂和\n\n$$\na_{n,m}=\\sum\\limits_{i=m}^ni^{\\underline m}\\qquad(n\\ge m\\ge 0)\n$$\n\n$$\n\\begin{aligned}F_{m}(x)&=\\sum\\limits_{n=m}^\\infin \\sum\\limits_{i=m}^{n}\\frac{i!}{(i-m)!}x^n\\\\\n&=\\sum\\limits_{i=m}^{\\infin}\\frac{i!}{(i-m)!}\\sum\\limits_{n=i}^\\infin x^n\\\\\n&=\\sum\\limits_{i=m}^{\\infin}\\frac{i!}{(i-m)!}\\frac{x^i}{1-x}\\\\\n&=\\left(\\sum\\limits_{i=m}^{\\infin}\\frac{i!}{(i-m)!}x^i\\right)\\frac{1}{1-x}\\\\&=m!\\left(\\sum\\limits_{i=m}^{\\infin}\\frac{i!}{(i-m)!m!}x^i\\right)\\frac{1}{1-x}\\\\\n&=m!\\left(\\sum\\limits_{i=m}^{\\infin}\\binom{i}{m}x^i\\right)\\frac{1}{1-x}\\\\\n&=m!\\frac{x^m}{(1-x)^{m+1}}\\frac{1}{1-x}\\\\\n&=m!\\frac{x^m}{(1-x)^{m+2}}\\\\\n\\end{aligned}\n$$\n\n所以：\n$$\na_{n,m}=\\frac{(n+1)!}{(m+1)(n-m)!}\n$$\n",
			"tags": [{"name":"学习笔记"},{"name":"数学"},{"name":"多项式、生成函数"},{"name":"组合计数"}],
			"title": "蛇油（Snake oil）方法学习笔记",
			"link": "https://exber.qzz.io/post/%E8%9B%87%E6%B2%B9%EF%BC%88Snake%20oil%EF%BC%89%E6%96%B9%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2024-08-20 18:20:03"
		},
	
		{
			"abstract": "",
			"content": "默认 $f_0=0$。\n\n### Part 1 自己卷别人\n\n> $f_n=\\sum\\limits_{i=0}^{n-1}f_{i}g_{n-1-i}$，$g$ 已知\n\n考虑分治计算 $f_{[l,r]}$。\n\n计算 $f_{[l,r]}$ 时，设 $mid=\\lfloor\\frac{l+r}{2}\\rfloor$，先分治计算 $f_{[l,mid]}$，再将 $f_{[l,mid]}$ 对 $f_{[mid+1,r]}$ 的贡献加上。即计算出 $f_{[l,mid]}\\times g_{[0,r-l]}$，并将结果按位加到 $f_{[mid+1,r]}$ 上。\n\n若 $l=r$ 则直接返回。\n\n例题：洛谷板题。\n\n### Part 2 自己卷自己\n\n> $f_n=\\sum\\limits_{i=0}^{n-1}f_if_{n-1-i}$\n\n此时有一个 bug：计算 $f_{[l,r]}$ 时 $f_{[0,r-l]}$ 不一定已经知道。\n\n但是注意到计算完 $f_{[l,mid]}$ 后 $f_{[0,mid]}$ 一定都知道，所以当且仅当 $l=1$ 时才会出现这个 bug。\n\n那么依旧是分治计算出 $[l,mid]$ 后考虑计算 $[l,mid]$ 对 $[mid+1,r]$ 的贡献。若 $l=1$，则此时只知道 $[1,mid]$，那么不妨把 $[0,r-l]$ 拆成 $[0,mid]$ 和 $[mid+1,r-l]$，先计算 $[1,mid]\\times [0,mid]$，$[1,mid]\\times [mid+1,r-l]$ 在 $[mid+1,r-l]$ 的某些信息明确后再计算。\n\n具体的，分治计算 $[l,r]$ 时若 $l=r$ 则返回，否则先分治计算 $[l,mid]$，接下来分讨：\n\n- 若 $l=1$，则计算 $[1,mid]\\times [0,mid]$，贡献到 $[mid+1,r]$；\n\n- 否则先计算 $[l,mid]\\times [0,r-l]$，贡献到 $[mid+1,r]$，再计算 $[0,r-l]\\times [l,mid]$，同样贡献到 $[mid+1,r]$；\n\n  注意应用时可能会带一些系数，所以可能不满足交换律；\n\n例题：[【2025NOI模拟赛01】青蛙](../【2025NOI模拟赛01】青蛙 做题记录/)\n",
			"tags": [{"name":"学习笔记"},{"name":"多项式、生成函数"},{"name":"小技巧"}],
			"title": "分治 NTT 学习笔记",
			"link": "https://exber.qzz.io/post/%E5%88%86%E6%B2%BB%20NTT%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2024-08-08 19:15:23"
		},
	
		{
			"abstract": "",
			"content": "### Part 1 介绍\n\n广义串并联图，就是不存在同胚于 $K4$ 的子图的无向图。\n\n翻译一下就是不存在这样的结构：\n\n![](../post-images/1720255598861.png)\n\n$n$ 点 $m$ 边的广义串并联图有如下性质：\n\n1. 是平面图；\n\n2. 删掉重边后 $m\\le 2n$；\n\n3. 可以通过不断重复以下操作缩成一个点：\n    - 删一度点（$a- b$ 变为 $a$）；\n    - 缩二度点（$a-b-c$ 变为 $a-c$）；\n    - 叠合重边；\n\n4. 去掉重边后可以从一个点不断重复以下操作构造：\n\n    - 加入一个新点，并和原图中的点连一条边；\n    - 选择原图中原有的一条边 $a-b$，加入一个点 $c$，连边 $c-a$ 和 $c-b$，原来的边 $a-b$ 可以任意删或不删；\n\n    分别对应性质 3 中的删一度点和缩二度点。\n\n    通过这条性质不难证明性质 2；\n\n广义串并联图的性质和结构并不是很重要，重要的是性质 3 中的三个操作，不妨称其为“广义串并联操作”。\n\n对于任意一个 $n$ 点 $m$ 边的无向图，设 $k=m-n$，不断在该图上重复广义串并联操作，则容易发现 $m-n$ 一定不会变大（删一度点和缩二度点不变，叠合重边减一），并且最后得到的图每个点度数 $\\ge 3$，所以有 $2m'\\ge 3n',m'\\le n'+k$，解得 $n'\\le 2k,m'\\le 3k$。\n\n也就是说，广义串并联操作可以将任意无向图变成 $O(m-n)$ 的图，并且原图的信息在新图上比较好维护。\n\n### Part 2 例题\n\n#### 2.1 典题\n\n> 给定一个 $n$ 点 $m$ 边的无向图，求给每条边定向的方案数，满足定向后的图是 DAG。\n>\n> $1\\le n,m\\le 10^5$，$m\\le n+10$。\n\n$n\\le 20$ 是简单的，枚举入度为 $0$ 的那一层转移即可。但是要容斥一下还有别的点入度为 $0$ 的情况，所以有：\n$$\nf_{s}=\\sum\\limits_{t\\subseteq s,t\\not=\\varnothing} (-1)^{|t|+1}\\times f_{s-t}\\times h_t\n$$\n其中若集合 $t$ 中点之间没有边则 $h_t=1$，否则其为 $0$。\n\n那么对于本题，考虑使用广义串并联操作将原图缩小。对于每条边（注意进行过广义串并联操作后该边可能对应原图中的若干点和边），设两个值 $(f,g)$ 分别表示两端连通但**未确定具体方向**（存在 $u\\to v$ 的路径或 $v\\to u$ 的路径）和两端不连通的方案数，初始每条边都是 $(1,0)$。\n\n考虑三种操作的影响：\n\n- 删一度点：它连出去的唯一边随便定向，直接将 $2f+g$ 乘入答案，并把这个点删掉；\n\n- 缩二度点：\n\n  设二度点 $u$ 的两个邻居是 $x$ 和 $y$，两条边分别是 $(f_1,g_1)$ 和 $(f_2,g_2)$，新的边是 $(f',g')$。\n\n  - 只有当 $x,u$ 和 $u,y$ 都连通且方向一致时 $x,y$ 才连通，故 $f'=f_1f_2$；\n  - $x,u$ 或 $u,y$ 至少一个不连通，或者 $x\\to u,u\\leftarrow y$ 或 $x\\leftarrow u,u\\to y$ 时 $x,y$ 不连通，故 $g'=2f_1g_2+2g_1f_2+g_1g_2+2f_1f_2$；\n\n  然后把 $u$ 删掉；\n\n- 叠合重边：\n\n  - 两条重边至少一条连通 $x,y$ 就连通，并且这些重边必定同向（否则有环），故 $f'=f_1f_2+f_1g_2+g_1f_2$；\n  - 两条重边都不连通 $x,y$ 才不连通，故 $g'=g_1\\times g_2$；\n\n最后统计答案的时候先将 $\\prod (f+g)$ 乘进答案里，对于转移时钦定的没有入度的点集，系数 $h_t$ 即为集合 $t$ 内点之间边 $(f,g)$ 的 $\\frac{g}{f+g}$ 之积。\n\n因为没有二度点，所以这样做一定是对的。\n\n很多广义串并联图的题目都可以用类似设 $(f,g)$ 的方法解决。\n\n### Part 3 更多题目\n\n- [P6790 [SNOI2020] 生成树](https://www.luogu.com.cn/problem/P6790)\n- [AT_pakencamp_2018_day2_g グランド・グラフ　(Grand Graph)](https://www.luogu.com.cn/problem/AT_pakencamp_2018_day2_g)\n- [P8426 [JOI Open 2022] 放学路（School Road）](https://www.luogu.com.cn/problem/P8426)\n",
			"tags": [{"name":"学习笔记"},{"name":"图论"}],
			"title": "广义串并联图学习笔记",
			"link": "https://exber.qzz.io/post/%E5%B9%BF%E4%B9%89%E4%B8%B2%E5%B9%B6%E8%81%94%E5%9B%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2024-07-05 19:55:12"
		},
	
		{
			"abstract": "",
			"content": "$m$ 次单位根 $\\omega_m$：$\\omega_m^m=1$ 且 $\\forall 1\\le i\\le m$，$\\omega_{m}^i$ 互不相同。\n\n单位根反演：\n$$\n[m|x]=\\frac{1}{m}\\sum\\limits_{i=1}^m\\omega_m^{ix}\\qquad(1)\\\\\n[x\\equiv r\\pmod m]=\\frac{1}{m}\\sum\\limits_{i=1}^m\\omega_m^{i(x-r)}\\qquad(2)\n$$\n\n证明：\n\n> 由 $(1)$ 易得 $(2)$，下面证明 $(1)$。\n>\n> 显然若 $m|x$ 则相当于 $\\frac{1}{m}\\sum\\limits_{i=1}^m 1^{\\frac{ix}{m}}=1$。\n>\n> 若 $m\\nmid x$，则相当于 $\\frac{1}{m}\\sum\\limits_{i=1}^m(\\omega_m^{x})^i$，此时 $\\omega_m^x\\not=1$，运用等比数列求和公式得 $\\frac{1}{m}\\times \\frac{\\omega_m^x-\\omega_m^x\\omega_m^{xm}}{1-\\omega_m^x}=\\frac{1}{m}\\times \\frac{\\omega_m^x-\\omega_m^x}{1-\\omega_m^x}=0$。\n>\n\n例题：\n$$\n\\begin{aligned}\n\\sum\\limits_{i=0}^n [i\\equiv r\\pmod m]\\binom{n}{i}&=\\frac{1}{m}\\sum\\limits_{i=0}^n \\binom{n}{i}\\sum\\limits_{j=1}^m \\omega_m^{j(i-r)}\\\\&=\\frac{1}{m}\\sum\\limits_{j=1}^m\\frac{1}{\\omega_m^{jr}}\\sum\\limits_{i=0}^n\\binom{n}{i}\\omega_m^{ji}\\\\&=\\frac{1}{m}\\sum\\limits_{j=1}^m\\frac{1}{\\omega_m^{jr}}(\\omega_m^j+1)^n\n\\end{aligned}\n$$\n",
			"tags": [{"name":"学习笔记"},{"name":"数学"},{"name":"数论"}],
			"title": "单位根反演学习笔记",
			"link": "https://exber.qzz.io/post/%E5%8D%95%E4%BD%8D%E6%A0%B9%E5%8F%8D%E6%BC%94%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2024-02-27 16:37:49"
		},
	
		{
			"abstract": "",
			"content": "### DDDDD 问题\n\n> 给一个正整数 $N$ 和 一个正个位数 $D$，求至少多少个 $D$ 组成的 $\\overline{DD\\dots DD}$ 可以被 $N$ 整除。\n>\n> $1\\le N\\le 2\\times 10^9$。\n\n显然 $\\overline{DD\\dots DD}$ 可以表示为 $\\frac{D\\times(10^k-1)}{9}$，推一波式子：\n$$\nN\\mid\\frac{D\\times(10^k-1)}{9}\\\\\n9N\\mid D\\times (10^k-1)\\\\\n设\\,d=\\gcd(D,9N):\\\\\n\\frac{9N}{d}\\mid10^k-1\\\\\n10^k\\equiv1\\pmod{\\frac{9N}{d}}\n$$\n此时，若 $10$ 和 $\\frac{9N}{d}$ 不互质那么无解。\n\n考虑如何求出 $k$ 的最小值，即答案，根据欧拉定理，有：\n$$\n10^{\\varphi(\\frac{9N}{d})}\\equiv 1\\pmod{\\frac{9N}{d}}\n$$\n此时最小的 $k$ 一定是 $\\varphi(\\frac{9N}{d})$ 的因子.\n\n<details><summary>证明</summary><p>\n\n> 设 $\\varphi(\\frac{9N}{d})=M$，假如最小的 $k=x$ 且 $x\\nmid M$，那么设 $M=qx+r$；\n> \n> 因为 $10^x\\equiv 1\\pmod{\\frac{9N}{d}}$，所以 $10^{qx}\\equiv 1\\pmod{\\frac{9N}{d}}$；\n> \n> 由于 $10^M\\equiv 1\\pmod{\\frac{9N}{d}}$ 所以 $10^{qx+r}\\equiv1\\pmod{\\frac{9N}{d}}$，$10^r\\equiv 1\\pmod{\\frac{9N}{d}}$；\n> \n> 由于 $0\\le r<x$，所以 $r$ 比 $x$ 更小，矛盾。\n</p></details>\n\n那么枚举 $\\varphi(\\frac{9N}{d})$ 的因子，快速幂判断即可。\n\n### 树的带权拓扑序问题\n\n> 给定一棵有根树，每个点有个权值 $a_i$，对于该树的所有拓扑序 $p$，求 $\\sum a_ip_i$ 的最大值。\n\n设 $a$ 的最小值为 $a_u$，那么不难发现一定有 $p_u=p_{fa_u}+1$。\n\n那么不妨把 $u$ 和 $fa_u$ 缩起来，给答案增加 $a_u$。\n\n对于两个连通块 $x,y$，设其点数和 $a_i$ 总和为 $(siz_x,sm_x)$ 和 $(siz_y,sm_y)$，那么 $x$ 在 $y$ 前贡献为 $siz_x\\times sm_y$，$y$ 在 $x$ 前贡献为 $siz_y\\times sm_x$，所以 $x$ 排在 $y$ 前当且仅当 $siz_x\\times sm_y\\ge siz_y\\times sm_x$ 即 $\\frac{sm_x}{siz_x}\\ge\\frac{sm_y}{siz_y}$。\n\n那么把连通块权值当成 $\\frac{sm}{siz}$ 看作正常点即可。\n\n合并 $u$ 的连通块 $(siz_u,sm_u)$ 和 $fa_u$ 的连通块 $(siz_{fa_u},sm_{fa_u})$ 会给答案增加 $siz_{fa_u}\\times sm_u$，边合并边计算即可。\n\n使用堆维护，时间复杂度 $O(n\\log n)$。\n\n### 区间虚树大小问题\n\n> 给定一棵有点权的有根树和一个节点序列 $a$，$q$ 次询问，每次求 $a_{[l,r]}$ 到根的路径覆盖到的所有点的点权和。\n>\n> 可以离线。\n\n可以回滚莫队维护，$O(n\\sqrt n)$。\n\n也可以先树剖再启发式合并维护每个点子树中点在 $a$ 中出现位置的集合，先把 $u$ 的贡献算进其重儿子，启发式合并维护轻儿子的贡献。\n\n具体的，令 $u$ 的子树大小为子树中每个点在 $a$ 中出现的次数之和，按照这个定义进行重链剖分。\n\n剖分完令 $w_u$ 为 $u$ 到其所在重链链顶的点权和，$st_u$ 为 $u$ 子树中每个点在 $a$ 中出现位置的集合，则 $st_u$ 直接从 $st_{hev_u}$ 继承（$hev_u$ 为 $u$ 的重儿子），然后把 $u$ 在 $a$ 中的出现位置插入到 $st_u$，再遍历 $u$ 的轻儿子 $v$，把 $x\\in st_v$ 插入到 $st_u$。\n\n每次插入 $x$ 找到其前驱后继 $lb,rb$，给 $l\\in [lb,x],r\\in [x,rb]$ 的所有区间 $[l,r]$ 增加 $w_u$ 的贡献，这个可以离线再用扫描线维护。\n\n这样由于轻儿子 $st_v$ 的大小总是不超过 $st_u$ 的大小，所以时间复杂度是启发式合并的复杂度，总复杂度 $O(n\\log ^2n)$。\n\n参考：[【2024NOI模拟赛11】项链 做题记录](../【2024NOI模拟赛11】项链 做题记录)\n",
			"tags": [{"name":"学习笔记"},{"name":"小技巧"}],
			"title": "一些经典问题",
			"link": "https://exber.qzz.io/post/%E4%B8%80%E4%BA%9B%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98",
			"date": "2024-02-25 20:59:27"
		},
	
		{
			"abstract": "",
			"content": "公平组合游戏：双方操作形式相同，先手操作一次后相当于交换先后手。\n\n## Part 1 Nim 游戏\n\n> 有 $n$ 个非负整数 $\\{a_i\\}$，双方轮流选择一个 $1\\le id\\le n$ 并将 $a_{id}$ 减少任意正整数，不能操作者输。\n\n先抛结论，先手必胜当且仅当 $\\oplus a_i\\not=0$。\n\n证明考虑归纳，显然 $\\forall a_i=0$ 的状态满足该结论。假设对于某个状态 $\\{a_i\\}$，已经证明其能到达的所有状态（满足 $b_i\\le a_i$ 且和 $\\{a_i\\}$ 不相同的状态 $\\{b_i\\}$）满足该结论，那么设当前异或和为 $x$：\n\n- 若 $x=0$ 那么无论怎么操作都会到达异或和不为 $0$ 的状态，即当前状态先手必败；\n- 否则设 $2^y$ 为 $x$ 的二进制最高位，那么一定存在某个 $j$ 满足 $a_j$ 该位也为 $1$，那么有 $a_j\\oplus x<a_j$，所以先手可以通过将 $a_j$ 修改为 $a_j\\oplus x$ 来到达异或和为 $0$ 的状态，即当前状态先手必胜；\n\n即 $\\{a_i\\}$ 也满足该结论，证毕。\n\n## Part 2 DAG 走路游戏和 SG 定理\n\n> 有一个有向无环图，初始某个点上有一个棋子，双方轮流沿着有向边推动棋子，无法操作者输。\n\n几乎所有公平组合游戏都能转换为该游戏。\n\n对于节点 $x$，设 $SG(x)=\\text{mex}\\{SG_v\\}$，其中 $v$ 是 $x$ 的所有后继节点，$\\text{mex}(S)$ 表示最小的不在集合 $S$ 中的非负整数。\n\n特别的，若 $x$ 没有后继节点，则 $SG(x)=0$。\n\nSG 引理断言：\n\n> 多个棋子情况下，棋子集合为 $\\{s_i\\}$ 的 DAG 走路游戏先手必胜当且仅当 $\\oplus SG(s_i)\\not=0$。\n\n证明考虑归纳，边界情况显然满足。\n\n对于 $x$ 的所有后继 $v$，显然 $SG(v)\\not=SG(x)$，且走到 $SG(v)>SG(x)$ 的 $v$ 是没有意义的，因为可以走回某一个 $SG(y)=SG(x)$ 的 $y$。\n\n由于 $\\forall s<SG(x)$ 都存在一个 $v$ 满足 $SG(v)=s$，所以这就是一个 Nim 游戏，根据 Nim 游戏的结论即可证明 SG 引理。\n\n同理，有推论：\n\n> SG 定理：多个棋子情况下，棋子集合为 $\\{s_i\\}$ 的 DAG 走路游戏满足 $SG(\\{s_i\\})=\\oplus SG(s_i)$。\n\n证明依旧是归纳，边界情况显然成立。\n\n对于一个状态 $\\{s_i\\}$，显然 $\\oplus SG(s_i)$ 是无法达到的，而对于 $x<\\oplus SG(s_i)$ 的 $x$，证明类比 Nim 游戏结论的证明，这些 $x$ 一定都能达到，故 $SG(\\{s_i\\})=\\oplus SG(s_i)$。\n\n## Part 3 一些特殊的游戏\n\n### 3.1 二分图游戏\n\n> 有一个二分图，初始有一个棋子在 $s$，每次可以将棋子移到相邻的点，不能移动到重复的点，无法操作的人输。\n\n<details><summary>结论</summary><p>\n\n\n> 定理 3.1：一个点 $u$ 先手必胜当且仅当其在所有最大匹配中。\n\n<details><summary>证明</summary><p>\n\n> 首先若 $u$ 不和任何点相连时显然满足定理 3.1。\n>\n> 先手必败情况证明：\n>\n> > 考虑若存在某个最大匹配 $M$，满足 $u$ 不在 $M$ 中，那么与 $u$ 有边相连的点 $v$，一定都在匹配 $M$ 中（否则 $(u,v)$ 可以加入匹配 $M$），那么后手只要每次移动到 $M$ 中对应匹配点上即可。\n>\n> 先手必胜情况证明：\n>\n> > 若 $u$ 在所有最大匹配中，那么先手可以随便选择一个最大匹配 $M$，从 $u$ 走到其匹配点 $v$，并把匹配 $(u,v)$ 删掉。\n> >\n> > 由于 $u$ 在所有最大匹配中，所以此时 $M$ 一定还是最大匹配，而 $v$ 不在匹配 $M$ 中，故是先手必败情况。\n>\n\n</p></details>\n\n判断一个点是否在所有最大匹配中是简单的，只要删掉这个点跑一次最大匹配和删点前的最大匹配比较即可。\n\n如果要判断每个点是否在所有最大匹配，那么可以跑网络流，再判断能否退流。具体的，对于匹配 $(u,v)$，判断是否存在 $S$ 到 $v$ 的路径即可，若有则 $u$ 不在所有最大匹配中。\n\n</p></details>\n\n### 3.2 翻转黑白棋游戏\n\n> 局面上有一些黑白棋，棋子总数不变，每次操作形如：\n>\n> - 若 $x$ 为白色则可以翻转满足 $s\\in S_x$ 的集合 $s$ 中棋子的颜色（$S_x$ 为集合组成的集合）；\n>\n> **操作保证不能无限进行，终止局面为全黑。**\n\n<details><summary>结论</summary><p>\n\n\n> 定理 3.2：用白棋位置的集合来表示一个局面，则 $SG(\\{a_1,a_2,\\dots,a_k\\})=\\oplus_{i=1}^k SG(\\{a_i\\})$，即可以看作是若干个只有一个白棋的独立游戏。\n\n<details><summary>证明</summary><p>\n\n> 首先只有一个白棋的情况显然满足。\n>\n> 而对于一个局面 $\\{a_i\\}$，显然其能进行的操作为 $\\cup S_{a_i}$，故拆成独立游戏后并不影响可行的操作集合。而取反了集合 $\\{s_i\\}$ 的操作相当于让总的 SG 值异或上 $\\oplus SG(s_i)$，由于颜色翻转相当于异或 $1$，而两个 $SG(s_i)$ 会抵消，故当前局面满足结论。\n\n</p></details>\n\n</p></details>\n",
			"tags": [{"name":"学习笔记"},{"name":"博弈论"},{"name":"数学"}],
			"title": "公平组合游戏学习笔记",
			"link": "https://exber.qzz.io/post/%E5%85%AC%E5%B9%B3%E7%BB%84%E5%90%88%E6%B8%B8%E6%88%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2024-02-23 16:21:46"
		},
	
		{
			"abstract": "> 有 $n$ 个大小为 $2$ 的照片堆，每张照片可以用一个二元组 $(a,b)$ 描述，每个堆可以用一个四元组 $(a1,b1,a2,b2)$ 描述，表示堆顶的照片为 $(a1,b1)$，堆底的照片为 $(a2,b2)$。\n>\n> Alice 和 Bob 要轮流取照片，Alice 先手，轮到某个人取时他可以选择跳过，若一轮中两人均选择跳过则游戏结束。\n>\n> 对于一张照片 $(a,b)$，Alice 取它能获得 $a$ 分，Bob 能获得 $b$ 分，位于堆底的照片要等到相应堆顶的照片被取掉才能取。\n>\n> 记 Alice 的得分和为 $ta$，Bob 的为 $tb$。Alice 的目标是最大化 $ta-tb$，Bob 则要最大化 $tb-ta$。\n>\n> 两人绝顶聪明，求出游戏结束时的 $ta-tb$。\n>\n> $1\\le n\\le 10^5$，$0\\le a1,b1,a2,b2\\le 10^9$。\n",
			"content": "> 有 $n$ 个大小为 $2$ 的照片堆，每张照片可以用一个二元组 $(a,b)$ 描述，每个堆可以用一个四元组 $(a1,b1,a2,b2)$ 描述，表示堆顶的照片为 $(a1,b1)$，堆底的照片为 $(a2,b2)$。\n>\n> Alice 和 Bob 要轮流取照片，Alice 先手，轮到某个人取时他可以选择跳过，若一轮中两人均选择跳过则游戏结束。\n>\n> 对于一张照片 $(a,b)$，Alice 取它能获得 $a$ 分，Bob 能获得 $b$ 分，位于堆底的照片要等到相应堆顶的照片被取掉才能取。\n>\n> 记 Alice 的得分和为 $ta$，Bob 的为 $tb$。Alice 的目标是最大化 $ta-tb$，Bob 则要最大化 $tb-ta$。\n>\n> 两人绝顶聪明，求出游戏结束时的 $ta-tb$。\n>\n> $1\\le n\\le 10^5$，$0\\le a1,b1,a2,b2\\le 10^9$。\n\n\n考虑每堆只有一张照片的情况，由于 $0\\le a,b$ 所以每张照片必然都会被取走，那么考虑先令 $ta=\\sum a,tb=\\sum b$，则 Alice 取走 $(x,y)$ 会令 $ta-tb$ 加上 $x+y$，Bob 取走它也会令 $tb-ta$ 加上 $x+y$，所以两人必然会按照 $a+b$ 从大到小的顺序取走照片。\n\n考虑推广到原题，但是有个问题就是不一定每张照片都被取走。考虑这样做的深层原因，对于两张照片 $(x1,y1)$ 和 $(x2,y2)$，若 $x1+y1>x2+y2$，则变形可得 $x1-y2>x2-y1$ 和 $y1-x2>y2-x1$，也就是说无论先后手先取 $(x1,y1)$ 肯定优。\n\n那么不难发现对于一个照片堆 $(a1,b1,a2,b2)$：\n\n- 若 $a1+b1\\ge a2+b2$，则两人都想取走上面那个，那么对于这些堆中的照片按照 $x+y$ 从大到小排序，轮流取即可。注意这样堆顶的照片一定会先被取走；\n- 否则 $a1+b1<a2+b2$，则变形得 $(a1-b2)+(b1-a2)<0$：\n  - 若 $a1-b2<0$ 且 $b1-a2<0$，则双方均不想动这堆，这堆对答案没贡献；\n  - 若 $a1-b2<0$ 且 $b1-a2>0$，则 Bob 会取这堆，对答案贡献 $a2-b1$；\n  - 若 $a1-b2>0$ 且 $b1-a2<0$，则 Alice 会取这堆，对答案贡献 $a1-b2$；\n\n时间复杂度 $O(n\\log n)$。\n",
			"tags": [{"name":"做题记录"},{"name":"贪心"},{"name":"博弈论"}],
			"title": "CF725F Family Photos 做题记录",
			"link": "https://exber.qzz.io/post/CF725F%20Family%20Photos%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2024-02-17 15:53:21"
		},
	
		{
			"abstract": "",
			"content": "## Part 1 斜率优化\n\n> 在线维护两种操作：\n>\n> - 插入直线 $(k_i,b_i)$；\n> - 给定 $x$，查询 $k_ix+b_i$ 的最大/最小值（可能有第二关键字）；\n>\n> 保证 $k_i$ 单调，$x$ 单调。\n\n这里以 $k_i$ 单调不降，$x$ 单调不增，查询最小值为例。\n\n直接做也可以，但是我写了调不出来。\n\n首先做一个神秘转化：把直线变成点 $(k_i,b_i)$，查询的时候变成求过 $(k_i,b_i)$ 的斜率为 $-x$ 的直线的最小截距：\n\n![](../post-images/1706018317951.png)\n\n考虑有两个点的情况，设它们分别是 $(x1,y1)$ 和 $(x2,y2)$（$x1<x2$）。观察它们的连线，其斜率为 $k=\\frac{y2-y1}{x2-x1}$，不难发现 $-x=k$ 时它们对应的截距相同（红线），$-x>k$ 时 $(x2,y2)$ 更优（绿线），$-x<k$ 时 $(x1,y1)$ 更优（蓝线）：\n\n![](../post-images/1706068131029.png)\n\n暂时不考虑三点共线，考虑加入的第三个点 $(x3,y3)$，设其与 $(x1,y1)$ 连线的斜率为 $k_{1,3}$，$(x1,y1)$ 与 $(x2,y2)$ 连线的斜率为 $k_{1,2}$，则：\n\n- 若 $k_{1,3}<k_{1,2}$（左图），则：\n  - $-x<k_{1,3}<k_{1,2}$ 时 $(x1,y1)$ 更优；\n  - $k_{1,3}<-x<k_{1,2}$ 时 $(x3,y3)$ 更优；\n  - $k_{1,3}<k_{1,2}<-x$ 时 $(x3,y3)$ 更优；\n  - $-x=k_{1,3}<k_{1,2}$ 时 $(x1,y1)$ 和 $(x3,y3)$ 均比 $(x2,y2)$ 优；\n  - $k_{1,3}<-x=k_{1,2}$ 时 $(x3,y3)$ 更优；\n  \n  所以 $(x2,y2)$ 无论怎样都不优，可以直接抛弃；\n  \n- 否则 $k_{1,3}>k_{1,2}$（右图），则：\n\n  - $-x<k_{1,2}<k_{1,3}$ 时 $(x1,y1)$ 更优；\n  - $k_{1,2}<-x<k_{1,3}$ 时 $(x2,y2)$ 更优；\n  - $k_{1,2}<k_{1,3}<-x$ 时 $(x3,y3)$ 更优；\n\n![](../post-images/1706068634810.png)\n\n而若三点共线，则若没有第二关键字则 $(x2,y2)$ 没用；否则设第二关键字为 $z1,z2,z3$，则 $(x2,y2,z2)$ 有用当且仅当 $z2<z1,z3$。\n\n考虑四点共线的情况，由于插入的点满足 $x$ 升序，所以若前三个点均没被删掉，则必有 $z2<z1,z3$，则此时必然不满足 $z3<z2,z4$，那么 $(x3,y3,z3)$ 必然没用。\n\n也就是说，仅判断 $z2$ 和 $z1,z3$ 之间的关系来决定 $(x2,y2,z2)$ 的去留可以保证最终的结构中不存在四点共线。\n\n不难发现，有用的点构成一个下凸壳，即对于相邻三个点必有 $k_{1,2}\\le k_{1,3}$ 也即 $k_{1,2}\\le k_{2,3}$，即斜率不降；并且若没有第二关键字则不存在三点共线，否则不存在四点共线。\n\n考虑处理询问，注意到查询的 $x$ 单调不增，即 $-x$ 单调不降。由于 $k_{1,2}\\le k_{2,3}$ 且不存在四点共线，所以每个查询的最优决策点 $(x_{i},y_i,z_i)$ 一定满足 $x$ 单调不降，那么不断把不优的点删掉即可保证 $x$ 最小的点最优。\n\n注意到插入时下凸壳只会在末尾插入/删除，且查询时只会在开头删除，那么可以使用双端队列来维护下凸壳，时间复杂度 $O(n)$。\n\n代码如下：（带第二关键字）\n\n```cpp\ntemplate<typename T>\nstruct hull // k++ x-- min\n{\n\ttypedef long long ll;\n\tconst __int128 ill=1;\n\tstruct node\n\t{\n\t\tll x,y;\n\t\tT vl;\n\t};\n\tinline bool cmp(node x,node y,node z) // y is useful\n\t{\n\t\tll up1=y.y-x.y,dn1=y.x-x.x;\n\t\tll up2=z.y-x.y,dn2=z.x-x.x;\n\t\tauto lft=ill*up1*dn2,rig=ill*up2*dn1;\n\t\tif(lft<rig) return true;\n\t\tif(lft==rig&&(y.vl<x.vl&&y.vl<z.vl)) return true;\n\t\treturn false;\n\t}\n\tint ps=0;\n\tvector<node> q;\n\tinline void clr(){ps=0,q.clear();}\n\tinline void ins(ll k,ll b,T vl)\n\t{\n\t\tauto u=(node){k,b,vl};\n\t\twhile(q.size()-ps>=2)\n\t\t{\n\t\t\tint sz=q.size();\n\t\t\tif(cmp(q[sz-2],q[sz-1],u)) break;\n\t\t\telse q.pop_back();\n\t\t}\n\t\tq.push_back(u);\n\t}\n\tinline pair<ll,T> que(ll x)\n\t{\n\t\twhile(q.size()-ps>=2)\n\t\t{\n\t\t\tll v1=q[ps].x*x+q[ps].y,v2=q[ps+1].x*x+q[ps+1].y;\n\t\t\tif(v1<v2||(v1==v2&&q[ps].vl<q[ps+1].vl)) break;\n\t\t\telse ps++;\n\t\t}\n\t\treturn make_pair(q[ps].x*x+q[ps].y,q[ps].vl);\n\t}\n};\n```\n\n## Part 2 wqs 二分\n\n> 给定一个凸壳，满足该凸壳加上直线后的极值点好求，求 $x=w$ 时 $y$ 的值。\n\n经常用于去除 “恰好选 $k$ 个” 的限制。\n\n注意到由于凸壳具有凸性，所以凸壳上的每个点都可能变成切点，且由于相邻点斜率单调，所以可以二分求出 $(w,y)$ 作为切点时的斜率。\n\n> 切点 $(x,y)$：对于斜率 $k$，满足 $(x,y)$ 在凸壳上且过它的斜率为 $k$ 的直线和凸壳仅有 $(x,y)$ 一个交点；\n\n并且注意到对于一个斜率 $k$，只需要将凸壳加上直线 $y=-kx$ 再求极值点即可求出切点。\n\n那么仅需二分 $k$，将凸壳加上 $y=-kx$ 求出极值点 $(x,y)$（即切点），再根据 $x$ 与 $w$ 的大小关系进行二分即可。\n\n若凸壳上存在多点共线，则为了保证正确性还需保证求出的切点 $(x,y)$ 满足 $x$ 最小/最大。\n\n这样可以以一个 $\\log$ 的代价去掉个数限制。\n\n例题：[P5633 最小度限制生成树](https://www.luogu.com.cn/problem/P5633)\n",
			"tags": [{"name":"学习笔记"},{"name":"数学"},{"name":"小技巧"}],
			"title": "斜率优化 & wqs 二分 学习笔记",
			"link": "https://exber.qzz.io/post/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96%20%26%20wqs%20%E4%BA%8C%E5%88%86%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2024-01-23 21:58:26"
		},
	
		{
			"abstract": "> 给定一个长 $n$ 的序列 $a$，每次操作可以选择相邻三个元素 $a_{i-1},a_i,a_{i+1}$，将 $a_{i-1}$ 和 $a_{i+1}$ 都加上 $a_i$ 然后删掉 $a_i$。操作完后序列会自动补位，即 $a_{i-1}$ 和 $a_{i+1}$ 会相邻。\n>\n> 最后会剩下两个元素，最小化它们的和。\n>\n> $2\\le n\\le 18$，$1\\le a_i\\le 10^9$。\n",
			"content": "> 给定一个长 $n$ 的序列 $a$，每次操作可以选择相邻三个元素 $a_{i-1},a_i,a_{i+1}$，将 $a_{i-1}$ 和 $a_{i+1}$ 都加上 $a_i$ 然后删掉 $a_i$。操作完后序列会自动补位，即 $a_{i-1}$ 和 $a_{i+1}$ 会相邻。\n>\n> 最后会剩下两个元素，最小化它们的和。\n>\n> $2\\le n\\le 18$，$1\\le a_i\\le 10^9$。\n\n\n直接做不好做，考虑时光倒流。\n\n不难发现每个元素最终都会以某个系数算入答案，考虑一次操作本质上是把 $a_{i-1}$ 和 $a_{i+1}$ 的系数都加到 $a_i$ 的上，那么设 $f_{l,r,x,y}$ 表示 $a_l$ 的系数为 $x$，$a_r$ 的系数为 $y$ 时 $a_{[l,r]}$ 的最小贡献，那么有转移：\n$$\nf_{l,r,x,y}=\\min\\limits_{l< k< r}\\{f_{l,k,x,x+y}+f_{k,r,x+y,y}-a_k\\times (x+y)\\}\n$$\n减掉是因为重复算了。\n\n这样状态数最多是 $O(n^22^n)$ 的，足以通过本题。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <map>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int S=25;\nconst ll inf=1e17;\n\nint n,a[S];\nmap<tuple<int,int,int,int>,ll> f;\n\nll dfs(int l,int r,int fl,int fr)\n{\n\tif(l+1==r) return 1ll*a[l]*fl+1ll*a[r]*fr; \n\ttuple<int,int,int,int> u(l,r,fl,fr);\n\tif(f.count(u)) return f[u];\n\tf[u]=inf;\n\tfor(int k=l+1;k<=r-1;k++)\n\t{\n\t\tll lb=dfs(l,k,fl,fl+fr),rb=dfs(k,r,fl+fr,fr);\n\t\tf[u]=min(f[u],lb+rb-1ll*(fl+fr)*a[k]);\n\t}\n\treturn f[u];\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tprintf(\"%lld\\n\",dfs(1,n,1,1));\n\treturn 0;\n}\n```\n\n",
			"tags": [{"name":"做题记录"},{"name":"DP"},{"name":"结论"}],
			"title": "AGC035D Add and Remove 做题记录",
			"link": "https://exber.qzz.io/post/AGC035D%20Add%20and%20Remove%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2024-01-16 21:50:42"
		},
	
		{
			"abstract": "> 给定一个长 $n$ 的序列 $a$，每次操作可以选择一个区间 $[l,r]$ 将其删去，代价为 $A+B\\times \\left(\\max\\limits_{l\\le i\\le r}\\{a_i\\}-\\min\\limits_{l\\le i\\le r}\\{a_i\\}\\right)$，其中 $A$ 和 $B$ 是给定的常数。\n>\n> 一个区间被删掉后两边的元素会自动补齐空位，求把序列删空的最小代价。\n>\n> $1\\le n\\le 50$，$1\\le A\\le 1500$，$1\\le B \\le 10$，$1\\le w_i\\le 1000$。\n",
			"content": "> 给定一个长 $n$ 的序列 $a$，每次操作可以选择一个区间 $[l,r]$ 将其删去，代价为 $A+B\\times \\left(\\max\\limits_{l\\le i\\le r}\\{a_i\\}-\\min\\limits_{l\\le i\\le r}\\{a_i\\}\\right)$，其中 $A$ 和 $B$ 是给定的常数。\n>\n> 一个区间被删掉后两边的元素会自动补齐空位，求把序列删空的最小代价。\n>\n> $1\\le n\\le 50$，$1\\le A\\le 1500$，$1\\le B \\le 10$，$1\\le w_i\\le 1000$。\n\n\n设 $f_{l,r}$ 表示把 $a_{[l,r]}$ 删掉的最小代价，但是发现转移不了，因为不知道最后一次删除时序列长什么样。\n\n那么考虑设 $g_{l,r,x,y}$ 表示把 $a_{[l,r]}$ 删至所有剩下的数都在 $[x,y]$ 中的最小代价，则有：\n$$\nf_{l,r}=\\min\\limits_{x\\le y}\\{g_{l,r,x,y}+A+B(x-y)\\}\n$$\n而 $g$ 可以通过枚举剩下的数中最靠左/靠右的来转移：\n$$\ng_{l,r,x,y}=\\min\\left(\\min\\limits_{l\\le k<r}\\{g_{l,k,x,y}+f_{k+1,r}\\},\\min\\limits_{l<k\\le r}\\{f_{l,k-1}+g_{k,r,x,y}\\}\\right)\n$$\n特别的，若 $a_{[l,r]}\\in [x,y]$，则 $g_{l,r,x,y}=0$。\n\n那么时间复杂度 $O(n^3V^2)$，可以通过本题。\n",
			"tags": [{"name":"做题记录"},{"name":"DP"}],
			"title": "P5336 [THUSC2016] 成绩单 做题记录",
			"link": "https://exber.qzz.io/post/P5336%20%5BTHUSC2016%5D%20%E6%88%90%E7%BB%A9%E5%8D%95%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2024-01-10 21:57:46"
		},
	
		{
			"abstract": "> 给定 $n,m,k$，考虑对某个 $n$ 的排列 $A$（标号 $0\\sim n-1$）做如下操作：\n>\n> - 从 $0$ 到 $k-1$ 枚举 $i$，把 $[A_{i\\text{ mod }n},A_{(i+1)\\text{ mod }n},A_{(i+2)\\text{ mod }n},\\dots,A_{(i+m-1)\\text{ mod }n}]$ 拿出来升序排序再放回去；\n>\n> 给定一个 $n$ 的排列 $B$，求有多少个 $A$ 满足操作完后会变成 $B$。\n>\n> $1\\le m\\le n\\le 3\\times 10^5$，$1\\le k\\le 10^9$。\n",
			"content": "> 给定 $n,m,k$，考虑对某个 $n$ 的排列 $A$（标号 $0\\sim n-1$）做如下操作：\n>\n> - 从 $0$ 到 $k-1$ 枚举 $i$，把 $[A_{i\\text{ mod }n},A_{(i+1)\\text{ mod }n},A_{(i+2)\\text{ mod }n},\\dots,A_{(i+m-1)\\text{ mod }n}]$ 拿出来升序排序再放回去；\n>\n> 给定一个 $n$ 的排列 $B$，求有多少个 $A$ 满足操作完后会变成 $B$。\n>\n> $1\\le m\\le n\\le 3\\times 10^5$，$1\\le k\\le 10^9$。\n\n\n由于 $k$ 很大，所以猜测操作很多次是没用的。\n\n观察到若 $k>n-m+1$ 则后 $k-(n-m+1)$ 次操作相当于拉着前 $m-1$ 大值在转圈，所以这些操作是没用的，仅需把前 $m-1$ 大值复位即可归约到 $k=n-m+1$ 的情况。\n\n不难发现 $k<n-m+1$ 的情况可以通过删掉操作没影响到的一段后缀来归约到 $k=n-m+1$ 的情况，所以仅需讨论 $k=n-m+1$ 情况下的做法。\n\n不难发现，若 $B_{i-1}>B_i$ 则 $B_i$ 一定填入 $A_{i+m-1}$，否则：\n\n- 若 $B_i$ 是前缀最大值，则其可以找 $A_{[1,i+m-1]}$ 中随便一个未填数的位置填入，有 $m$ 种方案；\n\n- 若 $B_i$ 不是前缀最大值，则 $B_i$ 一定填入 $A_{i+m-1}$，证明如下：\n\n  > 若 $B_{i-1}>B_i$ 则证明完毕，否则找到 $B_i$ 前面最靠后的 $>B_i$ 的 $B_j$，则 $B_i$ 一定不能填入 $A_{[j,j+m-1]}$。\n  >\n  > 观察到 $B_j>B_{[j+1,i]}$，所以 $B_{j+1}$ 一定填入 $A_{j+m}$，$B_{j+2}$ 原本可以填入 $A_{[j+m,j+m+1]}$，可 $A_{j+m}$ 被占用，所以它只能填入 $A_{j+m+1}$。这样一直循环进行，最终 $A_{[j+m,i+m-2]}$ 均被占用，所以 $B_i$ 仅能填入 $A_{i+m-1}$。\n  >\n  > Q.E.D.\n\n那么设 $B_{[0,k-1]}$ 有 $cnt$ 个前缀最大值，答案即为 $m^{cnt}(m-1)!$，最后的阶乘是因为最后一段的尾巴可以乱放。\n\n时间复杂度 $O(n)$，注意 $0$ 的判断，代码如下：\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=300005,p=998244353;\n\nint n,m,k,a[S];\nint b[S],c[S];\n\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tfor(int i=0;i<n;i++) scanf(\"%d\",&a[i]);\n\tif(k>n-m+1)\n\t{\n\t\tint lft=k-(n-m+1);\n\t\tint beg=((n-m+1)+lft)%n;\n\t\tfor(int i=0;i<m-1;i++) b[i]=a[(beg+i)%n];\n\t\tint siz=n-m+1;\n\t\tfor(int i=0;i<siz;i++) c[i]=a[(beg+m-1+i)%n];\n\t\tfor(int i=0;i<siz;i++) a[i]=c[((i-lft)%siz+siz)%siz];\n\t\tfor(int i=0;i<m-1;i++) a[siz+i]=b[i];\n\t\tk=n-m+1;\n\t}\n\tfor(int i=0;i<n;i++) b[i]=a[i];\n\tsort(b+k-1,b+k-1+m);\n\tfor(int i=k-1;i<=k-1+m-1;i++)\n\t{\n\t\tif(a[i]<a[k-1]||a[i]!=b[i]) return puts(\"0\"),0;\n\t}\n\tint ans=1;\n\tfor(int i=0;i<k;i++)\n\t{\n\t\tif(i==0||a[i]>a[i-1]) ans=1ll*ans*m%p;\n\t\telse a[i]=a[i-1];\n\t}\n\tfor(int i=1;i<m;i++) ans=1ll*ans*i%p;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n\n",
			"tags": [{"name":"做题记录"},{"name":"结论"},{"name":"组合计数"}],
			"title": "ARC149E Sliding Window Sort 做题记录",
			"link": "https://exber.qzz.io/post/ARC149E%20Sliding%20Window%20Sort%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-12-29 12:37:57"
		},
	
		{
			"abstract": "> 定义两个长 $n$ 的数组相似，当且仅当对于每一个区间 $[l,r]$，两个数组在该区间中最大值的位置相同。\n>\n> 给定 $n$ 的排列 $p$ 和一个长 $n$ 且缺了 $k$ 个值的数组 $a$，再给定一个大小为 $k-1$ 的集合 $S$。\n>\n> $q$ 次询问，每次给定一个整数 $d$，求能否将 $S\\cup\\{d\\}$ 以任意顺序填入 $a$ 的空缺位置使得 $a$ 和 $p$ 相似。\n>\n> 保证 $a,S,d$ 中元素两两不同。\n>\n> $1\\le n,q\\le 3\\times 10^5$，$2\\le k\\le n$，$1\\le a_i,S_i,d\\le 10^6$。\n",
			"content": "> 定义两个长 $n$ 的数组相似，当且仅当对于每一个区间 $[l,r]$，两个数组在该区间中最大值的位置相同。\n>\n> 给定 $n$ 的排列 $p$ 和一个长 $n$ 且缺了 $k$ 个值的数组 $a$，再给定一个大小为 $k-1$ 的集合 $S$。\n>\n> $q$ 次询问，每次给定一个整数 $d$，求能否将 $S\\cup\\{d\\}$ 以任意顺序填入 $a$ 的空缺位置使得 $a$ 和 $p$ 相似。\n>\n> 保证 $a,S,d$ 中元素两两不同。\n>\n> $1\\le n,q\\le 3\\times 10^5$，$2\\le k\\le n$，$1\\le a_i,S_i,d\\le 10^6$。\n\n\n首先观察到 $a$ 和 $p$ 相似当且仅当它们的笛卡尔树同构。\n\n那么对于一个空缺的位置 $u$，它填入的数至少要 $>$ 它子树的最大值 $mx_u$，并且至少要 $<$ 它父亲的值 $vf_u$。\n\n现在我们来证明，只要所有空缺位置填入的数都 $> mx_u$ 且 $<vf_u$ 那么 $a$ 就和 $p$ 相似。\n\n仅需证明互为祖先后代关系的空缺位置不会相互影响。\n\n考虑满足 $x$ 为 $y$ 祖先的两个空缺位置 $x,y$，显然有 $mx_x\\ge mx_y$ 且 $vf_x\\ge vf_y$，设 $x$ 填入的数为 $v_x$，$y$ 的为 $v_y$，那么 $v_x$ 和 $v_y$ 冲突当且仅当 $v_x<v_y$。此时必有 $mx_y\\le mx_x<v_x<v_y<vf_y\\le vf_x$，也就是说，交换 $v_x$ 和 $v_y$ 也还是合法的。那么只要找到了一组满足填入的数 $\\in[mx_u+1,vf_u-1]$ 的填法，就一定可以通过交换来让它合法。\n\n那么求出所有 $[mx_u+1,vf_u-1]$，问题变为：\n\n> 给定 $k$ 个区间 $[l,r]$ 和一个大小为 $k-1$ 的点的集合，$q$ 次询问，每次给定一个点 $d$，求 $S\\cup\\{d\\}$ 能否和区间一一匹配使得每个点都在对应区间内。\n\n若 $S\\cup\\{d\\}$ 固定，则这个问题有一个经典贪心：\n\n- 把区间按照 $l$ 从小到大排序，把点也从小到大排序；\n- 从小到大枚举位置 $p$：\n  - 加入 $l=p$ 的区间；\n  - 若存在点 $p$，则把它和当前已经加入的 $r$ 最小的区间匹配；\n- 若每次都能找到可以匹配的区间则有解，否则无解。\n\n考虑魔改一下这个贪心，直接在 $S$ 上跑，若有点找不到与之匹配的区间则无解，否则一定有一个区间失配，设该区间为 $[lb,rb]$。注意到这个贪心本质上是尽量让剩下的区间 $r$ 更大，所以 $d$ 一定要 $\\le rb$。\n\n同理，反过来做一遍这个贪心即可得出一个 $lb$ 表示 $d$ 一定要 $\\ge lb$。\n\n现在我们得知 $d\\in[lb,rb]$ 是必要条件，考虑证明它是充分的。\n\n注意到这是一个完美匹配问题，考虑用 Hall 定理描述其有解性。这类问题有一个结论：\n\n> 存在大小为 $k$ 的匹配当且仅当：\n>\n> - 把值域离散化到 $[1,k]$ 后，对于所有区间 $[l,r]$，被 $[l,r]$ 完全包含的区间个数 $\\le r-l+1$；\n\n那么设 $f(l,r)$ 表示被 $[l,r]$ 完全包含的区间个数，$g(l,r)$ 表示 $[l,r]$ 中点的个数，$h(l,r)=f(l,r)-g(l,r)$。\n\n若存在 $h(l,r)>1$ 则就算加入点 $d$ 也不合法，一定无解。\n\n若 $h(l,r)\\le 0$ 则不用管，设 $[L,R]=\\cap_{h(l,r)=1}[l,r]$，则仅需证明 $[L,R]=[lb,rb]$\n\n必要条件那里已经证明了 $lb\\le L,rb\\ge R$，现在仅需证明 $lb\\ge L,rb\\le R$。\n\n先来证明 $rb\\le R$，$lb\\ge L$ 同理。\n\n对于一个 $h(l,r)=1$ 的 $[l,r]$，必然有一个区间 $i$ 被它包含且无法被 $[l,r]$ 内点匹配，那么贪心肯定能找到 $r_i$，所以 $rb$ 必然 $\\le R$。\n\n那么证完了，$d\\in[lb,rb]$ 是充要条件。\n\n直接模拟即可，时间复杂度 $O(n\\log n)$。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n\nusing namespace std;\n\nconst int S=300005,BS=25;\nconst int inf=1e8;\n\nstruct node\n{\n\tint l,r;\n};\n\nint n,q,a[S],b[S];\nint m,idx[S],c[S];\nint mlog[S],mx[S][BS];\nint cnt,pos[S],rpos[S],ls[S],rs[S];\nint lb[S],rb[S];\nnode sg[S];\nbool vis[S];\nint L,R;\n\ninline int quemx(int l,int r)\n{\n\tint k=mlog[r-l+1];\n\tint x=mx[l][k],y=mx[r-(1<<k)+1][k];\n\treturn a[x]>a[y]?x:y;\n}\n\ninline void initmx()\n{\n\tmlog[0]=-1;\n\tfor(int i=1;i<=n;i++) mlog[i]=mlog[i>>1]+1;\n\tfor(int i=1;i<=n;i++) mx[i][0]=i;\n\tfor(int j=1;j<=mlog[n];j++)\n\t{\n\t\tfor(int i=1;i<=n-(1<<j)+1;i++)\n\t\t{\n\t\t\tint x=mx[i][j-1],y=mx[i+(1<<j-1)][j-1];\n\t\t\tmx[i][j]=a[x]>a[y]?x:y;\n\t\t}\n\t}\n}\n\nint built(int l,int r)\n{\n\tint u=++cnt;\n\tint rt=quemx(l,r);\n\trpos[pos[u]=rt]=u;\n\tls[u]=rt==l?0:built(l,rt-1);\n\trs[u]=rt==r?0:built(rt+1,r);\n\treturn u; \n}\n\nvoid dfs(int u,int x)\n{\n\trb[u]=x,lb[u]=0;\n\tif(b[pos[u]]!=0) x=min(x,b[pos[u]]);\n\tif(ls[u]!=0) dfs(ls[u],x),lb[u]=max(lb[u],max(lb[ls[u]],b[pos[ls[u]]]));\n\tif(rs[u]!=0) dfs(rs[u],x),lb[u]=max(lb[u],max(lb[rs[u]],b[pos[rs[u]]]));\n//\tprintf(\"%d(%d)[%d %d]: %d %d\\n\",u,pos[u],lb[u],rb[u],ls[u],rs[u]);\n}\n\ninline void getLR()\n{\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(b[i]==0) continue;\n\t\tif(b[i]<lb[rpos[i]]||b[i]>rb[rpos[i]]) return L=inf,R=-inf,void();\n\t}\n\tfor(int i=1;i<=m;i++) sg[i]=(node){lb[idx[i]],rb[idx[i]]};\n//\tfor(int i=1;i<=m;i++) printf(\"[%d %d]\\n\",sg[i].l,sg[i].r);\n\t// calc R\n\tfor(int i=1;i<=m;i++) vis[i]=false;\n\tsort(sg+1,sg+m+1,[&](node x,node y){return x.l<y.l;});\n\tsort(c+1,c+m,[&](int x,int y){return x<y;});\n\tpriority_queue<pair<int,int> > q;\n\tfor(int i=1,j=1;i<=m-1;i++)\n\t{\n\t\twhile(j<=m&&sg[j].l<=c[i]) q.push(make_pair(-sg[j].r,j)),j++;\n\t\twhile(!q.empty()&&-q.top().first<c[i]) q.pop();\n\t\tif(q.empty()) return L=inf,R=-inf,void();\n\t\tvis[q.top().second]=true;\n\t\tq.pop();\n\t}\n\tfor(int i=1;i<=m;i++) if(!vis[i]) R=sg[i].r;\n\t// calc L\n\tfor(int i=1;i<=m;i++) vis[i]=false;\n\tsort(sg+1,sg+m+1,[&](node x,node y){return x.r>y.r;});\n\tsort(c+1,c+m,[&](int x,int y){return x>y;});\n\twhile(!q.empty()) q.pop();\n\tfor(int i=1,j=1;i<=m-1;i++)\n\t{\n\t\twhile(j<=m&&sg[j].r>=c[i]) q.push(make_pair(sg[j].l,j)),j++;\n\t\twhile(!q.empty()&&q.top().first>c[i]) q.pop();\n\t\tif(q.empty()) return L=inf,R=-inf,void();\n\t\tvis[q.top().second]=true;\n\t\tq.pop();\n\t}\n\tfor(int i=1;i<=m;i++) if(!vis[i]) L=sg[i].l;\n}\n\ninline void slove()\n{\n\tscanf(\"%d%d\",&n,&q);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&b[i]);\n\tm=0;\n\tfor(int i=1;i<=n;i++) if(b[i]==0) idx[++m]=i;\n\tfor(int i=1;i<=m-1;i++) scanf(\"%d\",&c[i]);\n\tinitmx();\n\tcnt=0;\n\tbuilt(1,n);\n\tfor(int i=1;i<=m;i++) idx[i]=rpos[idx[i]]/*,printf(\">> %d\\n\",idx[i])*/;\n\tdfs(1,inf);\n\tfor(int i=1;i<=cnt;i++) lb[i]++,rb[i]--;\n\tgetLR();\n//\tprintf(\"%d %d\\n\",L,R);\n\twhile(q-->0)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tputs(L<=x&&x<=R?\"YES\":\"NO\");\n\t}\n}\n\nint main()\n{\n\tint T;\n\tscanf(\"%d\",&T);\n\twhile(T-->0) slove();\n\treturn 0;\n}\n/*\n1\n4 2\n4 1 3 2\n0 5 3 0\n2\n4\n6\n*/\n```\n\n",
			"tags": [{"name":"做题记录"},{"name":"图论"},{"name":"数学"},{"name":"结论"}],
			"title": "CF1718D Permutation for Burenka 做题记录",
			"link": "https://exber.qzz.io/post/CF1718D%20Permutation%20for%20Burenka%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-12-28 22:27:38"
		},
	
		{
			"abstract": "> 给定一张 $n$ 个点 $m$ 条边的无向图和一个正整数 $k$，边有边权表示机器人经过这条边消耗的电量，点 $1,2,3,\\dots,k$ 为充电中心。机器人可以在充电中心免费充满电。\n>\n> $q$ 组询问，每次给定两个节点 $s,t$，保证 $1\\le s,t\\le k$。你需要求解以下问题：\n>\n> - 若有一个机器人从 $s$ 出发，它的电池容量至少为多少才能顺利到达 $t$？\n>\n> $1\\le n,m,q\\le 3\\times 10^5$\n",
			"content": "> 给定一张 $n$ 个点 $m$ 条边的无向图和一个正整数 $k$，边有边权表示机器人经过这条边消耗的电量，点 $1,2,3,\\dots,k$ 为充电中心。机器人可以在充电中心免费充满电。\n>\n> $q$ 组询问，每次给定两个节点 $s,t$，保证 $1\\le s,t\\le k$。你需要求解以下问题：\n>\n> - 若有一个机器人从 $s$ 出发，它的电池容量至少为多少才能顺利到达 $t$？\n>\n> $1\\le n,m,q\\le 3\\times 10^5$\n\n\n首先有一个敏锐的观察，发现 $1\\le s,t\\le k$ 很有用，这意味着有一个策略是每到达一个新的点就去最近的充电中心充一次电是不劣的。\n\n观察出这个结论后，直接求出 $dis_u$ 表示 $u$ 到最近充电站的距离，那么对于一条路径 $E$，电池容量至少为 $\\max\\limits_{(u,v,w)\\in E}\\{dis_u+dis_v+w\\}$。\n\n那么做法就很显然了，求出 $dis_u$ 后把边 $(u,v,w)$ 变成 $(u,v,w+dis_u+dis_v)$，跑一遍 Kruskal 重构树即可。\n\n时间复杂度 $O((n+m)\\log n)$。\n",
			"tags": [{"name":"做题记录"},{"name":"图论"},{"name":"结论"}],
			"title": "CF1253F Cheap Robot 做题记录",
			"link": "https://exber.qzz.io/post/CF1253F%20Cheap%20Robot%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-12-28 21:04:40"
		},
	
		{
			"abstract": "",
			"content": "## Part 1 Border，Period 理论\n\n设有一长 $n$ 的字符串 $S$。\n\n### 1.1 定义\n\n- Border：\n\n  满足 $1\\le k<n$ 且 $S_{[1,k]}=S_{[n-k+1,n]}$ 的 $k$。\n\n  不妨把 $S$ 的 Border 放入集合 $B(S)$ 中。\n  \n  记 $B_l(S)$ 为 $\\max\\{k|k\\in B(S)\\}$。\n  \n- Period（周期元）：\n\n  满足 $1\\le k<n$ 且 $\\forall 1\\le i\\le n-k$ 都有 $S_i=S_{i+k}$ 的 $k$。\n\n  不妨把 $S$ 的 Period 放入集合 $P(S)$ 中。\n\n### 1.2 基本性质&定理\n\n#### 1.2.1 对偶性\n\n> $k\\in B(S)\\Leftrightarrow n-k\\in P(S)$\n\n证明考虑把已知的等价关系画出来。\n\n#### 1.2.2 弱周期定理\n\n> $x,y\\in P(S),x+y\\le n\\Rightarrow \\gcd(x,y)\\in P(S)$\n\n<details><summary>证明</summary><p>\n\n> 不妨令 $x<y$。\n>\n> 仅需证明 $y-x\\in P(S)$，辗转相除会出手。\n>\n> 对于 $S_i$：\n>\n> - $i\\le x$：$i+y\\le n$，$S_i=S_{i+y}=S_{i+y-x}$；\n> - $i>x$：$S_i=S_{i-x}=S_{i+y-x}$；\n\n</p></details>\n\n#### 1.2.3 Border 的传递性\n\n> $y\\in B(S_{[1,k]}|k\\in B(S))\\Rightarrow y\\in B(S)$\n>\n> 即 Border 的 Border 还是 Border。\n\n证明考虑画画。\n\n#### 1.2.4 Border 的区间包含单调性\n\n> $B_l(S_{[l+1,r-1]})\\ge B_l(S_{[l,r]})+2$\n\n### 1.3 Border 的结构\n\n#### 1.3.1 Border 的树状结构\n\n> $B(S)=B(S_{[1,B_l(S)]})+\\{B_l(S)\\}$\n\n\n<details><summary>证明</summary><p>\n\n> 根据传递性，有 $B(S_{[1,B_l(S)]}) \\subset B(S)$。\n>\n> 由于 $B_l(S)$ 是 $S$ 最长的 Border，所以 $B(S)-B(S_{[1,B_l(S)]})=\\{B_l(S)\\}$。\n\n</p></details>\n\n这启发我们可以建出 $n$ 个点的树，每个点代表 $S$ 的一个前缀，$i$ 的父亲为 $B_l(S_{[1,i]})$。\n\n容易发现这棵树的根为 $1$，每个节点的 $B$ 集合就是它到根路径上的节点集合。\n\n实际上这就是 AC 自动机的 fail 树。\n\n#### 1.3.2 Border 的等差数列结构\n\n##### 1.3.2.1 引理\n\n> 所有满足 $2k\\ge n$ 的 Border $k$ 构成一个等差数列\n\n<details><summary>证明</summary><p>\n\n> 考虑 $P(S)$ 中 $\\le \\lfloor\\frac{n}{2}\\rfloor$ 的元素 $x$ 构成的集合 $P_s(S)$，根据弱周期定理，显然 $r=\\min\\{P_s(S)\\}$ 是 $P_s(S)$ 中所有元素的因子。\n> \n> 且由于 $r$ 是最小的 Period，$P_s(S)$ 一定为 $\\{kr|1\\le k,kr\\le \\lfloor\\frac{n}{2}\\rfloor\\}$ 即 $r$ 的正整数倍构成的集合。\n> \n> 根据对偶定理，$A=\\{n-kr|1\\le k,kr\\le \\lfloor\\frac{n}{2}\\rfloor\\}\\subseteq B(S)$，并且 $A$ 包含所有 $2k\\ge n$ 的 Border $k$。\n> \n> 也就是说，满足 $2k\\ge n$ 的 Border $k$ 构成了一个首项为 $n-r$，公差为 $-r$ 的等差数列。 \n\n</p></details>\n\n##### 1.3.2.2 定理 - 等差数列结构\n\n> $B(S)$ 构成 $O(\\log n)$ 个等差数列\n\n<details><summary>证明</summary><p>\n\n> 根据引理 1.3.2.1，所有满足 $2k\\ge n$ 的 Border $k$ 构成了一个等差数列。\n>\n> 设 $l=\\max\\{k|k\\in B(S),2k<n\\}$，类比 1.3.1（树状结构）的证明，易知去除该等差数列后剩下的 Border 集合为 $B(S_{[1,l]})+\\{l\\}$。\n>\n> 那么在 $S_{[1,l]}$ 上调用一次引理 1.3.2.1，可以实现继续砍半。\n>\n> 由于每次砍半，所以总共会得到 $O(\\log n)$ 个等差数列。\n\n</p></details>\n\n<details><summary>等差数列的寻找方法</summary></details><p>\n\n> 这里给出一种寻找等差数列的方法：（该方法把 $n$ 也当作 $S$ 的 Border）\n>\n> - 找到 $S$ 的极长 Border $k$，设 $l=n-(n-k)\\lceil\\frac{n-\\lfloor\\frac{n}{2}\\rfloor}{n-k}\\rceil$；\n> - 加入新的首项为 $n-(n-k)\\lceil\\frac{n-\\lfloor\\frac{n}{2}\\rfloor}{n-k}\\rceil$，末项为 $n$，公差为 $n-k$ 的等差数列；\n> - 找到 $S_{[1,l]}$ 的最长 Border $p$，递归处理 $S_{[1,p]}$；\n\n</p></details>\n\n### 1.4 例题\n\n- [P5287 [HNOI2019] JOJO](https://www.luogu.com.cn/problem/P5287) | [题解](../P5287 [HNOI2019] JOJO 做题记录)\n",
			"tags": [{"name":"学习笔记"},{"name":"字符串"},{"name":"数学"}],
			"title": "一些字符串的定理",
			"link": "https://exber.qzz.io/post/%E4%B8%80%E4%BA%9B%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%AE%9A%E7%90%86",
			"date": "2023-12-28 20:49:55"
		},
	
		{
			"abstract": "> 你需要动态维护一个字符串 $S$，有 $n$ 次操作：\n>\n> - `1 x c`：在 $S$ 末尾加上 $x$ 个字符 $c$，保证操作前 $S$ 末尾字符不为 $c$；\n> - `2 x`：撤销第 $x$ 次操作后的所有操作；\n>\n> 输出每次操作结束 $S$ 的每个前缀的最长真 Border 的长度的和。\n>\n> $1\\le n\\le 10^5$，$1\\le x\\le 10^4$。\n",
			"content": "> 你需要动态维护一个字符串 $S$，有 $n$ 次操作：\n>\n> - `1 x c`：在 $S$ 末尾加上 $x$ 个字符 $c$，保证操作前 $S$ 末尾字符不为 $c$；\n> - `2 x`：撤销第 $x$ 次操作后的所有操作；\n>\n> 输出每次操作结束 $S$ 的每个前缀的最长真 Border 的长度的和。\n>\n> $1\\le n\\le 10^5$，$1\\le x\\le 10^4$。\n\n\n首先可持久化可以通过在操作树上 dfs 干掉，那么我们需要一个非均摊的东西来维护答案。\n\n由于相邻 $1$ 操作的 $c$ 不同，所以 $S$ 可以被划分成若干段，每次操作就相当于在末尾加入一段。\n\n考虑维护 $S$ 的最长真 Border，不妨用二元组 $(x,c)$ 表示一段。对于 $S$ 的一个 Border，不难发现前缀的 $(x,c)$ 和后缀的 $(x,c)$ 除了开头结尾外都要完全一致，而：\n\n- 若开头不一致，则之后插入时肯定不能继承这个 Border，所以这个 Border 没用；\n- 若结尾不一致，一定是后缀的 $x$ 大于前缀的 $x$，否则同样没用；\n\n也就是说，有用的 Border 的前缀肯定包含完整的段。\n\n那么不妨维护二元组序列，用 $fail_u$ 表示前缀 $u$ 的最长有用真 Border 包含的二元组的个数。\n\n有了 $fail$，一个暴力的想法是：直接跳 $fail$，假设当前插入的第 $t$ 个二元组为 $(x,c)$，则维护一个指针 $cur$ 表示已经算出了当前段 $[1,cur]$ 的极长真 Border 的长度，跳到一个 Border $i$ 时假设第 $i+1$ 个二元组是 $(y,c’)$ 且 $c=c'$，则：\n\n- 若 $x=y$ 则答案加上一个等差数列，更新 $fail_{t}=i+1$，停止跳 $fail$；\n- 否则若 $y>cur$ 则答案加上一个等差数列，更新 $cur=\\min\\{x,y\\}$；\n\n最后还要特判一下 $fail_t=1$ 且 $(x,c)$ 不被真 Border 完全包含的情况。\n\n这样暴力跳是均摊 $O(n)$ 的，操作树来个菊花就卡死了。\n\n继续利用相邻二元组 $c$ 不同的性质，对于一个 $>\\lfloor\\frac{n}{2}\\rfloor$ 的 Border $k$，$n-k$ 必然是一个 Period，并且这些 $>\\lfloor\\frac{n}{2}\\rfloor$ 的 Border 构成一个等差数列，所以对于每个 $>\\lfloor\\frac{n}{2}\\rfloor$ 的 Border $k$，第 $k+1$ 个二元组必然相同。由于相邻二元组 $c$ 不同，所以 $>\\lfloor\\frac{n}{2}\\rfloor$ 的 Border 都被它们中最长的那个支配，那么处理完最长那个后直接跳过剩下的即可。\n\n根据经典结论，这样的等差数列只会有 $O(\\log n)$ 个，那么就做完了，时间复杂度 $O(n\\log n)$。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nconst int S=100005,p=998244353;\n\nstruct node\n{\n\tint x,c;\n};\n\nint n,m,rt[S];\nvector<pair<int,node> > g[S];\nvector<int> idx[S];\nint tot;\nnode a[S];\nint len[S],fail[S];\nint ans[S];\n\ninline void add(int &x,int y)\n{\n\tx+=y;\n\tif(x>=p) x-=p;\n}\n\ninline int ins(node x)\n{\n\ta[++tot]=x;\n\tlen[tot]=(len[tot-1]+x.x)%p;\n\tif(tot==1)\n\t{\n\t\tfail[tot]=0;\n\t\treturn 1ll*(x.x-1)*x.x/2%p;\n\t}\n\tint res=0;\n\tfail[tot]=0;\n\tint cur=0,n=tot-1,u=fail[tot-1];\n\twhile(1)\n\t{\n\t\tif(a[u+1].c==x.c)\n\t\t{\n\t\t\tif(a[u+1].x==x.x)\n\t\t\t{\n\t\t\t\tint lft=x.x-cur;\n\t\t\t\tadd(res,1ll*(cur+1+x.x)*lft/2%p);\n\t\t\t\tadd(res,1ll*len[u]*lft%p);\n\t\t\t\tfail[tot]=u+1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(a[u+1].x>cur)\n\t\t\t{\n\t\t\t\tint le=min(x.x,a[u+1].x),lft=le-cur;\n\t\t\t\tadd(res,1ll*(cur+1+le)*lft/2%p);\n\t\t\t\tadd(res,1ll*len[u]*lft%p);\n\t\t\t\tcur=le;\n\t\t\t}\n\t\t\tif(u==0&&a[1].x<x.x)\n\t\t\t{\n\t\t\t\tint lft=x.x-cur;\n\t\t\t\tadd(res,1ll*a[1].x*lft%p);\n\t\t\t\tfail[tot]=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(u==0) break;\n\t\tif(u>n/2)\n\t\t{\n\t\t\tint len=n-u,lft=u-n/2;\n\t\t\tu=u-(lft/len+(lft%len!=0))*len+len;\n\t\t\tn=u,u=fail[u];\n\t\t}\n\t\telse n=u,u=fail[u];\n\t}\n\treturn res;\n}\n\nvoid dfs(int u,int res)\n{\n\tfor(int id:idx[u]) ans[id]=res;\n\tfor(auto t:g[u])\n\t{\n\t\tint v=t.first;\n\t\tnode x=t.second;\n\t\tint tt=tot;\n\t\tdfs(v,(res+ins(x))%p);\n\t\ttot=tt;\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\trt[0]=m=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint op,x;\n\t\tscanf(\"%d%d\",&op,&x);\n\t\tif(op==1)\n\t\t{\n\t\t\tchar c;\n\t\t\tscanf(\" %c\",&c);\n\t\t\tg[rt[i-1]].emplace_back(rt[i]=++m,(node){x,c-'a'+1});\n\t\t}\n\t\telse rt[i]=rt[x];\n\t\tidx[rt[i]].push_back(i);\n\t}\n\tdfs(rt[0],0);\n\tfor(int i=1;i<=n;i++) printf(\"%d\\n\",ans[i]);\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"字符串"}],
			"title": "P5287 [HNOI2019] JOJO 做题记录",
			"link": "https://exber.qzz.io/post/P5287%20%5BHNOI2019%5D%20JOJO%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-12-28 20:38:00"
		},
	
		{
			"abstract": "> 给定一张 $n$ 个点的边集为 $E$ 的无向图和一个正整数 $K$，你要给每个点分配一个非负实数点权 $s_i$，满足 $\\sum s_i=K$ 且 $\\sum\\limits_{(u,v)\\in E}s_u\\times s_v$ 最大。输出该式子的最大值（保留 $6$ 位小数）。\n>\n> $1\\le n\\le 40$，$1\\le K\\le 1000$。\n",
			"content": "> 给定一张 $n$ 个点的边集为 $E$ 的无向图和一个正整数 $K$，你要给每个点分配一个非负实数点权 $s_i$，满足 $\\sum s_i=K$ 且 $\\sum\\limits_{(u,v)\\in E}s_u\\times s_v$ 最大。输出该式子的最大值（保留 $6$ 位小数）。\n>\n> $1\\le n\\le 40$，$1\\le K\\le 1000$。\n\n\n首先若 $s_i\\not=0$ 的点不组成完全图，则可以找到两个相互没有连边的点 $x,y$，不妨假设 $\\sum\\limits_{(x,v)\\in E} s_v\\ge \\sum\\limits_{(y,v)\\in E} s_v$，那么把 $s_y$ 全部给 $s_x$ 肯定不劣。\n\n并且根据数学直觉，点权肯定尽量平均分。\n\n那么这就变成了最大团问题，这是个 NP 问题，但是我们有经典随机化算法：\n\n> 随机一个加点顺序，若加入当前点后还是团则加入，否则不加入。\n\n这个算法很难卡。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <ctime>\n#include <cstdlib>\n\nusing namespace std;\n\nconst int S=45,TS=1000000,RS=15;\n\nint n,k;\nint a[S][S];\nint tot,b[S],c[S];\n\nint main()\n{\n\tsrand(time(NULL));\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++) scanf(\"%d\",&a[i][j]);\n\t}\n\tfor(int i=1;i<=n;i++) b[i]=i;\n\tint ans=0;\n\tfor(int tt=1;tt<=TS;tt++)\n\t{\n\t\tfor(int i=1;i<=RS;i++) swap(b[rand()%n+1],b[rand()%n+1]);\n\t\tint tot=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tbool f=true;\n\t\t\tfor(int j=1;j<=tot&&f;j++) f&=a[b[i]][c[j]];\n\t\t\tif(f) c[++tot]=b[i];\n\t\t}\n\t\tans=max(ans,tot);\n\t}\n\tlong double res=k*k/(long double)(ans*ans)*(ans*(ans-1)/2);\n\tprintf(\"%Lf\\n\",res);\n\treturn 0;\n}\n```\n\n",
			"tags": [{"name":"做题记录"},{"name":"图论"},{"name":"结论"},{"name":"数学"},{"name":"构造"}],
			"title": "CF839E Mother of Dragons 做题记录",
			"link": "https://exber.qzz.io/post/CF839E%20Mother%20of%20Dragons%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-12-27 19:29:36"
		},
	
		{
			"abstract": "> 给定 $n,m$ 和一个 $n$ 的排列 $P$。重复进行如下操作 $m$ 次：\n>\n> - 选定 $1\\le i\\le j\\le n$，并将 $P_i,P_{i+1},..,P_j$ 翻转。\n>\n> 对于所有 $(\\frac{n(n+1)}{2})^m$ 种方案，计算 $\\sum_{i<j}[P_i>P_j](j-i)$ 的值的和。\n>\n> $1\\le n,m\\le 2\\times 10^5$。\n",
			"content": "> 给定 $n,m$ 和一个 $n$ 的排列 $P$。重复进行如下操作 $m$ 次：\n>\n> - 选定 $1\\le i\\le j\\le n$，并将 $P_i,P_{i+1},..,P_j$ 翻转。\n>\n> 对于所有 $(\\frac{n(n+1)}{2})^m$ 种方案，计算 $\\sum_{i<j}[P_i>P_j](j-i)$ 的值的和。\n>\n> $1\\le n,m\\le 2\\times 10^5$。\n\n\n考虑拆开 $\\sum_{i<j}[P_i>P_j](j-i)$：\n$$\n\\begin{aligned}\n\\sum_{i<j}[P_i>P_j](j-i)&=\\sum\\limits_{i}i\\times \\left(\\sum\\limits_{j<i}[P_i<P_j]-\\sum\\limits_{j>i}[P_i>P_j]\\right)\\\\\n&=\\sum\\limits_i i\\times \\left(i-\\sum\\limits_{j<i}[P_i\\ge P_j]-\\sum\\limits_{j>i}[P_i>P_j]\\right)\\\\\n&=\\sum\\limits_i i\\times \\left(i-\\sum\\limits_{j}[P_i\\ge P_j]\\right)\\\\\n&=\\sum\\limits_i i\\times (i-P_i)\\\\\n&=\\sum\\limits_i i^2-\\sum\\limits_i iP_i\n\\end{aligned}\n$$\n那么只要求出 $\\sum\\limits_{i} iP_i$ 的和即可。\n\n注意到操作只和位置相关，$P_i$ 的和不太好求，那么不妨转而求 $Q_i$ 表示 $P_i$ 最后去的位置（$P$ 的逆排列），那么 $\\sum\\limits_{i} iP_i=\\sum\\limits_{i} Q_iP_i$。\n\n发现 $Q_i$ 还是不好求，这时候你突然灵光一闪就能想到，其实可以求 $S_i$ 表示 $Q_i$ 的期望，最后再乘上 $(\\frac{n(n+1)}{2})^m$。\n\n注意到 $S_i$ 是好求的。具体的，$P_i$ 一旦被某次操作覆盖到，那么它去往 $j$ 和去往 $n-j+1$ 的概率是一样的，因为你总能构建出双射。\n\n那么答案即为 $(\\frac{n(n+1)}{2})^m\\left(\\sum\\limits_i i^2-\\sum\\limits_i S_iP_i\\right)$。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=200005,p=998244353,inv2=(p+1)/2;\n\nint n,m,a[S];\n\ninline int qpow(int x,int y)\n{\n\tint res=1;\n\tfor(;y>0;y>>=1,x=1ll*x*x%p) res=y&1?1ll*res*x%p:res;\n\treturn res;\n}\n\ninline void add(int &x,int y)\n{\n\tx+=y;\n\tif(x>=p) x-=p;\n}\n\ninline int calc(int n)\n{\n\treturn 1ll*(n+1)*n/2%p;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tint sm=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tadd(sm,1ll*i*i%p);\n\t\tint nc1=1ll*(calc(i-1)+calc(n-i))*qpow(calc(n),p-2)%p;\n\t\tint ncov=qpow(nc1,m);\n\t\tint si=0; \n\t\tadd(si,1ll*i*ncov%p);\n\t\tadd(si,1ll*(n+1)*inv2%p*(p+1-ncov)%p);\n\t\tadd(sm,p-1ll*si*a[i]%p);\n\t}\n\tsm=1ll*sm*qpow(calc(n),m)%p;\n\tprintf(\"%d\\n\",sm);\n\treturn 0;\n}\n```\n\n",
			"tags": [{"name":"做题记录"},{"name":"数学"},{"name":"组合计数"},{"name":"结论"},{"name":"概率、期望"}],
			"title": "ARC154E Reverse and Inversion 做题记录",
			"link": "https://exber.qzz.io/post/ARC154E%20Reverse%20and%20Inversion%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-12-27 18:55:59"
		},
	
		{
			"abstract": "> 给你两个 $2n$ 的排列 $P,Q$，你要构造一个长 $2n$ 的括号序列 $S$。定义一个 $2n$ 的排列 $C$ 是合法的，当且仅当按照 $S_{C_1}S_{C_2}\\cdots S_{C_{2n}}$ 是合法括号序列。你构造的 $S$ 要满足 $P$ 是字典序最小的合法排列，$Q$ 是最大的。\n>\n> $1\\le n\\le 2\\times 10^5$。\n",
			"content": "> 给你两个 $2n$ 的排列 $P,Q$，你要构造一个长 $2n$ 的括号序列 $S$。定义一个 $2n$ 的排列 $C$ 是合法的，当且仅当按照 $S_{C_1}S_{C_2}\\cdots S_{C_{2n}}$ 是合法括号序列。你构造的 $S$ 要满足 $P$ 是字典序最小的合法排列，$Q$ 是最大的。\n>\n> $1\\le n\\le 2\\times 10^5$。\n\n\n首先不难发现，若 $P_1\\not= 1$，那么 $S_{[1,P_1-1]}$ 一定都是 `)`，并且 $S_{P_1}$ 是 `(`，并且 $S_{P_i}$ 接下来长 $2(P_1-1)$ 的一段一定是 `()()()()` 这样的。\n\n这个似乎没什么用，继续观察。\n\n这种只有 $+1$ 和 $-1$ 的序列不妨考虑折线图。\n\n不难发现，`()()()()` 等价于把在 $y=0$ 下方的折线拉回来，而折线原本就在 $y=0$ 上方的部分在 $P$ 中不会被修改。\n\n所以，根据 $P$ 可以确认折线图 $y=0$ 上方的部分，根据 $Q$ 可以确认折线图 $y=0$ 下方的部分，这符合我们初步观察的结论。\n\n那么直接模拟即可。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <set>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nconst int S=400005;\n\nint n;\nint a[S],b[S];\nchar s[S];\nint c[S],d[S];\n\ninline void calca()\n{\n\tset<int> st;\n\tfor(int i=1;i<=n;i++) st.insert(i);\n\tfor(int i=1;i<=n&&!st.empty();i++)\n\t{\n\t\tif(a[i]==*st.begin())\n\t\t{\n\t\t\tint j=i;\n\t\t\ts[a[j]]='(';\n\t\t\tfor(;j<=n&&!st.empty()&&a[j]==*st.begin();j++)\n\t\t\t{\n\t\t\t\tst.erase(a[j]);\n\t\t\t}\n\t\t\tj--;\n\t\t\ts[a[j]]=')';\n\t\t\ti=j;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint tot=0;\n\t\t\twhile(!st.empty()&&*st.begin()<a[i])\n\t\t\t{\n\t\t\t\ts[*st.begin()]=')';\n\t\t\t\tst.erase(st.begin());\n\t\t\t\ttot++;\n\t\t\t}\n\t\t\tif(tot==0) return;\n\t\t\tfor(int j=i;j<=i+tot*2-1;j+=2)\n\t\t\t{\n\t\t\t\ts[a[j]]='(';\n\t\t\t\tst.erase(a[j]);\n\t\t\t}\n\t\t\ti=i+tot*2-1;\n\t\t}\n\t}\n}\n\ninline void calcb()\n{\n\tset<int,greater<int> > st;\n\tfor(int i=1;i<=n;i++) st.insert(i);\n\tfor(int i=1;i<=n&&!st.empty();i++)\n\t{\n\t\tif(b[i]==*st.begin())\n\t\t{\n\t\t\tint j=i;\n\t\t\ts[b[j]]='(';\n\t\t\tfor(;j<=n&&!st.empty()&&b[j]==*st.begin();j++)\n\t\t\t{\n\t\t\t\tst.erase(b[j]);\n\t\t\t}\n\t\t\tj--;\n\t\t\ts[b[j]]=')';\n\t\t\ti=j;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint tot=0;\n\t\t\twhile(!st.empty()&&*st.begin()>b[i])\n\t\t\t{\n\t\t\t\ts[*st.begin()]=')';\n\t\t\t\tst.erase(st.begin());\n\t\t\t\ttot++;\n\t\t\t}\n\t\t\tif(tot==0) return;\n\t\t\tfor(int j=i;j<=i+tot*2-1;j+=2)\n\t\t\t{\n\t\t\t\ts[b[j]]='(';\n\t\t\t\tst.erase(b[j]);\n\t\t\t}\n\t\t\ti=i+tot*2-1;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tn*=2;\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&b[i]);\n\tcalca();\n//\tputs(\"fina\");\n//\tfor(int i=1;i<=n;i++) printf(\"%c\",s[i]==0?'.':s[i]);\n//\tprintf(\"\\n\");\n\tcalcb();\n//\tfor(int i=1;i<=n;i++) printf(\"%c\",s[i]==0?'.':s[i]);\n//\tprintf(\"\\n\");\n//\tputs(\"fin\");\n\tfor(int i=1;i<=n;i++) if(s[i]==0) return puts(\"-1\"),0;\n\tint c0=0;\n\tfor(int i=1;i<=n;i++) c0+=s[i]=='(';\n\tif(c0!=n/2) return puts(\"-1\"),0;\n\tqueue<int> v0,v1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(s[i]=='(') v0.push(i);\n\t\telse v1.push(i);\n\t}\n\tfor(int i=1,k=0;i<=n;i++)\n\t{\n\t\tif(!v0.empty()&&(v1.empty()||v0.front()<v1.front()||k==0))\n\t\t{\n\t\t\tk++;\n\t\t\tc[i]=v0.front();\n\t\t\tv0.pop();\n\t\t}\n\t\telse k--,c[i]=v1.front(),v1.pop();\n\t}\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tif(s[i]=='(') v0.push(i);\n\t\telse v1.push(i);\n\t}\n\tfor(int i=1,k=0;i<=n;i++)\n\t{\n\t\tif(!v0.empty()&&(v1.empty()||v0.front()>v1.front()||k==0))\n\t\t{\n\t\t\tk++;\n\t\t\td[i]=v0.front();\n\t\t\tv0.pop();\n\t\t}\n\t\telse k--,d[i]=v1.front(),v1.pop();\n\t}\n\tbool f=true;\n//\tfor(int i=1;i<=n;i++) printf(\"%d \",c[i]);\n//\tprintf(\"\\n\");\n//\tfor(int i=1;i<=n;i++) printf(\"%d \",d[i]);\n//\tprintf(\"\\n\");\n\tfor(int i=1;i<=n&&f;i++) f&=a[i]==c[i];\n\tfor(int i=1;i<=n&&f;i++) f&=b[i]==d[i];\n\tif(!f) puts(\"-1\");\n\telse printf(\"%s\\n\",s+1);\n\treturn 0;\n}\n/*\n(\n*/\n```\n\n",
			"tags": [{"name":"做题记录"},{"name":"构造"}],
			"title": "ARC141C Bracket and Permutation 做题记录",
			"link": "https://exber.qzz.io/post/ARC141C%20Bracket%20and%20Permutation%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-12-27 18:55:23"
		},
	
		{
			"abstract": "> 黑板上有 $n$ 个正整数 $a_i$，再给定一个正整数 $k$，可进行操作如下：\n>\n> - 选择一个黑板上的正整数 $x$ 和两个满足 $y+z=x+k$ 的正整数 $y,z$，删掉 $x$，在黑板上写上 $y$ 和 $z$；\n>\n> 求最少进行多少次操作可以让黑板上的数相等，或报告无解。\n>\n> $1\\le n\\le 2\\times 10^5$，$1\\le a_i,k\\le 10^{12}$。\n",
			"content": "> 黑板上有 $n$ 个正整数 $a_i$，再给定一个正整数 $k$，可进行操作如下：\n>\n> - 选择一个黑板上的正整数 $x$ 和两个满足 $y+z=x+k$ 的正整数 $y,z$，删掉 $x$，在黑板上写上 $y$ 和 $z$；\n>\n> 求最少进行多少次操作可以让黑板上的数相等，或报告无解。\n>\n> $1\\le n\\le 2\\times 10^5$，$1\\le a_i,k\\le 10^{12}$。\n\n\n等号两边都有两个量不方便，注意到只要给每个 $a_i$ 都减去 $k$，那么操作的限制就变成 $y+z=x$，且 $-k<y,z$。\n\n那么无解当且仅当 $a_i$ 不同号，即存在 $1\\le i,j\\le n$ 满足 $a_i<0,a_j>0$ 或 $a_i=0,a_j\\not=0$。\n\n显然最后的数选择 $g=\\gcd\\{a_i\\}$ 最优，答案即为 $\\sum \\frac{a_i}{g}-1$。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int S=200005;\n\nint n;\nll k,a[S];\n\ninline ll gcd(ll x,ll y)\n{\n\tif(x==0||y==0) return x+y;\n\tll t=x%y;\n\twhile(t!=0) x=y,y=t,t=x%y;\n\treturn y;\n}\n\ninline void slove()\n{\n\tscanf(\"%d%lld\",&n,&k);\n\tfor(int i=1;i<=n;i++) scanf(\"%lld\",&a[i]),a[i]-=k;\n\tbool f=true;\n\tfor(int i=1;i<=n&&f;i++)\n\t{\n\t\tif(a[1]==0) f&=a[i]==0;\n\t\telse if(a[1]>0) f&=a[i]>0;\n\t\telse f&=a[i]<0;\n\t}\n\tif(!f) return puts(\"-1\"),void();\n\tif(a[1]==0) return puts(\"0\"),void();\n\tif(a[1]<0) for(int i=1;i<=n;i++) a[i]=-a[i];\n\tll m=0;\n\tfor(int i=1;i<=n;i++) m=gcd(m,a[i]);\n\tll ans=0;\n\tfor(int i=1;i<=n;i++) ans+=a[i]/m-1;\n\tprintf(\"%lld\\n\",ans);\n}\n\nint main()\n{\n\tint T;\n\tscanf(\"%d\",&T);\n\twhile(T-->0) slove();\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"数学"},{"name":"结论"}],
			"title": "CF1909D Split Plus K 做题记录",
			"link": "https://exber.qzz.io/post/CF1909D%20Split%20Plus%20K%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-12-24 17:29:09"
		},
	
		{
			"abstract": "",
			"content": "> 给定长 $n$ 的字符串 $S$，对于每个 $1\\le i\\le n$，求出 $z_i$ 表示 $\\text{lcp}(S,S_{[i,n]})$。\n>\n> 时间复杂度 $O(n)$。\n\n类似 manacher，若存在 $j$ 满足 $j<i$ 且 $j+z_j-1\\ge i$，则 $z_i$ 至少为 $\\min(z_{i-j+1},j+z_j-i)$：\n\n![](../post-images/1754900734842.jpg)\n\n那么记录 $p+z_p-1$ 最大的 $p$，每次暴力拓展 $z_i$ 都会令 $p+z_p-1$ 增加 $1$，所以时间复杂度均摊 $O(n)$。\n\n注意 $z_1$ 要单独计算。\n\n代码如下：\n\n```cpp\nz[1]=n;\nfor(int i=2,rb=2;i<=n;i++)\n{\n    if(rb+z[rb]-1>=i) z[i]=min(z[i-rb+1],rb+z[rb]-i);\n    while(z[i]<n-i+1&&a[z[i]+1]==a[i+z[i]]) z[i]++;\n    if(i+z[i]>rb+z[rb]) rb=i;\n}\n```\n### 拓展\n\n> 给定两个字符串 $S,T$，长度分别为 $n,m$。对于每个 $1\\le i\\le n$，求出 $p_i=\\text{lcp}(S_{[i,n]},T)$。\n>\n> 时间复杂度 $O(n+m)$。\n\n基本是一样的，先求出 $T$ 的 $z$ 数组，若存在 $j$ 满足 $j<i$ 且 $j+p_j-1\\ge i$，则 $p_i$ 至少为 $\\min(z_{i-j+1},j+p_j-i)$。那么记录 $r+p_r-1$ 最大的 $r$ 即可，时间复杂度还是线性的。\n\n例题：[P5410 【模板】扩展 KMP/exKMP（Z 函数）](https://www.luogu.com.cn/problem/P5410)\n",
			"tags": [{"name":"学习笔记"},{"name":"字符串"}],
			"title": "Z 函数（EX KMP）学习笔记",
			"link": "https://exber.qzz.io/post/Z%20%E5%87%BD%E6%95%B0%EF%BC%88EX%20KMP%EF%BC%89%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-12-21 16:28:37"
		},
	
		{
			"abstract": "",
			"content": "可并堆就是支持快速合并的堆。\n\n某些时候用这个东西可能会少一个 $log$。\n\n阅读一般的二叉堆合并代码：\n\n```cpp\nint merge(int x,int y)\n{\n    if(x==0||y==0) return x+y;\n    if(tr[x].val>tr[y].val) swap(x,y);\n    if(...) tr[x].ls=merge(tr[x].ls,y);\n    else tr[x].rs=merge(tr[x].rs,y);\n    return x;\t\n}\n```\n\n注意到由于只需要维护堆的性质，所以 $y$ 和 $x.ls$ 或者 $x.rs$ 中任意一个合并都是可行的。\n\n不难发现，合并会停止当且仅当 $x$ 和 $y$ 其中一个为空节点。那么在每个节点处维护它到子树内最近的空节点（即最近的缺左/右儿子的左/右儿子）的距离 $dist$，每次往 $dist$ 小的儿子递归。\n\n由于 $dist=x$ 的节点子树大小至少为 $2^{x-1}$，所以 $dist$ 是 $\\log$ 级别的。\n\n那么单次合并的时间复杂度也就是一个 $\\log$ 的了。\n\n为了方便实现，不妨钦定左儿子 $dist$ 较小。\n\n合并代码如下：\n\n```cpp\ninline void upda(int u)\n{\n    int &ls=tr[u].ls,&rs=tr[u].rs;\n    if(tr[ls].dist>tr[rs].dist) swap(ls,rs);\n    tr[u].dist=tr[ls].dist+1;\n}\nint merge(int x,int y)\n{\n    if(x==0||y==0) return x+y;\n    if(tr[x].val>tr[y].val) swap(x,y);\n    tr[x].ls=merge(tr[x].ls,y);\n    upda(x);\n    return x;\t\n}\n```\n\n有了合并操作，其它操作都是 Ordinary 的，时间复杂度都只有一个 $\\log$，常数也比较小。\n\n封装板子：\n\n```cpp\ntemplate<typename T,int siz>\nclass LTree\n{\n\tprivate:\n\t\tstruct node\n\t\t{\n\t\t\tT val;\n\t\t\tint dist,ls,rs;\n\t\t}tr[siz];\n\t\tint tot;\n\t\tinline int nnde(T val)\n\t\t{\n\t\t\ttr[++tot]={val,1,0,0};\n\t\t\treturn tot;\n\t\t}\n\t\tinline void upda(int u)\n\t\t{\n\t\t\tint &ls=tr[u].ls,&rs=tr[u].rs;\n\t\t\tif(tr[ls].dist>tr[rs].dist) swap(ls,rs);\n\t\t\ttr[u].dist=tr[ls].dist+1;\n\t\t}\n\t\tint merge(int x,int y)\n\t\t{\n\t\t\tif(x==0||y==0) return x+y;\n\t\t\tif(tr[x].val>tr[y].val) swap(x,y);\n\t\t\ttr[x].ls=merge(tr[x].ls,y);\n\t\t\tupda(x);\n\t\t\treturn x;\t\n\t\t}\n\tpublic:\n\t\tinline void clear()\n\t\t{\n\t\t\ttr[tot=0]=(node){T(),0,0,0};\n\t\t}\n\t\tinline void ins(int &rt,T x)\n\t\t{\n\t\t\trt=merge(rt,nnde(x));\n\t\t}\n\t\tinline T top(int rt)\n\t\t{\n\t\t\treturn tr[rt].val;\n\t\t}\n\t\tinline void pop(int &rt)\n\t\t{\n\t\t\trt=merge(tr[rt].ls,tr[rt].rs);\n\t\t}\n\t\tinline void meg(int &x,int y)\n\t\t{\n\t\t\tx=merge(x,y);\n\t\t}\n};\n```\n",
			"tags": [{"name":"学习笔记"},{"name":"数据结构"}],
			"title": "可并堆学习笔记",
			"link": "https://exber.qzz.io/post/%E5%8F%AF%E5%B9%B6%E5%A0%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-12-18 20:39:02"
		},
	
		{
			"abstract": "> 有 $m$ 个卡，第 $i$ 个卡每次抽到的概率都是 $\\frac{a_i}{n}$，其中 $n=\\sum\\limits_{i=1}^m a_i$，求集齐所有卡期望需要多少次，对 $998244353$ 取模。\n>\n> $1\\le n,m\\le 10^5$，$1\\le a_i\\le n$。\n",
			"content": "> 有 $m$ 个卡，第 $i$ 个卡每次抽到的概率都是 $\\frac{a_i}{n}$，其中 $n=\\sum\\limits_{i=1}^m a_i$，求集齐所有卡期望需要多少次，对 $998244353$ 取模。\n>\n> $1\\le n,m\\le 10^5$，$1\\le a_i\\le n$。\n\n首先 min-max 容斥转化为背包。\n\n然后相当于 $\\sum\\limits_{k=1}^{n}\\frac{n}{k}[x^k]\\prod\\limits_{i=1}^m (1-x^{a_i})$。\n\n把 $\\prod\\limits_{i=1}^m (1-x^{a_i})$ 转化为 $\\exp\\left(\\sum\\limits_{i=1}^m\\ln(1-x^{a_i})\\right)$。\n$$\n\\begin{aligned}\n\\ln(1-x^v)'&=\\frac{-vx^{v-1}}{1-x^v}\\\\\n&=-\\sum\\limits_{j=0}^{\\infin}vx^{v-1+vj}\\\\\n&=-\\sum\\limits_{j=1}^{\\infin}vx^{vj-1}\\\\\n&=-\\sum\\limits_{j=1}^{\\infin}\\frac{vjx^{vj-1}}{j}\\\\\n\\end{aligned}\n$$\n\n\n$$\n\\begin{aligned}\n\\int \\ln(1-x^v)'dx&=\\int -\\sum\\limits_{j=1}^{\\infin}\\frac{vjx^{vj-1}}{j}dx\\\\\n&=-\\sum\\limits_{j=1}^{\\infin}\\frac{\\int vjx^{vj-1}dx}{j}\\\\\n&=-\\sum\\limits_{j=1}^{\\infin}\\frac{x^{vj}}{j}\\\\\n&=-\\sum\\limits_{j=1}^{\\infin}\\frac{x^{vj}}{j}\\\\\n\\end{aligned}\n$$\n\n$$\n\\ln(1-x^v)=-\\sum\\limits_{j=1}^{\\infin}\\frac{x^{vj}}{j}\n$$\n\n注意到 $-\\sum\\limits_{j=1}^{\\infin}\\frac{x^{vj}}{j}$ 在 $\\text{mod } x^n$ 意义下只有 $\\lfloor\\frac{n}{v}\\rfloor$ 项非零，枚举 $v$ 即可 $O(n\\ln n)$ 算出 $\\sum\\limits_{i=1}^m\\ln(1-x^{a_i})$，然后 $O(n\\log n)$ 求 exp 即可。\n\n时间复杂度 $O(m+n\\log n)$。\n",
			"tags": [{"name":"做题记录"},{"name":"组合计数"},{"name":"概率、期望"},{"name":"数学"},{"name":"多项式、生成函数"}],
			"title": "ABC331G Collect Them All 做题记录",
			"link": "https://exber.qzz.io/post/ABC331G%20Collect%20Them%20All%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-12-05 21:41:09"
		},
	
		{
			"abstract": "> 有 $m$ 种货币，第 $i$ 种面值为 $2^{i-1}$，求凑出 $n$ 元钱有多少种方案数，对 $998244353$ 取模。\n>\n> Ex：求 $n$ 有多少种 $m$ 位 $k$ 进制表示（每一位的数字无上限）。\n>\n> $1\\le m\\le 30$，$0\\le n\\le 10^{18}$，$2\\le k\\le 16$。\n",
			"content": "> 有 $m$ 种货币，第 $i$ 种面值为 $2^{i-1}$，求凑出 $n$ 元钱有多少种方案数，对 $998244353$ 取模。\n>\n> Ex：求 $n$ 有多少种 $m$ 位 $k$ 进制表示（每一位的数字无上限）。\n>\n> $1\\le m\\le 30$，$0\\le n\\le 10^{18}$，$2\\le k\\le 16$。\n\n\n考虑把面值为 $2^i$ 的货币拆成面值 $2^{i}$、$2^{i+1}$、$2^{i+2}$……的货币各一个，即把 $2^i$ 的选择个数 $a_i$“摊平”。这样就可以转化为 01 背包。\n\n那么数位 dp，设 $dp_{i,j}$ 表示考虑完 $2^0\\sim 2^i$，向后进了 $j$ 的方案数。\n\n转移考虑枚举有 $k$ 种面值当前位都为 $1$，枚举上一位的进位 $l$，则：\n$$\ndp_{i,\\lfloor\\frac{k+l}{2}\\rfloor}=[k+l\\equiv n_{2^i}\\text{ (mod }2\\text{)}]\\binom{\\min(m,i+1)}{k}dp_{i-1,l}\n$$\nEx 做法类似，不过拆出来的每种货币可以选 $k-1$ 个。\n",
			"tags": [{"name":"做题记录"},{"name":"组合计数"},{"name":"DP"}],
			"title": "【2023GGXS】货币 做题记录",
			"link": "https://exber.qzz.io/post/%E3%80%902023GGXS%E3%80%91%E8%B4%A7%E5%B8%81%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-12-04 22:32:02"
		},
	
		{
			"abstract": "> 给定 $n,m$ 和一个长 $n$ 的序列 $a_i$，求满足以下条件的长 $n$ 的序列 $b$ 的个数\n>\n> - $1\\le b_i\\le m$；\n> - $b_i$ 两两不同；\n> - $b_i$ 可以被 $a_i$ 整除；\n>\n> 对 $998244353$ 取模。\n>\n> $1\\le n\\le 16$，$1\\le a_i\\le m\\le 10^{18}$。\n",
			"content": "> 给定 $n,m$ 和一个长 $n$ 的序列 $a_i$，求满足以下条件的长 $n$ 的序列 $b$ 的个数\n>\n> - $1\\le b_i\\le m$；\n> - $b_i$ 两两不同；\n> - $b_i$ 可以被 $a_i$ 整除；\n>\n> 对 $998244353$ 取模。\n>\n> $1\\le n\\le 16$，$1\\le a_i\\le m\\le 10^{18}$。\n\n若 $b_i=b_j$ 则连接无向边 $(i,j)$，则两两不同的限制相当于图中没有边。\n\n考虑容斥，设 $dp_S$ 为 $i\\in S$ 的 $b_i$ 的方案数。钦定某些点在同一个连通块，不难发现相同大小的连通块的容斥系数是相同的。不妨设大小为 $n$ 的连通块的容斥系数为 $f_n$，则有转移：\n$$\ndp_S=\\sum\\limits_{T\\subseteq S,\\min\\{T\\}=\\min\\{S\\}}f_{|T|}\\left\\lfloor\\frac{m}{\\text{lcm}\\{a_i|i\\in T\\}}\\right\\rfloor dp_{S-T}\n$$\n考虑 $f_n$ 需要满足的条件，设 $g_n$ 表示所有 $n$ 个点的无向图的容斥系数的总和，那么枚举图中边的个数，有：\n$$\n\\begin{aligned}\ng_n&=\\sum\\limits_{i=0}^{\\frac{n(n-1)}{2}}\\binom{\\frac{n(n-1)}{2}}{i}(-1)^i\\\\\n&=\\sum\\limits_{i=0}^{\\frac{n(n-1)}{2}}\\binom{\\frac{n(n-1)}{2}}{i}(-1)^i1^{n-i}\\\\\n&=[n=0]+[n=1]\n\\end{aligned}\n$$\n而枚举 $n$ 所在的连通块大小，有：\n$$\n\\begin{aligned}\ng_n&=\\sum\\limits_{i=1}^{n}\\binom{n-1}{i-1}f_{i}g_{n-i}\\\\\n&=f_n+(n-1)f_{n-1}\n\\end{aligned}\n$$\n而 $g_1=f_1=1$。\n\n所以有：\n$$\nf_{n}=\\begin{cases}\n1&n=1\\\\\n-(n-1)f_{n-1}&n>1\n\\end{cases}\n$$\n那么 $f_n=(-1)^{n-1}(n-1)!$。\n\n那么直接 dp 即可，时间复杂度 $O(3^n)$，代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int S=20,BS=1<<16,p=998244353;\n\nint n;\nll m,a[S];\nll lcm[BS];\nint f[S],dp[BS];\n\n#define popc __builtin_popcount\n\ninline ll gcd(ll x,ll y)\n{\n\tif(x==0||y==0) return x+y;\n\tll t=x%y;\n\twhile(t!=0) x=y,y=t,t=x%y;\n\treturn y;\n}\n\ninline ll getlcm(int st)\n{\n\tll res=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(st>>i-1&1)\n\t\t{\n\t\t\tll g=gcd(res,a[i]);\n\t\t\tres/=g;\n\t\t\tif(res>m/a[i]) res=m+1;\n\t\t\telse res*=a[i];\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tscanf(\"%d%lld\",&n,&m);\n\tfor(int i=1;i<=n;i++) scanf(\"%lld\",&a[i]);\n\tfor(int i=0;i<(1<<n);i++) lcm[i]=getlcm(i);\n\tf[1]=1;\n\tfor(int i=2;i<=n;i++) f[i]=p-1ll*(i-1)*f[i-1]%p;\n\tdp[0]=1;\n\tfor(int i=1;i<(1<<n);i++)\n\t{\n\t\tfor(int j=i;j>0;j=(j-1)&i)\n\t\t{\n\t\t\tif((i&-i)!=(j&-j)) continue;\n\t\t\tdp[i]=(dp[i]+1ll*f[popc(j)]*((m/lcm[j])%p)%p*dp[i^j]%p)%p;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[(1<<n)-1]);\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"数学"},{"name":"组合计数"},{"name":"容斥"}],
			"title": "ABC236Ex Distinct Multiples 做题记录",
			"link": "https://exber.qzz.io/post/ABC236Ex%20Distinct%20Multiples%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-11-15 21:40:00"
		},
	
		{
			"abstract": "",
			"content": "## 做法\n\n最小割。\n\n这是我第一次在赛场上做出有难度的网络流，写篇题解纪念一下。\n\n赛后发现**我的建模方法和官方题解并不相同**，所以这篇题解也算是提供了一种新奇的建图思路吧。\n\n首先**观察到每个人有两种选择：愿意和不愿意**。那么可以用源点表示愿意，汇点表示不愿意。具体就是**对第 $i$ 个人建立节点 $i$，然后从源点向 $i$ 连一条流量为 $d_i$ 的边，从 $i$ 向汇点连一条流量为 $c_i$ 的边**：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/lcz0hk8f.png)\n\n然后考虑同一组内的两个人 $x,y$ 意见不同（$x$ 选择了愿意）的情况，此时情况如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/eznq6i04.png)\n\n因为会产生 $e_x$ 的不满，所以**从 $x$ 向 $y$ 连一条流量为 $e_x$ 的边来增加不满**。\n\n对于 $y$ 选择了愿意但是 $x$ 选择了不愿意的情况亦然。\n\n加上这些边之后的图如下：（两个奇奇怪怪的点是用来防止边权重叠的）\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qxt14ja3.png)\n\n接下来我们就需要解决最棘手的喜欢关系了。（赛场上想了 1h 左右/ll）\n\n首先可以发现，只有一组里两个人都选择愿意才可以合作。所以**可以给每一组引入一个点 $x_i$，从 $x_i$ 分别向两个成员连流量为 $\\inf$ 的边**：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/mnqf3c2s.png)\n\n这么连边的目的是，假设有一些流量送到了 $x_i$：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/awfurcaq.png)\n\n那么就**可以保证每一组如果不合作的话给 $x_i$ 送流量的边都要被割断，如果合作的话就不隔断，并且如果一组中有一个或以上人选择了不愿意那么就必须不合作**。换句话说，**$x_i$ 没有流量代表这一组不合作，否则代表这一组合作**。\n\n现在我们可以表示合不合作了，接下来考虑喜欢关系的连边。\n\n若第 $j$ 组关系是 $x_j$ 喜欢 $y_j$，**设 $u$ 表示 $x_j$ 那一组的 $x_i$，$v$ 表示 $y_j$ 那一组的 $x_i$**，那么：\n\n如果 $x_j$ 没有和队友合作，并且 $y_j$ 选择了愿意，在图上就是 $y_j$ 有流量并且 $u$ 不能有流量。此时会产生 $a_j$ 的不满，那么我们可以**从有流量的 $y_j$ 向不能有流量的 $u$ 连一条流量为 $a_j$ 的边**。\n\n如果 $x_j$ 选择了不愿意，并且 $y_j$ 和队友合作了，在图上就是 $x_j$ 连向汇点的边没有被割断并且 $v$ 有流量。此时会产生 $b_j$ 的不满，那么我们可以**从有流量的 $v$ 向可以到达汇点的 $x_j$ 连一条流量为 $b_j$ 的边**。\n\n加上这些边后的图：（假设有一条喜欢关系：$2$ 喜欢 $3$）\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/objy4fqi.png)\n\n这样我们就建完图了，跑最小割即可。\n\n## AC 代码\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\nstruct node\n{\n};\n\ntypedef long long ll;\n\nconst ll S=5000005,MS=1000005;\n\nint n,m,s,t;\nint xid[MS];\nint esum,to[S],nxt[S],h[MS];\nll c[S];\nint dep[MS];\n\ninline void init()\n{\n\tesum=1;\n\tmemset(h,0,sizeof(h));\n\ts=0;\n\tt=1000003;\n}\n\ninline void add(int x,int y,ll w)\n{\n\tc[++esum]=w;\n\tto[esum]=y;\n\tnxt[esum]=h[x];\n\th[x]=esum;\n}\n\ninline bool bfs()\n{\n\tmemset(dep,0,sizeof(dep));\n\tqueue<int> q;\n\tq.push(s);\n\tdep[s]=1;\n\twhile(!q.empty())\n\t{\n\t\tint u=q.front();\n\t\tq.pop();\n\t\tfor(int i=h[u];i;i=nxt[i])\n\t\t{\n\t\t\tint v=to[i];\n\t\t\tif(c[i]>0&&dep[v]==0)\n\t\t\t{\n\t\t\t\tdep[v]=dep[u]+1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn dep[t]!=0;\n}\n\nll dfs(int u,ll w)\n{\n\tif(u==t)\n\t{\n\t\treturn w;\n\t}\n\tll sum=0;\n\tfor(int i=h[u];i;i=nxt[i])\n\t{\n\t\tint v=to[i];\n\t\tif(c[i]>0&&dep[v]==dep[u]+1)\n\t\t{\n\t\t\tll re=dfs(v,min(w,c[i]));\n\t\t\tc[i]-=re;\n\t\t\tc[i^1]+=re;\n\t\t\tsum+=re;\n\t\t\tw-=re;\n\t\t\tif(w==0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif(sum==0)\n\t{\n\t\tdep[u]=0;\n\t}\n\treturn sum;\n}\n\ninline ll dinic()\n{\n\tll ans=0;\n\twhile(bfs())\n\t{\n\t\tans+=dfs(s,1e17);\n\t}\n\treturn ans;\n}\n\ninline void slove()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tn*=2;\n\tinit();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tll C,D,E;\n\t\tscanf(\"%lld%lld%lld\",&C,&D,&E);\n\t\tadd(s,i,D);\n\t\tadd(i,s,0);\n\t\tadd(i,t,C);\n\t\tadd(t,i,0);\n\t\tint v=(i&1)?i+1:i-1;\n\t\tadd(i,v,E);\n\t\tadd(v,i,0);\n\t}\n\tfor(int i=1;i<=n;i+=2)\n\t{\n\t\tint u=n+(i+1)/2;\n\t\tadd(u,i,1e17);\n\t\tadd(i,u,0);\n\t\tadd(u,i+1,1e17);\n\t\tadd(i+1,u,0);\n\t\txid[i]=u;\n\t\txid[i+1]=u;\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x,y;\n\t\tll a,b;\n\t\tscanf(\"%d%d%lld%lld\",&x,&y,&a,&b);\n\t\tint u1=xid[y],v1=xid[x];\n\t\tadd(u1,x,b);\n\t\tadd(x,u1,0);\n\t\tadd(y,v1,a);\n\t\tadd(v1,y,0);\n\t}\n\tprintf(\"%lld\\n\",dinic());\n}\n\nint main()\n{\n\tint _=1;\n//\tscanf(\"%d\",&_);\n\twhile(_--)\n\t{\n\t\tslove();\n\t}\n\treturn 0; \n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"网络流"},{"name":"图论"},{"name":"构造"}],
			"title": "P8215 [THUPC2022 初赛] 分组作业 做题记录",
			"link": "https://exber.qzz.io/post/P8215%20%5BTHUPC2022%20%E5%88%9D%E8%B5%9B%5D%20%E5%88%86%E7%BB%84%E4%BD%9C%E4%B8%9A%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-11-09 16:28:42"
		},
	
		{
			"abstract": "",
			"content": "有些时候把坐标系转 45 度看着会更好理解。\n\n**若无特殊说明，所有数字均为非负整数，保证能从起点走到终点。**\n\n## Part 1 曼哈顿格路计数\n\n> 当你在 $(x,y)$，你下一步只能走到 $(x+1,y)$ 或者 $(x,y+1)$。\n\n### 1.1 定义\n\n- $f(x1,y1,x2,y2)$ 为从 $(x1,y1)$ 走到 $(x2,y2)$ 的方案数（$x1\\le x2,y1\\le y2$）；\n- $cf(x1,y1,x2,y2,k)$ 为从 $(x1,y1)$ 走到 $(x2,y2)$，并且和直线 $y=x+k$ **有交**的方案数；\n- $ncf(x1,y1,x2,y2,k)$ 为从 $(x1,y1)$ 走到 $(x2,y2)$，并且和直线 $y=x+k$ **没有交**的方案数；\n- $csf(n,m,k)$ 为从 $(0,0)$ 走到 $(n,m)$ 的所有方案中，和直线 $y=x+k$ 的交点个数和；\n- $cbf(n,k,b)$ 为从 $(0,0)$ 走到 $(n,kn+b)$，并且和直线 $y=kx+b+1$ **有交**的方案数；\n- $ncbf(n,k,b)$ 为从 $(0,0)$ 走到 $(n,kn+b)$，并且和直线 $y=kx+b+1$ **没有交**的方案数；\n- $nc2f(n,m,k1,k2)$ 为从 $(0,0)$ 走到 $(n,m)$，并且和直线 $y=x+k1$ 与直线 $y=x+k2$ **都没有交**的方案数，保证 $(0,0)$ 和 $(n,m)$ 都在两条直线之间（$k1>0$，$k2<0$）；\n\n### 1.2 正文\n\n#### 1.2.1 $f$\n\n会有 $x2-x1$ 步向上，$y2-y1$ 步向右，它们可以任意排列，则 $f(x1,y1,x2,y2)=\\binom{x2-x1+y2-y1}{x2-x1}$。\n\n#### 1.2.2 $cf$ 和 $ncf$\n\n显然有 $ncf=f-cf$。\n\n则只需要计算 $cf$。\n\n分三种情况：\n\n- 若 $x2+k<y1$ 或 $x1+k>y2$ 则直线和路径没有任何关系，则 $cf=0$；\n\n- 若 $x2+k\\le y2$ 则一定有交，那么 $cf=f$；\n\n- 否则考虑类似将军饮马的思路，找出 $(x2,y2)$ 关于 $y=x+k$ 的对称点 $(y2-k,x2+k)$，则从 $(x1,y1)$ 到 $(y2-k,x2+k)$ 一定有交，且将第一个交点后面的路径关于 $y=x+k$ 整体翻折后与从 $(x1,y1)$ 到 $(x2,y2)$ 的和直线相交的路径构成双射：\n\n  ![](../post-images/1697632295321.png)\n\n  那么有 $cf(x1,y1,x2,y2,k)=f(x1,y1,y2-k,x2+k)$；\n\n综上，有：\n$$\ncf(x1,y1,x2,y2)=\\begin{cases}\n0& x2+k<y1\\text{ 或 }x1+k>y2\\\\\nf(x1,y1,x2,y2)& x2+k\\le y2\\\\\nf(x1,y1,y2-k,x2+k)&x2+k>y2\n\\end{cases}\n$$\n$ncf$ 减一减就出来了。\n\n#### 1.2.3 $csf$\n\n对每个 $(x,x+k)$ 算贡献，有：\n\n$$\ncsf(n,m,k)=\\sum\\limits_{i=0}^n f(0,0,i,i+k)\\times f(i,i+k,n,m)\n$$\n\n似乎没法优化，换一种思路，注意到：\n\n- 若 $n+k\\le m$ 则一定要交至少一次。那么不妨设 $csf(n,m,k)=f(0,0,n,m)+res$，其中 $res$ 为不是最后一个交点的交点个数，则有：\n\n    $$\n    \\begin{aligned}\n    res&=\\sum\\limits_{i=0}^n f(0,0,i,i+k)\\times(cf(i+1,i+k,n,m,k)+cf(i,i+k+1,n,m,k))\\\\\n    &=\\sum\\limits_{i=0}^n f(0,0,i,i+k)\\times(f(i+1,i+k,n,m)+f(i,i+k+1,m-k,n+k))\\\\\n    &=\\sum\\limits_{i=0}^n f(0,0,i,i+k)\\times f(i+1,i+k,n,m)\\times 2\\\\\n    &=2\\times \\sum\\limits_{i=0}^n f(0,0,i,i+k)\\times f(i,i+k,n-1,m)\\\\\n    \\end{aligned}\n    $$\n\n    第二行到第三行是因为两个路径关于直线对称，第三行到第四行是因为先往右走一步等价于最后往左走一步。\n\n    注意到 $\\sum\\limits_{i=0}^n f(0,0,i,i+k)\\times f(i,i+k,n-1,m)=csf(n-1,m,k)$，那么有：\n    $$\n    res=2\\times csf(n-1,m,k)\n    $$\n    那么不断展开下去，直到 $n=0$，得到：\n    $$\n    csf(n,m,k)=\\sum\\limits_{i=0}^n 2^{n-i}f(0,0,i,m)=\\sum\\limits_{i=0}^n 2^{n-i}\\binom{m+i}{m}\n    $$\n\n- 对于 $n+k>m$ 的情况，只有 $cf(0,0,n,m,k)$ 种方案会有交。那么仍然是设 $csf(n,m,k)=cf(0,0,n,m,k)+res$，$res$ 的定义不变，那么有：\n    $$\n    \\begin{aligned}\n    res&=\\sum\\limits_{i=0}^n f(0,0,i,i+k)\\times(cf(i+1,i+k,n,m,k)+cf(i,i+k+1,n,m,k))\\\\\n    &=\\sum\\limits_{i=0}^n f(0,0,i,i+k)\\times(f(i+1,i+k,m-k,n+k)+f(i,i+k+1,n,m))\\\\\n    &=\\sum\\limits_{i=0}^n f(0,0,i,i+k)\\times f(i,i+k+1,n,m)\\times 2\\\\\n    &=2\\times \\sum\\limits_{i=0}^n f(0,0,i,i+k)\\times f(i,i+k,n,m-1)\\\\\n    &=2\\times csf(n,m-1,k)\n    \\end{aligned}\n    $$\n    所以：\n    $$\n    csf(n,m,k)=\\sum\\limits_{i=0}^m 2^{m-i}cf(0,0,n,i,k)=\\sum\\limits_{i=k}^m 2^{m-i}\\binom{n+i}{n+k}\n    $$\n\n那么问题转变为求解 $\\sum\\limits_{i=k}^n 2^{n-i}\\binom{m+i}{m+k}$（$n,m,k$ 不再是原来那三个 $n,m,k$）。\n\n遇到这种组合数求和，不妨放到杨辉三角上看看：（牢记 $\\binom{n}{m}=\\binom{n-1}{m}+\\binom{n-1}{m-1}$）\n\n![](../post-images/1697632948748.png)\n\n所以有：\n$$\n\\sum\\limits_{i=k}^n 2^{n-i}\\binom{m+i}{m+k}=\\sum\\limits_{i=m+k+1}^{m+n+1}\\binom{m+n+1}{i}\n$$\n所以：\n$$\ncsf(n,m,k)=\\begin{cases}\n\\sum\\limits_{i=m+1}^{m+n+1}\\binom{m+n+1}{i}&n+k\\le m\\\\\n\\sum\\limits_{i=n+k+1}^{m+n+1}\\binom{m+n+1}{i}&n+k> m\n\\end{cases}\n$$\n\n#### 1.2.4 $cbf$ 和 $ncbf$\n\n只需要求 $cbf$。\n\n设 $m=kn+b$。\n\n枚举钦定的最后一个交点 $(p,kp+b+1)$，则交点之后的路径数（不管实际上有没有交）为：\n\n$$\\begin{aligned}\\\\f(p,kp+b+1,n,m)&=\\frac{(m-kp-b-1+n-p)!}{(m-kp-b-1)!(n-p)!}\\\\&=\\frac{(m-kp-b-1+n-p)!}{(m-kp-b)!(n-p-1)!}\\times\\frac{m-kp-b}{n-p}\\\\&=\\binom{m-kp-b+n-p-1}{n-p-1}\\times\\frac{m-kp-b}{n-p}\\\\&=f(p,kp+b+1,n-1,m+1)\\times\\frac{kn+b-kp-b}{n-p}\\\\&=f(p,kp+b+1,n-1,m+1)k\\\\\\end{aligned}$$\n\n由于所有走到 $(n-1,m+1)$ 的路径都一定会和直线相交，所以有交点的路径和最后一个交点在 $(n,kn+b+1)$ 的路径构成双射，那么有 $cbf(n,k,b)=k\\binom{n+m}{n-1}=k\\binom{(k+1)n+b}{n-1}$。\n\n#### 1.2.5 $nc2f$\n\n回顾 $ncf$ 的计算方法，考虑容斥计算和两条直线有交的方案数。\n\n注意到沿 $y=x+k1$ 翻转终点可以计算出与 $y=x+k1$ 有交的方案数，沿 $y=x+k2$ 翻转终点可以计算出与 $y=x+k2$ 有交的方案数：\n\n![](../post-images/1709034036460.png)\n\n但是同时和两条直线相交的路径会被算两次。\n\n考虑终点先沿 $y=x+k1$ 翻转再沿 $y=x+k2$ 翻转后的路径，注意到每一条这样的路径先把和 $y=x+k2$ 的第一个交点后的部分翻转，再把该部分第一个和 $y=x+k1$ 的交点后的部分翻转都对应着一条和两条直线都有交的路径：\n\n![](../post-images/1709034549859.png)\n\n具体的，对于每一条从 $(0,0)$ 到 $(n,m)$ 的路径，设其交点序列 $b$ 为一个记录产生其每个交点的直线编号的 01 序列，例如上图红色路径的 $b$ 序列即为 $010$。\n\n那么把终点沿 $y=x+k1$ 翻转后相当于计算有多少路径的 $b$ 序列包含了子序列 $0$，沿 $y=x+k2$ 翻转后相当于计算有多少路径的 $b$ 序列包含了子序列 $1$，先沿 $k1$ 再沿 $k2$ 翻转相当于计算有多少包含了 $10$，先 $k2$ 再 $k1$ 相当于计算有多少包含了 $01$，先 $k1$ 再 $k2$ 再 $k1$ 相当于计算有多少包含了 $010$……\n\n接下来考虑一个很智慧的容斥，对于长 $l$ 的 $01$ 相间序列（终点翻转了 $l$ 次），其方案数对答案的贡献为 $(-1)^{l-1}$。\n\n证明这个容斥的正确性仅需证明每种非空 $b$ 序列都会被计算恰好 $1$ 次。\n\n对于一个非空 $b$ 序列，设其最长的 $0$ 开头的 $01$ 相间子序列长 $l_0$，$1$ 开头的长 $l_1$，显然 $|l_0-l_1|=1$。\n\n也就是说，$l_0$ 和 $l_1$ 奇偶性不同。\n\n注意到 $l_0$ 若为奇数则会贡献 $1$，为偶数则会贡献 $0$，$l_1$ 也一样。由于它们奇偶性不同，所以贡献和一定为 $1$，证毕。\n\n由于 $b$ 序列最多长 $n+m$，所以时间复杂度 $O(n+m)$。\n\n**upd 2025.10.27**\n\n考虑将坐标轴旋转 $45\\degree$，变成向右上走或者右下走，那么显然每翻折一次终点的 $y$ 坐标就会增加 $O(k1-k2)$，所以复杂度其实是 $O(\\frac{n}{k1-k2})$ 的\n\n## Part 2 切比雪夫格路计数\n\n这里主要讨论 $y$ 和 $0$ 取 $\\max$ 的特殊版本。实际上 $y$ 和一个数 $k$ 取 $\\min$ 的版本也是一样的。\n\n> 当你在 $(x,y)$，你下一步只能走到 $(x+1,y+1)$ 或者 $(x+1,\\max(y-1,0))$。\n\n### 2.1 定义\n\n- $qf(x_1,y_1,x_2,y_2)$ 为不取 $\\max$（每一步 $y+1$ 或者 $y-1$），从 $(x_1,y_1)$ 走到 $(x_2,y_2)$ 的方案数，显然这个可以直接用一个组合数算；\n- $qfm(x_1,y_1,x_2,y_2)$ 为从 $(x_1,y_1)$ 走到 $(x_2,y_2)$ 的方案数；\n\n### 2.2 正文\n\n#### 2.2.1 双射\n\n这样构造双射：\n\n> 考虑 $y$ 坐标的变化。不断将第一个 $0\\to 0$ 变成 $0\\to-1$，第二个 $0\\to 0$ 变成 $-1\\to 0$，这中间的部分翻转下去：\n>\n> ![](../post-images/1761528174513.png)\n\n#### 2.2.2 $qfm$\n\n根据双射，只需要枚举一下终点是否被翻下去即可。所以有：（注意还要求 $y_1,y_2\\ge 0$）\n$$\nqfm(x_1,y_1,x_2,y_2)=qf(x_1,y_1,x_2,y_2)+qf(x_1,y_1,x_2,-1-y_2)\n$$\n\n#### 2.2.3 推广\n\n不难发现这个双射性质很好，所以类比曼哈顿格路计数，也可以求出各种关于一根横线的问题的方案数。注意在这个走路模型下不碰到两根横线的问题显然是没有意义的。\n\n## Part 3 一些技巧\n\n### 3.1 连边映射\n\n对于每一步转移都会让路径权值乘上关于 $x$ 和 $y$ 的一次代价的格路计数问题，可以考虑把每一步转移放进序列，利用分配律拆贡献，每一步转移选择前面一个和其有贡献的转移连权值为对应贡献的无向边，形成一棵树，然后对于这样的树计算权值积之和。\n\n例如：\n\n> 每一步从 $(x,y)$ 走到 $(x+1,y)$ 或 $(x,y+1)$。\n>\n> - 从 $(x,y)$ 走到 $(x+1,y)$ 会让路径权值乘上 $a_1x+b_1y+w_1$；\n> - 从 $(x,y)$ 走到 $(x,y+1)$ 会让路径权值乘上 $a_2x+b_2y+w_2$；\n>\n> 求从 $(0,0)$ 走到 $(n,m)$ 的所有路径权值之和。\n\n考虑把每一步转移放入序列 $a$ 中，$x+1$ 为 $1$，否则为 $0$，则对于每个 $a_i$：\n\n- $a_i=0$：\n  - $i$ 和它前面的每个 $1$ 都会造成 $a_1$ 的贡献，故其可以和前面的每个 $1$ 连权值为 $a_1$ 的无向边 ；\n  - $i$ 和它前面的每个 $0$ 都会造成 $b_1$ 的贡献，故其可以和前面的每个 $0$ 连权值为 $b_1$ 的无向边；\n  - $i$ 还会额外贡献 $w_1$ 的权值，故其可以和点 $0$ 连权值为 $w_1$ 的无向边；\n- $a_i=1$ 同理，把 $a_1,b_1,w_1$ 换成 $a_2,b_2,w_2$ 即可；\n\n由于权值乘算，故每步转移选择一条能连的无向边连，这样会形成以 $0$ 为根的一棵父亲比儿子编号小的树，对于所有这样的树算边权积的和即可。\n\n由于 $(n,m)$ 固定，所以 $a$ 中 $0$ 和 $1$ 的个数都知道，那么用各种方法答案即可。\n\n例题：[【2024暑假集训ACM2】G.Competition](../【2024暑假集训ACM2】G.Competition 做题记录)\n\n## Part 4 练习\n\n- [【2023NOI模拟赛37】商人](../【2023NOI模拟赛37】商人 做题记录)\n- [QOJ14419 Maximum Segment Sum](https://qoj.ac/problem/14419)\n",
			"tags": [{"name":"学习笔记"},{"name":"数学"},{"name":"组合计数"}],
			"title": "格路计数入门",
			"link": "https://exber.qzz.io/post/%E6%A0%BC%E8%B7%AF%E8%AE%A1%E6%95%B0%E5%85%A5%E9%97%A8",
			"date": "2023-10-18 20:11:34"
		},
	
		{
			"abstract": "> 给定一个 $n$ 的排列 $a$ 和一个 $m$ 的排列 $b$。\n>\n> 每次操作你可以：\n>\n> - 选择两个正整数 $1\\le i\\le n$ 和 $1\\le j\\le m$；\n> - 将 $a$ 修改为 $a_{[i+1,n]}a_ia_{[1,i-1]}$，将 $b$ 修改为 $b_{[j+1,n]}b_jb_{[1,j-1]}$；\n>\n> 构造一组操作使得 $p_i=i$ 且 $q_i=i$ 且操作次数最少。如果无解，输出 $-1$。\n>\n> $1\\leq n,m\\leq 2500$。\n",
			"content": "> 给定一个 $n$ 的排列 $a$ 和一个 $m$ 的排列 $b$。\n>\n> 每次操作你可以：\n>\n> - 选择两个正整数 $1\\le i\\le n$ 和 $1\\le j\\le m$；\n> - 将 $a$ 修改为 $a_{[i+1,n]}a_ia_{[1,i-1]}$，将 $b$ 修改为 $b_{[j+1,n]}b_jb_{[1,j-1]}$；\n>\n> 构造一组操作使得 $p_i=i$ 且 $q_i=i$ 且操作次数最少。如果无解，输出 $-1$。\n>\n> $1\\leq n,m\\leq 2500$。\n\n显然若求出 $ma_{0/1}$ 和 $mb_{0/1}$ 表示操作次数为奇/偶数时复原 $a$ 和复原 $b$ 最少需要的操作次数，则最少的操作次数即为 $\\min(\\max(ma_0,mb_0),\\max(ma_1,mb_1))$。\n\n那么 $a$ 和 $b$ 独立。\n\n考虑把 $a$ 放在环上，并加入一个 $0$ 代表开头。对于一次操作，$a$ 从：\n$$\n0Aa_iB\n$$\n变成了：\n$$\n0Ba_iA=a_iA0B\n$$\n那么一次操作相当于交换 $a_i$ 和 $0$。\n\n那么枚举 $0$ 最终的位置，问题变成了每次交换 $a_i$ 和 $0$，求把一个 $0\\sim n$ 的排列还原的最小操作次数和方案。\n\n那么把置换环找出来，设 $l_{1\\sim k}$ 为这些环的大小，其中 $0$ 在 $l_1$ 对应的环中，则最小操作次数显然为 $l_1-1+\\sum\\limits_{i=2}^k [l_i>1](l_i+1)$。因为除了 $0$ 所在的环，其它的环都要先和 $0$ 交换一次以便把 $0$ 加入当前环。\n\n构造方案是简单的。\n\n而根据置换环的性质，每次操作一定会改变环数的奇偶性，所以所有还原方案的操作次数奇偶性一定相同。\n\n所以只需要找到最少的操作次数即可。\n\n时间复杂度 $O(n^2)$，代码如下：\n\n```cpp\n// Problem: Two Permutations (Hard Version)\n// Contest: Luogu\n// URL: https://www.luogu.com.cn/problem/CF1882E2\n// Memory Limit: 250 MB\n// Time Limit: 2000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n#include <iostream>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nconst int S=2505,inf=1e8;\n\nint n,m;\nint a[S],b[S];\nint ta[S];\nint fa[S],siz[S],pos[S];\nvector<int> ansa,ansb;\n\nint fnd(int x)\n{\n\treturn fa[x]==x?x:fa[x]=fnd(fa[x]);\n}\n\ninline int calc(int n,int a[],int x)\n{\n\tfor(int i=0;i<=n;i++) ta[(i+x)%(n+1)]=a[i];\n\tfor(int i=0;i<=n;i++) fa[i]=i,siz[i]=0;\n\tfor(int i=0;i<=n;i++) fa[fnd(i)]=fnd(ta[i]);\n\tfor(int i=0;i<=n;i++) siz[fnd(i)]++;\n\tint res=0;\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tint rx=fnd(i);\n\t\tif(i==0) res+=siz[rx]-1,siz[rx]=1;\n\t\telse if(siz[rx]!=1) res+=siz[rx]+1,siz[rx]=1;\n\t}\n\treturn res;\n}\n\ninline void getres(int n,int a[],int x,vector<int> &res)\n{\n\tfor(int i=0;i<=n;i++) ta[(i+x)%(n+1)]=a[i];\n\tfor(int i=0;i<=n;i++) pos[ta[i]]=i;\n\twhile(pos[0]!=0)\n\t{\n\t\tint u=pos[0],v=pos[u];\n\t\tres.push_back((v-pos[0]+(n+1))%(n+1));\n\t\tswap(pos[ta[u]],pos[ta[v]]);\n\t\tswap(ta[u],ta[v]);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(ta[i]!=i)\n\t\t{\n\t\t\tres.push_back((i-pos[0]+(n+1))%(n+1));\n\t\t\tswap(pos[ta[0]],pos[ta[i]]);\n\t\t\tswap(ta[0],ta[i]);\n\t\t\twhile(pos[0]!=0)\n\t\t\t{\n\t\t\t\tint u=pos[0],v=pos[u];\n\t\t\t\tres.push_back((v-pos[0]+(n+1))%(n+1));\n\t\t\t\tswap(pos[ta[u]],pos[ta[v]]);\n\t\t\t\tswap(ta[u],ta[v]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=m;i++) scanf(\"%d\",&b[i]);\n\tint ra[2]={-1,-1},rb[2]={-1,-1};\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tint val=calc(n,a,i);\n\t\tif(ra[val&1]==-1||val<calc(n,a,ra[val&1])) ra[val&1]=i;\n\t}\n\tfor(int i=0;i<=m;i++)\n\t{\n\t\tint val=calc(m,b,i);\n\t\tif(rb[val&1]==-1||val<calc(m,b,rb[val&1])) rb[val&1]=i;\n\t}\n\tint r0=inf,r1=inf;\n\tif(ra[0]!=-1&&rb[0]!=-1) r0=max(calc(n,a,ra[0]),calc(m,b,rb[0]));\n\tif(ra[1]!=-1&&rb[1]!=-1) r1=max(calc(n,a,ra[1]),calc(m,b,rb[1]));\n\tif(r0==inf&&r1==inf) return puts(\"-1\"),0;\n\tif(r0<r1)\n\t{\n\t\tgetres(n,a,ra[0],ansa);\n\t\tgetres(m,b,rb[0],ansb);\n\t}\n\telse\n\t{\n\t\tgetres(n,a,ra[1],ansa);\n\t\tgetres(m,b,rb[1],ansb);\n\t}\n\tint len=max(ansa.size(),ansb.size());\n\tprintf(\"%d\\n\",len);\n\tfor(int i=0;i<len;i++)\n\t{\n\t\tif(i<ansa.size()) printf(\"%d \",ansa[i]);\n\t\telse printf(\"%d \",i&1?1:n);\n\t\tif(i<ansb.size()) printf(\"%d\\n\",ansb[i]);\n\t\telse printf(\"%d \",i&1?1:m);\n\t}\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"结论"}],
			"title": "CF1882E2 Two Permutations (Hard Version) 做题记录",
			"link": "https://exber.qzz.io/post/CF1882E2%20Two%20Permutations%20%28Hard%20Version%29%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-10-14 22:25:03"
		},
	
		{
			"abstract": "> 给定一个 $n$ 的排列 $P$，一个长 $n$ 的 01 串 $S$ 合法当且仅当：\n>\n> - 设 $A$ 为所有 $S_i=1$ 的 $a_i$ 构成的子序列，$B$ 为所有 $S_i=0$ 的 $a_i$ 构成的子序列，则 $A$ 和 $B$ 的前缀最大值个数相等；\n>\n> 求所有合法的 $S$ 中字典序最小的那个。\n>\n> $1\\le n\\le 2\\times 10^5$。\n",
			"content": "> 给定一个 $n$ 的排列 $P$，一个长 $n$ 的 01 串 $S$ 合法当且仅当：\n>\n> - 设 $A$ 为所有 $S_i=1$ 的 $a_i$ 构成的子序列，$B$ 为所有 $S_i=0$ 的 $a_i$ 构成的子序列，则 $A$ 和 $B$ 的前缀最大值个数相等；\n>\n> 求所有合法的 $S$ 中字典序最小的那个。\n>\n> $1\\le n\\le 2\\times 10^5$。\n\n\n显然 $P$ 中的前缀最大值在 $A$ 和 $B$ 中还是前缀最大值，那么不妨将在 $P$ 中就是前缀最大值的数称为“旧的”，在 $P$ 中不是但在 $A$ 或 $B$ 中是前缀最大值的数成为“新的”。\n\n那么有个结论：\n\n> 若合法的 $S$ 存在，那么一定存在某个合法的 $S$ 满足 $A$ 中的前缀最大值都是旧的。\n\n<details><summary>证明</summary><p>\n\n> 若 $A$ 和 $B$ 中都存在新的前缀最大值，那么交换它们管辖（$A$ 中 $i$ 能管辖到 $j$ 当且仅当 $A_i=\\max\\limits_{k=1}^jA_k$，$B$ 中同理）到的所有数即可。\n\n</p></details>\n\n那么考虑贪心，从前往后枚举 $S$ 的每个位，判断这一位填 $0$ 后还存不存在合法的 $S$ 即可。\n\n设当前填完了 $S_{[1,i]}$，$A$ 共有 $cx$ 个前缀最大值，当前最大值为 $mx$；$B$ 共有 $cy$ 个前缀最大值，当前最大值为 $my$，$P_{[i+1,n]}$ 中一共有 $c$ 个旧的前缀最大值。\n\n不妨假设 $A$ 之后的前缀最大值全都是旧的，那么设 $B$ 后面共有 $k$ 个旧的前缀最大值和 $m$ 个新的前缀最大值，则当前填法合法当且仅当有：\n$$\n\\begin{aligned}\ncx+c-k&=cy+k+m\\\\\nm+2k&=cx+c-cy\n\\end{aligned}\n$$\n$cx+c-cy$ 是已知的，那么只要判断 $m+2k$ 是否能满足即可。\n\n而这就相当于给旧的前缀最大值赋一个 $2$ 的权值，其它数赋 $1$，求能否在 $P_{[i+1,n]}$ 中找到一个严格上升子序列 $R$ 满足 $R_1>my$ 且 $R$ 的权值和为 $cx+c-cy$。\n\n不难发现若找到了权值和为 $x$ 的严格上升子序列，则一定能找到权值和为 $x-2$ 的。所以找到权值和为奇数/偶数的最大的权值和即可。\n\n那么使用值域线段树维护，先倒着扫一遍求出 $f_{i,0/1}$ 表示以 $i$ 开头的权值和为偶数/奇数的严格上升子序列的最大的权值和，在贪心的时候每次把 $f_{P_i}$ 删掉即可。\n\n时间复杂度 $O(n\\log n)$，代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=200005;\n\nstruct segment\n{\n\tint mx[S<<2];\n\tinline void upda(int u)\n\t{\n\t\tmx[u]=max(mx[u<<1],mx[u<<1|1]);\n\t}\n\tvoid upd(int u,int l,int r,int p,int x)\n\t{\n\t\tif(l==r) return mx[u]=x,void();\n\t\tint mid=l+r>>1;\n\t\tif(p<=mid) upd(u<<1,l,mid,p,x);\n\t\telse upd(u<<1|1,mid+1,r,p,x);\n\t\tupda(u);\n\t}\n\tint que(int u,int l,int r,int L,int R)\n\t{\n\t\tif(l>R||r<L) return -1e8;\n\t\tif(l>=L&&r<=R) return mx[u];\n\t\tint mid=l+r>>1,res=-1e8;\n\t\tif(L<=mid) res=max(res,que(u<<1,l,mid,L,R));\n\t\tif(R>=mid+1) res=max(res,que(u<<1|1,mid+1,r,L,R));\n\t\treturn res;\n\t}\n}tr[2];\n\nint n,a[S];\nbool flg[S];\nint ans[S];\n\ninline bool chk(int x,int val)\n{\n\tif(val<0) return false;\n\treturn tr[val&1].que(1,1,n,x,n)>=val;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor(int i=1,mx=0;i<=n;i++)\n\t{\n\t\tflg[i]=a[i]>mx;\n\t\tmx=max(mx,a[i]);\n\t}\n\tfor(int i=1;i<=n;i++) tr[1].upd(1,1,n,i,-1e8);\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tint p0=tr[0].que(1,1,n,a[i],n);\n\t\tint p1=tr[1].que(1,1,n,a[i],n);\n\t\tif(flg[i])\n\t\t{\n\t\t\ttr[0].upd(1,1,n,a[i],p0+2);\n\t\t\ttr[1].upd(1,1,n,a[i],p1+2);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttr[0].upd(1,1,n,a[i],p1+1);\n\t\t\ttr[1].upd(1,1,n,a[i],p0+1);\n\t\t}\n\t}\n\tint c=0;\n\tfor(int i=1;i<=n;i++) c+=flg[i];\n\tint cx=0,cy=0,mx=0,my=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tc-=flg[i];\n\t\ttr[0].upd(1,1,n,a[i],0);\n\t\ttr[1].upd(1,1,n,a[i],-1e8);\n\t\tint nx=cx+(a[i]>mx);\n\t\tint valx=nx+c-cy;\n\t\tint valy=cy+c-nx;\n\t\tif(chk(my,valx)||chk(max(mx,a[i]),valy))\n\t\t{\n\t\t\tans[i]=0;\n\t\t\tcx+=a[i]>mx;\n\t\t\tmx=max(mx,a[i]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tans[i]=1;\n\t\t\tcy+=a[i]>my;\n\t\t\tmy=max(my,a[i]);\n\t\t}\n\t}\n\tif(cx!=cy) return puts(\"-1\"),0;\n\tfor(int i=1;i<=n;i++) putchar(ans[i]+'0');\n\tprintf(\"\\n\");\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"贪心"},{"name":"结论"},{"name":"做题记录"}],
			"title": "AGC028E High Elements 做题记录",
			"link": "https://exber.qzz.io/post/AGC028E%20High%20Elements%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-10-10 21:10:15"
		},
	
		{
			"abstract": "> 给定一个长 $n$ 的 01 序列 $a$，对于每一个 $1\\le k\\le n$，求出 $a$ 划分为 $k$ 个连续段重排后的最长不下降子序列的最大值。\n>\n> $1\\le n\\le 3\\times 10^5$。\n",
			"content": "> 给定一个长 $n$ 的 01 序列 $a$，对于每一个 $1\\le k\\le n$，求出 $a$ 划分为 $k$ 个连续段重排后的最长不下降子序列的最大值。\n>\n> $1\\le n\\le 3\\times 10^5$。\n\n\n下文称最长不下降子序列为 LNDS。\n\n首先问题等价于划分成 $\\le k$ 个连续段。\n\n不难发现若 $a_i=a_{i+1}$ 则它们一定会被划分进同一个连续段，那么不妨将它们合并。\n\n于是问题转化为了长度为 $m$ 的 01 相间序列 $b_i$ 且每个 $i$ 有大小 $c_i$。\n\n发现由于 LNDS 中相邻两个 $b_i$ 相同的元素可以划分进同一段，所以直接做并不好做。那么考虑把不在 LNDS 中的元素删除，并把相邻两个相同元素合并。那么若最后剩下 $l$ 个元素，则：\n\n- LNDS 的长度为这 $l$ 个元素的 $c_i$ 之和；\n- 若 $l\\ge 3$ 则需要划分 $l-1$ 段因为 $\\exist i,b_i=0,b_{i+1}=1$；\n\n对于 $l\\le 2$ 的情况，不妨直接单独做。所以下面默认 $l\\ge 3$。\n\n不难发现如下性质：\n\n- 若删除边界元素，元素个数会减少 $1$，否则会减少 $2$，因为两边的元素会合并；\n\n- 一定不会同时删除 $b_i$ 和 $b_{i+1}$；\n\n那么先枚举 $b_1$ 和 $b_m$ 有没有被删，则问题转化为要找一些两两不相邻的元素删去，使得删掉的元素的 $c_i$ 之和最小。\n\n这是一个~~经典~~反悔贪心问题。\n\n不难发现对于未被删除的元素中 $c_i$ 最小的元素 $i$，若 $i$ 没被删掉则 $i-1$ 和 $i+1$ 就一定要都被删掉。\n\n那么用链表+小根堆维护，设当前删掉的元素总和为 $sm$，每次找到堆顶 $p$：\n\n- 令 $sm$ 加上 $c_p$；\n\n- 找到 $p$ 的前驱 $l$ 和后继 $r$：\n\n  - 若 $l$ 和 $r$ 均存在，则 $p$ 有可能不被删除，令 $c_p:=c_l+c_r-c_p$，在堆中加入 $(c_p,p)$。\n\n    此时原来的 $p$ 已被删除，现在的 $p$ 为 $l$ 和 $r$ 合并成的新元素，所以在链表中删除 $l$ 和 $r$。\n\n  - 否则 $p$ 一定会被删除，则在链表中删除 $p$。\n\n    此时 $l$ 和 $r$ 一定不会被删除，那么在链表中删除 $l$ 和 $r$（若存在）。\n\n重复 $k$ 次该过程则 LNDS 中将会有 $m-(2k+t)$（$t$ 为 $1$ 和 $m$ 中被删除的元素个数）个元素，需要划分为 $m-(2k+t)-1$ 段，那么开个答案数组每次对 $sm$ 取 $\\min$ 即可。\n\n时间复杂度 $O(n\\log n)$。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <queue>\n\nusing namespace std;\n\nconst int S=300005;\n\nint n;\nchar str[S];\nint m,a[S],val[S];\nint pre[S],nxt[S];\nbool sta[S];\nint ans[S];\n\ninline void del(int x)\n{\n\tpre[nxt[x]]=pre[x];\n\tnxt[pre[x]]=nxt[x];\n\tsta[x]=false;\n}\n\ninline void slove(int x,int y)\n{\n\tfor(int i=1;i<=m;i++) val[i]=a[i],pre[i]=i-1,nxt[i]=i+1,sta[i]=true;\n\tint c=0,sm=0;\n\tif(x) c++,sm+=val[1],del(nxt[1]);\n\tif(y) c++,sm+=val[m],del(pre[m]);\n\tdel(1),del(m);\n\tpriority_queue<pair<int,int>> q;\n\tfor(int i=1;i<=m;i++) if(sta[i]) q.push(make_pair(-val[i],i));\n\tans[m-c-1]=min(ans[m-c-1],sm);\n\twhile(m-c-1>=1&&!q.empty())\n\t{\n\t\tauto u=q.top();\n\t\tq.pop();\n\t\tint p=u.second;\n\t\tif(!sta[p]) continue;\n\t\tc+=2;\n\t\tsm+=val[p];\n\t\tans[m-c-1]=min(ans[m-c-1],sm);\n\t\tint l=pre[p],r=nxt[p];\n\t\tif(l!=0&&r!=m+1)\n\t\t{\n\t\t\tval[p]=val[l]+val[r]-val[p];\n\t\t\tq.push(make_pair(-val[p],p));\n\t\t}\n\t\telse del(p);\n\t\tif(l!=0) del(l);\n\t\tif(r!=m+1) del(r);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%s\",&n,str+1);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(str[i]=='0')\n\t\t{\n\t\t\tif(m==0||a[m]<0) a[++m]=1;\n\t\t\telse a[m]++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(m==0||a[m]>0) a[++m]=-1;\n\t\t\telse a[m]--;\n\t\t}\n\t}\n\tfor(int i=1;i<=m;i++) if(a[i]<0) a[i]=-a[i];\n\tfor(int i=1;i<=n;i++) ans[i]=1e8;\n\tslove(0,0);\n\tslove(1,0);\n\tslove(0,1);\n\tslove(1,1);\n\tfor(int i=1;i<=n;i++) ans[i]=n-ans[i];\n\tans[1]=0;\n\tint c1=0;\n\tfor(int i=1;i<=n;i++) c1+=str[i]=='1';\n\tfor(int i=1,c0=0;i<=n;i++)\n\t{\n\t\tc0+=str[i]=='0';\n\t\tans[1]=max(ans[1],c0+c1);\n\t\tc1-=str[i]=='1';\n\t}\n\tfor(int i=2;i<=n;i++) ans[i]=max(ans[i],ans[i-1]);\n\tfor(int i=1;i<=n;i++) printf(\"%d \",ans[i]);\n\tprintf(\"\\n\");\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"贪心"},{"name":"结论"}],
			"title": "QOJ5013 Astral Birth 做题记录",
			"link": "https://exber.qzz.io/post/QOJ5013%20Astral%20Birth%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-10-09 09:51:32"
		},
	
		{
			"abstract": "> 给定长 $n$ 的序列 $d$，求有多少个 $n$ 个点的有标号简单无向图（无自环重边）满足：\n>\n> - 点 $i$ 的度数为 $d_i$；\n> - 点 $1$ 到点 $i$ 有且仅有一条最短路；\n> - $\\forall j<i$，点 $1$ 到点 $i$ 的最短路长度大于等于点 $1$ 到点 $j$ 的；\n>\n> 对 $998244353$ 取模。\n>\n> $3\\le n\\le 300$，$2\\le d_i\\le 3$。\n",
			"content": "> 给定长 $n$ 的序列 $d$，求有多少个 $n$ 个点的有标号简单无向图（无自环重边）满足：\n>\n> - 点 $i$ 的度数为 $d_i$；\n> - 点 $1$ 到点 $i$ 有且仅有一条最短路；\n> - $\\forall j<i$，点 $1$ 到点 $i$ 的最短路长度大于等于点 $1$ 到点 $j$ 的；\n>\n> 对 $998244353$ 取模。\n>\n> $3\\le n\\le 300$，$2\\le d_i\\le 3$。\n\n考虑 bfs，显然图可以分成若干层，每一层点的编号连续且 bfs 树上的横叉边都在同一层内。\n\n那么不难想到设 $f_{i,j}$ 表示处理完前 $i$ 个点，最后一层往下连了 $j$ 条边的方案数。\n\n转移时下一层的区间一定是 $[i+1,i+j-1]$，且区间内去掉当前层的 $j$ 条边就只剩下一度点和二度点。那么不难想到设 $g_{i,j,k}$ 表示一层内有 $i$ 个 $1$ 度点和 $j$ 个二度点，往下一层连了 $k$ 条边的内部连边方案数。则有：\n$$\nf_{i,j}\\times g_{c1,c2,k}\\times j!\\to f_{i+j,k}\n$$\n其中 $c1$ 和 $c2$ 表示 $d_{[i+1,i+j-1]}$ 中 $2$ 和 $3$ 的个数。\n\n但是发现这样会算重，因为二度点无论连哪边都是一样的。\n\n所以若上一层有 $l$ 个二度点是两边都往下连的，则转移时需要除掉 $2^l$。\n\n这个问题是好处理的，只需要把 $2^l$ 放进 $g$ 中即可。\n\n现在来考虑 $g$ 怎么求，首先显然有 $g_{0,0,0}=1$。\n\n不难发现一度点和二度点之间的顺序是没有关系的，所以不妨钦定先放一度点再放二度点。\n\n下文 `x` 表示一度点，`o` 表示二度点，`-` 表示层内连边，`+` 表示向下一层的连边\n\n对于没有二度点的情况，考虑最后一个一度点 $u$：\n\n- `u+` 型：$g_{i-1,0,k-1}$；\n- `x-u` 型：$g_{i-2,0,k}\\times (i-1)$；\n\n对于有二度点的情况，考虑最后一个二度点 $u$。为了避免算重，$u$ 多出来的边直接往下连：\n\n- `+u+` 型：$g_{i,j-1,k-2}\\times \\frac{1}{2}$，其中 $\\frac{1}{2}$ 是转移时的 $2^l$；\n- `x-u+` 型：$g_{i-1,j-1,k-1}\\times i$；\n- `-o-u+` 型：连出去的二度点规约为一个一度点，$g_{i+1,j-2,k-1}\\times(j-1)$；\n- `x-u-x` 型：$g_{i-2,j-1,k}\\times \\frac{i\\times(i-1)}{2}$；\n- `x-u-o-` 型：连出去的二度点规约为一个一度点，$g_{i,j-2,k}\\times i\\times (j-1)$；\n- `-o-u-o-` 型：两个二度点都规约为一度点，$g_{i+2,j-3,k}\\times \\frac{(j-1)\\times(j-2)}{2}$；\n\n时间复杂度 $O(n^3)$，空间复杂度 $O(n^3)$。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=305,p=1000000007,inv2=(p+1)/2;\n\nint fra[S];\nint n,a[S];\nint g[S][S][S],f[S][S];\n\ninline void add(int &x,int y)\n{\n\tx+=y;\n\tif(x>=p) x-=p;\n}\n\ninline int qpow(int x,int y)\n{\n\tint res=1;\n\tfor(;y>0;y>>=1,x=1ll*x*x%p) res=y&1?1ll*res*x%p:res;\n\treturn res;\n}\n\nint main()\n{\n\tfra[0]=1;\n\tfor(int i=1;i<=S-3;i++) fra[i]=1ll*fra[i-1]*i%p;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tg[0][0][0]=1;\n\tfor(int k=0;k<=n;k++)\n\t{\n\t\tfor(int j=0;j<=n&&j+k<=n;j++)\n\t\t{\n\t\t\tfor(int i=0;i<=n&&i+j+k<=n;i++)\n\t\t\t{\n\t\t\t\tif(i+j*2<k) continue;\n\t\t\t\tif(i+j+k==0) continue;\n\t\t\t\tint &u=g[i][j][k];\n\t\t\t\tif(j==0)\n\t\t\t\t{\n\t\t\t\t\t// u-\n\t\t\t\t\tif(k>=1) add(u,g[i-1][j][k-1]);\n\t\t\t\t\t// u-x\n\t\t\t\t\tif(i>=2) add(u,1ll*g[i-2][j][k]*(i-1)%p);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// x-u-x\n\t\t\t\t\tif(i>=2) add(u,1ll*g[i-2][j-1][k]*i%p*(i-1)%p*inv2%p);\n\t\t\t\t\t// x-u-o- OR -o-u-x\n\t\t\t\t\tif(i>=1&&j>=2) add(u,1ll*g[i][j-2][k]*i%p*(j-1)%p);\n\t\t\t\t\t// -o-u-o-\n\t\t\t\t\tif(j>=3) add(u,1ll*g[i+2][j-3][k]*(j-1)%p*(j-2)%p*inv2%p);\n\t\t\t\t\tif(k>=1)\n\t\t\t\t\t{\n\t\t\t\t\t\t// x-u- OR -u-x\n\t\t\t\t\t\tif(i>=1) add(u,1ll*g[i-1][j-1][k-1]*i%p);\n\t\t\t\t\t\t// -o-u- OR -u-o-\n\t\t\t\t\t\tif(j>=2) add(u,1ll*g[i+1][j-2][k-1]*(j-1)%p);\n\t\t\t\t\t\tif(k>=2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// -u-\n\t\t\t\t\t\t\tadd(u,1ll*g[i][j-1][k-2]*inv2%p);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tf[1][a[1]]=qpow(fra[a[1]],p-2);\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tint c1=0,c2=0;\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tc1+=a[j]==2;\n\t\t\tc2+=a[j]==3;\n\t\t\tfor(int k=0;k<=n&&k<=c1+c2*2;k++)\n\t\t\t{\n\t\t\t\tint pre=1ll*f[i][j-i]*g[c1][c2][k]%p*fra[j-i]%p;\n\t\t\t\tadd(f[j][k],pre);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",f[n][0]);\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"DP"},{"name":"组合计数"}],
			"title": "LOJ6094 「Codeforces Round #418」归乡迷途 做题记录",
			"link": "https://exber.qzz.io/post/LOJ6094%20%E3%80%8CCodeforces%20Round%20%23418%E3%80%8D%E5%BD%92%E4%B9%A1%E8%BF%B7%E9%80%94%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-10-06 22:07:28"
		},
	
		{
			"abstract": "",
			"content": "## Part 1 定义\n\n在长链剖分中，我们定义 $u$ 的长儿子为：\n\n- $u$ 的所有儿子 $v$ 中，子树最高的那个 $v$；\n\n与重链剖分一样，每个点和它的长儿子划分到同一条长链。\n\n## Part 2 性质\n\n#### 2.1 每个点属于且仅属于一条长链\n\n#### 2.2 一个点到根的路径上长链的条数是 $O(\\sqrt n)$ 的\n\n对于一个子树高度为 $k$ 的节点 $u$，若它的父亲 $fa$ 和 $u$ 并不在一条长链中，则 $fa$ 的子树大小至少为 $2k+1$。\n\n那么如果跳了 $x$ 条长链，则子树大小至少为 $\\sum\\limits_{i=1}^x i$。\n\n所以一个节点到根的路径上，长链的条数是 $O(\\sqrt n)$ 的。\n\n#### 2.3 一个点的 $k$ 级祖先所在的长链的长度至少为 $k$\n\n## Part 3 应用\n\n#### 3.1 $O(n\\log n)/O(1)$ 在线求 $k$ 级祖先\n\n根据性质 2.1 和 2.3，不难想到 $u$ 的 $k$ 级祖先距离 $u$ 的 $2^{\\lfloor\\log_2k\\rfloor}$ 级祖先所在的长链 $lnk$ 的链头一定不超过 $|lnk|$ 个节点。\n\n那么维护出每个点 $u$ 的 $2^j$ 级祖先 $fa_{u,j}$，并维护每条长 $len$ 的长链链头的 $0\\sim len$ 级祖先和链上节点的顺序。\n\n查询的时候只需要找到 $u$ 的 $2^{\\lfloor\\log_2k\\rfloor}$ 级祖先 $fa_{u,\\lfloor\\log_2k\\rfloor}$，然后从链头开始跳即可。\n\n#### 3.2 优化树形 dp\n\n某些树形 dp 的第二维只和深度有关系，且转移时的整体变化可以快速维护，则可以使用长链剖分优化。\n\n例如 [CF1009F Dominant Indices](https://www.luogu.com.cn/problem/CF1009F)：\n\n> 给定一棵以 $1$ 为根，$n$ 个节点的树。设 $d(u,x)$ 为 $u$ 子树中到 $u$ 距离为 $x$ 的节点数。  \n>\n> 对于每个点，求一个最小的 $k$，使得 $d(u,k)$ 最大。\n\n不难想到一个朴素的 dp：设 $f_{u,i}$ 表示点 $u$ 子树内距离 $u$ 为 $i$ 的节点个数。\n\n转移：\n$$\nf_{u,0}=1\\\\\nf_{u,j}=\\sum\\limits_{v\\in son_u} f_{v,j-1}\n$$\n考虑优化，设点 $u$ 距离它所在长链的链头 $tp_u$ 为 $dep_u$，则考虑用 $tp_u$ 向下 $dep_u+j$ 个位置的点来保存 $u$ 的信息。根据性质 2.2，这样的点一定存在。\n\n那么把 $f_{u,j}$ 挂到 $f_{tp_u,dep_{u}+j}$ 上，则每个点的转移相当于直接继承它长儿子的信息，并把其它儿子的长链上信息暴力合并。\n\n由于每条长链只会被合并一次且长链的总长为 $n$，所以这样做的时间复杂度为 $O(n)$。\n\n<details><summary>代码</summary><p>\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nconst int S=1000005;\n\nint n;\nvector<int> g[S];\nint len[S],mx[S];\nint top[S],dep[S];\nint mxp[S];\nvector<int> f[S];\nint ans[S];\n\nvoid dfs(int u,int fa)\n{\n\tfor(int v:g[u])\n\t{\n\t\tif(v==fa) continue;\n\t\tdfs(v,u);\n\t\tlen[u]=max(len[u],len[v]);\n\t\tif(len[v]>len[mx[u]]) mx[u]=v;\n\t}\n\tlen[u]++;\n}\n\nvoid dfs2(int u,int fa,int tp)\n{\n\ttop[u]=tp;\n\tdep[u]=u==tp?1:dep[fa]+1;\n\tif(mx[u]!=0) dfs2(mx[u],u,tp);\n\tfor(int v:g[u])\n\t{\n\t\tif(v==fa||v==mx[u]) continue;\n\t\tdfs2(v,u,v);\n\t}\n}\n\nvoid dfs3(int u,int fa)\n{\n\tif(mx[u]!=0) dfs3(mx[u],u);\n\tint id=top[u];\n\tfor(int v:g[u])\n\t{\n\t\tif(v==fa||v==mx[u]) continue;\n\t\tdfs3(v,u);\n\t\tfor(int j=1;j<f[v].size();j++)\n\t\t{\n\t\t\tint idx=dep[u]+j;\n\t\t\tf[id][idx]+=f[v][j];\n\t\t\tif(f[id][idx]>f[id][mxp[id]]) mxp[id]=idx;\n\t\t\telse if(f[id][idx]==f[id][mxp[id]]&&idx<mxp[id]) mxp[id]=idx;\n\t\t}\n\t}\n\tint idx=dep[u];\n\tf[id][idx]++;\n\tif(f[id][idx]>f[id][mxp[id]]) mxp[id]=idx;\n\telse if(f[id][idx]==f[id][mxp[id]]&&idx<mxp[id]) mxp[id]=idx;\n\tans[u]=mxp[id]-dep[u];\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tg[x].push_back(y),g[y].push_back(x);\n\t}\n\tdfs(1,0),dfs2(1,0,1);\n\tfor(int i=1;i<=n;i++) f[i]={0};\n\tfor(int i=1;i<=n;i++) f[top[i]].push_back(0);\n\tdfs3(1,0);\n\tfor(int i=1;i<=n;i++) printf(\"%d\\n\",ans[i]);\n\treturn 0;\n}\n```\n\n</p></details>\n\n##### 更多例题\n\n- [P9655 『GROI-R2』 Beside You](https://www.luogu.com.cn/problem/P9655)\n",
			"tags": [{"name":"学习笔记"},{"name":"小技巧"}],
			"title": "长链剖分学习笔记",
			"link": "https://exber.qzz.io/post/%E9%95%BF%E9%93%BE%E5%89%96%E5%88%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-09-29 16:45:58"
		},
	
		{
			"abstract": "> 给定一张 $n$ 个点 $m$ 条边的无向图，求有哪些边满足删掉这一条边后的图是二分图。\n>\n> $1\\le n\\le 10^4$，$0\\le m\\le 10^4$，要求线性。\n",
			"content": "> 给定一张 $n$ 个点 $m$ 条边的无向图，求有哪些边满足删掉这一条边后的图是二分图。\n>\n> $1\\le n\\le 10^4$，$0\\le m\\le 10^4$，要求线性。\n\n\n显然要求的是所有奇环的交。\n\n考虑图的任意一棵生成树，称只包含一条返祖边的环为本源环，那么有个结论就是所有简单环都可以通过若干个本源环异或得到。\n\n证明是显然的，每个简单环都等价于环中非树边对应的本源环异或起来。\n\n接下来开始 Jelly Wen 定理，挖掘一条边可以成为答案的必要条件：\n\n- 必须要被所有奇本源环覆盖，这个显然；\n\n- 不能被任何偶本源环覆盖，这是因为删掉这条边后随便找一个奇本源环异或上覆盖它的偶本源环就可以得到一个奇环：\n\n  ![](../post-images/1695727615826.png)\n\n现在来证明这些必要条件的并是充要条件：\n\n- 所有奇环都是由奇数个奇本源环异或上若干个偶本源环得到的；\n- 被删掉的这条边被所有奇本源环覆盖且不被任何偶本源环覆盖；\n- 所以所有奇环中，被删掉的这条边都被本源环覆盖了奇数次；\n- 所以最后的图不存在奇环；\n\n那么用树上差分维护即可，时间复杂度 $O(n)$。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nconst int S=10005;\n\nint n,m;\nvector<pair<int,int>> g[S];\nbool vis[S];\nvector<int> son[S];\nint fid[S],dep[S],col[S];\nint ctt,tot[S];\n\nvoid dfs(int u,int fa)\n{\n\tdep[u]=dep[fa]+1;\n\tcol[u]=col[fa]^1;\n\tson[fa].push_back(u);\n\tvis[u]=true;\n\tint cnt=0;\n\tfor(auto t:g[u])\n\t{\n\t\tint v=t.first;\n\t\tif(!vis[v]) fid[v]=t.second,dfs(v,u);\n\t\telse if(v==fa)\n\t\t{\n\t\t\tif(++cnt>=2) ctt++,tot[u]--,tot[fa]++;\n\t\t}\n\t\telse if(dep[v]<dep[u])\n\t\t{\n\t\t\tif(col[u]==col[v]) ctt++,tot[u]++,tot[v]--;\n\t\t\telse tot[u]--,tot[v]++;\n\t\t}\n\t}\n}\n\nvoid dfs2(int u)\n{\n\tvis[u]=true;\n\tfor(int v:son[u])\n\t{\n\t\tdfs2(v);\n\t\ttot[u]+=tot[v];\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tg[x].push_back({y,i}),g[y].push_back({x,i});\n\t}\n\tfor(int i=1;i<=n;i++) if(!vis[i]) dfs(i,0);\n\tif(ctt==0)\n\t{\n\t\tprintf(\"%d\\n\",m);\n\t\tfor(int i=1;i<=m;i++) printf(\"%d \",i);\n\t\tprintf(\"\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++) vis[i]=false;\n\tfor(int i=1;i<=n;i++) if(!vis[i]) dfs2(i);\n\tvector<int> ans;\n\tfor(int i=1;i<=n;i++) if(tot[i]==ctt&&fid[i]!=0) ans.push_back(fid[i]);\n\tif(ctt==1)\n\t{\n\t\tfor(int u=1;u<=n;u++)\n\t\t{\n\t\t\tfor(auto t:g[u])\n\t\t\t{\n\t\t\t\tint v=t.first;\n\t\t\t\tif(v<u&&col[u]==col[v]) ans.push_back(t.second);\n\t\t\t}\n\t\t}\n\t}\n\tsort(ans.begin(),ans.end());\n\tprintf(\"%d\\n\",ans.size());\n\tfor(int u:ans) printf(\"%d \",u);\n\tprintf(\"\\n\");\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"图论"},{"name":"结论"}],
			"title": "CF19E Fairy 做题记录",
			"link": "https://exber.qzz.io/post/CF19E%20Fairy%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-09-26 19:26:51"
		},
	
		{
			"abstract": "> 给定两个正整数 $n,m$ 以及 $m$ 组限制 $l1_i,r1_i,l2_i,r2_i$，求是否存在一个长 $n$ 的序列 $a$ 满足 $\\forall 1\\le i\\le m$ 都有 $a_{[l1_i,r1_i]}$ 的字典序严格小于 $a_{[l2_i,r2_i]}$。\n>\n> $1\\le n,m\\le 2\\times 10^3$。\n",
			"content": "> 给定两个正整数 $n,m$ 以及 $m$ 组限制 $l1_i,r1_i,l2_i,r2_i$，求是否存在一个长 $n$ 的序列 $a$ 满足 $\\forall 1\\le i\\le m$ 都有 $a_{[l1_i,r1_i]}$ 的字典序严格小于 $a_{[l2_i,r2_i]}$。\n>\n> $1\\le n,m\\le 2\\times 10^3$。\n\n\n比较巧妙的建模题。\n\n对于每个限制，先考虑其第一个字符的大小关系，显然有 $a_{l1_i}\\le a_{l2_i}$。考虑建出一个 $n$ 个点的图 $G$，对于第 $i$ 个限制，从 $l1_i$ 向 $l2_i$ 连一条有向边表示它们的大小关系。\n\n那么不难发现 $G$ 中同一个强连通分量中的点对应位置上的字符是相同的。那么不妨把 $G$ 缩点。缩点后对于第 $i$ 个限制，设 $a_{[l1_i,r1_i]}$ 和 $a_{[l2_i,r2_i]}$ 长 $st_i$ 前缀已知相同，那么让 $l1_i$ 和 $l2_i$ 均加上 $st_i$，即可转化为子问题。\n\n无解当且仅当某一时刻某条限制 $i$ 满足 $l1_i+st_i\\le r1_i$ 且 $l2_i+st_i> r2_i$，有解则当且仅当这个过程可以不断进行下去，不难发现只有前 $n$ 次缩点是有效的。\n\n时间复杂度 $O(n^2)$。\n\n代码如下：\n\n```cpp\n// Problem: [ARC165D] Substring Comparison\n// Contest: Luogu\n// URL: https://www.luogu.com.cn/problem/AT_arc165_d\n// Memory Limit: 1 MB\n// Time Limit: 2000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n#include <iostream>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nconst int S=2005;\n\nstruct node\n{\n\tint l1,r1,l2,r2;\n}a[S];\n\nint n,m;\nint fa[S];\nvector<int> g[S];\nint cnt,dfn[S],low[S];\nint top,sta[S];\nbool vis[S],inst[S];\n\nint fnd(int x)\n{\n\treturn fa[x]==x?x:fa[x]=fnd(fa[x]);\n}\n\nvoid dfs(int u)\n{\n\tlow[u]=dfn[u]=++cnt;\n\tvis[u]=true;\n\tsta[++top]=u;\n\tinst[u]=true;\n\tfor(int v:g[u])\n\t{\n\t\tif(!vis[v]) dfs(v),low[u]=min(low[u],low[v]);\n\t\telse if(inst[v]) low[u]=min(low[u],dfn[v]);\n\t}\n\tif(low[u]==dfn[u])\n\t{\n\t\twhile(1)\n\t\t{\n\t\t\tint v=sta[top--];\n\t\t\tfa[fnd(v)]=fnd(u);\n\t\t\tinst[v]=false;\n\t\t\tif(v==u) break;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++) scanf(\"%d%d%d%d\",&a[i].l1,&a[i].r1,&a[i].l2,&a[i].r2);\n\tfor(int i=1;i<=n;i++) fa[i]=i;\n\tfor(int i=1;i<=m;i++) g[a[i].l1].push_back(a[i].l2);\n\tfor(int T=1;T<=n;T++)\n\t{\n\t\tcnt=0;\n\t\tfor(int i=1;i<=n;i++) vis[i]=inst[i]=false;\n\t\ttop=0;\n\t\tfor(int i=1;i<=n;i++) if(!vis[i]) dfs(i);\n\t\tfor(int i=1;i<=n;i++) g[i].clear();\n\t\tfor(int i=1;i<=m;i++)\n\t\t{\n\t\t\tint &l1=a[i].l1,&l2=a[i].l2;\n\t\t\tint r1=a[i].r1,r2=a[i].r2;\n\t\t\twhile(l1<=r1&&l2<=r2&&fnd(l1)==fnd(l2)) l1++,l2++;\n\t\t\tif(l2>r2) return puts(\"No\"),0;\n\t\t\tif(l1>r1) continue;\n\t\t\tg[fnd(l1)].push_back(fnd(l2));\n\t\t}\n\t}\n\tputs(\"Yes\");\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"图论"},{"name":"构造"}],
			"title": "ARC165D Substring Comparison 做题记录",
			"link": "https://exber.qzz.io/post/ARC165D%20Substring%20Comparison%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-09-21 08:27:32"
		},
	
		{
			"abstract": "> 给定长度为 $n$ 的序列 $a$，每次操作可以选定一个 $i$，并 $\\operatorname{swap}(a_i,a_{a_i})$。求能通过进行任意次这种操作得到的不同序列数。\n>\n> $n\\le 10^6$。 \n",
			"content": "> 给定长度为 $n$ 的序列 $a$，每次操作可以选定一个 $i$，并 $\\operatorname{swap}(a_i,a_{a_i})$。求能通过进行任意次这种操作得到的不同序列数。\n>\n> $n\\le 10^6$。 \n\n\n不妨称能经过若干次操作得到的序列为合法序列。\n\n看到这个操作形式可以想到建立一个 $n$ 个点的图 $G$ 且从 $i$ 向 $a_i$ 连一条有向边。那么 $G$ 一定是一棵内向基环树。\n\n那么发现一次操作相当于：\n\n![](../post-images/1695201087791.png)\n\n那么对于一个固定的 $i$，操作若干次相当于：\n\n![](../post-images/1695202077979.png)\n\n设 $i$ 最后指向的点为 $p_i$，显然 $p_i$ 一定是 $i$ 的某个祖先。则不难发现 $G$ 中每个点会且仅会被一条 $[i,p_i)$ 的链（$i\\to p_i$ 的去掉 $p_i$ 的路径）包含，那么每一个 $G$ 的链剖分方案都能对应一个合法序列（不一定是一一对应，一个合法序列有可能对应多个链剖分方案）：\n\n![](../post-images/1695204211184.png)\n\n设 $son_u=\\sum\\limits_{i=1}^n [a_i=u]$ 即 $u$ 的儿子个数，那么显然 $G$ 的链剖分方案个数就是 $\\prod\\limits_{i=1}^n son_i+1$ 即每个点可以选一个儿子的链接上或者不接。\n\n对于树的情况，容易发现链剖分方案和合法序列一一对应。但是由于是基环树，所以会出现这种情况：\n\n![](../post-images/1695208966470.png)\n\n也就是绕了一圈回来了。\n\n不难证明只有这种情况不合法，那么减掉这种链剖分的个数 $\\sum\\limits_{i=1}^n [i\\in cir]son_{i}\\times \\prod\\limits_{i=1}^n[i\\notin cir](son_i+1)$ 即可（在环上的每个点都可以选择某个儿子的链接上再绕一圈，不在环上的点不影响）。\n\n时间复杂度 $O(n)$，代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nconst int S=1000005,p=1000000007;\n\nint fra[S];\nint n,a[S];\nvector<int> g[S];\nint ind[S];\nint son[S],fa[S];\nint siz[S],res[S],ans[S];\n\nint fnd(int x)\n{\n\treturn fa[x]==x?x:fa[x]=fnd(fa[x]);\n}\n\nint main()\n{\n\tfra[0]=1;\n\tfor(int i=1;i<=S-3;i++) fra[i]=1ll*fra[i-1]*i%p;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++) g[i].push_back(a[i]),ind[a[i]]++;\n\tqueue<int> q;\n\tfor(int i=1;i<=n;i++) if(ind[i]==0) q.push(i);\n\twhile(!q.empty())\n\t{\n\t\tint u=q.front();\n\t\tq.pop();\n\t\tfor(int v:g[u]) if(--ind[v]==0) q.push(v);\n\t}\n\tfor(int i=1;i<=n;i++) son[a[i]]++,fa[i]=i;\n\tfor(int i=1;i<=n;i++) fa[i]=fnd(a[i]);\n\tfor(int i=1;i<=n;i++) siz[i]=0,res[i]=ans[i]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint ri=fnd(i);\n\t\tif(ind[i]==0) res[ri]=1ll*res[ri]*(son[i]+1)%p;\n\t\telse siz[ri]+=son[i],ans[ri]=1ll*ans[ri]*(son[i]+1)%p;\n\t}\n\tint val=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(fa[i]!=i) continue;\n\t\tval=1ll*val*((ans[i]-siz[i])%p+p)%p*res[i]%p;\n\t}\n\tprintf(\"%d\\n\",val);\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"组合计数"}],
			"title": "CF1863G Swaps 做题记录",
			"link": "https://exber.qzz.io/post/CF1863G%20Swaps%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-09-20 17:11:12"
		},
	
		{
			"abstract": "> 有 $n$ 个人来过，第 $i$ 个人在 $a_i$ 时刻来在 $b_i$ 时刻走，每个人可以在来时或走时登记，问可能的登记顺序有多少种。\n>\n> $n\\leqslant 5\\times 10^5$，$a_i,b_i$ 互不相同，$\\forall i<n,a_i<a_{i+1},b_{i}<b_{i+1}$。\n",
			"content": "> 有 $n$ 个人来过，第 $i$ 个人在 $a_i$ 时刻来在 $b_i$ 时刻走，每个人可以在来时或走时登记，问可能的登记顺序有多少种。\n>\n> $n\\leqslant 5\\times 10^5$，$a_i,b_i$ 互不相同，$\\forall i<n,a_i<a_{i+1},b_{i}<b_{i+1}$。\n\n\n容斥。\n\n观察到一个 $i$ 选 $a_i$ 和选 $b_i$ 本质不同当且仅当 $[a_i,b_i]$ 中有其他人选。\n\n那么容斥一下，钦定 $y$ 个不同的 $i$ 满足 $[a_i,b_i]$ 中没有其他人选，则对答案的贡献为 $2^{x}(-1)^y$，其中 $x$ 为与这 $y$ 个区间没有交的区间个数。\n\n那么设 $f_{i}$ 表示算完了前 $i$ 个人，钦定了 $[a_i,b_i]$ 中没有其他人选的总贡献和。\n\n转移直接枚举上一个钦定的人即可。\n\n可以用前缀和优化，时间复杂度 $O(n)$。\n\n代码如下：（$O(n\\log n)$ 树状数组）\n\n```cpp\n// Problem: [AGC061C] First Come First Serve\n// Contest: Luogu\n// URL: https://www.luogu.com.cn/problem/AT_agc061_c\n// Memory Limit: 1 MB\n// Time Limit: 2000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=500005,p=998244353,inv2=499122177;\n\nstruct node\n{\n\tint l,r;\n}a[S];\n\nint n;\nint iv2[S],pw2[S];\nint lst[S],nxt[S];\nint f[S],sum[S*2];\n\ninline void add(int &x,int y)\n{\n\tx+=y;\n\tif(x>=p) x-=p;\n}\n\ninline void addt(int p,int y)\n{\n\tif(p==0) return add(sum[p],y);\n\tfor(int i=p;i<=2*n;i+=i&-i) add(sum[i],y);\n}\n\ninline int quet(int p)\n{\n\tint res=sum[0];\n\tfor(int i=p;i>=1;i-=i&-i) add(res,sum[i]);\n\treturn res;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d%d\",&a[i].l,&a[i].r);\n\tiv2[0]=pw2[0]=1;\n\tfor(int i=1;i<=S-3;i++) iv2[i]=1ll*iv2[i-1]*inv2%p;\n\tfor(int i=1;i<=S-3;i++) pw2[i]=1ll*pw2[i-1]*2%p;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tlst[i]=i==1?1:lst[i-1];\n\t\twhile(a[lst[i]].r<a[i].l) lst[i]++;\n\t}\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tnxt[i]=i==n?n:nxt[i+1];\n\t\twhile(a[nxt[i]].l>a[i].r) nxt[i]--;\n\t}\n\tf[0]=1;\n\taddt(0,1ll*f[0]*iv2[0]%p);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint pre=p-1ll*pw2[lst[i]-1]*quet(a[i].l-1)%p;\n\t\taddt(a[nxt[i]].r,1ll*pre*iv2[nxt[i]]%p);\n\t}\n\tprintf(\"%d\\n\",1ll*pw2[n]*quet(2*n)%p);\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"组合计数"},{"name":"容斥"}],
			"title": "AGC061C First Come First Serve 做题记录",
			"link": "https://exber.qzz.io/post/AGC061C%20First%20Come%20First%20Serve%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-09-12 21:17:42"
		},
	
		{
			"abstract": "> 给定一个长度为 $n$ 的 01 串，求最多可以选出多少互不相交的子串，满足这些子串按照原串中的顺序，字典序严格升序。\n>\n> $1\\le n\\le 2.5\\times 10^4$。\n",
			"content": "> 给定一个长度为 $n$ 的 01 串，求最多可以选出多少互不相交的子串，满足这些子串按照原串中的顺序，字典序严格升序。\n>\n> $1\\le n\\le 2.5\\times 10^4$。\n\n\n不要再自然根号了。\n\n设最终选出的子串为 $s_1,s_2,\\dots,s_k$，则 $\\forall 1\\le i<k$，必定有 $|s_{i+1}|\\le |s_i|+1$。\n\n并且必定有 $|s_1|=1$。\n\n那么不难得出， $\\sum\\limits_{i=1}^{\\max\\{|s_i|\\}}i\\le n$，因为对于所有 $i$ 都必定存在 $j$ 满足 $|s_j|=|s_i|-1$。\n\n所以 $\\max\\{|s_i|\\}\\le \\sqrt{2n}$。\n\n那么设 $f_i$ 表示 $s_{[1,i]}$ 的答案，把所有长度 $\\le \\sqrt{2n}$ 的子串都拉出来放到 trie 上，用树状数组维护 $f_i$ 的转移即可。\n\n答案即为 $\\max\\{f_i\\}$，时间复杂度 $O(n\\sqrt n\\log n)$。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nconst int S=25005,M=250,MS=10000005;\n\nint n;\nchar a[S];\nint cnt,son[MS][2];\nvector<pair<int,int>> idx[MS];\nint c[S],f[S];\n\ninline void addt(int u,int val)\n{\n\tfor(int i=u;i<=n;i+=i&-i) c[i]=max(c[i],val);\n}\n\ninline int quet(int u)\n{\n\tint res=0;\n\tfor(int i=u;i>=1;i-=i&-i) res=max(res,c[i]);\n\treturn res;\n}\n\nvoid dfs(int u)\n{\n\tfor(auto u:idx[u])\n\t{\n\t\tint l=u.first,r=u.second;\n\t\tf[r]=max(f[r],quet(l-1)+1);\n\t\taddt(r,f[r]);\n\t}\n\tif(son[u][0]!=0) dfs(son[u][0]);\n\tif(son[u][1]!=0) dfs(son[u][1]);\n}\n\nint main()\n{\n\tscanf(\"%d%s\",&n,a+1);\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tint u=0;\n\t\tfor(int j=i;j<=n&&j<=i+M-1;j++)\n\t\t{\n\t\t\tint id=a[j]-'0';\n\t\t\tif(son[u][id]==0) son[u][id]=++cnt;\n\t\t\tu=son[u][id];\n\t\t\tidx[u].push_back({i,j});\n\t\t}\n\t}\n\tdfs(0);\n\tint ans=0;\n\tfor(int i=1;i<=n;i++) ans=max(ans,f[i]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"结论"},{"name":"DP"}],
			"title": "ABC240Ex Sequence of Substrings 做题记录",
			"link": "https://exber.qzz.io/post/ABC240Ex%20Sequence%20of%20Substrings%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-09-11 11:47:27"
		},
	
		{
			"abstract": "> 给定长 $n$ 的序列 $a_i$，满足 $a_1=a_n=\\max\\{a_i\\}$。\n>\n> 构建一个 $n$ 个点的无向图 $G$ 如下：\n>\n> - $\\forall 1\\le i<j\\le n$，若存在某个正整数 $k$ 满足 $a_i,a_j\\ge k$ 且 $\\forall i<p<j$ 都有 $a_p<k$，则 $G$ 中存在边 $(i,j)$；\n>\n> $q$ 次询问，每次询问点 $x_i$ 和 $y_i$ 之间的**最短路长度减一**。\n>\n> $1\\le n,q\\le 10^5$，$1\\le a_i\\le n$。\n",
			"content": "> 给定长 $n$ 的序列 $a_i$，满足 $a_1=a_n=\\max\\{a_i\\}$。\n>\n> 构建一个 $n$ 个点的无向图 $G$ 如下：\n>\n> - $\\forall 1\\le i<j\\le n$，若存在某个正整数 $k$ 满足 $a_i,a_j\\ge k$ 且 $\\forall i<p<j$ 都有 $a_p<k$，则 $G$ 中存在边 $(i,j)$；\n>\n> $q$ 次询问，每次询问点 $x_i$ 和 $y_i$ 之间的**最短路长度减一**。\n>\n> $1\\le n,q\\le 10^5$，$1\\le a_i\\le n$。\n\n\n不妨称满足 $a_i,a_j\\ge k$ 且 $\\forall i<p<j$ 都有 $a_p<k$ 的边 $(i,j)$ 为 $k-\\text{边}$。\n\n不难发现若把边 $(x,y)$ 看作区间 $[x,y-1]$，则：\n\n- 任意两个区间要么包含要么相离；\n- 对于同一个 $k$，所有 $k-\\text{边}$ 对应的区间的并为 $[1,n-1]$（整个序列）；\n- 对于某条 $k-边$ $(l,r)$，$\\forall k'< k$，所有满足 $l\\le x\\le y\\le r$ 的 $k'-边$ $(x,y)$ 对应的区间的并为 $[l,r-1]$；\n\n![](../post-images/1693983518283.png)\n\n那么这些边形成了类似树的结构：把每一条边看作一个点，则对于每一条 $k-\\text{边}$ $(x,y)$，所有端点在 $[x,y]$ 内的 $(k-1)-\\text{边}$ 都是它的儿子。\n\n那么最短路的形态肯定是不断往父亲走，走到 $\\text{lca}$ 后再往儿子走。\n\n也就是说，设路径序列为 $p$，则：\n\n- 存在一个分界点 $l$，满足 $\\forall i< l$，$a_{p_i}\\le a_{p_{i+1}}$ 且 $\\forall i>l$，$a_{p_{i-1}}\\ge a_{p_i}$，即路径上的 $a_i$ 先增再减；\n- $\\forall p_i<j<p_{i+1}$，都有 $a_j\\le \\min(a_{p_i},a_{p_{i+1}})$，否则把 $j$ 加入 $p$ 肯定不劣；\n\n那么考虑倍增，不妨设 $lb_{i,j}$ 和 $rb_{i,j}$ 分别表示 $p$ 长度为 $2^j$ 且 $p_1=i$ 时 $p_j$ 可能的最小值和最大值，显然 $\\forall lb_{i,j}<k<rb_{i,j}$ 都有 $a_k<\\min(a_{lb_{i,j}},a_{rb_{i,j}})$。\n\n那么根据之前的结论，有：\n$$\nlb_{i,j}=\\min(lb_{lb_{i,j-1},j-1},lb_{rb_{i,j-1},j-1})\\\\\nrb_{i,j}=\\max(rb_{lb_{i,j-1},j-1},rb_{rb_{i,j-1},j-1})\\\\\n$$\n\n而 $lb_{i,0}$ 和 $rb_{i,0}$ 分别为 $i$ 左边和右边第一个 $a_j>a_i$ 的 $j$。\n\n不妨令询问的 $x_i\\le y_i$，则每次询问：\n\n1. 从 $x_i$ 开始在 $rb<y_i$ 的情况下不断跳 $rb$，设最后跳到了 $r$；\n2. 从 $y_i$ 开始在 $lb>r$ 的情况下不断跳 $lb$；\n\n时间复杂度 $O((n+q)\\log n)$，代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=100005,BS=25;\n\nint n,k,q,a[S];\nint top,sta[S];\nint lb[S][BS],rb[S][BS];\n\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&k,&q);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\ttop=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\twhile(top>0&&a[sta[top]]<a[i]) top--;\n\t\tlb[i][0]=top==0?i:sta[top];\n\t\tsta[++top]=i;\n\t}\n\ttop=0;\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\twhile(top>0&&a[sta[top]]<a[i]) top--;\n\t\trb[i][0]=top==0?i:sta[top];\n\t\tsta[++top]=i;\n\t}\n\tfor(int j=1;j<=BS-3;j++)\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tint l=lb[i][j-1],r=rb[i][j-1];\n\t\t\tlb[i][j]=min(lb[l][j-1],lb[r][j-1]);\n\t\t\trb[i][j]=max(rb[l][j-1],rb[r][j-1]);\n\t\t}\n\t}\n\twhile(q--)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(x>y) swap(x,y);\n\t\tint ans=0;\n\t\tint l=x,r=x;\n\t\tfor(int i=BS-3;i>=0;i--)\n\t\t{\n\t\t\tif(max(rb[l][i],rb[r][i])<y)\n\t\t\t{\n\t\t\t\tans+=1<<i;\n\t\t\t\tint tl=l,tr=r;\n\t\t\t\tl=min(lb[tl][i],lb[tr][i]);\n\t\t\t\tr=max(rb[tl][i],rb[tr][i]);\n\t\t\t}\n\t\t}\n\t\tint u=r;\n\t\tl=y,r=y;\n\t\tfor(int i=BS-3;i>=0;i--)\n\t\t{\n\t\t\tif(min(lb[l][i],lb[r][i])>u)\n\t\t\t{\n\t\t\t\tans+=1<<i;\n\t\t\t\tint tl=l,tr=r;\n\t\t\t\tl=min(lb[tl][i],lb[tr][i]);\n\t\t\t\tr=max(rb[tl][i],rb[tr][i]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"结论"},{"name":"小技巧"}],
			"title": "JOISC2017F 鉄道旅行 (Railway Trip) 做题记录",
			"link": "https://exber.qzz.io/post/JOISC2017F%20%E9%89%84%E9%81%93%E6%97%85%E8%A1%8C%20%28Railway%20Trip%29%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-09-06 14:58:35"
		},
	
		{
			"abstract": "> 给定一棵 $n$ 个点的树，每个点有一个权值 $a_i$。\n>\n> 一个长度为 $n$ 的序列 $b$ 合法当且仅当 $\\forall 1\\le u\\le n$，都存在两个整数 $x,y$ 满足：\n>\n> - $1\\le x,y\\le n$；\n> - $x\\not=y$；\n> - $u$ 在 $x$ 到 $y$ 的简单路径上；\n> - $\\min(b_x,b_y)\\ge a_u$；\n>\n> 输出所有合法的 $b$ 中最小的 $\\sum b_i$。\n>\n> $2\\le n\\le 2\\times 10^5$，$1\\le a_i\\le 10^9$。\n",
			"content": "> 给定一棵 $n$ 个点的树，每个点有一个权值 $a_i$。\n>\n> 一个长度为 $n$ 的序列 $b$ 合法当且仅当 $\\forall 1\\le u\\le n$，都存在两个整数 $x,y$ 满足：\n>\n> - $1\\le x,y\\le n$；\n> - $x\\not=y$；\n> - $u$ 在 $x$ 到 $y$ 的简单路径上；\n> - $\\min(b_x,b_y)\\ge a_u$；\n>\n> 输出所有合法的 $b$ 中最小的 $\\sum b_i$。\n>\n> $2\\le n\\le 2\\times 10^5$，$1\\le a_i\\le 10^9$。\n\n\n首先不难发现只有叶子（一度点）的 $b_i\\not=0$。\n\n令 $a_i$ 最大的点 $rt$ 做根，那么其余的点 $u$ 只要满足在它子树内存在 $b_v\\ge a_u$ 的 $v$ 即可。\n\n那么按照深度从深往浅贪心，贪到 $u$ 时选 $u$ 子树内 $b_v$ 最大的 $v$ 让 $b_v\\to \\max(b_v,a_u)$ 即可。\n\n最后选树中最大和次大的 $b_i$ 令它们为 $a_{rt}$ 即可。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nconst int S=200005;\n\nint n,a[S];\nvector<int> g[S];\nint val[S];\nint mx[S],mx2[S];\n\nvoid dfs(int u,int fa)\n{\n\tbool f=false;\n\tfor(int v:g[u])\n\t{\n\t\tif(v==fa) continue;\n\t\tf=true;\n\t\tdfs(v,u);\n\t\tif(val[mx[v]]>val[mx[u]]) mx2[u]=mx[u],mx[u]=mx[v];\n\t\telse if(val[mx[v]]>val[mx2[u]]) mx2[u]=mx[v];\n\t}\n\tif(!f) mx[u]=u;\n\tval[mx[u]]=max(val[mx[u]],a[u]);\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tg[x].push_back(y),g[y].push_back(x);\n\t}\n\tint rt=1;\n\tfor(int i=1;i<=n;i++) if(a[i]>a[rt]) rt=i;\n\tdfs(rt,0);\n\tif(mx2[rt]==0) mx2[rt]=rt;\n\tval[mx[rt]]=val[mx2[rt]]=a[rt];\n\tlong long ans=0;\n\tfor(int i=1;i<=n;i++) ans+=val[i];\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"贪心"}],
			"title": "CF1637F Towers 做题记录",
			"link": "https://exber.qzz.io/post/CF1637F%20Towers%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-09-04 11:11:47"
		},
	
		{
			"abstract": "> 给定非负整数 $n,x,y$，对于所有满足 $\\sum \\limits_{i=1}^n a_i=x$，所有 $a_i$ 按位或和为 $y$ 的序列 $a$，求出 $\\oplus_{i=1}^n a_i$ 的异或和。\n>\n> $1\\le n\\le 2^{40}$，$0\\le x< 2^{60}$，$0\\le x< 2^{20}$。\n",
			"content": "> 给定非负整数 $n,x,y$，对于所有满足 $\\sum \\limits_{i=1}^n a_i=x$，所有 $a_i$ 按位或和为 $y$ 的序列 $a$，求出 $\\oplus_{i=1}^n a_i$ 的异或和。\n>\n> $1\\le n\\le 2^{40}$，$0\\le x< 2^{60}$，$0\\le x< 2^{20}$。\n\n不难发现由于可以任意调换位置，所以所有 $a_i$ 本质相同，也就是说，$n$ 为偶数时答案为 $0$。\n\n考虑 $n$ 为奇数的情况，此时只需要统计所有 $a_1$ 的异或和即可。\n\n考虑拆位，对每个 $i$ 计算 $a_1$ 第 $i$ 位为 $1$ 的方案数 $\\text{mod }2$ 的结果 $cnt_i$，则答案即为 $\\sum 2^icnt_i$。\n\n考虑通过容斥计算 $cnt_i$，设 $f(y')$ 表示 $a_i$ 的或和为 $y'$ 的子集且 $a_1$ 第 $i$ 位为 $1$ 的方案数，则：\n$$\ncnt_i=\\oplus_{y'\\subseteq y}(-1)^{|y|-|y'|}f(y')=\\oplus_{y'\\subseteq y}f(y')\n$$\n考虑计算 $f(y')$，由于 $a_1$ 第 $i$ 位一定为 $1$，所以不妨令 $a_1\\to a_1-y^i$，则有：\n$$\nf(y')=\\sum\\limits_{a_1+a_2+\\dots+a_n=x-2^i}[a_1\\subseteq (y'-2^i)]\\prod\\limits_{i=2}^n[a_i\\subseteq y']\\mod 2\n$$\n注意到 $\\binom{n}{m}\\text{ mod }2=[m\\subseteq n]$，所以：\n$$\n\\begin{aligned}\nf(y')&=\\sum\\limits_{a_1+a_2+\\dots+a_n=x-2^i}\\binom{y'-2^i}{a_1}\\prod\\limits_{i=2}^n\\binom{y'}{a_i}\\mod 2\\\\\n&=\\binom{ny'-2^i}{x-2^i}\\mod 2\\\\\n&=[(x-2^i)\\subseteq(ny'-2^i)]\\\\\n\\end{aligned}\n$$\n所以答案为：\n$$\n\\sum 2^i\\oplus_{y'\\subseteq y}[(x-2^i)\\subseteq(ny'-2^i)]\n$$\n时间复杂度 $O(y\\log y)$，代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nlong long n,x;\nint y;\n\nint main()\n{\n\tscanf(\"%lld%lld%d\",&n,&x,&y);\n\tif(n&1^1) return puts(\"0\"),0;\n\tint ans=0;\n\tfor(int i=0;i<20;i++)\n\t{\n\t\tint f=0;\n\t\tfor(int j=y;j>0;j=(j-1)&y)\n\t\t{\n\t\t\tif(j>>i&1^1) continue;\n\t\t\tf^=((x-(1<<i))|(n*j-(1<<i)))==(n*j-(1<<i));\n\t\t}\n\t\tans+=f<<i;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"数学"},{"name":"组合计数"}],
			"title": "CF1770F Koxia and Sequence 做题记录",
			"link": "https://exber.qzz.io/post/CF1770F%20Koxia%20and%20Sequence%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-08-25 16:43:24"
		},
	
		{
			"abstract": "> 给定长度为 $n$ 的序列 $A$，求满足以下条件的序列 $B$ 的个数模 $998244353$ 的结果：\n>\n> - 值域 $[1, n]$；\n> - $i$ 的个数不超过 $A_i$；\n> - $B_i$ 的个数不超过 $A_i$；\n>\n> $1 \\le A_i\\le n \\le 500$。\n",
			"content": "> 给定长度为 $n$ 的序列 $A$，求满足以下条件的序列 $B$ 的个数模 $998244353$ 的结果：\n>\n> - 值域 $[1, n]$；\n> - $i$ 的个数不超过 $A_i$；\n> - $B_i$ 的个数不超过 $A_i$；\n>\n> $1 \\le A_i\\le n \\le 500$。\n\n\n刚开始想的是把 $A$ 从大到小排序，这样每个数的出现次数就由它最后一次出现的位置决定，设 $f_{i,j,k}$ 表示处理完前 $A_{[1,i]}$，一共填了 $j$ 个位置，一共填了 $k$ 种数的方案数，但是发现是 $O(n^4)$ 的。\n\n看题解发现忽略了一个很重要的东西：调和级数 $\\sum\\limits_{i=1}^n O(\\frac{n}{i})=O(n\\ln n)$。\n\n设 $d_i$ 表示 $i$ 的出现次数，观察 $d$ 需要满足什么性质：\n\n- $d_i\\le A_i$；\n- 对于所有满足 $d_i\\le A_j$ 的位置 $j$，$B_j$ 可以等于 $i$；\n\n观察到 $\\forall d_i<d_j$，$j$ 能放的位置 $i$ 都能放，即 $i$ 的决策包含 $j$。\n\n那么设 $f_{i,j,k}$ 表示决定完 $d_x\\in[i,n]$ 的 $x$，共放了 $j$ 种不同的数，消耗了 $k$ 个位置的答案。\n\n转移直接枚举有多少个 $x$ 满足 $d_x=i$ 即可。\n\n由于 $j$ 的上界是 $\\frac{n}{i}$，$d_x=i$ 的 $x$ 的个数上界也是 $\\frac{n}{i}$，所以时间复杂度为 $O(n\\sum\\limits_{i=1}^n\\frac{n^2}{i^2})$，约为 $O(n^2\\ln^3 n)$，代码如下：\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=505,p=998244353;\n\nint n,a[S];\nint fra[S],inv[S],pinv[S][S],C[S][S],f[S][S][S];\n\ninline void add(int &x,int y)\n{\n\tx+=y;\n\tif(x>=p) x-=p;\n}\n\ninline int qpow(int x,int y)\n{\n\tint res=1;\n\tfor(;y>0;y>>=1,x=1ll*x*x%p) res=y&1?1ll*res*x%p:res;\n\treturn res;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tfra[i]=i==0?1:1ll*i*fra[i-1]%p;\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<=i;j++) C[i][j]=(C[i-1][j]+C[i-1][j-1])%p;\n\t}\n\tinv[n]=qpow(fra[n],p-2);\n\tfor(int i=n;i>=1;i--) inv[i-1]=1ll*inv[i]*i%p;\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tpinv[i][0]=1;\n\t\tfor(int j=1;j<=n;j++) pinv[i][j]=1ll*pinv[i][j-1]*inv[i]%p;\n\t}\n\tf[n+1][0][0]=1;\n\tfor(int i=n,pp=n+1;i>=1;i--)\n\t{\n\t\twhile(pp>1&&a[pp-1]>=i) pp--;\n\t\tint len=n-pp+1;\n\t\tfor(int j=0;j<=n/i&&j<=len;j++)\n\t\t{\n\t\t\tfor(int k=0;k<=n;k++)\n\t\t\t{\n\t\t\t\tfor(int l=0;l<=j&&l<=n/i&&l<=k/i;l++)\n\t\t\t\t{\n\t\t\t\t\tint bse=1ll*C[len-j+l][l]*C[len-k+i*l][i*l]%p*fra[i*l]%p*pinv[i][l]%p;\n\t\t\t\t\tadd(f[i][j][k],1ll*bse*f[i+1][j-l][k-i*l]%p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;i++) add(ans,f[1][i][n]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"DP"},{"name":"组合计数"},{"name":"数学"}],
			"title": "ARC162E Strange Constraints 做题记录",
			"link": "https://exber.qzz.io/post/ARC162E%20Strange%20Constraints%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-08-23 15:31:16"
		},
	
		{
			"abstract": "> 给定一个 $H\\times W$ 的矩阵 $c$ 和一个整数 $n$。\n>\n> 起初在任意格子上放置一个棋子，接下来操作 $n$ 次，第 $i$ 次操作：\n>\n> - 若 $i$ 是奇数，则把棋子移动到当前所在**行**中任意一个格子（可以不动）；\n> - 若 $i$ 是偶数，则把棋子移动到当前所在**列**中任意一个格子（可以不动）；\n>\n> 把每次操作完后棋子所在的格子上的数依次写下，形成一个长度为 $2n$ 的序列 $b$，请你求出有多少种可能的序列 $b$，对 $998244353$ 取模。\n>\n> $1\\le H,W\\leq10$，$1\\le n\\leq 300$，$1\\le c_{i,j}\\le 9$。\n",
			"content": "> 给定一个 $H\\times W$ 的矩阵 $c$ 和一个整数 $n$。\n>\n> 起初在任意格子上放置一个棋子，接下来操作 $n$ 次，第 $i$ 次操作：\n>\n> - 若 $i$ 是奇数，则把棋子移动到当前所在**行**中任意一个格子（可以不动）；\n> - 若 $i$ 是偶数，则把棋子移动到当前所在**列**中任意一个格子（可以不动）；\n>\n> 把每次操作完后棋子所在的格子上的数依次写下，形成一个长度为 $2n$ 的序列 $b$，请你求出有多少种可能的序列 $b$，对 $998244353$ 取模。\n>\n> $1\\le H,W\\leq10$，$1\\le n\\leq 300$，$1\\le c_{i,j}\\le 9$。\n\n\n发现奇数次操作之前不关心所在列，偶数次操作之前不关心所在行，那么一个朴素的想法是设 $f_{i,j}$ 表示第 $i$ 次操作完后在第 $j$ 行/列的答案。\n\n但是由于有可能有数字重复的格子，所以可能会算重。\n\n观察到一个性质：设 $f(b)$ 为所有能形成 $b$ 的路径的末尾位置的集合，那么两个 $b$ 相同当且仅当 $f(b)$ 相同。\n\n证明是显然的。\n\n那么设 $f_{i,S}$ 表示第 $i$ 次操作完了后 $f(b)=S$（只保留行或列）的答案。\n\n转移是显然的，时间复杂度 $O(n(2^H+2^W)HW)$。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=15,BS=1<<10,KS=605,p=998244353;\n\nint n,m,k;\nint a[S][S];\nint f[KS][BS];\n\ninline void add(int &x,int y)\n{\n\tx+=y;\n\tif(x>=p) x-=p;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tk*=2;\n\tfor(int i=1;i<=n;i++) for(int j=1;j<=m;j++) scanf(\" %c\",&a[i][j]),a[i][j]-='0';\n\tint nl=1<<n,ml=1<<m;\n\tf[0][nl-1]=1;\n\tfor(int i=0;i<=k-1;i++)\n\t{\n\t\tif(i&1^1)\n\t\t{\n\t\t\tfor(int j=1;j<nl;j++)\n\t\t\t{\n\t\t\t\tfor(int v=1;v<=9;v++)\n\t\t\t\t{\n\t\t\t\t\tint nv=0;\n\t\t\t\t\tfor(int x=1;x<=n;x++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(j>>x-1&1^1) continue;\n\t\t\t\t\t\tfor(int y=1;y<=m;y++) if(a[x][y]==v) nv|=1<<y-1;\n\t\t\t\t\t}\n\t\t\t\t\tadd(f[i+1][nv],f[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int j=1;j<ml;j++)\n\t\t\t{\n\t\t\t\tfor(int v=1;v<=9;v++)\n\t\t\t\t{\n\t\t\t\t\tint nv=0;\n\t\t\t\t\tfor(int y=1;y<=m;y++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(j>>y-1&1^1) continue;\n\t\t\t\t\t\tfor(int x=1;x<=n;x++) if(a[x][y]==v) nv|=1<<x-1;\n\t\t\t\t\t}\n\t\t\t\t\tadd(f[i+1][nv],f[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=1;i<nl;i++) add(ans,f[k][i]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"DP"},{"name":"组合计数"}],
			"title": "ABC228G Digits on Grid 做题记录",
			"link": "https://exber.qzz.io/post/ABC228G%20Digits%20on%20Grid%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-08-23 10:18:51"
		},
	
		{
			"abstract": "> 给定一个长 $n$ 的元素两两不同的序列 $a$，$\\forall 1\\le i<j\\le n$，若 $a_i<a_j$，则让 $i$ 向 $j$ 连一条无向边。\n>\n> $q$ 次修改数组某个位置的值，每次修改后输出图中连通块个数。\n>\n> $1\\le n,q\\le 5\\times 10^5$，$1\\le a_i\\le 10^6$，保证任意时刻数组中元素两两不同。\n",
			"content": "> 给定一个长 $n$ 的元素两两不同的序列 $a$，$\\forall 1\\le i<j\\le n$，若 $a_i<a_j$，则让 $i$ 向 $j$ 连一条无向边。\n>\n> $q$ 次修改数组某个位置的值，每次修改后输出图中连通块个数。\n>\n> $1\\le n,q\\le 5\\times 10^5$，$1\\le a_i\\le 10^6$，保证任意时刻数组中元素两两不同。\n\n首先有个结论：\n\n> 若 $i$ 和 $j$ 满足 $a_i<a_j$，则 $\\forall i\\le k\\le j$，$k$ 与 $i$、$j$ 连通。\n\n证明是显然的。\n\n根据这个结论，每个连通块一定是一个连续段。\n\n那么注意到 $\\forall 2\\le i\\le n$，$i-1$ 和 $i$ 不在同一个连通块中当且仅当 $\\min\\limits_{j=1}^{i-1} a_j>\\max\\limits_{j=i}^n a_j$。而由于每个连通块都是连续段，所以连通块个数就是这样的 $i$ 的个数 $+1$。\n\n定义 $x$ 的前驱 $\\text{pre}(x)$ 为满足 $0\\le i\\le n,a_i<x$ 且 $a_i$ 最大的 $i$，令 $b_i=\\sum\\limits_{j=1}^n [\\text{pre}(a_j)+1\\le i\\le j]$，则一定有：\n\n- $b_1=0$；\n- $b$ 中 $0$ 的个数就是连通块个数，因为每个 $b_i=0$ 的 $i$ 显然都满足 $\\min\\limits_{j=1}^{i-1} a_j>\\max\\limits_{j=i}^n a_j$；\n\n那么用 set 维护前驱后继、线段树维护 $b$ 中最小值以及最小值个数即可。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <set>\n\nusing namespace std;\n\nconst int S=500005;\n\nint n,q,a[S];\nint tag[S<<2],mn[S<<2],mnc[S<<2];\nset<pair<int,int>> st;\n\ninline void upda(int u)\n{\n\tint ls=u<<1,rs=u<<1|1;\n\tmnc[u]=0;\n\tmn[u]=min(mn[ls],mn[rs]);\n\tif(mn[ls]==mn[u]) mnc[u]+=mnc[ls];\n\tif(mn[rs]==mn[u]) mnc[u]+=mnc[rs];\n}\n\ninline void addtag(int u,int val)\n{\n\ttag[u]+=val;\n\tmn[u]+=val;\n}\n\ninline void dwntag(int u)\n{\n\tif(tag[u]==0) return;\n\taddtag(u<<1,tag[u]),addtag(u<<1|1,tag[u]);\n\ttag[u]=0;\n}\n\nvoid build(int u,int l,int r)\n{\n\tif(l==r) return tag[u]=0,mn[u]=0,mnc[u]=1,void();\n\tint mid=l+r>>1;\n\tbuild(u<<1,l,mid),build(u<<1|1,mid+1,r);\n\tupda(u);\n}\n\nvoid upd(int u,int l,int r,int L,int R,int val)\n{\n\tif(l>R||r<L) return;\n\tif(l>=L&&r<=R) return addtag(u,val);\n\tdwntag(u);\n\tint mid=l+r>>1;\n\tif(L<=mid) upd(u<<1,l,mid,L,R,val);\n\tif(R>=mid+1) upd(u<<1|1,mid+1,r,L,R,val);\n\tupda(u);\n}\n\ninline void updd(int l,int r,int x)\n{\n\tif(l==0||r==n+1) return;\n\tr=min(r,n);\n\tif(l+1>r) return;\n\tupd(1,1,n,l+1,r,x);\n}\n\ninline void ins(int p,int x)\n{\n\tst.insert(make_pair(x,p));\n\tauto lb=st.lower_bound(make_pair(x,p));\n\tauto rb=st.lower_bound(make_pair(x,p));\n\tlb--,rb++;\n\tupdd(lb->second,rb->second,-1);\n\tupdd(lb->second,p,1);\n\tupdd(p,rb->second,1);\n}\n\ninline void del(int p,int x)\n{\n\tauto lb=st.lower_bound(make_pair(x,p));\n\tauto rb=st.lower_bound(make_pair(x,p));\n\tlb--,rb++;\n\tupdd(lb->second,p,-1);\n\tupdd(p,rb->second,-1);\n\tupdd(lb->second,rb->second,1);\n\tst.erase(make_pair(x,p));\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&q);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tbuild(1,1,n);\n\tst.insert(make_pair(-1e9,0)),st.insert(make_pair(1e9,n+1));\n\tfor(int i=1;i<=n;i++) ins(i,a[i]);\n\twhile(q-->0)\n\t{\n\t\tint p,x;\n\t\tscanf(\"%d%d\",&p,&x);\n\t\tdel(p,a[p]);\n\t\ta[p]=x;\n\t\tins(p,a[p]);\n\t\tprintf(\"%d\\n\",mnc[1]);\n\t}\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"数据结构"},{"name":"结论"}],
			"title": "CF1270H Number of Components 做题记录",
			"link": "https://exber.qzz.io/post/CF1270H%20Number%20of%20Components%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-08-22 11:50:25"
		},
	
		{
			"abstract": "> 给定一张 $n$ 个点 $m$ 条边的 DAG，每个点出度至多为 $2$。可以删除不超过 $\\frac{4}{7}n$ 个点，使得删点后的图中不存在包含三个点的链。\n>\n> $1 \\leq n \\leq 2 \\times 10^5$。\n",
			"content": "> 给定一张 $n$ 个点 $m$ 条边的 DAG，每个点出度至多为 $2$。可以删除不超过 $\\frac{4}{7}n$ 个点，使得删点后的图中不存在包含三个点的链。\n>\n> $1 \\leq n \\leq 2 \\times 10^5$。\n\n做题时可以设出一些未知量，写出一些已知条件方便思考。\n\n图中的点一定能分成三个集合：\n\n- 删去的点集 $S$；\n- 删完点后没有入度的点集 $A$；\n- 删完点后有入度但没有出度的点集 $B$；\n\n注意到原图每个点出度至多为 $2$，所以一定有 $|B|\\le 2|A|$。发现只有 $B$ 中点出边指向的点才会删掉，所以有 $|S|\\le 2|B|$。那么有 $|S|\\le 2|B|\\le 4|A|$，即 $|S|$ 最大不超过 $\\frac{4}{7}n$。\n\n那么考虑增量构造，遍历每个点：\n\n- 若它没有入边或入边都来自 $S$ 则加入 $A$；\n- 若它没有入边来自 $B$ 则加入 $B$；\n- 否则加入 $S$；\n\n时间复杂度 $O(n\\log n)$（$\\log n$ 来自 set），代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nconst int S=200005;\n\nint n,m;\nvector<int> g[S];\nset<int> as,bs,st;\n\ninline void slove()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++) g[i].clear();\n\tas.clear(),bs.clear(),st.clear();\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tg[y].push_back(x);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(g[i].size()==0) as.insert(i);\n\t\telse\n\t\t{\n\t\t\tbool f=false,f2=false;\n\t\t\tfor(int v:g[i]) f|=bs.count(v),f2|=as.count(v);\n\t\t\tif(f) st.insert(i);\n\t\t\telse if(f2) bs.insert(i);\n\t\t\telse as.insert(i);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",st.size());\n\tfor(int u:st) printf(\"%d \",u);\n\tprintf(\"\\n\");\n}\n\nint main()\n{\n\tint T;\n\tscanf(\"%d\",&T);\n\twhile(T-->0) slove();\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"构造"},{"name":"图论"}],
			"title": "CF1368E Ski Accidents 做题记录",
			"link": "https://exber.qzz.io/post/CF1368E%20Ski%20Accidents%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-08-19 15:31:06"
		},
	
		{
			"abstract": "> 给定 $n,m$ 表示存在 $n$ 个宝箱和 $m$ 把钥匙，第 $i$ 把钥匙需要 $b_i$ 元，第 $i$ 个宝箱内部有 $a_i$ 元。\n>\n> 现在进行一场游戏，Bob 是本场游戏的玩家，而 Alice 则是场景布置者，Alice 可以给每个宝箱上一些锁（第 $j$ 种锁需要第 $j$ 种钥匙打开）\n>\n> 如果 Bob 可以购买一些钥匙，然后打开一些宝箱，使得 Bob 的收益大于 $0$，那么 Bob 就赢得了游戏，反之 Alice 获得了胜利。\n>\n> 现在 Alice 打算布置宝箱上的锁，第 $i$ 个宝箱上放置第 $j$ 种锁的花费为 $c_{i,j}$，请帮助 Alice 找到一种布置锁的方案，使得花费最小，且 Alice 将取得胜利。\n>\n> 注意：一个箱子上可以放置若干把锁，Bob 需打开所有锁才能获得内部的钱。\n>\n> $n,m\\le 6,a_i,b_i\\le 4,c_{i,j}\\le 10^7$。\n",
			"content": "> 给定 $n,m$ 表示存在 $n$ 个宝箱和 $m$ 把钥匙，第 $i$ 把钥匙需要 $b_i$ 元，第 $i$ 个宝箱内部有 $a_i$ 元。\n>\n> 现在进行一场游戏，Bob 是本场游戏的玩家，而 Alice 则是场景布置者，Alice 可以给每个宝箱上一些锁（第 $j$ 种锁需要第 $j$ 种钥匙打开）\n>\n> 如果 Bob 可以购买一些钥匙，然后打开一些宝箱，使得 Bob 的收益大于 $0$，那么 Bob 就赢得了游戏，反之 Alice 获得了胜利。\n>\n> 现在 Alice 打算布置宝箱上的锁，第 $i$ 个宝箱上放置第 $j$ 种锁的花费为 $c_{i,j}$，请帮助 Alice 找到一种布置锁的方案，使得花费最小，且 Alice 将取得胜利。\n>\n> 注意：一个箱子上可以放置若干把锁，Bob 需打开所有锁才能获得内部的钱。\n>\n> $n,m\\le 6,a_i,b_i\\le 4,c_{i,j}\\le 10^7$。\n\n设箱子 $i$ 上的锁的集合为 $L_i$，那么 $L$ 需要满足：\n$$\n\\forall S\\subseteq\\{1,2,3,\\dots n\\},\\sum\\limits_{u\\in S} a_u\\le \\sum\\limits_{v\\in (\\cup_{u\\in S}L_u)}b_v\n$$\n注意到这个东西很像 Hall 定理，那么考虑建立一张这样的二分图：\n\n- 左部每个箱子拆成 $a_i$ 个点，共有 $\\sum\\limits_{i=1}^n a_i$ 个点；\n- 右部每个锁拆成 $b_i$ 个点，共有 $\\sum\\limits_{i=1}^m b_i$ 个点；\n- 若 $i$ 号箱子有 $j$ 号锁，那么从 $i$ 号箱子拆出的所有点和 $j$ 号锁拆出的所有点之间连一条边；\n\n问题等价于最小化有连边的锁的 $b_i$ 和，使得二分图存在大小为 $\\sum\\limits_{i=1}^n a_i$ 的匹配。\n\n那么直接找大小为 $\\sum\\limits_{i=1}^n a_i$ 的匹配即可。设 $dp_{i,st}$ 为前 $i$ 个箱子拆出来的点都匹配完了，锁拆出来的点的状态为 $st$（五进制，每个锁拆出来的点还有多少个）时的最小代价。那么转移直接枚举当前箱子拆出来的每个点匹配了哪个锁拆成的点，如果匹配了至少一个锁 $j$ 拆出来的点，则需要加上 $c_{i,j}$ 的代价。\n\n时间复杂度 $O(nm2^{2n})$，跑不满所以能过。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nconst int S=8,SS=45,BS=20005;\n\nint n,m;\nint a[S],b[S],c[S][S];\nint tot[SS],sta[SS][BS][S];\nint st[S],pst[S];\nint dp[S][BS];\n\ninline int getval()\n{\n\tint val=0;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tval*=5;\n\t\tval+=st[i];\n\t}\n\treturn val;\n}\n\ninline void getsta(int val)\n{\n\tfor(int i=m;i>=1;i--)\n\t{\n\t\tst[i]=val%5;\n\t\tval/=5;\n\t}\n}\n\ninline void tmin(int &x,int y)\n{\n\tx=min(x,y);\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=m;i++) scanf(\"%d\",&b[i]);\n\tfor(int i=1;i<=n;i++) for(int j=1;j<=m;j++) scanf(\"%d\",&c[i][j]);\n\tfor(int i=1;i<=m;i++) st[i]=b[i];\n\tint mxval=getval();\n\tfor(int i=0;i<=mxval;i++)\n\t{\n\t\tgetsta(i);\n\t\tint cnt=0;\n\t\tfor(int j=1;j<=m;j++) cnt+=st[j];\n\t\ttot[cnt]++;\n\t\tfor(int j=1;j<=m;j++) sta[cnt][tot[cnt]][j]=st[j];\n\t}\n\tmemset(dp,127,sizeof(dp));\n\tint inf=dp[0][0];\n\tdp[0][mxval]=0;\n\tfor(int i=0;i<=n-1;i++)\n\t{\n\t\tfor(int j=0;j<=mxval;j++)\n\t\t{\n\t\t\tif(dp[i][j]==inf) continue;\n\t\t\tgetsta(j);\n\t\t\tfor(int k=1;k<=m;k++) pst[k]=st[k];\n\t\t\tfor(int k=1;k<=tot[a[i+1]];k++)\n\t\t\t{\n\t\t\t\tfor(int l=1;l<=m;l++) st[l]=pst[l];\n\t\t\t\tbool f=true;\n\t\t\t\tint sum=0;\n\t\t\t\tfor(int l=1;l<=m&&f;l++)\n\t\t\t\t{\n\t\t\t\t\tint u=sta[a[i+1]][k][l];\n\t\t\t\t\tif(u>st[l]) f=false;\n\t\t\t\t\tif(u>0) sum+=c[i+1][l];\n\t\t\t\t\tst[l]-=u;\n\t\t\t\t}\n\t\t\t\tif(f)\n\t\t\t\t{\n\t\t\t\t\tint idx=getval();\n\t\t\t\t\ttmin(dp[i+1][idx],dp[i][j]+sum);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=inf;\n\tfor(int i=0;i<=mxval;i++) tmin(ans,dp[n][i]);\n\tprintf(\"%d\\n\",ans==inf?-1:ans);\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"结论"},{"name":"图论"},{"name":"DP"}],
			"title": "CF1519F Chests and Keys 做题记录",
			"link": "https://exber.qzz.io/post/CF1519F%20Chests%20and%20Keys%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-08-16 19:51:23"
		},
	
		{
			"abstract": "> 给定长 $n$ 的序列 $a_{[1,n]}$。\n>\n> 输出最长的满足不同的众数（出现次数最多的数）至少有两个的区间的长度。\n>\n> D1：$1\\le n\\le 2\\times 10^5$，$1\\le a_i\\le \\min(100,n)$；\n>\n> D2：$1\\le n\\le 2\\times 10^5$，$1\\le a_i\\le n$；\n",
			"content": "> 给定长 $n$ 的序列 $a_{[1,n]}$。\n>\n> 输出最长的满足不同的众数（出现次数最多的数）至少有两个的区间的长度。\n>\n> D1：$1\\le n\\le 2\\times 10^5$，$1\\le a_i\\le \\min(100,n)$；\n>\n> D2：$1\\le n\\le 2\\times 10^5$，$1\\le a_i\\le n$；\n\n现特判掉整个序列不同众数个数 $>1$ 的情况。\n\n设 $X$ 为整个序列的众数，有个结论：\n\n> $X$ 一定是答案区间的其中一个众数。\n\n证明考虑反证，若 $X$ 不是答案区间的众数，因为 $X$ 是序列中最多的数，所以一定可以向左向右拓展答案区间使得 $X$ 是答案区间的众数，这样一定不劣因为原来的众数还是众数。\n\n那么 D1 就可以直接枚举答案区间的另一个众数 $Y$ 然后 $O(n)$ 找到最长的满足 $X$ 和 $Y$ 出现次数相等的区间，总时间复杂度 $O(nV)$。\n\n对于 D2，注意到是颜色题，所以考虑根号分治。\n\n- 对于出现次数 $> \\sqrt n$ 的数，直接用 D1 的做法，这部分总时间复杂度 $O(n\\sqrt n)$；\n- 对于出现次数 $\\le \\sqrt n$ 的数，直接枚举众数的出现次数然后双指针找到最长的合法区间，这部分总时间复杂度 $O(n\\sqrt n)$；\n\n总时间复杂度 $O(n\\sqrt n)$，代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nconst int S=200005,B=450;\n\nint n,a[S];\nint cnt[S];\nint mnp[S*2],b[S];\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++) cnt[a[i]]++;\n\tint mx=0,val;\n\tfor(int i=1;i<=n;i++) if(cnt[i]>mx) mx=cnt[i],val=i;\n\tfor(int i=1;i<=n;i++) if(i!=val&&cnt[i]==mx) return printf(\"%d\\n\",n),0;\n\tint ans=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(i==val) continue;\n\t\tif(cnt[i]>B)\n\t\t{\n\t\t\tfor(int j=0;j<=n+n;j++) mnp[j]=0;\n\t\t\tint cnt=0;\n\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t{\n\t\t\t\tif(a[j]==i) cnt--;\n\t\t\t\tif(a[j]==val) cnt++;\n\t\t\t\tif(cnt==0||mnp[n+cnt]!=0) ans=max(ans,j-mnp[n+cnt]);\n\t\t\t\telse mnp[n+cnt]=j;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=B;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++) b[j]=0;\n\t\tint l=1,cnt=0;\n\t\tfor(int r=1;r<=n;r++)\n\t\t{\n\t\t\tcnt+=++b[a[r]]==i;\n\t\t\twhile(l<=r&&b[a[r]]>i)\n\t\t\t{\n\t\t\t\tcnt-=b[a[l++]]--==i;\n\t\t\t}\n\t\t\tif(cnt>=2) ans=max(ans,r-l+1);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"结论"}],
			"title": "CF1446D1&2 Frequency Problem 做题记录",
			"link": "https://exber.qzz.io/post/CF1446D1%262%20Frequency%20Problem%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-08-16 19:50:05"
		},
	
		{
			"abstract": "> 定义集合 $S$ 合法当且仅当满足以下条件：\n>\n> - $S \\subseteq \\{1,2,...,n\\}$；\n>\n> - $\\forall a\\in S,b\\in S$， $|a-b|\\not\\in\\{x,y\\}$；\n>\n> 给定 $n,x,y$，求最大的 $|S|$。\n>\n> $1\\le n\\le 10^9$，$1\\le x,y\\le 22$。\n",
			"content": "> 定义集合 $S$ 合法当且仅当满足以下条件：\n>\n> - $S \\subseteq \\{1,2,...,n\\}$；\n>\n> - $\\forall a\\in S,b\\in S$， $|a-b|\\not\\in\\{x,y\\}$；\n>\n> 给定 $n,x,y$，求最大的 $|S|$。\n>\n> $1\\le n\\le 10^9$，$1\\le x,y\\le 22$。\n\n问题等价于找到一个长 $n$ 的 01 序列满足序列中任意两个 $1$ 的位置差不为 $x$ 或 $y$，最大化 01 序列中 $1$ 的个数。\n\n**引理 1**\n\n> 任意长 $x+y$ 的合法的 01 序列无限重复构成的 01 序列仍然合法。\n>\n> <details><summary>证明</summary><p>\n>\n> > 反证法。\n> >\n> > 若存在一个长 $x+y$ 的合法的 01 序列 $s$ 满足其无限重复构成的 01 序列 $a$ 中：\n> >\n> > - $a_i$ 和 $a_{i+x}$ 均为 $1$：不妨假设 $i\\le x+y,i+x>x+y$，那么此时一定有 $a_{i+x-x-y}=a_{i-y}=1$，注意到 $a_i$ 为 $1$，$i-y\\le x+y$，所以此时 $s$ 一定不合法；\n> > - $a_i$ 和 $a_{i+y}$ 均为 $1$：同理，一定有 $a_i=a_{i-x}=1$；\n> >\n> > Q.E.D.\n>\n> </p></details>\n\n**定理 1**\n\n> 最优解一定是某个长 $x+y$ 的合法 01 序列无限重复构成的 01 序列的长度为 $n$ 的前缀。\n>\n> <details><summary>证明</summary><p>\n>\n> > $n\\equiv 0\\pmod {x+y}$ 的情况下显然成立。\n> >\n> > 设 $n\\equiv r\\pmod{x+y}$（$r\\not=0$），现在来证明最后一小段长 $r$ 的跟着前面循环是不劣的：\n> >\n> > - 反证法，设最后一小段长 $r$ 的 01 序列为 $t$，设循环节（长度为 $x+y$ 的不断出现的 01 串）为 $s$；\n> > - $t$ 不跟着前面循环更优，当且仅当 $st$（拼起来）合法但用 $t$ 替换掉 $s$ 的长 $|t|$ 的前缀不合法，不妨设用 $t$ 替换掉 $s$ 的长 $|t|$ 的前缀得到的字符串为 $ts'$；\n> > - 设 $ts'$ 中不合法的两个位置为 $i$ 和 $i+x$（$i+y$ 同理），那么一定有 $i\\le |t|,i+x>|t|$；\n> > - 考察答案的后缀 $ts't$，由于位置 $i$ 和 $i+x$ 都是 $1$，那么位置 $i+x$ 和 $i+x+y$ 一定也都是 $1$，那么 $s't$ 不合法，所以 $st$ 不合法，矛盾；\n> >\n> > Q.E.D.\n>\n> </p></details>\n\n那么 $O((x+y)2^{\\max(x,y)})$ 状压 dp 即可，代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nconst int BS=1<<22;\n\nint n,x,y;\nint f[2][BS];\n\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&x,&y);\n\tif(x<y) swap(x,y);\n\tmemset(f,128,sizeof(f));\n\tint p=0;\n\tf[p][0]=0;\n\tfor(int i=0;i<=x+y-1&&i<=n-1;i++)\n\t{\n\t\tp^=1;\n\t\tmemset(f[p],128,sizeof(f[p]));\n\t\tfor(int j=0;j<(1<<x);j++)\n\t\t{\n\t\t\tint s0=(j<<1)&((1<<x)-1),s1=s0|1;\n\t\t\tif((s0&(j>>x-1))==0&&(s0&(j>>y-1))==0) f[p][s0]=max(f[p][s0],f[p^1][j]);\n\t\t\tif((s1&(j>>x-1))==0&&(s1&(j>>y-1))==0) f[p][s1]=max(f[p][s1],f[p^1][j]+n/(x+y)+(i+1<=n%(x+y)));\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=0;i<(1<<x);i++) ans=max(ans,f[p][i]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"结论"}],
			"title": "CF1463F Max Correct Set 做题记录",
			"link": "https://exber.qzz.io/post/CF1463F%20Max%20Correct%20Set%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-08-16 19:19:11"
		},
	
		{
			"abstract": "",
			"content": "## Part 1 前言\n\n基本子串结构是许廷强在 2023 年集训队论文《一类基础子串数据结构》中提出的一种新型字符串数据结构，可以同时处理前缀和后缀的信息，是一种很强力的字符串数据结构。\n\n论文链接：[国家集训队2023论文集](https://github.com/OI-wiki/libs/blob/master/集训队历年论文/国家集训队2023论文集.pdf)\n\n另外感谢 [《一类基础子串数据结构》摘抄及注解 - crashed](https://www.cnblogs.com/crashed/p/17382894.html)。\n\n## Part 2 基础定义\n\n- 字符串 $S$：若无特殊说明，$S$ 为给定的某个字符串；\n\n- 字符集大小：默认 $O(1)$；\n\n- $|S|$ 和 $S_{[l,r]}$：\n\n  - $|S|$ 为字符串 $S$ 的长度；\n  - $S_{[l,r]}$ 为字符串 $S_lS_{l+1}\\dots S_r$ 即字符串 $S$ 从 $S_l$ 到 $S_r$ 的子串；\n\n- $\\text{occ}_S(T)$、$\\text{endpos}_S(T)$ 和 $\\text{srtpos}_S(T)$：\n\n  - $\\text{occ}_S(T)$ 为字符串 $T$ 在字符串 $S$ 中的出现次数；\n  - $\\text{endpos}_S(T)$ 为字符串 $T$ 在 $S$ 中出现时的**右**端点位置的集合；\n  - $\\text{srtpos}_S(T)$ 为字符串 $T$ 在 $S$ 中出现时的**左**端点位置的集合；\n\n  易知 $\\text{occ}_S(T)=\\text{endpos}_S(T)=\\text{srtpos}_S(T)$。\n\n  若无特殊说明，下标中的 $S$ 略去时表示 $S$ 为给定的字符串 $S$；\n\n- $S\\in T$：表示字符串 $S$ 是字符串 $T$ 的子串，$S\\notin T$ 同理；\n\n- $T_0$ 和 $T_1$：\n\n  - $T_0$ 为正串的 SAM 的 parent 树；\n  - $T_1$ 为反串的 SAM 的 parent 树；\n  \n  默认 parent 树上的节点等价于 SAM 中的对应节点；\n\n## Part 3 理论\n\n### 3.1 拓展串\n\n##### 定义 3.1（拓展串）\n\n> $\\forall t\\in S$，定义 $\\text{ext}(t)$ 为最长的 $S$ 的子串 $t'$ 满足 $t\\in t'$ 且 $\\text{occ}(t)=\\text{occ}(t')$。\n\n这个显然是良定义的，对于子串 $t$，只要不断往左往右添加字符即可找到 $\\text{ext}(t)$。\n\n##### 定理 3.1\n\n> 设 $t=S_{[l,r]},\\text{ext}(t)=S_{[L,R]}$，则  $\\forall l'\\in[L,l],r'\\in[r,R]$ 都有 $\\text{ext}(S_{[l',r']})=S_{L,R}$。\n\n由于子串 $t$ 找 $\\text{ext}(t)$ 是往左往右不断添加字符。\n\n### 3.2 等价类\n\n##### 定义 3.2.1（等价关系）\n\n> $\\forall s\\in S,t\\in S$，$s$ 与 $t$ 等价当且仅当 $\\text{ext(s)}=\\text{ext(t)}$。\n\n易证明该关系具有传递性、自反性、对称性。\n\n##### 定义 3.2.2（等价类和代表元）\n\n> $\\forall s\\in S$：\n>\n> - 定义 $s$ 所在的等价类 $\\text{E}(s)=\\{t|t\\in S,\\text{ext}(t)=\\text{ext}(s)\\}$。\n>\n> - 定义 $s$ 所在的等价类的代表元 $\\text{R}(s)=t|t\\in \\text{E}(s),t=\\text{ext}(t)$。\n\n容易发现根据定理 3.1，$\\forall s\\in S$，$\\text{R}(s)$ 存在且唯一。\n\n##### 定理 3.2\n\n>$t\\in \\text{E}(s)$ 当且仅当存在一个可空字符串 $c$ 满足以下两者之一：\n>\n>- $s$ 和 $t$ 每次在 $S$ 中出现都是以 $tcs$ 的形式出现；\n>- $s$ 和 $t$ 每次在 $S$ 中出现都是以 $sct$ 的形式出现；\n\n根据定理 3.1 易得。\n\n### 3.3 引入二维平面\n\n将 $S$ 的 $\\frac{n(n+1)}{2}$ 个子串放在二维平面上，$(i,j)$ 即第 $i$ 行第 $j$ 列的点表示 $S_{[i,j]}$。\n\n若无特殊说明，$(i,j)$ 等价于 $S_{[i,j]}$。\n\n##### 定理 3.3（阶梯）\n\n> 每个等价类中的字符串对应的**坐标最小的点**在二维平面中构成了一个的右、上边界与坐标轴平行，左、下边界呈阶梯状的图形。\n>\n> **注意：一个等价类构成的阶梯状图形可能会重复出现很多次。**\n\n根据定理 3.1 易得。\n\n直观感受一下，这里以 $S=abaab$ 为例：\n\n![](../post-images/1692084425285.png)\n\n相同颜色的串在同一个等价类中，这里一共有三个等价类。\n\n##### 定义 3.3（周长）\n\n> 定义一个等价类 $g$ 的周长 $\\text{len}(g)$ 为 $g$ 对应的阶梯状图形的宽度加上长度。\n\n##### 推论 3.3.1（凸性）\n\n> - 对于任意两行 $(a,*),(b,*)$，存在某个 $i$ 满足：\n>   - $\\forall j\\ge i$，$(a,j)$ 与 $(b,j)$ 在同一个等价类中；\n>   - $\\forall j<i$，$(a,j)$ 与 $(b,j)$ 在同一个等价类中；\n> - 对于任意两列 $(*,a),(*,b)$，存在某个 $i$ 满足：\n>   - $\\forall j\\le i$，$(j,a)$ 与 $(j,b)$ 在同一个等价类中；\n>   - $\\forall j>i$，$(j,a)$ 与 $(j,b)$ 在同一个等价类中；\n>\n> 即不存在这样的情况：\n>\n> ![](../post-images/1692087042691.png)\n>\n> <details><summary>证明</summary><p>\n>\n> > ![](../post-images/1692087668956.png)\n> >\n> > 由于 $T$ 和 $aT$ 在同一个等价类中，所以 $\\text{endpos}(T)=\\text{endpos}(aT)$。所以 $T$ 每次都是以 $aT$ 的形式出现的，那么 $Tb$ 每次肯定都是以 $aTb$ 的形式出现的，根据定理 3.2，$aTb$ 一定和 $Tb$ 在一个等价类中。\n>\n> </p></details>\n\n##### 推论 3.3.2\n\n> $\\forall t\\in S$，$\\text{occ}(t)$ 等于 $\\text{E}(t)$ 对应的阶梯型出现的次数。\n\n### 3.4 与 SAM 的关系\n\n和 SAM 联系起来。\n\n#### 3.4.1 与节点以及 parent 树中的边的关系\n\n##### 定理 3.4.1.1（与节点的关系）\n\n> 对于某个等价类对应的阶梯形，每一**列**对应 $T_0$ 中的一个节点，每一**行**对应 $T_1$ 中的一个节点。\n>\n> <details><summary>证明</summary><p>\n>\n> > 单看一行，所有字符串都是最长的那个的前缀，所以这些字符串等价当且仅当它们的 $\\text{srtpos}$ 相等。\n>>\n> > 单看一列，所有字符串都是最长的那个的后缀，所以这些字符串等价当且仅当它们的 $\\text{endpos}$ 相等。\n> </p></details>\n\n\n##### 定理 3.4.1.2（与边的关系）\n\n> - 对于二维平面中的第 $u$ **列**，若 $(u,i)$ 和 $(u,i+1)$ 不在同一个等价类中则 $(u,i+1)$ 对应的 $T_0$ 中的节点是  $(u,i)$ 对应的 $T_0$ 中的节点的儿子；\n>\n> - 对于二维平面中的第 $u$ **行**，若 $(i,u)$ 和 $(i+1,u)$ 不在同一个等价类中则 $(i+1,u)$ 对应的 $T_1$ 中的节点是  $(i,u)$ 对应的 $T_1$ 中的节点的儿子；\n>\n> 反过来：\n>\n> - 在 $T_0$ 上往父亲走相当于在平面上往**上**走到相邻的等价类；\n> - 在 $T_1$ 上往父亲走相当于在平面上往**右**走到相邻的等价类；\n>\n> 直观一点：（$T_1$ 上的连边在平面上的体现）\n>\n> ![](../post-images/1692094211555.png)\n\n挺显然的，根据定理 3.4.1.1 立得。\n\n##### 推论 3.4.1（总周长线性）\n\n> 对于所有等价类 $g$，$\\text{len}(g)$ 的和是 $O(|S|)$ 级别的。\n>\n> **注意：同一个等价类对应的阶梯状图形只算一次。**\n>\n> <details><summary>证明</summary><p>\n>\n> > $\\text{len}(g)$ 的和相当于满足属于不同等价类的相邻点的对数，根据定理 3.4.1.2，这样的一对点对应着 $T_0$ 或 $T_1$ 中的一条边，由于 $T_0$ 和 $T_1$ 中的边的条数都是 $O(|S|)$ 的，所以这样的点对也是 $O(|S|)$ 的。\n> \n> </p></details>\n\n##### 定理 3.4.1.3（同等价类同构）\n\n> 对于在同一个等价类中的同一棵 parent 树上的节点 $u,v$，它们的子树同构。\n>\n> 即把它们的子树看作无标号有根树后节点一一对应，且对应的两个点满足：包含的串的个数，包含的串的 $\\text{occ}$ 相同，它们在二维平面上的位置差（两横/竖条的横纵距离）和 $u,v$ 在二维平面上的位置差相同。\n>\n> <details><summary>证明</summary><p>\n>\n> > 等价于对应的两个点在同一个等价类中。\n> >\n> > 根据定理 3.4.1.2，$u$ 和 $v$ 的子树中的点一定在 $u$ 和 $v$ 对应的横/竖条的上/右边，而根据推论 3.3.1，同一行/列且在同一个的两个点同时往上/右走后还在同一个等价类中。\n>\n> </p></details>\n\n#### 3.4.2 再见，SAM 中的边\n\n考虑正串 SAM 中的一条边，体现在二维平面上就是往右走，而反串 SAM 中的一条边体现在二维平面上就是往上走。\n\n##### 定理 3.4.2\n\n> 对于 SAM 中的一条边，它连接的两个节点对应的横条/竖列在同一个等价类当且仅当它们中字符串的 $\\text{endpos}$ 集合大小相同，且这样的边构成若干条链。\n\n该定理根据定理 3.4.1.1 以及 SAM 的性质易得。\n\n根据定理 3.4.2 和定理 3.4.1.2，容易发现正串 SAM 中的一条连接不同两个等价类的边等价于 $T_1$ 中的一条边，反串 SAM 中的一条连接不同等价类的边等价于 $T_0$ 中的一条边。\n\n而若把一个等价类看作一个点，去掉自环，只保留每个等价类代表元的出边，那么 SAM 中的边就和另一棵 parent 树中的边一一对应了！\n\n## Part 4 实践\n\n### 4.1 构建\n\n先想清楚需要什么：\n\n- 每个等价类的阶梯状结构（底边长、每个竖条的长度）；\n- 每个等价类的代表元的第一次出现的左右端点；\n- 不同等价类之间的连边：\n  - 只保留每个等价类代表元的出边；\n  - 横向边的和纵向边的分开；\n  - 边上标注上 SAM 中对应边的字符所在的可能的最小的位置（方便定位等价类的相对位置）；\n\n根据定理 3.4.2，把**正串** SAM 中满足连接的两个节点的 $\\text{endpos}$ 集合大小相同的边抽出来，不妨把这些边叫做关键边。\n\n找到这些关键边构成的若干条链，每条链对应了一个等价类：\n\n![](../post-images/1692171174405.png)\n\n链的长度（点数）就是等价类底边的长度，链中每个点对应等价类中的一竖条，点中字符串的个数就是对应竖条的长度。\n\n链尾的点中最长的字符串就是这个等价类的代表元，第一次出现的右端点可以通过在 parent 树上做子树 min 得到，第一次出现的左端点可以通过第一次出现的右端点得出。\n\n对于不同等价类之间的边，只需要通过哈希表找到代表元在正反串 SAM 中对应的节点 $A$ 和 $B$（$A$ 是正串 SAM 上的），$A$ 的所有出边即为代表元横向的出边，$B$ 的则为代表元纵向的出边。\n\n每条出边的字符所在的可能的最小的位置就是出边指向的节点的 $\\text{endpos}$ 集合中的最小值，可以通过在 parent 树上做子树 min 得到。\n\n梳理一下流程：\n\n1. 建出正反 SAM，通过在 parent 树上做子树 min 得到每个节点的 $\\text{endpos}$ 集合中的最小值；\n2. 在**正** SAM 中找到满足连接的两个节点的 $\\text{endpos}$ 集合大小相同的边构成的若干条链；\n3. 遍历一次所有链，对于每条链：\n   1. 给这条链代表的等价类分配一个新的点 $id$，把链上节点都标记上 $id$；\n   2. 得出链代表的等价类的宽度（链的长度）；\n   3. 遍历一次链，得出链代表的等价类每一列的长度；\n   4. 找到链尾节点 $T$ 中最长的字符串第一次出现的位置 $S_{[l,r]}$，在哈希表把 $(l,r)$ 标记为 $id$；\n4. 再遍历一次所有链，对于每条链：\n   1. 找到链代表的节点 $A$；\n   2. 遍历链尾节点 $T$ 的所有出边 $u$：\n      1. 找到 $u$ 连向的点的 $\\text{endpos}$ 集合中的最小值 $x$；\n      2. 找到 $u$ 连向的点的标记 $B$；\n      3. 从 $A$ 向 $B$ 连一条权值为 $x$ 的**横向边**；\n5. 在**反** SAM 中找到满足连接的两个节点的 $\\text{endpos}$ 集合大小相同的边构成的若干条链；\n6. 遍历一次所有链，对于每条链：\n   1. 找到链尾节点 $T$ 中最长的字符串第一次出现的位置 $S_{[l,r]}$，找到哈希表中 $(l,r)$ 的标记 $id$（这条链代表的节点）；\n   2. 把链上节点都标记上 $id$；\n7. 再遍历一次所有链，对于每条链：\n   1. 找到链代表的节点 $A$；\n   2. 遍历链尾节点 $T$ 的所有出边 $u$：\n      1. 找到 $u$ 连向的点的 $\\text{endpos}$ 集合中的最小值 $x$；\n      2. 找到 $u$ 连向的点的标记 $B$；\n      3. 从 $A$ 向 $B$ 连一条权值为 $x$ 的**纵向边**；\n\n时间复杂度 $O(n)$，哈希表使用 map 实现则为 $O(n\\log n)$。\n\n看起来很复杂，但是看代码应该很好懂。\n\n<details><summary>展开代码</summary><p>\n\n```cpp\nstruct SBOOK\n{\n\tint n;\n\tchar str[S];\n\tint tot;\n\tstruct node\n\t{\n\t\tint l,r;         // 代表元位置\n\t\tvector<int> len; // 每一列的长度\n\t\tvector<pair<int,int>> tor,tol; // 横向边，纵向边\n\t}a[S*2];\n\tint nxt[S*2],til[S*2],idx[S*2];\n\tbool vis[S*2];\n\tstruct SAM\n\t{\n\t\tint lst;\n\t\tint cnt,len[S*2],to[S*2][V],link[S*2];\n\t\tvector<int> son[S*2];\n\t\tint siz[S*2],mnr[S*2];\n\t\tinline void init()\n\t\t{\n\t\t\tfor(int i=0;i<=cnt;i++)\n\t\t\t{\n\t\t\t\tlen[i]=link[i]=siz[i]=0;\n\t\t\t\tmnr[i]=1e8;\n\t\t\t\tmemset(to[i],0,sizeof(to[i]));\n\t\t\t\tson[i].clear();\n\t\t\t}\n\t\t\tcnt=lst=0;\n\t\t\tlink[0]=-1;\n\t\t}\n\t\tinline void ins(int r,int x)\n\t\t{\n\t\t\tint pre=++cnt;\n\t\t\tlen[pre]=len[lst]+1;\n\t\t\tint p=lst;\n\t\t\twhile(p!=-1&&to[p][x]==0) to[p][x]=pre,p=link[p];\n\t\t\tif(p==-1) link[pre]=0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tint q=to[p][x];\n\t\t\t\tif(len[q]==len[p]+1) link[pre]=q;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tint cpy=++cnt;\n\t\t\t\t\tlen[cpy]=len[p]+1;\n\t\t\t\t\tsiz[cpy]=0,mnr[cpy]=1e8;\n\t\t\t\t\tmemcpy(to[cpy],to[q],sizeof(to[q]));\n\t\t\t\t\tlink[cpy]=link[q];\n\t\t\t\t\tlink[pre]=cpy;\n\t\t\t\t\twhile(p!=-1&&to[p][x]==q) to[p][x]=cpy,p=link[p];\n\t\t\t\t\tlink[q]=cpy;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlst=pre;\n\t\t\tsiz[pre]=1;\n\t\t\tmnr[pre]=r;\n\t\t}\n\t\tinline void build(){for(int i=1;i<=cnt;i++) son[link[i]].push_back(i);}\n\t\tvoid dfs(int u=0)\n\t\t{\n\t\t\tfor(int v:son[u])\n\t\t\t{\n\t\t\t\tdfs(v);\n\t\t\t\tsiz[u]+=siz[v];\n\t\t\t\tmnr[u]=min(mnr[u],mnr[v]);\n\t\t\t}\n\t\t}\n\t}sam[2];\n\tstruct HASH\n\t{\n\t\tint n;\n\t\tstatic const int mod=114547;\n\t\tvector<pair<pair<int,int>,int>> vec[mod];\n\t\tinline void init(int x)\n\t\t{\n\t\t\tn=x;\n\t\t\tfor(int i=0;i<mod;i++) vec[i].clear();\n\t\t}\n\t\tinline void ins(pair<int,int> u,int val)\n\t\t{\n\t\t\tint idx=(1ll*u.first*n%mod+u.second)%mod;\n\t\t\tfor(auto &v:vec[idx]) if(v.first==u) return v.second=val,void();\n\t\t\tvec[idx].push_back(make_pair(u,val));\n\t\t}\n\t\tinline int que(pair<int,int> u)\n\t\t{\n\t\t\tint idx=(1ll*u.first*n%mod+u.second)%mod;\n\t\t\tfor(auto &v:vec[idx]) if(v.first==u) return v.second;\n\t\t\treturn -1;\n\t\t}\n\t}mp;\n\tinline void build()\n\t{\n\t\t// 清空\n\t\tfor(int i=1;i<=tot;i++) a[i].l=a[i].r=0,a[i].len.clear(),a[i].tor.clear(),a[i].tol.clear();\n\t\ttot=0;\n\t\tmp.init(n);\n\t\t// 建正反 SAM & 预处理节点 endpos 集合中最小值\n\t\tsam[0].init(),sam[1].init();\n\t\tfor(int i=1;i<=n;i++) sam[0].ins(i,str[i]-'a');\n\t\tfor(int i=n;i>=1;i--) sam[1].ins(i,str[i]-'a');\n\t\tsam[0].build(),sam[1].build();\n\t\tsam[0].dfs(),sam[1].dfs();\n\t\t// 正 SAM 找链\n\t\tfor(int i=1;i<=sam[0].cnt;i++) nxt[i]=vis[i]=til[i]=0;\n\t\tfor(int u=1;u<=sam[0].cnt;u++)\n\t\t{\n\t\t\tfor(int i=0;i<V;i++)\n\t\t\t{\n\t\t\t\tint v=sam[0].to[u][i];\n\t\t\t\tif(v!=0&&sam[0].siz[u]==sam[0].siz[v])\n\t\t\t\t{\n\t\t\t\t\tnxt[u]=v;\n\t\t\t\t\tvis[v]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// 正 SAM 第一次遍历链\n\t\tfor(int u=1;u<=sam[0].cnt;u++)\n\t\t{\n\t\t\tif(!vis[u])\n\t\t\t{\n\t\t\t\ttot++;\n\t\t\t\tint x=u;\n\t\t\t\twhile(1)\n\t\t\t\t{\n\t\t\t\t\tidx[x]=tot;\n\t\t\t\t\ta[tot].len.push_back(sam[0].len[x]-sam[0].len[sam[0].link[x]]);\n\t\t\t\t\tif(nxt[x]==0) break;\n\t\t\t\t\tx=nxt[x];\n\t\t\t\t}\n\t\t\t\ttil[u]=x;\n\t\t\t\ta[tot].r=sam[0].mnr[x],a[tot].l=a[tot].r-sam[0].len[x]+1;\n\t\t\t\tmp.ins(make_pair(a[tot].l,a[tot].r),tot);\n\t\t\t}\n\t\t}\n\t\t// 正 SAM 第二次遍历链\n\t\tfor(int u=1;u<=sam[0].cnt;u++)\n\t\t{\n\t\t\tif(!vis[u])\n\t\t\t{\n\t\t\t\tint x=til[u];\n\t\t\t\tfor(int j=0;j<V;j++)\n\t\t\t\t{\n\t\t\t\t\tint y=sam[0].to[x][j];\n\t\t\t\t\tif(y==0) continue;\n\t\t\t\t\tint B=idx[y],val=sam[0].mnr[y];\n\t\t\t\t\ta[idx[x]].tor.push_back(make_pair(B,val));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// 反 SAM 找链\n\t\tfor(int i=1;i<=sam[1].cnt;i++) nxt[i]=vis[i]=til[i]=0;\n\t\tfor(int u=1;u<=sam[1].cnt;u++)\n\t\t{\n\t\t\tfor(int i=0;i<V;i++)\n\t\t\t{\n\t\t\t\tint v=sam[1].to[u][i];\n\t\t\t\tif(v!=0&&sam[1].siz[u]==sam[1].siz[v])\n\t\t\t\t{\n\t\t\t\t\tnxt[u]=v;\n\t\t\t\t\tvis[v]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// 反 SAM 第一次遍历链\n\t\tfor(int u=1;u<=sam[1].cnt;u++)\n\t\t{\n\t\t\tif(!vis[u])\n\t\t\t{\n\t\t\t\tint x=u;\n\t\t\t\twhile(1)\n\t\t\t\t{\n\t\t\t\t\tif(nxt[x]==0) break;\n\t\t\t\t\tx=nxt[x];\n\t\t\t\t}\n\t\t\t\ttil[u]=x;\n\t\t\t\tint l=sam[1].mnr[x],r=l+sam[1].len[x]-1;\n\t\t\t\tint id=mp.que(make_pair(l,r));\n\t\t\t\tx=u;\n\t\t\t\twhile(x!=0)\n\t\t\t\t{\n\t\t\t\t\tidx[x]=id;\n\t\t\t\t\tx=nxt[x];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// 反 SAM 第二次遍历链\n\t\tfor(int u=1;u<=sam[1].cnt;u++)\n\t\t{\n\t\t\tif(!vis[u])\n\t\t\t{\n\t\t\t\tint x=til[u];\n\t\t\t\tfor(int j=0;j<V;j++)\n\t\t\t\t{\n\t\t\t\t\tint y=sam[1].to[x][j];\n\t\t\t\t\tif(y==0) continue;\n\t\t\t\t\tint B=idx[y],val=sam[1].mnr[y];\n\t\t\t\t\ta[idx[x]].tol.push_back(make_pair(B,val));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n```\n\n</p></details>\n\n### 4.2 例题\n\n- [CF1817F Entangled Substrings](https://www.luogu.com.cn/problem/CF1817F)\n\n  <details><summary>题解</summary><p>\n  \n  > 建出基本子串结构后，合法的 $a$ 和 $b$ 一定在同一个等价类中且满足它们在 $S$ 中第一次出现位置不交。\n  >\n  > 由于已知代表元第一次出现的位置，所以等价类中每个字符串的第一次出现的位置都是可以求出来的，由于阶梯型本身具有单调性，所以对于每个阶梯型做一遍双指针即可。\n  >\n  > 时间复杂度 $O(n)$。\n  >\n  > 核心代码：\n  >\n  > ```cpp\n  > __int128 ans=0;\n  > for(int i=1;i<=bok.tot;i++)\n  > {\n  >        SBOOK::node &pre=bok.a[i];\n  >        int m=pre.len.size();\n  >        int lb=pre.l,rb=pre.r-m+1;\n  >        __int128 sm=0;\n  >        for(int j=m-1,k=m;j>=0;j--)\n  >        {\n  >            int pr=rb+j;\n  >            while(k>=1&&lb+pre.len[k-1]-1>=pr) sm+=pre.len[--k];\n  >            ans+=pre.len[j]*(sm-1ll*(pr-lb+1)*(m-k));\n  >        }\n  > }\n  > ```\n  \n  </p></details>\n  \n- 【2023NOI模拟赛35】字符串\n",
			"tags": [{"name":"学习笔记"},{"name":"字符串"}],
			"title": "基本子串结构 学习笔记",
			"link": "https://exber.qzz.io/post/%E5%9F%BA%E6%9C%AC%E5%AD%90%E4%B8%B2%E7%BB%93%E6%9E%84%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-08-15 15:26:18"
		},
	
		{
			"abstract": "> 你有一个包含 $1 \\sim 2n$ 共 $2n$ 个整数的集合 $S$。你必须执行恰好 $k$（$1 \\le k \\le n \\le 10^6$）次操作，每个操作都是以下两种其中之一：\n>\n> - 将 $S$ 中第 $1, 2$ 个元素删去。\n>\n> - 将 $S$ 中第 $\\frac{|S|}2, \\frac{|S|}2 + 1$ 个元素删去。（显然 $|S|$ 一直是偶数，所以 $\\frac{|S|}2$ 也一定是整数）\n>\n> 请你统计，通过这些操作可以获得多少个本质不同的最终集合 $S$？答案对 $998244353$ 取模。\n",
			"content": "> 你有一个包含 $1 \\sim 2n$ 共 $2n$ 个整数的集合 $S$。你必须执行恰好 $k$（$1 \\le k \\le n \\le 10^6$）次操作，每个操作都是以下两种其中之一：\n>\n> - 将 $S$ 中第 $1, 2$ 个元素删去。\n>\n> - 将 $S$ 中第 $\\frac{|S|}2, \\frac{|S|}2 + 1$ 个元素删去。（显然 $|S|$ 一直是偶数，所以 $\\frac{|S|}2$ 也一定是整数）\n>\n> 请你统计，通过这些操作可以获得多少个本质不同的最终集合 $S$？答案对 $998244353$ 取模。\n\n\nJerry Wen 定理。\n\n考虑什么样的序列有可能得到（找必要条件），不妨关心被删除的数。\n\n考虑被删除的数的连续段，由于每次是删除相邻两个数，所以**每个连续段的长度一定是偶数**。\n\n不难发现，第一个连续段一定可以被操作一删掉，为了防止算重，不妨钦定**第一个连续段是被操作一删掉的**。而之后的连续段一定不能被操作一删掉，所以**除了第一个之外的连续段都是被操作二删掉的**。\n\n继续观察，发现第 $i$ 次操作时中位数中较大的那个一定是 $n+i$，所以**被删除的最大的数不超过 $n+k$**。\n\n发现操作二删除连续段有两种方式：\n\n- $((()))$ 型，即不进行操作一，只进行操作二；\n- $()()()$ 型，即一二交替；\n\n发现只有第二个连续段可能使用第一种方式删除，且只有这种方式能删去 $\\le n$ 的数。所以**若第二个连续段中第一个数为 $p$ 且 $p\\le n$，则 $[p,2n+1-p]$ 一定都在第二个连续段中**。\n\n考虑对于所有满足上述加粗条件的连续段集合 $S$，一定能构造出合法的操作序列：对于 $S$ 中的每个连续段的右半部分，若中位数中较大的一个在其中则执行操作二，否则执行操作一。\n\n那么只要数这样的 $S$ 即可。\n\n为了计数方便，设 $f(n,m)$ 表示从 $n$ 个数中选出 $2m$ 个数且这些数构成的所有连续段长度均为偶数的方案数。这相当于从 $n-m$ 个数中选出 $m$ 个，每数再扩充成两个，所以 $f(n,m)=\\binom{n-m}{m}$。\n\n枚举第一段的长度 $2i$：\n\n- 首先有可能剩下的所有连续段都是一二交替地删除的，即第二段的第一个数 $>n$，这部分的方案数是 $f(\\min(k,k-2i+n-1),k-i)$；\n\n- 若 $2i<n$ 则第二段的第一个数有可能 $\\le n$，那么需要枚举 $p$ 即第二段的第一个数，方案数是：\n  $$\n  \\begin{aligned}\n  \\sum\\limits_{p=2i+2}^nf(k-n+p-1,k-i-n-1+p)&=\\sum\\limits_{p=2i+2}^nf(k-n+p-1,k-i-n+p-1)\\\\\n  &=\\sum\\limits_{p=2i+2}^n\\binom{i}{k-i-n+p-1}\\\\\n  \\end{aligned}\n  $$\n  \n  发现相当于是求 $\\sum\\limits_{j=L_i}^{R_i} \\binom{i}{j}$，注意到 $[L_i,R_i]$ 到 $[L_{i+1},R_{i+1}]$ 两端指针的移动是 $O(1)$ 的，并且若已知 $sml=\\sum\\limits_{j=L_i}^{R_i} \\binom{i-1}{j}$ 也可以快速求出 $smp=\\sum\\limits_{j=L_i}^{R_i} \\binom{i}{j}$ 因为 $smp=2sml+\\binom{i-1}{L_i-1}-\\binom{i-1}{R_i}$，那么双指针维护即可；\n\n时间复杂度 $O(n)$，代码如下：\n\n```cpp\n// Problem: Minimums or Medians\n// Contest: Luogu\n// URL: https://www.luogu.com.cn/problem/CF1784F\n// Memory Limit: 500 MB\n// Time Limit: 4000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n#include <iostream>\n#include <cstdio>\n\nint mod;\n\n// fastmod\nstruct mint\n{\n\tint val;\n\tinline mint(){val=0;}\n\toperator int(){return val;}\n\ttemplate<typename T>inline mint(T x){val=(x%mod+mod)%mod;}\n\tinline mint operator-(){return mod-val;}\n\ttemplate<typename T>inline mint operator^(T b)\n\t{\n\t\tmint tmp=*this,res=1;\n\t\tfor(;b>0;b>>=1,tmp*=tmp) res=b&1?res*tmp:res;\n\t\treturn res; \n\t}\n\ttemplate<typename T>inline mint operator^=(T b){return *this=*this^b;}\n\tinline mint inv(){return this->operator^(mod-2);}\n\tinline mint operator+(mint b){return val+b.val-(val+b.val>=mod?mod:0);}\n\tinline mint operator-(mint b){return val-b.val+(val-b.val<0?mod:0);}\n\tinline mint operator*(mint b){return 1ll*val*b.val%mod;}\n\tinline mint operator/(mint b){return 1ll*val*b.inv().val%mod;}\n\tinline mint operator+=(mint b){return val=val+b.val-(val+b.val>=mod?mod:0);}\n\tinline mint operator-=(mint b){return val=val-b.val+(val-b.val<0?mod:0);}\n\tinline mint operator*=(mint b){return val=1ll*val*b.val%mod;}\n\tinline mint operator/=(mint b){return val=1ll*val*b.inv().val%mod;}\n\ttemplate<typename T>inline mint operator+(T b){return this->operator+(mint(b));};\n\ttemplate<typename T>inline mint operator-(T b){return this->operator-(mint(b));};\n\ttemplate<typename T>inline mint operator*(T b){return this->operator*(mint(b));};\n\ttemplate<typename T>inline mint operator/(T b){return this->operator/(mint(b));};\n\ttemplate<typename T>inline mint operator+=(T b){return this->operator+=(mint(b));};\n\ttemplate<typename T>inline mint operator-=(T b){return this->operator-=(mint(b));};\n\ttemplate<typename T>inline mint operator*=(T b){return this->operator*=(mint(b));};\n\ttemplate<typename T>inline mint operator/=(T b){return this->operator/=(mint(b));};\n};\n\nusing namespace std;\n\nconst int S=10000005;\n\nmint fra[S],inv[S];\nint n,k;\n\ninline mint C(int n,int m)\n{\n\tif(n<0||m<0||n<m) return 0;\n\treturn fra[n]*inv[n-m]*inv[m];\n}\n\ninline mint f(int n,int m)\n{\n\treturn C(n-m,m);\n}\n\nint main()\n{\n\tmod=998244353;\n\tfra[0]=1;\n\tfor(int i=1;i<=S-3;i++) fra[i]=fra[i-1]*i;\n\tinv[S-3]=fra[S-3].inv();\n\tfor(int i=S-3;i>=1;i--) inv[i-1]=inv[i]*i;\n\tscanf(\"%d%d\",&n,&k);\n\tmint ans=0;\n\tint lb=1,rb=0,pr=-1;\n\tmint sum=0;\n\tfor(int i=0;i<=k;i++)\n\t{\n\t\tans+=i==n?(mint)1:f(min(k,k-i*2+n-1),k-i);\n\t\tif(i*2<n)\n\t\t{\n\t\t\tint L=k-n+i+1,R=k-i-1;\n\t\t\tif(pr>=0) sum=sum*2+C(pr,lb-1)-C(pr,rb);\n\t\t\tpr++;\n\t\t\twhile(lb>L) sum+=C(pr,--lb);\n\t\t\twhile(rb<R) sum+=C(pr,++rb);\n\t\t\twhile(lb<L) sum-=C(pr,lb++);\n\t\t\twhile(rb>R) sum-=C(pr,rb--);\n\t\t\tans+=sum;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"数学"},{"name":"组合计数"}],
			"title": "CF1784F Minimums or Medians 做题记录",
			"link": "https://exber.qzz.io/post/CF1784F%20Minimums%20or%20Medians%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-08-12 15:09:59"
		},
	
		{
			"abstract": "> 一张 $n$ 个点 $m$ 条边的无向带权简单连通图，其上一条路径的权值为其中所有边权的 $\\max$。\n>\n> 考虑这张图的补图，补图中一条边的权值为原图中该边两端点间的最短路（路径长度的定义同上）。保证补图亦是连通图。\n>\n> 对于原图中每条边，求出其两端点在补图中的最短路（定义仍同上）。\n> \n> $1\\le n,m\\le 2\\times 10^5$，边权范围 $[0,10^9]$。\n",
			"content": "> 一张 $n$ 个点 $m$ 条边的无向带权简单连通图，其上一条路径的权值为其中所有边权的 $\\max$。\n>\n> 考虑这张图的补图，补图中一条边的权值为原图中该边两端点间的最短路（路径长度的定义同上）。保证补图亦是连通图。\n>\n> 对于原图中每条边，求出其两端点在补图中的最短路（定义仍同上）。\n> \n> $1\\le n,m\\le 2\\times 10^5$，边权范围 $[0,10^9]$。\n\n下文所有最短路的定义都与题目中一致。\n\n建出 kruskal 重构树，那么两点间的最短路就是它们 lca 的权值，而 lca 越深权值越小，所以在重构树的 dfn 序中到 $u$ 的最短路最小的点一定是 $u$ 左边离它最近的点或 $u$ 右边离它最近的点。\n\n考虑找出补图的最小生成树，易证明两点在补图中的最短路等与它们在补图的最小生成树中的最短路。\n\n发现补图是个稠密图，所以考虑 Boruvka 算法。\n\n考虑怎么找到补图中距离某个连通块最近的点，可以转化为求出补图中到每个点最近的点。考虑给 $n$ 个点按照 dfs 序排序，那么相当于找到 $u$ 左边和右边最近的不在 $u$ 的连通块且在原图中与 $u$ 没有直接连边的点。这个可以考虑预处理同一个连通块的连续段，对于点 $u$，直接暴力往左往右依次找，遇到连续的与 $u$ 在同一个连通块的点就直接快速跳，遇到和 $u$ 有直接连边的点就跳过。\n\n这样做的话 Boruvka 一轮时间复杂度是 $O(m)$，那么总时间复杂度为 $O(m\\log n)$。\n\n代码如下：\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\n// fastI\ntemplate<typename T>\ninline void read(T &x)\n{\n\tx=0;\n\tbool fl=false;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9') fl^=c=='-',c=getchar();\n\twhile(c>='0'&&c<='9') x=x*10+(c^48),c=getchar();\n\tx=fl?-x:x;\n}\ntemplate<>inline void read<char>(char &x)\n{\n\tx=getchar();\n\twhile(x==' '||x=='\\r'||x=='\\n') x=getchar();\n}\ninline void read(){return;};\ntemplate<typename T,typename ...Args>\ninline void read(T &x,Args&...args){read(x),read(args...);}\n\n// fastO\ntemplate<typename T>\nvoid write(T x){x>9?write(x/10),putchar(x%10|48):putchar(x%10|48);}\ntemplate<>inline void write<char>(char x){putchar(x);}\ntemplate<typename T,typename ...Args>\ninline void write(T x,Args...args){write(x),write(args...);}\n\nconst int S=200005,TS=400005,BS=25;\n\nstruct node\n{\n\tint x,y,w,id;\n}ed[S],ed2[S];\n\nint n,m;\nint fa[TS];\nint cnt,b[TS];\nvector<int> son[TS];\nint fat[TS],dep[TS],tot,dfn[TS],a[TS],mlog[TS],mn[TS][BS];\nvector<int> vc[S];\nint pp[S];\nint lb[S],rb[S],el[S],er[S],nxt[S],lst[S];\nint mnl[S],mnr[S],mnlu[S],mnru[S],mnlv[S],mnrv[S];\nint m2;\n\nint fnd(int x)\n{\n\treturn fa[x]==x?x:fa[x]=fnd(fa[x]);\n}\n\nvoid dfs(int u,int fa)\n{\n\tfat[u]=fa;\n\tdep[u]=dep[fa]+1;\n\ta[dfn[u]=++tot]=u;\n\tfor(int v:son[u]) dfs(v,u);\n}\n\ninline void initlca()\n{\n\tmlog[0]=-1;\n\tfor(int i=1;i<=tot;i++) mlog[i]=mlog[i>>1]+1,mn[i][0]=i;\n\tfor(int j=1;j<=mlog[tot];j++)\n\t{\n\t\tfor(int i=1;i<=tot-(1<<j)+1;i++)\n\t\t{\n\t\t\tint x=mn[i][j-1],y=mn[i+(1<<j-1)][j-1];\n\t\t\tmn[i][j]=dep[a[x]]<dep[a[y]]?x:y;\n\t\t}\n\t}\n}\n\ninline int quelca(int x,int y)\n{\n\tif(x==y) return x;\n\tx=dfn[x],y=dfn[y];\n\tif(x>y) swap(x,y);\n\tx++;\n\tint k=mlog[y-x+1];\n\tint aa=mn[x][k],bb=mn[y-(1<<k)+1][k];\n\tif(dep[a[aa]]<dep[a[bb]]) return fat[a[aa]];\n\telse return fat[a[bb]];\n}\n\ninline void kruskal(node *ed,int m)\n{\n\tfor(int i=1;i<=n*2;i++) son[i].clear();\n\tsort(ed+1,ed+m+1,[&](node x,node y){return x.w<y.w;});\n\tfor(int i=1;i<=n*2;i++) fa[i]=i;\n\tcnt=n;\n\tfor(int i=1;i<=n;i++) b[i]=0;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x=ed[i].x,y=ed[i].y;\n\t\tint rx=fnd(x),ry=fnd(y);\n\t\tif(rx==ry) continue;\n\t\tfa[rx]=fa[ry]=++cnt;\n\t\tson[cnt].push_back(rx),son[cnt].push_back(ry);\n\t\tb[cnt]=ed[i].w;\n\t}\n\ttot=0;\n\tdfs(cnt,0);\n\tinitlca();\n}\n\ninline void boruvka()\n{\n\tfor(int i=1;i<=n;i++) vc[i].clear();\n\tfor(int i=1;i<=n;i++) pp[i]=i;\n\tsort(pp+1,pp+n+1,[&](int x,int y){return dfn[x]<dfn[y];});\n\tfor(int i=1;i<=m;i++) vc[ed[i].x].push_back(ed[i].y),vc[ed[i].y].push_back(ed[i].x);\n\tfor(int i=1;i<=n;i++) sort(vc[i].begin(),vc[i].end(),[&](int x,int y){return dfn[x]<dfn[y];});\n\tm2=0;\n\tfor(int i=1;i<=n;i++) fa[i]=i;\n\twhile(1)\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tint j=i;\n\t\t\twhile(j<n&&fnd(pp[j+1])==fnd(pp[i])) j++;\n\t\t\tfor(int k=i;k<=j;k++) lb[pp[k]]=i-1,rb[pp[k]]=j+1;\n\t\t\tnxt[i]=j,lst[j]=i;\n\t\t\ti=j;\n\t\t}\n\t\tif(nxt[1]==n) break;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tel[i]=vc[i].size()-1;\n\t\t\tfor(int j=0;j<vc[i].size();j++)\n\t\t\t{\n\t\t\t\tif(dfn[vc[i][j]]>dfn[pp[lb[i]]])\n\t\t\t\t{\n\t\t\t\t\tel[i]=j-1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\ter[i]=0;\n\t\t\tfor(int j=vc[i].size()-1;j>=0;j--)\n\t\t\t{\n\t\t\t\tif(dfn[vc[i][j]]<dfn[pp[rb[i]]])\n\t\t\t\t{\n\t\t\t\t\ter[i]=j+1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++) mnlv[i]=mnrv[i]=2e9;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tint x=pp[i];\n\t\t\twhile(lb[x]>=1&&(el[x]>=0&&vc[x][el[x]]==pp[lb[x]]))\n\t\t\t{\n\t\t\t\tlb[x]--,el[x]--;\n\t\t\t\tif(lb[x]>=1&&fnd(pp[lb[x]])==fnd(x)) lb[x]=lst[lb[x]]-1;\n\t\t\t\twhile(el[x]>0&&dfn[vc[x][el[x]-1]]>=dfn[pp[lb[x]]]) el[x]--;\n\t\t\t}\n\t\t\tif(lb[x]>=1&&b[quelca(pp[lb[x]],x)]<mnlv[fnd(x)])\n\t\t\t{\n\t\t\t\tmnl[fnd(x)]=pp[lb[x]];\n\t\t\t\tmnlu[fnd(x)]=x;\n\t\t\t\tmnlv[fnd(x)]=b[quelca(pp[lb[x]],x)];\n\t\t\t}\n\t\t\twhile(rb[x]<=n&&(er[x]<=vc[x].size()-1&&vc[x][er[x]]==pp[rb[x]]))\n\t\t\t{\n\t\t\t\trb[x]++,er[x]++;\n\t\t\t\tif(rb[x]<=n&&fnd(pp[rb[x]])==fnd(x)) rb[x]=nxt[rb[x]]+1;\n\t\t\t\twhile(er[x]<vc[x].size()-1&&dfn[vc[x][er[x]+1]]<=dfn[pp[rb[x]]]) er[x]++;\n\t\t\t}\n\t\t\tif(rb[x]<=n&&b[quelca(pp[rb[x]],x)]<mnrv[fnd(x)])\n\t\t\t{\n\t\t\t\tmnr[fnd(x)]=pp[rb[x]];\n\t\t\t\tmnru[fnd(x)]=x;\n\t\t\t\tmnrv[fnd(x)]=b[quelca(pp[rb[x]],x)];\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(fa[i]==i)\n\t\t\t{\n\t\t\t\tif(mnlv[i]<mnrv[i])\n\t\t\t\t{\n\t\t\t\t\tint p=mnl[i];\n\t\t\t\t\tif(fnd(p)!=i)\n\t\t\t\t\t{\n\t\t\t\t\t\ted2[++m2]={p,mnlu[i],mnlv[i],0};\n\t\t\t\t\t\tfa[fnd(p)]=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tint p=mnr[i];\n\t\t\t\t\tif(fnd(p)!=i)\n\t\t\t\t\t{\n\t\t\t\t\t\ted2[++m2]={p,mnru[i],mnrv[i],0};\n\t\t\t\t\t\tfa[fnd(p)]=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void slove()\n{\n\tread(n,m);\n\tfor(int i=1;i<=m;i++) read(ed[i].x,ed[i].y,ed[i].w),ed[i].id=i;\n\tkruskal(ed,m);\n\tboruvka();\n\tkruskal(ed2,m2);\n\tsort(ed+1,ed+m+1,[&](node x,node y){return x.id<y.id;});\n\tfor(int i=1;i<=m;i++) write(b[quelca(ed[i].x,ed[i].y)],' ');\n\twrite('\\n');\n}\n\nint main()\n{\n\tint T;\n\tread(T);\n\twhile(T-->0) slove();\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"图论"}],
			"title": "CF1648E Air Reform 做题记录",
			"link": "https://exber.qzz.io/post/CF1648E%20Air%20Reform%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-08-12 09:43:51"
		},
	
		{
			"abstract": "",
			"content": "数学期望和组合计数有许多共通之处，可以看作是带系数的计数。\n\n## Part 1 记号和定义\n\n在本文中：\n\n- 仅讨论在值域中**均匀随机**的随机变量；\n\n- 设 $x$ 为某随机变量，即取值在值域中随机的变量，则 $P_x(i)$ 为 $x$ 取到 $i$ 的概率；\n\n- 设 $x$ 为某随机变量，则 $\\mathbb E(x)$ 表示 $x$ 的期望值，即 $\\sum\\limits_{i} i\\cdot P_x(i)$ 或 $\\int i\\cdot P_x(i)\\,di$；\n\n## Part 2 性质和技巧\n\n把期望看作带系数计数 与 考虑组合意义 都是常用的推导方法。\n\n### 2.0 约定\n\n- 证明中只用到了 $\\sum$ 且没有特殊说明：这里只证明值域离散（随机变量只能取整数）的情况下的性质，值域连续（随机变量可以取实数）的情况下也有这些性质，将这些证明中的 $\\sum\\limits_{i}$ 换成 $\\int\\,di$ 即可证明；\n- 证明中用到了 $\\int$ 且没有特殊说明：这些性质只有在值域连续的情况下才能存在；\n\n### 2.1 基础性质\n\n设 $x$ 和 $y$ 为某两随机变量（不一定无关，即它们可能会互相影响）。\n\n- **可加性**：\n  \n  > $$\n  > \\mathbb E(x+y)=\\mathbb E(x)+\\mathbb E(y)\n  > $$\n  \n  <details><summary>证明</summary><p>\n  \n  > $$\n  > \\begin{aligned}\n  >   \\mathbb E(x+y)&=\\sum\\limits_{i} i\\cdot \\sum \\limits_{j}P_x(j)P_y(i-j)\\\\\n  >   &=\\sum\\limits_{j}P_x(j)\\sum\\limits_{k}P_y(k)\\cdot(j+k)\\\\\n  >   &=\\sum\\limits_{j}j\\cdot P_x(j)+\\sum\\limits_{k}k\\cdot P_y(k)\n  >   \\end{aligned}\n  > $$\n  > Q.E.D.\n  \n  </p></details>\n  \n- **线性性**：\n\n  > 对于某常数 $\\alpha$，有：\n  > $$\n  > \\mathbb E(\\alpha x)=\\alpha \\mathbb E(x)\n  > $$\n  \n  <details><summary>证明</summary><p>\n  \n  > $$\n  > \\mathbb E(\\alpha x)=\\sum\\limits_{i}\\alpha \\cdot P_x(i)=\\alpha\\sum\\limits_{i}i\\cdot P_x(i)=\\alpha\\mathbb E(x)\n  > $$\n  > Q.E.D.\n  \n  </p></details>\n  \n- **无关可乘性**：\n\n  > 若 $x$ 与 $y$ 无关，即一个的取值不会影响到另一个，则有：\n  > $$\n  > \\mathbb E(xy)=\\mathbb E(x)\\cdot\\mathbb E(y)\n  > $$\n\n  <details><summary>证明</summary><p>\n\n  > $$\n  > \\mathbb E(xy)=\\sum\\limits_{i}\\sum\\limits_{j}ij\\cdot P_x(i)P_y(j)=\\mathbb E(x)\\cdot \\mathbb E(y)\n  > $$\n  >\n  > Q.E.D.\n  \n  </p></details>\n\n### 2.2 常用技巧\n\n若无特殊说明，公式中出现的变量均为随机变量。\n\n- **发生事件期望所需次数**：\n\n  > 若某事件每次发生的概率为 $a$，其中 $a$ 是一个确定的实数，则发生该事件所需的期望次数为 $\\frac{1}{a}$。\n  \n    <details><summary>证明</summary><p>\n  \n    > $$\n    > \\mathbb E=a+(1-a)(\\mathbb E+1)\\\\\n    > \\mathbb E=a+\\mathbb E+1-a\\mathbb E-a\\\\\n    > a\\mathbb E=1\\\\\n    > \\mathbb E=\\frac{1}{a}\n    > $$\n    >\n    > Q.E.D.\n  \n    </p></details>\n  \n- **分配**：\n\n  > $$\n  > \\mathbb E((a+b)(c+d))=\\mathbb E(ac)+\\mathbb E(ad)+\\mathbb E(bc)+\\mathbb E(bd)\n  > $$\n  > \n\n  > $$\n  > \\mathbb E\\left(\\prod\\limits_{i=1}^n\\sum\\limits_{j=1}^m x_{i,j}\\right)=\\\\\n  > \\mathbb E(x_{1,1}\\times x_{2,1}\\times \\dots \\times x_{n,1})+E(x_{1,2}\\times x_{2,1}\\times \\dots \\times x_{n,1})+\\dots+E(x_{1,m}\\times x_{2,m}\\times \\dots \\times x_{n,m})\n  > $$\n  >\n  > 即每一个 $\\mathbb E()$ 中一共有 $n$ 项相乘，第 $i$ 项可以是 $x_{i,[1,m]}$ 中的任意一个。\n  \n  拆括号后运用期望的可加性即可证明，第二条是第一条的拓展。\n  \n- **$n$ 个值域相同的随机变量的第 $k$ 小值的期望**：\n\n  >设 $n$ 个在 $[0,1]$ 间的**连续**随机变量 $x_{1\\sim n}$，则 $\\mathbb E\\left(\\text{kth-min}_k\\{x_i\\}\\right)=\\frac{k}{n+1}$。\n\n  > 设 $n$ 个在 $[1,m]$ 间的**离散**随机变量 $x_{1\\sim n}$，则 $\\mathbb E\\left(\\text{kth-min}_k\\{x_i\\}\\right)=\\frac{km}{n+1}$。\n  \n  \n    <details><summary>证明</summary><p>\n  \n    > 先证明第一条。\n    >\n    > 引入另一个 $[0,1]$ 间的连续随机变量 $y$，设 $P(i)$ 为 $i\\le\\text{kth-min}_k\\{x_i\\}$ 的概率，那么 $\\mathbb E\\left(\\text{kth-min}_k\\{x_i\\}\\right)=\\frac{\\int_0^1 P(i)\\,di}{1}=P(y)$。\n    >\n    > 考虑给所有随机变量升序排序，相同则按原来的位置排，那么一共有 $(n+1)!$ 种顺序，其中 $y$ 排在前 $k$ 位的一共有 $kn!$ 种顺序，具体的考虑插入即可。\n    >\n    > 那么 $P(y)=\\frac{kn!}{(n+1)!}=\\frac{k}{n+1}=\\mathbb E\\left(\\text{kth-min}_k\\{x_i\\}\\right)$。\n    >\n    > 第二条相当于第一条把 $x_i$ 乘上 $m$ 然后取整转化为离散情况。\n    >\n    > Q.E.D.\n  \n    </p></details>\n\n## Part 3 例题\n\n### 3.1 期望参与答案计算\n\n- [CF1523E Crypto Lights](https://www.luogu.com.cn/problem/CF1523E) | [题解](https://www.ckjweb.tk/post/cf1523e-crypto-lights-zuo-ti-ji-lu)\n\n- [CF1278F Cards](https://www.luogu.com.cn/problem/CF1278F)\n\n   <details><summary>查看题解</summary><p>\n\n\n  > 考虑设第 $i$ 次洗牌后第一张牌的情况为 $x_i$（是王牌则 $x_i=1$，否则 $x_i=0$），那么显然 $\\mathbb E(x_i)=\\frac{1}{m}$。\n  >\n  > 发现答案等价于 $\\mathbb E\\left(\\left(\\sum\\limits_{i=1}^n x_i\\right)^k\\right)$，根据 2.2 中的分配技巧，这个东西相当于：\n  > $$\n  > \\mathbb E(x_1^k)+\\mathbb E(x_1^{k-1}x_2)+\\dots+\\mathbb E(x_n^k)\n  > $$\n  > 即每一个 $\\mathbb E()$ 中一共有 $k$ 项相乘，第 $i$ 项可以是 $x_{[1,n]}$ 中的任意一个。\n  >\n  > 考虑一项一项填入 $\\mathbb E()$ 中，由于不同的 $x_p$ 互相独立且本质相同，则 $\\forall p_1\\not=p_2,\\mathbb E(x_{p_1}x_{p_2})=\\mathbb E(x_{p_1})\\mathbb E(x_{p_2})=\\frac{1}{m^2}$。而相同的 $x_p$ 取值肯定一样，那么我们只需要关心有多少个不同的 $x_p$。\n  >\n  > 设 $f_{i,j}$ 表示确定了前 $i$ 项，其中一共有 $j$ 个不同的 $x_p$。显然 $f_{0,0}=1$，转移考虑下一位填入的 $x_p$ 是否出现过：\n  > $$\n  > f_{i,j}=f_{i-1,j}\\times j+f_{i-1,j-1}\\times (n-j+1)\\times \\frac{1}{m}\n  > $$\n  > 最后答案即为 $\\sum\\limits_{i=0}^k f_{k,i}$。\n  >\n  > 时间复杂度 $O(k^2)$。\n\n  </p></details>\n\n- [CF1842G Tenzing and Random Operations](https://www.luogu.com.cn/problem/CF1842G)\n\n### 3.2 期望参与时间复杂度计算\n\n- [【2023NOIP模拟赛09】补幺梨](../【2023NOIP模拟赛09】补幺梨 做题记录)\n",
			"tags": [{"name":"学习笔记"},{"name":"数学"},{"name":"概率、期望"}],
			"title": "数学期望学习笔记",
			"link": "https://exber.qzz.io/post/%E6%95%B0%E5%AD%A6%E6%9C%9F%E6%9C%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-08-08 20:50:23"
		},
	
		{
			"abstract": "> 给定一个如图所示的计算方法：\n>\n> ![](../post-images/1691492484006.webp)\n>\n> 现在给定长 $n$ 的数组 $a$ 和 $p$，要求 $q$ 次询问 $\\text{sum}(a,l_i,r_i,p)$ 的值。\n>\n> $1\\le n\\le 10^6$，$1\\le m\\le 2\\times 10^5$，$1\\le p\\le 10^9$，$|a_i|\\le 10^9$。\n",
			"content": "> 给定一个如图所示的计算方法：\n>\n> ![](../post-images/1691492484006.webp)\n>\n> 现在给定长 $n$ 的数组 $a$ 和 $p$，要求 $q$ 次询问 $\\text{sum}(a,l_i,r_i,p)$ 的值。\n>\n> $1\\le n\\le 10^6$，$1\\le m\\le 2\\times 10^5$，$1\\le p\\le 10^9$，$|a_i|\\le 10^9$。\n\n\n设 $F(x,l,r)$ 表示 $x$ 经过区间 $[l,r]$ 后要减多少次 $p$，发现这个是分成 $r-l+1$ 段的分段函数。\n\n直接线段树，设 $c_{u,x}$ 表示最小的 $x$ 满足经过节点 $u$ 对应的区间后减了 $x$ 次 $p$，那么空间复杂度是 $O(n\\log n)$ 的，询问时可以直接二分找到应该减去的值，单次询问时间复杂度 $O(n\\log ^2n)$。\n\n考虑如何合并 $u$ 的左右儿子，$c_{ls,x}$ 和 $c_{rs,y}$ 可以贡献到 $c_{u,x+y}$ 当且仅当：\n$$\nc_{ls,x+1}-1+sum_{ls}-xp\\ge c_{rs,y}\n$$\n\n因为在区间 $c_{ls,x+1}-1$ 是经过左区间要减 $x$ 次 $p$ 的最大的数。\n\n那么对于一对合法的 $x,y$ 有：\n$$\nc_{u,x+y}=\\min(c_{u,x+y},\\max(c_{ls,x},c_{rs,y}-sum_{ls}+xp))\n$$\n但是直接做是 $O(n^2)$ 的，发现：\n$$\nc_{u,x+1}\\ge c_{u,x}+p\n$$\n\n因为 $c_{u,x}$ 是减 $x$ 次 $p$ 的最小的数，它经过区间时每一次 $MODADD$ 的结果的最大值一定是 $0$，那么想要让它减多一次 $p$ 就至少要给它加上 $p$。\n\n那么对于合法的 $x,y$，设 $f(x,y)=\\max(c_{ls,x},c_{rs,y}-sum_{ls}+xp)$，则一定有：\n$$\nf(x,y)<f(x+1,y-1)\n$$\n因为：\n$$\nc_{ls,x+1}-1+sum_{ls}-xp\\ge c_{rs,y}\\\\\nc_{rs,y}-sum_{ls}+xp+1\\le c_{ls,x+1}\\\\\nc_{rs,y}-sum_{ls}+xp<c_{ls,x+1}\\\\\n$$\n所以 $f(x,y)<c_{ls,x+1}=f(x+1,y-1)$。\n\n由于 $c_{u,x+1}\\ge c_{u,x}+p$ 所以若 $x,y$ 合法则 $x+1,y$ 也一定合法，那么能动 $y$ 就尽量先动 $y$ 即可。\n\n时间复杂度 $O(n\\log n+m\\log^2n)$，代码如下：\n\n```cpp\n// Problem: Nauuo and Bug\n// Contest: Luogu\n// URL: https://www.luogu.com.cn/problem/CF1172F\n// Memory Limit: 1000 MB\n// Time Limit: 4000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nconst int S=1000005;\n\nint n,m;\nlong long p,a[S];\nlong long sum[S<<2];\nvector<long long> c[S<<2];\n\ninline void merge(int u)\n{\n\tint ls=u<<1,rs=u<<1|1;\n\tsum[u]=sum[ls]+sum[rs];\n\tint lc=c[ls].size()-1,rc=c[rs].size()-1;\n\tfor(int i=1;i<=lc+rc;i++) c[u][i]=1e17;\n\tfor(int x=0,y=0;x<=lc;x++)\n\t{\n\t\tif(y>rc) y--;\n\t\twhile(y<=rc)\n\t\t{\n\t\t\tif(x!=lc&&c[ls][x+1]-1+sum[ls]-x*p<c[rs][y])\n\t\t\t{\n\t\t\t\tif(y>0) y--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tc[u][x+y]=min(c[u][x+y],max(c[ls][x],c[rs][y]-sum[ls]+x*p));\n\t\t\ty++;\n\t\t}\n\t}\n}\n\nvoid build(int u,int l,int r)\n{\n\tc[u]=vector<long long>(r-l+2,0);\n\tc[u][0]=-1e17;\n\tif(l==r) return sum[u]=a[l],c[u][1]=p-a[l],void();\n\tint mid=l+r>>1;\n\tbuild(u<<1,l,mid),build(u<<1|1,mid+1,r);\n\tmerge(u);\n}\n\nlong long que(int u,int l,int r,int L,int R,long long val)\n{\n\tif(l>R||r<L) return val;\n\tif(l>=L&&r<=R) return val+sum[u]-(upper_bound(c[u].begin(),c[u].end(),val)-c[u].begin()-1)*p;\n\tint mid=l+r>>1;\n\treturn que(u<<1|1,mid+1,r,L,R,que(u<<1,l,mid,L,R,val));\n}\n\nint main()\n{\n\tscanf(\"%d%d%lld\",&n,&m,&p);\n\tfor(int i=1;i<=n;i++) scanf(\"%lld\",&a[i]);\n\tbuild(1,1,n);\n\twhile(m--)\n\t{\n\t\tint l,r;\n\t\tscanf(\"%d%d\",&l,&r);\n\t\tprintf(\"%lld\\n\",que(1,1,n,l,r,0));\n\t}\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"数据结构"},{"name":"结论"}],
			"title": "CF1172F Nauuo and Bug & P5609 做题记录",
			"link": "https://exber.qzz.io/post/CF1172F%20Nauuo%20and%20Bug%20%26%20P5609%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-08-08 18:59:20"
		},
	
		{
			"abstract": "> 你有一个长为 $n$ 的序列 $x_1,x_2,\\dots,x_n$，一开始全部为 $0$，你现在可以以任意顺序进行任意次以下两种操作：\n>\n> 1. 选定整数 $1\\le k\\le n$ 与不下降非负整数序列 $c_1,c_2,\\dots,c_k$，对所有 $1\\le i \\le k$，令 $x_i$ 加上 $c_i$。\n> 2. 选定整数 $1\\le k\\le n$ 与不上升非负整数序列 $c_1,c_2,\\dots,c_k$，对所有 $1\\le i \\le k$，令 $x_{n-k+i}$ 加上 $c_i$。\n>\n> 问最少进行多少次操作使得 $x_i=a_i$。\n>\n> $1\\le n\\le 2\\times 10^5$，$1\\le a_i\\le 10^9$。\n",
			"content": "> 你有一个长为 $n$ 的序列 $x_1,x_2,\\dots,x_n$，一开始全部为 $0$，你现在可以以任意顺序进行任意次以下两种操作：\n>\n> 1. 选定整数 $1\\le k\\le n$ 与不下降非负整数序列 $c_1,c_2,\\dots,c_k$，对所有 $1\\le i \\le k$，令 $x_i$ 加上 $c_i$。\n> 2. 选定整数 $1\\le k\\le n$ 与不上升非负整数序列 $c_1,c_2,\\dots,c_k$，对所有 $1\\le i \\le k$，令 $x_{n-k+i}$ 加上 $c_i$。\n>\n> 问最少进行多少次操作使得 $x_i=a_i$。\n>\n> $1\\le n\\le 2\\times 10^5$，$1\\le a_i\\le 10^9$。\n\n\n对于这种和单调性有关的情况，一般考虑差分序列。那么设 $b_i=x_{i+1}-x_i$。\n\n考虑只有一种操作怎么做，显然两种操作是对称的，所以只用考虑第一种操作。不难发现第一种操作相当于把 $b_{[1,k-1]}$ 都加上任意非负整数， 把 $b_k$ 减去任意非负整数。而我们的目的是让 $b_i=a_{i+1}-a_i$，所以答案即为 $\\sum\\limits_{i=1}^{n-1}[a_i>a_{i+1}]+1$。\n\n同理，只有第二种操作时的答案为 $\\sum\\limits_{i=1}^{n-1} [a_i<a_{i+1}]+1$。\n\n考虑设 $y_i$ 表示第一种操作让 $x_i$ 增加了多少（$y_{n+1}=a_{n+1}=y_0=a_0=0$），则答案为 $\\sum\\limits_{i=1}^{n+1}[y_{i-1}>y_i]+[a_{i-1}-y_{i-1}<a_{i}-y_{i}]$。\n\n设 $dp_{i,j}$ 表示确定完 $y_{[1,i]}$ 且 $y_i=j$ 的前 $i$ 项的答案，不难发现对于同一个 $i$，$j$ 越大 $dp_{i,j}$ 越小，而转移时 $j'$ 越小 $dp_{i-1,j'}$ 转移到 $dp_{i,j}$ 的代价越小。注意到对于同一个 $i$，$dp_{i,j}$ 最多只有三种取值，那么记录下这三种取值的值和最小的 $j$ 即可转移。\n\n时间复杂度 $O(n)$，代码如下：\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=200005,inf=1e9;\n\nint n,a[S];\nint f[S][3],g[S][3];\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\ta[0]=a[n+1]=0;\n\tf[0][0]=0,g[0][0]=0;\n\tf[0][1]=g[0][1]=inf;\n\tf[0][2]=g[0][2]=inf;\n\tfor(int i=1;i<=n+1;i++)\n\t{\n\t\tint y[7],dp[7]={inf,inf,inf,inf,inf,inf,inf};\n\t\tfor(int j=0;j<3;j++) y[j]=a[i]-a[i-1]+f[i-1][j];\n\t\tfor(int j=3;j<6;j++) y[j]=f[i-1][j-3];\n\t\ty[6]=0;\n\t\tfor(int j=0;j<7;j++)\n\t\t{\n\t\t\tint v=y[j];\n\t\t\tif(v<0||v>a[i]) continue;\n\t\t\tfor(int k=0;k<3;k++)\n\t\t\t{\n\t\t\t\tint u=f[i-1][k];\n\t\t\t\tif(u<0||u>a[i-1]) continue;\n\t\t\t\tdp[j]=min(dp[j],g[i-1][k]+(u>v)+(a[i-1]-u<a[i]-v));\n\t\t\t}\n\t\t}\n\t\tint id[7]={0,1,2,3,4,5,6};\n\t\tsort(id,id+7,[&](int a,int b){return dp[a]<dp[b]||(dp[a]==dp[b]&&y[a]<y[b]);});\n\t\tint p=0;\n\t\tfor(int j=0;j<7&&p<3;j++)\n\t\t{\n\t\t\tint k=id[j];\n\t\t\tif(p==0||dp[k]!=g[i][p-1])\n\t\t\t{\n\t\t\t\tf[i][p]=y[k],g[i][p]=dp[k];\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\tfor(int j=p;j<3;j++) f[i][j]=g[i][j]=inf;\n\t}\n\tprintf(\"%d\\n\",g[n+1][0]);\n\treturn 0;\n}\n// (y[i]>y[i+1])+(a[i]-y[i]<a[i+1]-y[i+1])\n```\n",
			"tags": [{"name":"做题记录"},{"name":"DP"},{"name":"结论"}],
			"title": "AGC040E Prefix Suffix Addition 做题记录",
			"link": "https://exber.qzz.io/post/AGC040E%20Prefix%20Suffix%20Addition%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-08-07 08:31:00"
		},
	
		{
			"abstract": "> 给定 $n$, $k$, $m$ , 问有多少个序列组 $(A_0,A_1,\\dots,A_n)$ 满足：\n>\n> - 序列 $A_i$ 的元素个数为 $i$；\n>- 所有元素都在 $[1,k]$ 内；\n> - $\\forall i\\in[0,n-1]$，$A_i$ 是 $A_{i+1}$ 的子序列且 $A_i$ 的字典序小于 $A_{i+1}$；\n>\n> 答案对 $m$ 取模。\n> \n> $1\\le n,k\\le 300$，$2\\le m\\le 10^9$。\n\n",
			"content": "> 给定 $n$, $k$, $m$ , 问有多少个序列组 $(A_0,A_1,\\dots,A_n)$ 满足：\n>\n> - 序列 $A_i$ 的元素个数为 $i$；\n>- 所有元素都在 $[1,k]$ 内；\n> - $\\forall i\\in[0,n-1]$，$A_i$ 是 $A_{i+1}$ 的子序列且 $A_i$ 的字典序小于 $A_{i+1}$；\n>\n> 答案对 $m$ 取模。\n> \n> $1\\le n,k\\le 300$，$2\\le m\\le 10^9$。\n\n\n等价于不断插入 $[1,k]$  之间的元素。\n\n设当前序列为 $a$，考虑若在 $a_i$ 之前插入 $x$，显然需要满足以下条件中至少一个：\n\n- $i=n+1$；\n- $x>a_i$；\n- 设 $to_i=\\min\\limits_{j>i,a_j\\not=a_i}j$，$a_i>a_{to_i}$；\n\n发现第三种情况等价于在 $a_{to_i}$ 之前插入 $x$，那不妨钦定只能有第一种和第二种情况，这样钦定刚好避免算重。 \n\n令 $a_{n+1}=0$，则只能在比 $x$ 小的元素前插入。\n\n但是还是不好做，设 $nt_i$ 表示最终序列中 $a_i$ 插入时其后继在最终序列的位置，则 $[i,nt_i]$ 这些区间肯定要么相交要么包含。不妨从 $i$ 向 $nt_i$ 连边，这样会形成一棵以 $n+1$ 为根的树，只需要对树的方案计数即可。\n\n具体的，对于一棵树，其根 $rt$ 必定是最先插入的；对于 $rt$ 的儿子，我们可以确定一个插入时间的相对顺序，来确定其子树在最终序列中的位置。\n\n也就是说树中每个点的儿子有顺序。\n\n注意到我们只关心树根元素的大小和树的大小，于是设 $f_{i,u}$ 表示大小为 $i$，树根元素为 $u$ 的树的方案数，转移考虑枚举插入时间最早的儿子 $v$（序列中最远离 $u$），那么有转移：\n$$\nf_{i,u}=\\sum\\limits_{j=1}^{i-1}\\binom{i-2}{j-1}\\times f_{i-j,u}\\times\\sum\\limits_{v>u}f_{j,v}\n$$\n其中组合数相当于有 $i$ 个插入的时间可以选择，$rt$ 和 $v$ 必定是前两个插入的，$v$ 子树中点的插入时间可以任意选择。\n\n使用前缀和优化可以做到 $O(n^2k)$。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=305;\n\nint n,k,p;\nint C[S][S],f[S][S],sum[S][S];\n\ninline void add(int &x,int y)\n{\n\tx+=y;\n\tif(x>=p) x-=p;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&k,&p);\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<=i;j++) C[i][j]=(C[i-1][j]+C[i-1][j-1])%p;\n\t}\n\tfor(int i=0;i<=k;i++) f[1][i]=1;\n\tfor(int i=k;i>=0;i--) sum[1][i]=(sum[1][i+1]+f[1][i])%p;\n\tfor(int i=2;i<=n+1;i++)\n\t{\n\t\tfor(int j=0;j<=k;j++)\n\t\t{\n\t\t\tfor(int s=1;s<=i-1;s++)\n\t\t\t{\n\t\t\t\tadd(f[i][j],1ll*sum[s][j+1]*C[i-2][s-1]%p*f[i-s][j]%p);\n\t\t\t}\n\t\t}\n\t\tfor(int j=k;j>=0;j--) sum[i][j]=(sum[i][j+1]+f[i][j])%p;\n\t}\n\tprintf(\"%d\\n\",f[n+1][0]);\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"数学"},{"name":"组合计数"},{"name":"DP"}],
			"title": "AGC024E Sequence Growing Hard 做题记录",
			"link": "https://exber.qzz.io/post/AGC024E%20Sequence%20Growing%20Hard%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-07-21 15:11:40"
		},
	
		{
			"abstract": "> 给定 $n$ 和 $k$，有 $n$ 个 $< 2^k$ 的非负整数变量 $x_1,x_2,\\dots,x_n$，其中 $x_i$ 的取值范围是 $[l_i,r_i]$。\n>\n> 给出数列 $c_0,c_1,\\dots,c_{K-1}$，并由此定义一个代价函数 $f(x)$：\n>\n> $$\n> f(x)=\\sum_{i=0}^{k-1}(\\lfloor\\tfrac x{2^i}\\rfloor\\bmod 2)\\cdot c_i\n> $$\n> 确定每个变量的取值，使得 $\\sum_{i=2}^nf(x_i\\oplus x_{i-1})$ 最小，输出该最小值。\n>\n> $2\\le n\\le50$，$1\\le k\\le50$，$0\\le l_i\\le r_i< 2^k$，$0\\le c_i\\le10^{12}$。\n",
			"content": "> 给定 $n$ 和 $k$，有 $n$ 个 $< 2^k$ 的非负整数变量 $x_1,x_2,\\dots,x_n$，其中 $x_i$ 的取值范围是 $[l_i,r_i]$。\n>\n> 给出数列 $c_0,c_1,\\dots,c_{K-1}$，并由此定义一个代价函数 $f(x)$：\n>\n> $$\n> f(x)=\\sum_{i=0}^{k-1}(\\lfloor\\tfrac x{2^i}\\rfloor\\bmod 2)\\cdot c_i\n> $$\n> 确定每个变量的取值，使得 $\\sum_{i=2}^nf(x_i\\oplus x_{i-1})$ 最小，输出该最小值。\n>\n> $2\\le n\\le50$，$1\\le k\\le50$，$0\\le l_i\\le r_i< 2^k$，$0\\le c_i\\le10^{12}$。\n\n\n考虑二进制意义下从高往低一位一位填，若当前填到了第 $p$ 位且 $x_{[l,r]}$ 之后的位无论怎么填都不会超出 $[l_i,r_i]$ 的限制，则 $x_{[l,r]}$ 后面的位可以贪心地和 $x_{l-1}$ 一样，所以 $x_{[l,r]}$ 可以删掉。\n\n不妨能删就删，即钦定 $x_{l-1}$ 和 $x_{r+1}$ 的高 $p$ 位都顶着上界和下界中的至少一个。\n\n那么有一个朴素的 dp，设 $f_{p,l,r,0/1,0/1}$ 表示填完高 $p$ 位，删掉了区间 $x_{[l,r]}$，$x_{l-1}$ 顶到上界/下界，$x_{r+1}$ 顶到上界/下界。\n\n发现这样转移不了，因为若 $x_k$ 在第 $p$ 位时解除了限制，则它的第 $p$ 位需要翻转。不妨把这个东西加入状态，设 $f_{p,l,r,0/1,0/1,0/1,0/1}$ 表示填完高 $p$ 位，删掉了区间 $x_{[l,r]}$；$x_{l-1}$ 顶到上界/下界，是否在第 $p$ 位解除限制；$x_{r+1}$ 顶到上界/下界，是否在第 $p$ 位解除限制。\n\n注意这样设计状态后 $f_{*,*,*,*,0,*,0}$ 才是我们想要的东西，$f_{*,*,*,*,1,*,*}$ 和 $f_{*,*,*,*,*,*,1}$ 只是中间状态。\n\n转移较为简单，注意到 $f_{p,l,r,*,*,*,*}$ 只有两个来源，即 $f_{p+1,l,r,*,0,*,0}+\\text{第 }p\\text{ 位的代价}$ 和 $f_{p,l,k-1,*,*,*,1}+f_{p,k+1,r,*,1,*,*}$。前者对应 $x_{[l,r]}$ 没有在第 $p$ 位解除限制的变量，后者则对应有这样的变量。\n\n注意 $p=0$ 时后面没有位了，要特判。\n\n时间复杂度 $O(kn^3)$，使用记忆化搜索实现会简洁很多，代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nconst int S=55;\nconst long long inf=1e18;\n\nint n,m;\nlong long L[S],R[S],c[S];\nlong long f[S][S][S][2][2][2][2];\n\ninline void tom(long long &x,long long y){x=min(x,y);}\n\nlong long g(int p,int l,int r,int l0,int l1,int r0,int r1)\n{\n\tif(p==m) return l>r?0:inf;\n\tlong long &u=f[p][l][r][l0][l1][r0][r1];\n\tif(u!=-1) return u;\n\tint stl=(((l0==0?L[l-1]:R[l-1])>>p)&1)^l1;\n\tint str=(((r0==0?L[r+1]:R[r+1])>>p)&1)^r1;\n\tu=inf;\n\ttom(u,g(p+1,l,r,l0,0,r0,0)+(l!=1&&r!=n&&stl!=str)*c[p]);\n\tfor(int k=l;k<=r;k++)\n\t{\n\t\tfor(int t=0;t<=1;t++)\n\t\t{\n\t\t\tif(p==0) tom(u,g(p,l,k-1,l0,l1,t,0)+g(p,k+1,r,t,0,r0,r1));\n\t\t\tlong long vk=(t==0?L[k]:R[k])^(1ll<<p);\n\t\t\tif((vk&(~((1ll<<p)-1)))>=L[k]&&(vk|((1ll<<p)-1))<=R[k])\n\t\t\t{\n\t\t\t\ttom(u,g(p,l,k-1,l0,l1,t,1)+g(p,k+1,r,t,1,r0,r1));\n\t\t\t}\n\t\t}\n\t}\n\treturn u;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++) scanf(\"%lld%lld\",&L[i],&R[i]);\n\tfor(int i=0;i<=m-1;i++) scanf(\"%lld\",&c[i]);\n\tmemset(f,-1,sizeof(f));\n\tprintf(\"%lld\\n\",g(0,1,n,0,0,0,0));\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"DP"}],
			"title": "CF1456E XOR-ranges 做题记录",
			"link": "https://exber.qzz.io/post/CF1456E%20XOR-ranges%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-07-20 21:17:05"
		},
	
		{
			"abstract": "",
			"content": "## Part 1 简介\n\n启发式分裂是一种基于启发式合并思想的分治。\n\n通常应用于：\n\n- 统计所有区间 $[i,j]$ 的有关区间内某个代表元（极值、不合法的位置）的贡献；\n\n注意 $[l,r]$ 的代表元 $x$ 需要满足 $\\forall x\\in [l',r']\\in [l,r]$，$x$ 是 $[l',r']$ 的代表元，例如极值就满足这个性质。请注意**同一个区间的代表元可能有多个**。\n\n做题时一般较难想到，需要注意一下可以往这方面想。\n\n## Part 2 算法流程\n\n考虑当前分治区间 $[l,r]$，显然可以：\n\n1. **遍历一次区间**找到代表元 $x$；\n2. 处理 $l'\\in [l,x],r'\\in [x,r]$ 的 $[l',r']$ 的贡献；\n3. 分治处理 $[l,x-1]$ 和 $[x+1,r]$；\n\n但是这样做的时间复杂度最劣是 $O(n^2)$ 的，考虑类似 meet-in-middle 的思想：\n\n1. **从左右两端同时往中间遍历区间 / 预处理**，找到代表元 $x$；\n2. 处理 $l'\\in [l,x],r'\\in [x,r]$ 的 $[l',r']$ 的贡献：\n   - 若 $x-l+1<r-x+1$，即 $[l,x]$ 更短，则枚举 $l'$，快速计算所有 $r'$ 的贡献和 / 对 $[x+1,r]$ 的影响；\n   - 否则枚举 $r'$，快速计算所有 $l'$ 的贡献和 / 对 $[l,x-1]$ 的影响；\n3. 分治处理 $[l,x-1]$ 和 $[x+1,r]$；\n\n这样做的本质可以看做在 dfs 树上启发式合并，时间复杂度 $O(n\\log n)$。\n\n有些时候需要注意分治处理时左右区间的顺序。\n\n## Part 3 例题\n\n### 3.1 [P4755 Beautiful Pair](https://www.luogu.com.cn/problem/P4755)\n\n> 小 D 有个数列 $\\{a\\}$，当一个数对 $(i,j)$（$i \\le j$）满足 $a_i$ 和 $a_j$ 的积不大于 $a_i, a_{i+1}, \\ldots, a_j$ 中的最大值时，小 D 认为这个数对是美丽的。请你求出美丽的数对的数量。\n> \n> $1\\le n\\le{10}^5$，$1\\le a_i\\le{10}^9$。\n\n<details><summary>题解</summary><p>\n\n> 启发式分裂，先离散化，在处理 $[1,n]$ 前把所有 $a_i$ 扔进树状数组里。\n>\n> 处理 $[l,r]$ 时：\n>\n> 1. 若 $l>r$，直接返回；\n> 2. 若 $l=r$，在树状数组中删除 $a_l$ 并返回；\n> 3. 预处理 ST 表快速找到 $[l,r]$ 中最大值的位置 $x$;\n> 4. 处理 $l'\\in [l,x],r'\\in [x,r]$ 的 $[l',r']$ 的贡献：\n>    - 若 $x-l+1<r-x+1$：\n>      1. 在树状数组中删除 $a_{[l,x-1]}$；\n>      2. 遍历 $l'\\in [l,x]$，算出树状数组中 $\\le \\lfloor\\frac{a_x}{a_{l'}}\\rfloor$ 的数的个数 $cnt$，令答案增加 $cnt$；\n>      3. 在树状数组中删除 $a_{x}$；\n>      4. 分治处理 $[x+1,r]$，注意处理后树状数组中的 $a_{[x+1,r]}$ 已经被删除；\n>      5. 在树状数组中加入 $a_{[l,x-1]}$ 并分治处理 $[l,x-1]$；\n>    - 否则枚举 $r'$，处理方法类似，注意要先分治处理 $[l,x-1]$；\n>\n> 时间复杂度 $O(n\\log^2 n)$，代码如下：\n>\n> ```cpp\n> #include <iostream>\n> #include <algorithm>\n> #include <cstdio>\n> \n> using namespace std;\n> \n> const int S=100005,BS=25;\n> \n> int n,a[S];\n> int m,b[S];\n> int mlog[S],mx[S][BS];\n> int c[S];\n> long long ans;\n> \n> inline int que(int l,int r)\n> {\n> \tint k=mlog[r-l+1];\n> \tint x=mx[l][k],y=mx[r-(1<<k)+1][k];\n> \treturn a[x]>a[y]?x:y;\n> }\n> \n> inline void addtr(int pos,int val)\n> {\n> \tfor(int i=pos;i<=m;i+=i&-i) c[i]+=val;\n> }\n> \n> inline int quetr(int pos)\n> {\n> \tint res=0;\n> \tfor(int i=pos;i>=1;i-=i&-i) res+=c[i];\n> \treturn res;\n> }\n> \n> void slove(int l,int r)\n> {\n> \tif(l>r) return;\n> \tif(l==r) return ans+=b[a[l]]==1,addtr(a[l],-1),void();\n> \tint x=que(l,r);\n> \tif(x-l+1<r-x+1)\n> \t{\n> \t\tfor(int i=l;i<=x-1;i++) addtr(a[i],-1);\n> \t\tfor(int i=l;i<=x;i++)\n> \t\t{\n> \t\t\tint p=upper_bound(b+1,b+m+1,b[a[x]]/b[a[i]])-b-1;\n> \t\t\tans+=quetr(p);\n> \t\t}\n> \t\taddtr(a[x],-1);\n> \t\tslove(x+1,r);\n> \t\tfor(int i=l;i<=x-1;i++) addtr(a[i],1);\n> \t\tslove(l,x-1);\n> \t}\n> \telse\n> \t{\n> \t\tfor(int i=x+1;i<=r;i++) addtr(a[i],-1);\n> \t\tfor(int i=x;i<=r;i++)\n> \t\t{\n> \t\t\tint p=upper_bound(b+1,b+m+1,b[a[x]]/b[a[i]])-b-1;\n> \t\t\tans+=quetr(p);\n> \t\t}\n> \t\taddtr(a[x],-1);\n> \t\tslove(l,x-1);\n> \t\tfor(int i=x+1;i<=r;i++) addtr(a[i],1);\n> \t\tslove(x+1,r);\n> \t}\n> }\n> \n> int main()\n> {\n> \tscanf(\"%d\",&n);\n> \tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]),b[++m]=a[i];\n> \tsort(b+1,b+m+1),m=unique(b+1,b+m+1)-b-1;\n> \tfor(int i=1;i<=n;i++) a[i]=lower_bound(b+1,b+m+1,a[i])-b;\n> \tmlog[0]=-1;\n> \tfor(int i=1;i<=n;i++) mlog[i]=mlog[i>>1]+1,mx[i][0]=i;\n> \tfor(int j=1;j<=BS-3;j++)\n> \t{\n> \t\tfor(int i=1;i<=n-(1<<j)+1;i++)\n> \t\t{\n> \t\t\tint x=mx[i][j-1],y=mx[i+(1<<j-1)][j-1];\n> \t\t\tmx[i][j]=a[x]>a[y]?x:y;\n> \t\t}\n> \t}\n> \tfor(int i=1;i<=n;i++) addtr(a[i],1);\n> \tslove(1,n);\n> \tprintf(\"%lld\\n\",ans);\n> \treturn 0;\n> }\n> ```\n</p></details>\n\n### 3.2 [LOJ6198 谢特](https://loj.ac/p/6198)\n\n> 给定一个长 $n$ 的字符串 $S$ 和 $n$ 个整数 $w_i$，定义二元组 $(i,j)$（$i\\not=j$）的权值为 $\\text{LCP}(S_{[i,n]},S_{[j,n]})+(w_i\\oplus w_j)$，其中 $\\oplus$ 为按位异或运算。对于所有 $(i,j)$（$i\\not=j$），求出最大的权值。\n> \n> $1\\le n\\le 10^5$，$0\\le w_i<n$。\n\n<details><summary>题解</summary><p>\n\n> 如果不往启发式分裂这方面想是挺难想到的。\n> \n> $\\text{LCP}(S_{[i,n]},S_{[j,n]})$ 相当于跑 SA 之后的 $\\min\\limits_{k=rk_i}^{rk_j-1}height_k$，即某个区间中的最小值，而最大异或又很好维护，所以直接 SA + trie + 启发式分裂即可。\n>\n> 时间复杂度 $O(n\\log^2 n)$。\n</p></details>\n\n### 3.3 [【2023NOIP模拟赛06】我是 C 题](../【2023NOIP模拟赛06】我是 C 题 做题记录)\n",
			"tags": [{"name":"学习笔记"},{"name":"小技巧"}],
			"title": "启发式分裂 学习笔记",
			"link": "https://exber.qzz.io/post/%E5%90%AF%E5%8F%91%E5%BC%8F%E5%88%86%E8%A3%82%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-07-17 20:43:39"
		},
	
		{
			"abstract": "> 给定一棵 $n$ 个点的无根树，每条边有一个未知的正整数边权。\n> \n> 对于所有的 $1 \\le i < n$，给出点 $i$ 到点 $i + 1$ 的距离 $d_i$，请还原出任意一组合法的边权，可能无解。\n> \n> $2\\le n\\le 10^5$，$1\\le d_i\\le 10^{12}$。\n",
			"content": "> 给定一棵 $n$ 个点的无根树，每条边有一个未知的正整数边权。\n> \n> 对于所有的 $1 \\le i < n$，给出点 $i$ 到点 $i + 1$ 的距离 $d_i$，请还原出任意一组合法的边权，可能无解。\n> \n> $2\\le n\\le 10^5$，$1\\le d_i\\le 10^{12}$。\n\n逐位确定。\n\n令根为点 $1$，设 $dep_{u}$ 为 $u$ 到根的距离，那么有 $d_i=dep_{i}+dep_{i+1}-2dep_{lca}$，并且我们已知 $dep_1=0$。\n\n注意到 $2dep_{lca}\\equiv 0\\pmod 2$，所以可以知道 $dep_i\\text{ mod }2$；然后注意到 $2dep_{lca}\\text{ mod }4=2(dep_{lca}\\text{ mod }2)$，所以接下来就可以知道 $dep_i\\text{ mod }4$ ……\n\n这启发我们从小到大枚举 $k$，依次确定 $dep_{i}\\text{ mod } 2^k$。\n\n由于 $d_i\\le 10^{12}$，所以 $dep_i\\text{ mod }2^{60}=dep_i$，再做一次 dfs 即可知道边权。\n\n注意若求出的边权 $\\le 0$ 或 $2dep_i>2^{60}$ 则无解。\n\n时间复杂度 $O(n\\log V)$，代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nconst int S=100005,BS=25,B=60;\n\nint n;\nvector<pair<int,int>> g[S];\nlong long a[S];\nint dep[S],fat[S][BS];\nint b[S];\nlong long tmp[S],res[S],ans[S];\n\nvoid dfs(int u,int fa)\n{\n\tdep[u]=dep[fa]+1;\n\tfat[u][0]=fa;\n\tfor(int i=1;i<=BS-3;i++) fat[u][i]=fat[fat[u][i-1]][i-1];\n\tfor(auto v:g[u]) if(v.first!=fa) dfs(v.first,u);\n}\n\ninline int getlca(int x,int y)\n{\n\tif(dep[x]<dep[y]) swap(x,y);\n\tfor(int i=BS-3;i>=0;i--) if(dep[fat[x][i]]>=dep[y]) x=fat[x][i];\n\tif(x==y) return x;\n\tfor(int i=BS-3;i>=0;i--) if(fat[x][i]!=fat[y][i]) x=fat[x][i],y=fat[y][i];\n\treturn fat[x][0];\n}\n\nvoid getans(int u,int fa,int faid)\n{\n\tif(faid!=0) ans[faid]=res[u]-res[fa];\n\tfor(auto v:g[u]) if(v.first!=fa) getans(v.first,u,v.second);\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tg[x].push_back(make_pair(y,i)),g[y].push_back(make_pair(x,i));\n\t}\n\tfor(int i=1;i<=n-1;i++) scanf(\"%lld\",&a[i]);\n\tdfs(1,0);\n\tfor(int i=1;i<=n-1;i++) b[i]=getlca(i,i+1);\n\tfor(int i=1;i<=B;i++)\n\t{\n\t\tlong long pre=1ll<<i;\n\t\tfor(int j=1;j<=n-1;j++) tmp[j+1]=((a[j]+2*res[b[j]]%pre-tmp[j])%pre+pre)%pre;\n\t\tfor(int j=1;j<=n;j++) res[j]=tmp[j];\n\t}\n\tfor(int j=2;j<=n;j++) if(res[j]==0||2*res[j]>(1ll<<B)) return puts(\"-1\"),0;\n\tgetans(1,0,0);\n\tfor(int i=1;i<=n-1;i++) if(ans[i]<=0) return puts(\"-1\"),0;\n\tfor(int i=1;i<=n-1;i++) printf(\"%lld\\n\",ans[i]);\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"构造"},{"name":"数学"},{"name":"结论"}],
			"title": "CF1844G Tree Weights 做题记录",
			"link": "https://exber.qzz.io/post/CF1844G%20Tree%20Weights%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-07-17 15:19:55"
		},
	
		{
			"abstract": "> 对于排列 $\\{p_i\\}$，定义一次操作为按顺序执行以下步骤：\n> 1. 令 $p_i$ 为排列中最大的满足 $p_i\\neq i$ 的数；\n> 2. 令 $p_j$ 为排列中最小的满足 $j>i$ 的数；\n> 3. 交换 $p_i$ 和 $p_j$；\n> 定义 $f(p)$ 为将 $p$ 升序排序所需的操作次数。\n>\n> 给定一个排列 $p$，会进行 $q$ 次交换 $p_{x_i},p_{y_i}$ 的操作，每次操作后输出 $f(p)$，交换操作是永久的。\n> \n> $2\\le n\\le 5\\times 10^5$，$1\\le q\\le 5\\times 10^4$。\n",
			"content": "> 对于排列 $\\{p_i\\}$，定义一次操作为按顺序执行以下步骤：\n> 1. 令 $p_i$ 为排列中最大的满足 $p_i\\neq i$ 的数；\n> 2. 令 $p_j$ 为排列中最小的满足 $j>i$ 的数；\n> 3. 交换 $p_i$ 和 $p_j$；\n> 定义 $f(p)$ 为将 $p$ 升序排序所需的操作次数。\n>\n> 给定一个排列 $p$，会进行 $q$ 次交换 $p_{x_i},p_{y_i}$ 的操作，每次操作后输出 $f(p)$，交换操作是永久的。\n> \n> $2\\le n\\le 5\\times 10^5$，$1\\le q\\le 5\\times 10^4$。\n\n\n人类智慧题。\n\n考虑排序过程中一次操作对逆序对个数 $cnt$ 做出的改变，由于 $p_{[i+1,j-1]}$ 均在 $[p_i+1,p_j-1]$ 内，所以一次操作会让逆序对个数减少 $2(j-i)-1$。\n\n接下来就很人类智慧。\n\n首先发现 $p_i$ 这个数在排序过程中只会向它的目的地 $p_i$ 单向移动。\n\n<details><summary>证明</summary><p>\n\n> 只需要考虑移动太多导致要反向移动的情况。\n> \n> 首先一次操作中 $p_j$ 显然不会移动太多，因为有 $p_j\\le i$。\n> <details><summary>证明</summary><p>\n>\n> > 若 $\\forall j>i,p_j>i$，则 $p_{[i+1,n]}$ 一定构成子排列，那么一定有 $p_i<i$。\n> >\n> > 此时找到满足 $p_k=i$ 的 $k$，则一定有 $p_k\\not=k$ 且 $p_k>p_i$，与 $i$ 的定义矛盾。\n> </p></details>\n>\n> 然后一定有 $j\\le p_i$，因为把 $p$ 的满足 $p_i=i$ 的极长后缀删掉后 $p_i$ 一定是最大值。\n</p></details>\n\n那么设 $sum=\\sum\\limits_{k=1}^n\\max(p_k-k,0)$，考虑排序过程中一次操作对这个东西的影响：\n\n- 一定有 $p_i>i$，所以 $\\max(p_i-i,0)=p_i-i$；\n- 一定有 $p_j\\le i<j$，所以 $\\max(p_j-j,0)=0$；\n- 一定有 $p_j\\le i$，所以 $\\max(p_j-i,0)=0$；\n- 一定有 $p_i\\ge j$，所以 $\\max(p_i-j,0)=p_i-j$；\n\n那么一次操作让 $sum$ 减少了：\n\n$$\n\\begin{aligned}\n\\Delta sum&=(\\max(p_i-i,0)+\\max(p_j-j,0))-(\\max(p_j-i,0)+\\max(p_i-j,0))\\\\\n&=(p_i-i+0)-(0+p_i-j)\\\\\n&=j-i\n\\end{aligned}\n$$\n\n发现 $\\Delta cnt=2(j-i)-1$，所以 $2\\Delta sum-\\Delta cnt=1$。\n\n所以 $f(p)=2sum-cnt$。\n\n$sum$ 是很好维护的，$cnt$ 的维护相当于三维偏序，可以考虑 cdq 分治。\n\n时间复杂度 $O(n\\log ^2 n)$，代码如下：\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nstruct node\n{\n\tint tme,pos,val,w;\n};\n\nconst int S=500005;\n\nint n,q,a[S];\nint tot;\nnode que[S*2];\nint c[S];\nlong long res[S],ans[S];\n\ninline void addt(int p,int val)\n{\n\tfor(int i=p;i<=n;i+=i&-i) c[i]+=val;\n}\n\ninline int quet(int p)\n{\n\tint res=0;\n\tfor(int i=p;i>=1;i-=i&-i) res+=c[i];\n\treturn res;\n}\n\ninline void clrt(int p)\n{\n\tfor(int i=p;i<=n;i+=i&-i) c[i]=0;\n}\n\nvoid cdq(int l,int r)\n{\n\tif(l>=r) return;\n\tint mid=l+r>>1;\n\tcdq(l,mid);\n\tcdq(mid+1,r);\n\tauto cmp=[&](node x,node y){return x.pos<y.pos;};\n\tsort(que+l,que+mid+1,cmp),sort(que+mid+1,que+r+1,cmp);\n\tint p=l;\n\tfor(int i=mid+1;i<=r;i++)\n\t{\n\t\twhile(p<=mid&&que[p].pos<que[i].pos) addt(n-que[p].val+1,que[p].w),p++;\n\t\tans[que[i].tme]+=quet(n-que[i].val)*que[i].w;\n\t}\n\tfor(int i=l;i<p;i++) clrt(n-que[i].val+1);\n\tp=mid;\n\tfor(int i=r;i>=mid+1;i--)\n\t{\n\t\twhile(p>=l&&que[p].pos>que[i].pos) addt(que[p].val,que[p].w),p--;\n\t\tans[que[i].tme]+=quet(que[i].val-1)*que[i].w;\n\t}\n\tfor(int i=p+1;i<=mid;i++) clrt(que[i].val);\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&q);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tque[++tot]=(node){0,i,a[i],true};\n\t\tres[0]+=max(a[i]-i,0);\n\t}\n\tfor(int i=1;i<=q;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tque[++tot]=(node){i*2-1,x,a[x],-1};\n\t\tque[++tot]=(node){i*2-1,x,a[y],1};\n\t\tque[++tot]=(node){i*2,y,a[y],-1};\n\t\tque[++tot]=(node){i*2,y,a[x],1};\n\t\tres[i]=res[i-1];\n\t\tres[i]-=max(a[x]-x,0);\n\t\tres[i]-=max(a[y]-y,0);\n\t\tswap(a[x],a[y]);\n\t\tres[i]+=max(a[x]-x,0);\n\t\tres[i]+=max(a[y]-y,0);\n\t}\n\tcdq(1,tot);\n\tfor(int i=1;i<=q*2;i++) ans[i]+=ans[i-1];\n\tfor(int i=1;i<=q;i++) printf(\"%lld\\n\",2*res[i]-ans[i*2]);\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"结论"}],
			"title": "CF1830E Bully Sort 做题记录",
			"link": "https://exber.qzz.io/post/CF1830E%20Bully%20Sort%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-07-17 07:46:10"
		},
	
		{
			"abstract": "> 有 $n$ 个台灯，初始时都是暗的，每次等概率随机一个暗台灯将其点亮，若点亮后**存在**一个长度为 $k$ 的连续段有**大于一个**台灯被点亮则立刻停止，求期望点亮多少台灯。对 $10^9+7$ 取模。\n> \n> $2\\le k\\le n\\le 10^5$。\n",
			"content": "> 有 $n$ 个台灯，初始时都是暗的，每次等概率随机一个暗台灯将其点亮，若点亮后**存在**一个长度为 $k$ 的连续段有**大于一个**台灯被点亮则立刻停止，求期望点亮多少台灯。对 $10^9+7$ 取模。\n> \n> $2\\le k\\le n\\le 10^5$。\n\n\n考虑期望的本质，设 $p_i$ 为恰好在点亮第 $i$ 个台灯后停止，则答案为：\n$$\n\\sum\\limits_{i=1}^{n} i\\cdot p_i\n$$\n发现若设 $s_i=\\sum\\limits_{j=i}^{n}p_j$ 即 $p$ 的后缀和，那么答案等于：\n$$\n\\sum\\limits_{i=1}^{n} s_i\n$$\n发现 $s_i$ 可以看作是点亮了前 $i-1$ 个台灯仍未停止的概率，所以 $s_i=\\frac{\\binom{n-(k-1)(i-2)}{i-1}(i-1)!}{\\binom{n}{i-1}(i-1)!}=\\frac{\\binom{n-(k-1)(i-2)}{i-1}}{\\binom{n}{i-1}}$。\n\n其中分子的计算方式是在确定完亮的台灯的位置后在相邻两个亮的台灯之间插入 $k-1$ 个暗的台灯。\n\n那么直接计算即可，不过 $s_1=1$ 要特判。时间复杂度 $O(n)$，代码如下：\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=100005,p=1000000007;\n\nint n,k;\nint fra[S],inv[S];\n\ninline int qpow(int x,int y)\n{\n\tint res=1;\n\tfor(;y>0;y>>=1,x=1ll*x*x%p) res=y&1?1ll*res*x%p:res;\n\treturn res;\n}\n\ninline int C(long long n,int m)\n{\n\tif(n<0||m<0||n<m) return 0;\n\treturn 1ll*fra[n]*inv[n-m]%p*inv[m]%p;\n}\n\nint main()\n{\n\tfra[0]=1;\n\tfor(int i=1;i<=S-3;i++) fra[i]=1ll*fra[i-1]*i%p;\n\tinv[S-3]=qpow(fra[S-3],p-2);\n\tfor(int i=S-3;i>=1;i--) inv[i-1]=1ll*inv[i]*i%p;\n\tint T;\n\tscanf(\"%d\",&T);\n\twhile(T-->0)\n\t{\n\t\tscanf(\"%d%d\",&n,&k);\n\t\tint ans=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tint si=i==1?1:1ll*C(n-1ll*(k-1)*(i-2),i-1)*qpow(C(n,i-1),p-2)%p;\n\t\t\tans=(ans+si)%p;\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"概率、期望"},{"name":"数学"},{"name":"组合计数"}],
			"title": "CF1523E Crypto Lights 做题记录",
			"link": "https://exber.qzz.io/post/CF1523E%20Crypto%20Lights%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-07-16 11:46:09"
		},
	
		{
			"abstract": "> 对于一个 01 序列 $b$，定义 $f(b)=\\frac{\\sum\\limits [b_i=1]}{|b|}$，即 $b$ 中 $1$ 的个数除以它的长度。\n>\n> 现给定一个长度为 $n$ 的序列 $a$ 和一个正整数 $m$，请你找到 $a$ 的若干不相交子串使得这些它们拼起来后得到的 01 串 $p$ 满足 $|p|=m$ 且 $f(p)=f(a)$。输出方案。\n>\n> $1\\le m\\le n\\le 2\\times 10^5$。\n",
			"content": "> 对于一个 01 序列 $b$，定义 $f(b)=\\frac{\\sum\\limits [b_i=1]}{|b|}$，即 $b$ 中 $1$ 的个数除以它的长度。\n>\n> 现给定一个长度为 $n$ 的序列 $a$ 和一个正整数 $m$，请你找到 $a$ 的若干不相交子串使得这些它们拼起来后得到的 01 串 $p$ 满足 $|p|=m$ 且 $f(p)=f(a)$。输出方案。\n>\n> $1\\le m\\le n\\le 2\\times 10^5$。\n\n\n设 $c1=\\sum[a_i=1],x=\\frac{c1\\cdot m}{n}$ 即 $p$ 中需要的 $1$ 的个数。\n\n首先显然若 $\\frac{c1\\cdot m}{n}$ 不是整数即 $m$ 不是 $\\frac{n}{\\gcd(n,c1)}$ 的倍数则无解，否则一定有解。\n\n对于这种题，一般猜想答案 $\\le 2$。那么猜想最多只需要两段，考虑证明。\n\n考虑最多两段不交的区间可能是什么，~~不难~~想到它有可能是一个环上的一段区间。那么考虑把 $a$ 放到环上，即令 $a_{i+n}=a_i$。设 $c_i=\\sum\\limits_{j=i}^{i+m-1}[a_j=1]$，考察 $c$ 的性质：\n\n1. $|c_{i}-c_{i+1}|\\le 1$：显然，因为滑动窗口不可能同时加入/删除两个 $1$；\n\n2. $\\forall y\\in \\mathbb{N},\\min\\{c_i\\}\\le y\\le \\max\\{c_i\\},\\exist c_k=y$：通过第一条性质不难得出，因为无法“跳过”某个 $y$；\n\n3. $\\min\\{c_i\\}\\le x\\le \\max\\{c_i\\}$：\n\n   考虑反证，假设 $\\min\\{c_i\\}>x$，则 $\\sum\\limits_{i=1}^n c_i>c1\\cdot m$。注意到 $\\sum\\limits_{i=1}^n c_i=c1\\cdot m$ 因为每个 $1$ 都被计算了 $m$ 次。所以有 $c1\\cdot m>c1\\cdot m$，矛盾。\n\n   $\\max\\{c_i\\}\\ge x$ 的证明同理。\n\n根据第二条和第三条性质可以得出 $\\exist c_k=x$，那么找到这个 $k$ 即可找到环上符合条件的区间，即序列上最多两个不交的区间。\n\n所以最多只需要两段。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=200005;\n\nint n,m;\nchar a[S];\nint c1,c[S];\n\ninline int gcd(int x,int y)\n{\n\tint t=x%y;\n\twhile(t!=0) x=y,y=t,t=x%y;\n\treturn y;\n}\n\ninline void slove()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",a+1);\n\tfor(int i=1;i<=n;i++) c[i]=c1=0;\n\tfor(int i=1;i<=n;i++) c1+=a[i]=='1';\n\tif(m%(n/gcd(n,c1))!=0) return puts(\"-1\"),void();\n\tint x=1ll*c1*m/n;\n\tfor(int i=1;i<=m;i++) c[1]+=a[i]=='1';\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tc[i]=c[i-1];\n\t\tc[i]-=a[i-1]=='1';\n\t\tc[i]+=a[(i+m-1-1)%n+1]=='1';\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(c[i]==x)\n\t\t{\n\t\t\tif(i+m-1<=n) printf(\"1\\n%d %d\\n\",i,i+m-1);\n\t\t\telse printf(\"2\\n%d %d\\n%d %d\\n\",i,n,1,i+m-1-n);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint T;\n\tscanf(\"%d\",&T);\n\twhile(T-->0) slove();\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"构造"},{"name":"结论"}],
			"title": "CF1658F Juju and Binary String 做题记录",
			"link": "https://exber.qzz.io/post/CF1658F%20Juju%20and%20Binary%20String%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-07-14 20:24:27"
		},
	
		{
			"abstract": "> [题目链接](http://poj.org/problem?id=3834)\n>\n> 给定一张 $n$ 个点 $m$ 条边的无向图，一开始所有边都没有被染色。Alice 和 Bob 在这张图上轮流操作直到所有边都被染色，Alice 先手。他们的操作为：\n>\n> - Alice：选择一条没被染色的边，染上红色；\n> - Bob：选择一条没被染色的边，染上蓝色；\n>\n> 若最终被染上蓝色的边连通了整张图，那么 Bob 赢，否则 Alice 赢。\n>\n> 若两个人都足够聪明，求谁会赢。\n>\n> $1\\le n\\le 10$，$1\\le m\\le \\min(\\frac{n(n-1)}{2},30)$。\n",
			"content": "> [题目链接](http://poj.org/problem?id=3834)\n>\n> 给定一张 $n$ 个点 $m$ 条边的无向图，一开始所有边都没有被染色。Alice 和 Bob 在这张图上轮流操作直到所有边都被染色，Alice 先手。他们的操作为：\n>\n> - Alice：选择一条没被染色的边，染上红色；\n> - Bob：选择一条没被染色的边，染上蓝色；\n>\n> 若最终被染上蓝色的边连通了整张图，那么 Bob 赢，否则 Alice 赢。\n>\n> 若两个人都足够聪明，求谁会赢。\n>\n> $1\\le n\\le 10$，$1\\le m\\le \\min(\\frac{n(n-1)}{2},30)$。\n\n\n考虑 Jerry Wen 定理，找必要/充分条件。\n\n对于 Bob 必胜，有一个不那么显然的必要条件：\n\n- 能在原图中找到两棵边集不交的生成树；\n\n考虑证明它是充要条件：\n\n- 必要性：\n\n  设两棵生成树分别为 $A$ 与 $B$，若某一步 Alice 选择了 $A$ 中的一条边，把图分裂成了两个连通块，则 Bob 一定可以选择 $B$ 中的一条跨越这两个连通块的边；Alice 选择 $B$ 中的边也是同理。\n\n- 充分性：\n\n  若没有生成树（图不连通），显然 Bob 必败。\n\n  若不存在边不交的两棵生成树但图联通，则考虑某次 Alice 操作时 Bob 的必胜条件：\n  \n  > 图去掉所有**红**边，把所有**蓝**边复制一次后，能找到两棵边不交的生成树。\n  \n  显然刚开始并不满足这个条件，若 Bob 存在一种策咯使得他某次操作后满足了这个条件（必胜策略），则由于 Alice 是先手，所以她一定能把 Bob 的策略照搬过来，使得她某一次操作后满足：\n  \n  > 图去掉所有**蓝**边，把所有**红**边复制一次后，能找到两棵边不交的生成树。\n  \n  也就是说，角色互换了。所以若 Bob 存在必胜策略，则 Alice 存在可以让红边构成一棵生成树的策略。由于不存在边相交的两颗生成树，所以 Bob 必败，与 Bob 存在必胜策略矛盾。\n  \n  所以 Bob 不存在必胜策略。\n  \n  Q.E.D.\n\n观察到 $\\binom{30}{9}=14307150$ 比较小，所以可以直接爆搜，但是要注意剪枝。代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <set>\n\nusing namespace std;\n\nconst int S=15;\n\nstruct node\n{\n\tint x,y;\n}b[S*S];\n\nint n,m;\nint fa[S];\nbool vis[S*S];\nset<int> st;\n\nint fnd(int x){return fa[x]==x?x:fa[x]=fnd(fa[x]);}\n\ninline bool chk(int sta)\n{\n\tfor(int i=1;i<=m;i++) vis[i]=false;\n\tfor(int i=1;i<=m;i++) if(sta>>i-1&1) vis[i]=true;\n\tfor(int i=1;i<=n;i++) fa[i]=i;\n\tfor(int i=1;i<=m;i++) if(!vis[i]) fa[fnd(b[i].x)]=fnd(b[i].y);\n\tint r1=fnd(1);\n\tfor(int i=1;i<=n;i++) if(fnd(i)!=r1) return false;\n\treturn true;\n}\n\nbool dfs(int s1,int s2)\n{\n\tif(!chk(s1)) return false;\n\tif(s2==(1<<n)-1) return true;\n\tif(st.count(s1)) return false;\n\tst.insert(s1);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif(s1>>i-1&1) continue;\n\t\tif((s2>>b[i].x-1&1)+(s2>>b[i].y-1&1)!=1) continue;\n\t\tif(dfs(s1|(1<<i-1),s2|(1<<b[i].x-1)|(1<<b[i].y-1))) return true;\n\t}\n\treturn false;\n}\n\ninline void slove()\n{\n\tst.clear();\n\tputs(dfs(0,1)?\"YES\":\"NO\");\n}\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==-1&&m==-1) break;\n\t\tfor(int i=1;i<=m;i++) scanf(\"%d%d\",&b[i].x,&b[i].y);\n\t\tfor(int i=1;i<=m;i++) b[i].x++,b[i].y++;\n\t\tslove();\n\t}\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"图论"},{"name":"结论"},{"name":"博弈论"}],
			"title": "POJ3834 Graph Game 做题记录",
			"link": "https://exber.qzz.io/post/POJ3834%20Graph%20Game%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-07-14 18:49:14"
		},
	
		{
			"abstract": "> 给定一个 $n$ 个点 $m$ 条边的图 $G$，有一些边有向，剩下的边无向。你要给每条无向边定向使得定向后的有向图 $H$ 强连通。输出方案。\n>\n> $1\\le n,m\\le 5000$。\n",
			"content": "> 给定一个 $n$ 个点 $m$ 条边的图 $G$，有一些边有向，剩下的边无向。你要给每条无向边定向使得定向后的有向图 $H$ 强连通。输出方案。\n>\n> $1\\le n,m\\le 5000$。\n\nJerry Wen 定理，考虑找有解的若干必要/充分条件，再证明这些条件的并是充要的：\n\n- 若把所有有向边看作无向边，则 $G$ 一定是一个点双；\n- 若把所有无向边看作双向边（两条有向边：$u\\to v$ 和 $v\\to u$），则 $G$ 一定强连通；\n\n这些条件的并显然是必要的，考虑证明它们的并是充要的：\n\n- 必要性显然；\n\n- 充分性：\n\n  考虑反证。若某个时刻满足这两个条件，且对于某条无向边 $(u,v)$，无论如何定向都不能同时满足这两个条件，则：\n\n  * 由于第一个条件定向后一定仍满足，所以一定是不满足第二个条件；\n\n  * 由于定向前满足第二个条件，定向后不满足，所以 $u\\to v$ 与 $v\\to u$ 一定都要被经过，那么图一定是长这样的：\n\n    ![](../post-images/1689220303315.png)\n\n    但是这样显然可以把这两个环合并得到一个大环，不需要走 $(u,v)$ 这条边。\n\n    所以不存在这种情况。\n\n    Q.E.D.\n\n由于题目保证了一定有解，所以第一个条件一定满足，只用判断第二个条件是否满足。\n\n那么直接枚举每条边，$O(n+m)$ 判断哪种定向合法即可，时间复杂度 $O(m(n+m))$。注意判合法只要判断定向后 $u$ 和 $v$ 能否互相到达。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nconst int S=5005;\n\nstruct node\n{\n\tint x,y,t;\n}ed[S];\n\nint n,m;\nvector<int> g[S];\nbool vis[S];\nint ans[S];\n\nbool chk(int u,int v,int ban)\n{\n\tvis[u]=true;\n\tif(u==v) return true;\n\tfor(int i:g[u])\n\t{\n\t\tif(i==ban) continue;\n\t\tint too=-1;\n\t\tif(ed[i].x==u)\n\t\t{\n\t\t\tif(ed[i].t==0||ed[i].t==1) too=ed[i].y;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(ed[i].t==0||ed[i].t==2) too=ed[i].x;\n\t\t}\n\t\tif(v!=-1&&!vis[too]&&chk(too,v,ban)) return true;\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++) scanf(\"%d%d%d\",&ed[i].x,&ed[i].y,&ed[i].t);\n\tfor(int i=1;i<=m;i++) g[ed[i].x].push_back(i),g[ed[i].y].push_back(i);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif(ed[i].t==0)\n\t\t{\n\t\t\tfor(int j=1;j<=n;j++) vis[j]=false;\n\t\t\tif(chk(ed[i].y,ed[i].x,i)) ed[i].t=1,ans[i]=0;\n\t\t\telse ed[i].t=2,ans[i]=1;\n\t\t}\n\t\telse ans[i]=0;\n\t}\n\tfor(int i=1;i<=m;i++) printf(\"%d\\n\",ans[i]);\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"图论"},{"name":"结论"}],
			"title": "UOJ134 App 管理器 做题记录",
			"link": "https://exber.qzz.io/post/UOJ134%20App%20%E7%AE%A1%E7%90%86%E5%99%A8%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-07-13 14:54:20"
		},
	
		{
			"abstract": "> 给定一个长 $n$ 的正整数序列 $a_i$，Alice 会把整个序列任意排列，然后 Bob 可以进行任意次操作，每次选择两个相邻的互质的数交换位置。\n>\n> Alice 希望最终序列的字典序尽量小，而 Bob 希望字典序尽量大。\n>\n> 若 Alice 和 Bob 都足够聪明，求最终序列。\n",
			"content": "> 给定一个长 $n$ 的正整数序列 $a_i$，Alice 会把整个序列任意排列，然后 Bob 可以进行任意次操作，每次选择两个相邻的互质的数交换位置。\n>\n> Alice 希望最终序列的字典序尽量小，而 Bob 希望字典序尽量大。\n>\n> 若 Alice 和 Bob 都足够聪明，求最终序列。\n\n\n考虑建立一个 $n$ 个点的无向图 $G$， $\\forall 1\\le i<j\\le n,\\gcd(a_i,a_j)\\not=1$ 都有 $(i,j)\\in G$。\n\n考虑 Alice 的操作对 Bob 的影响，设他任意排列后的序列为 $b$。那么 $\\forall 1\\le i<j\\le n,\\gcd(b_i,b_j)\\not=1$，Bob 都无法把 $b_j$ 移到 $b_i$ 前面。所以 Alice 相当于是给 $G$ 中每条边都定向，使得得到的有向图 $H$ 是个 DAG，Bob 则会找到 $H$ 中字典序最大的拓扑序。\n\n那么问题转化为给 $G$ 中的边定向使得得到的有向图 $H$ 是 DAG 且拓扑序字典序最大值最小。考虑 $H$ 固定时 Bob 如何找到字典序最大的拓扑序，显然只要用大根堆拓扑就行了。也就是说，若当前入度为 $0$ 的点集为 $S$，Bob 会选择 $S$ 中最大的元素进行拓展。\n\n考虑如何定向，显然要让 $S$ 中最小的元素 $x$ 控制（即指向）尽可能多的其它元素，这样这些元素都会被放到 $x$ 的后面。那么按 $a_i$ 从小到大对每一个 $i$ 跑 dfs，dfs $u$ 时对于所有与 $u$ 有连边的点 $v$ 再按照 $a_v$ 从小到大 dfs 即可：\n\n```cpp\nset<int> g[S];\n\nvoid dfs(int x)\n{\n\tvis[x]=true;\n\tfor(int v:g[x]) if(!vis[v]) g2[x].push_back(v),ind[v]++,dfs(v);\n}\n```\n\n这样做的正确性比较显然，考虑 $u$ 在拓扑时删掉后剩下的若干互不连通的子图，子图之间在拓扑序中的顺序显然 Alice 无法控制，而子图内部一定是让目前能拓展的字典序最小的点（$v$）控制尽可能多的其它点。\n\n时间复杂度 $O(n^2\\log V)$（$\\log V$ 来自于计算 $\\gcd$），代码如下：\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <queue>\n\nusing namespace std;\n\nconst int S=2005;\n\nint n,a[S];\nset<int> g[S];\nbool vis[S];\nvector<int> g2[S];\nint ind[S];\nint tt,ans[S];\n\ninline int gcd(int x,int y)\n{\n\tint t=x%y;\n\twhile(t!=0) x=y,y=t,t=x%y;\n\treturn y;\n}\n\nvoid dfs(int x)\n{\n\tvis[x]=true;\n\tfor(int v:g[x]) if(!vis[v]) g2[x].push_back(v),ind[v]++,dfs(v);\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tif(i==j) continue;\n\t\t\tif(gcd(a[i],a[j])>1) g[i].insert(j);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++) if(!vis[i]) dfs(i);\n\tpriority_queue<pair<int,int>> q;\n\tfor(int i=1;i<=n;i++) if(ind[i]==0) q.push(make_pair(a[i],i));\n\twhile(!q.empty())\n\t{\n\t\tint u=q.top().second;\n\t\tq.pop();\n\t\tans[++tt]=u;\n\t\tfor(int v:g2[u]) if(--ind[v]==0) q.push(make_pair(a[v],v));\n\t}\n\tfor(int i=1;i<=n;i++) printf(\"%d \",a[ans[i]]);\n\tprintf(\"\\n\");\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"图论"},{"name":"构造"}],
			"title": "AGC010E Rearranging 做题记录",
			"link": "https://exber.qzz.io/post/AGC010E%20Rearranging%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-07-12 19:56:10"
		},
	
		{
			"abstract": "",
			"content": "## Part 0 声明\n\n本文**若无特殊说明，所有集合皆为有限集合**。\n\n## Part 1 群定义\n\n### 1.1 群\n\n称一个**集合** $G$ 和某种**二元运算** $\\cdot$ 构成群当且仅当：\n\n- **存在单位元**：$\\exists e\\in G$ 满足 $\\forall g\\in G$ 有 $e\\cdot g=g\\cdot e=g$；\n- **满足结合律**：$\\forall g_1,g_2,g_3\\in G$，有 $g_1\\cdot(g_2\\cdot g_3)=(g_1\\cdot g_2)\\cdot g_3$；\n- **封闭**：$\\forall g_1,g_2\\in G$，满足 $g_1\\cdot g_2\\in G$；\n- **存在逆元**：$\\forall g\\in G$，有 $g^{-1}\\in G$ 满足 $g\\cdot g^{-1}=g^{-1}\\cdot g=e$；\n\n注意 $G$ **不一定满足交换律，满足交换律的群叫交换群或阿贝尔群**。\n\n集合 $G$ 和运算 $\\cdot$ 构成的群记为 $(G,\\cdot)$，本文为了方便省略了运算 $\\cdot$，统一**记作群 $G$**。\n\n### 1.2 子群\n\n对于一个群 $G$，称群 $H$ 为 $G$ 的子群当且仅当 $H\\subseteq G$。\n\n例如模 $3$ 意义下的乘法群 $\\{1\\}$ 是模 $3$ 意义下的乘法群 $\\{1,2\\}$ 的子群。\n\n### 1.3 左陪集和右陪集\n\n对于一个群 $G$、它的子群 $H$ 和一个 $g\\in G$：\n\n- 定义 $g\\cdot H=\\{g\\cdot h|h\\in H\\}$ 为 $H$ 的左陪集；\n\n- 定义 $H\\cdot g=\\{h\\cdot g|h\\in H\\}$ 为 $H$ 的右陪集；\n\n例如 $\\{2\\}$ 是模 $3$ 意义下的乘法群 $\\{1,2\\}$ 的子群 $\\{1\\}$ 的左陪集，也是它的右陪集。\n\n## Part 2 群性质\n\n### 2.1 群皆可逆矩阵群\n\n考虑一个大小为 $n$ 的群 $G$，$\\forall g\\in G$，显然可以把 $g$ 写成一个 $n\\times n$ 的 01 矩阵且保证写出的矩阵集仍是一个群。\n\n所以**任意群都和全体可逆矩阵群的一个子群同构**。\n\n### 2.2 陪集的性质和 Lagrange 定理\n\n#### 2.2.1 陪集的性质\n\n考虑群 $G$ 的任意子群 $H$ 和任意 $a,b\\in G$：（这里考虑右陪集，左陪集同理）\n\n1. $H\\cdot a\\in G$：由于 $G$ 是群所以封闭；\n\n2. $a\\in H\\cdot a$：因为 $e\\in H$；\n\n3. $a\\in H\\Leftrightarrow H\\cdot a=H$：由于 $H$ 是群所以封闭；\n\n4. $b\\in H\\cdot a\\Leftrightarrow H\\cdot a=H\\cdot b$；\n\n   <details><summary>证明</summary><p>\n\n   > 右到左显然，左到右：\n   >\n   > $\\exist h\\in H,h\\cdot a=b$，所以 $H\\cdot b=H\\cdot(h\\cdot a)=(H\\cdot h)\\cdot a=H\\cdot a$。（根据 2）\n   >\n   > Q.E.D.\n\n   </p></details>\n\n5. $H\\cdot a$ 与 $H\\cdot b$ 要么相等要么不交；\n\n   <details><summary>证明</summary><p>\n\n   > 若有交则 $\\exist c\\in H\\cdot a,c\\in H\\cdot b$，根据 3，$H\\cdot a=H\\cdot c=H\\cdot b$。\n   >\n   > Q.E.D.\n\n   </p></details>\n\n6. $|H\\cdot a|=|H|$；\n\n   <details><summary>证明</summary><p>\n\n   > 若 $|H\\cdot a|\\not=|H|$，则一定有 $|H\\cdot a|<|H|$，则有 $h_1,h_2\\in H$ 满足 $h_1\\not=h_2$ 且 $h_1\\cdot a=h_2\\cdot a$。\n   >\n   > 由于 $a\\in G$，所以 $a^{-1}\\in G$，所以 $h_1\\cdot a\\cdot a^{-1}=h_2\\cdot a\\cdot a^{-1}$，$h_1=h_2$，矛盾。\n   >\n   > 所以 $|H\\cdot a|=|H|$，Q.E.D.\n\n   </p></details>\n\n#### 2.2.2 Lagrange 定理\n\n> 对于群 $G$ 的任意子群 $S$，均有 $|G|$ 是 $|S|$ 的因子。\n\n证明是显然的，根据 2.2.1 中的 1、5、6 立得。\n\n**推论：$\\forall \\gcd(x,p)=1,x^{\\varphi(p)}\\equiv 1\\pmod p$**\n\n> 考虑模 $m$ 的乘法群 $S_p=\\{x|1\\le x<p,\\gcd(x,p)=1\\}$，显然有 $|S_p|=\\varphi(p)$。\n>\n> 对于 $S_p$ 的幂子群 $H_x=\\{x^y\\text{ mod } p|y\\in \\mathbb{N}\\}(x\\in S_p)$，均有 $|H_x|$ 是 $|S_p|$ 即 $\\varphi(p)$ 的因数。\n>\n> 因为 $x^{|H_x|}\\equiv 1\\pmod p$，所以 $x^{\\varphi(p)}\\equiv (x^{|H_x|})^{\\frac{\\varphi(p)}{|H_x|}}\\equiv 1\\pmod p$。\n\n## Part 3 群作用\n\n考虑一个**置换群** $G$ 和一个集合 $X$，满足 $\\forall x\\in X,g\\in G$ 都有 $x\\cdot g\\in X$。\n\n这时称 $G$ 是 $X$ 上的作用，例如 $n$ 阶置换群就是 $n$ 阶排列集上的作用。\n\n### 3.1 轨道和定点\n\n$\\forall x\\in X$，定义 $G$ 作用在 $X$ 上的**轨道** $O_x$ 和**定作用集（其实是群）** $G_x$：\n$$\nO_x=\\{x\\cdot g|g\\in G\\}\\\\\nG_x=\\{g|g\\in G,x\\cdot g=x\\}\\\\\n$$\n\n$O_x$ 实际上是在 $G$ 作用下 $X$ 中与 $x$ **等价元素的集合**。\n\n考察 $G_x$ 的性质：\n\n- $G_x\\subseteq G$；\n- 存在单位元：$e\\in G_x$，这很显然；\n- 满足结合律：$\\forall g_1,g_2,g_3\\in G_x$，有 $g_1\\cdot(g_2\\cdot g_3)=(g_1\\cdot g_2)\\cdot g_3$，这也很显然；\n- 封闭：$\\forall g_1,g_2\\in G_x$ 有 $g_1\\cdot g_2\\in G_x$，因为 $x\\cdot g_1\\cdot g_2=(x\\cdot g_1)\\cdot g_2=x\\cdot g_2=x$；\n- 存在逆元：$\\forall g\\in G_x$ 有 $g^{-1}\\in G_x$，因为 $x\\cdot g=x\\Leftrightarrow x=x\\cdot g^{-1}\n  $；\n\n所以 $G_x$ **是 $G$ 的子群**。\n\n### 3.2 Burnside 引理和 Polya 定理\n\n #### 3.2.1 轨道-不动点引理（Orbit-stabilizer 引理）\n\n> $$\n> |O_x|\\times |G_x|=|G|\n> $$\n\n<details><summary>证明</summary><p>\n\n>有：\n>$$\n>\\forall g_1,g_2\\in G,x\\cdot g_1=x\\cdot g_2\\\\\n>G_x\\cdot g_1=G_x\\cdot g_2\\\\\n>$$\n>\n><details><summary>证明</summary><p>\n>\n>> $$\n>> \\begin{aligned}\n>> &\\because x\\cdot g_1\\cdot g_2^{-1}=x\\\\\n>> &\\therefore g_1\\cdot g_2^{-1}\\in G_{x}\\\\\n>> &\\therefore g_1\\in G_x\\cdot g_2,g_2\\in G_x\\cdot g_1\\\\\n>> &\\therefore G_x\\cdot g_1=G_x\\cdot g_2\n>> \\end{aligned}\n>> $$\n>> Q.E.D.\n>\n></p></details>\n>\n>也就是说，每个满足 $x\\cdot g_y\\in O_x$ 的 $g_y$ 都在 $G_x\\cdot g_y$ 这个右陪集中，并且每个 $y\\in O_x$ 都单独对应一个 $G_x$ 的右陪集。由于子群的不同右陪集互不相交、大小相等且覆盖整个大群（Lagrange 定理、陪集的性质），所以：\n>$$\n>\\begin{aligned}\n>\\therefore |O_x|=|G/G_x|=|\\{G_x\\cdot g|g\\in G\\}|\n>\\end{aligned}\n>$$\n>那么显然有：\n>$$\n>|O_x|\\times |G_x|=|G|\n>$$\n>Q.E.D.\n\n</p></details>\n\n#### 3.2.2 Burnside 引理\n\n> 设 $X^g=\\{x|x\\in X,x\\cdot g=x\\}$，$X/G=\\{O_x|x\\in X\\}$ 即 $X$ 在 $G$ 作用下的轨道集合（$|X/G|$ 即为 $X$ 在 $G$ 作用下**本质不同元素个数**），则：\n> $$\n> |X/G|=\\frac{1}{|G|}\\sum\\limits_{g\\in G}|X^g|\n> $$\n\n<details><summary>证明</summary><p>\n\n>根据轨道-不动点引理：\n>$$\n>|O_x|\\times |G_x|=|G|\n>$$\n>并且注意到：\n>$$\n>\\sum\\limits_{x\\in X} |G_x|=\\sum\\limits_{g\\in G}|X^g|\\\\\n>\\sum\\limits_{x\\in X/G}|x|=|X|\\\\\n>\\forall y_1,y_2\\in O_x,G_{y_1}=G_{y_2}\n>$$\n>所以：\n>$$\n>\\begin{aligned}\n>\\sum\\limits_{g\\in G}|X^g|&=\\sum\\limits_{x\\in X} |G_x|=\\sum\\limits_{O_x\\in X/G}\\sum\\limits_{y\\in O_x}|G_y|\\\\\n>&=\\sum\\limits_{O_x\\in X/G}|O_x|\\times |G_x|\\\\\n>&=|X/G|\\times |G|\n>\\end{aligned}\n>$$\n>Q.E.D.\n\n</p></details>\n\n#### 3.2.3 Polya 定理\n\n> 考虑给所有满足 $x\\in X$ 的 $x$ 中元素染上 $m$ 种不同颜色（相同颜色元素本质相同）。$\\forall g\\in G$，设 $c(g)$ 为 $g$ 中轮换个数（置换中环的个数），则在 $G$ 作用下本质不同染色方案数为：\n> $$\n> \\frac{1}{|G|}\\sum\\limits_{g\\in G}m^{c(g)}\n> $$\n\n<details><summary>证明</summary><p>\n\n> 只需证明 $|X^g|=m^{c(g)}$。\n>\n> 由于对于每一个 $g$ 的轮换 $o$，$o$ 中元素染相同颜色才能在应用变换 $g$ 后保持不变，所以每个轮换有 $m$ 种染色方案。而一共有 $c(g)$ 个轮换，所以有 $m^{c(g)}$ 种染色方式在应用变换 $g$ 后保持不变。\n>\n> 所以 $|X^g|=m^{c(g)}$，Q.E.D.\n>\n\n</p></details>\n\n**Tips：**\n\n> 观察 Ploya 定理的证明过程，不难发现对于置换作用 $g$，满足 $x\\cdot g=x$ 的 $x\\in X$ 必定满足位于同一个轮换的元素本质相同。\n>\n> 这方便了 Burnside 引理的应用。\n\n## Part 4 群例题\n\n- [P4980 【模板】Pólya 定理](https://www.luogu.com.cn/problem/P4980)\n\n  <details><summary>查看题解</summary><p>\n\n  > 考虑 $n$ 阶顺时针旋转置换构成的集合 $G$：\n  >\n  > - 存在单位元：置换 $p_i=i$ 在 $G$ 中；\n  > - 满足结合律：显然；\n  > - 封闭：显然；\n  > - 存在逆元：显然，可以绕一大圈再回来；\n  >\n  > 所以 $G$ 是一个群。\n  >\n  > 考虑 Polya 定理：\n  > $$\n  > |X[m]/G|=\\frac{1}{|G|}\\sum\\limits_{g\\in G}m^{c(g)}\n  > $$\n  > 注意到 $\\forall g\\in G$，若 $p\\cdot g$ 后 $p_1\\to p_x$，则 $g$ 中置换环有 $\\gcd(x,n)$ 个，即 $c(g)=\\gcd(x,n)$。证明考虑从 $i$ 向 $i+x-1\\text{ mod }n+1$ 即旋转后的点连边。\n  >\n  > 所以答案即为：\n  > $$\n  > \\frac{1}{n}\\sum\\limits_{d|n}n^d\\sum\\limits_{i=1}^{\\frac{n}{d}}[\\gcd(i,\\frac{n}{d})=1]=\\frac{1}{n}\\sum\\limits_{d|n} n^d\\varphi(\\frac{n}{d})\n  > $$\n  > 有一个神奇的结论，$\\sum\\limits_{d|n}O(\\sqrt d)=O(n^{\\frac{3}{4}})$，所以暴力计算 $\\varphi(\\frac{n}{d})$ 能过。\n  >\n  > 考虑时间复杂度更正确的做法，实际上可以把 $n$ 质因数分解，求 $\\varphi(\\frac{n}{d})$ 时再 $O(\\log n)$ 分解质因数根据 $\\varphi$ 的积性算出 $\\varphi(\\frac{n}{d})$。单次时间复杂度 $O(\\sqrt n\\log n)$。\n  >\n  > 代码如下：（$O(T\\sqrt n\\log n)$ 做法）\n  >\n  > ```cpp\n  > #include <iostream>\n  > #include <cstdio>\n  > #include <vector>\n  > \n  > using namespace std;\n  > \n  > const int S=100005,BS=35,p=1000000007;\n  > \n  > int n;\n  > bool nop[S];\n  > int tot,prime[S];\n  > int cp,ps[S],pi[S][BS];\n  > \n  > inline int qpow(int x,int y)\n  > {\n  > \tint res=1;\n  > \tfor(;y>0;y>>=1,x=1ll*x*x%p) res=y&1?1ll*res*x%p:res;\n  > \treturn res;\n  > }\n  > \n  > inline void init()\n  > {\n  > \tnop[0]=nop[1]=true;\n  > \tfor(int i=2;i<=S-3;i++)\n  > \t{\n  > \t\tif(!nop[i]) prime[++tot]=i;\n  > \t\tfor(int j=1;j<=tot;j++)\n  > \t\t{\n  > \t\t\tif(1ll*i*prime[j]>S-3) break;\n  > \t\t\tnop[i*prime[j]]=true;\n  > \t\t\tif(i%prime[j]==0) break;\n  > \t\t}\n  > \t}\n  > }\n  > \n  > inline void slove()\n  > {\n  > \tscanf(\"%d\",&n);\n  > \tcp=0;\n  > \tint tn=n;\n  > \tfor(int i=1;1ll*prime[i]*prime[i]<=tn;i++)\n  > \t{\n  > \t\tif(tn%prime[i]==0)\n  > \t\t{\n  > \t\t\t++cp;\n  > \t\t\tint tt=1;\n  > \t\t\tps[cp]=prime[i],pi[cp][0]=1,pi[cp][1]=ps[cp]-1;\n  > \t\t\twhile(tn%ps[cp]==0) tn/=ps[cp],pi[cp][tt+1]=pi[cp][tt]*ps[cp],tt++;\n  > \t\t}\n  > \t}\n  > \tif(tn>1) cp++,ps[cp]=tn,pi[cp][0]=1,pi[cp][1]=tn-1;\n  > \tint sum=0;\n  > \tfor(int i=1;1ll*i*i<=n;i++)\n  > \t{\n  > \t\tif(n%i==0)\n  > \t\t{\n  > \t\t\tint d=i,pid=1;\n  > \t\t\tfor(int j=1;j<=cp;j++)\n  > \t\t\t{\n  > \t\t\t\tint ct=0;\n  > \t\t\t\twhile(d%ps[j]==0) ct++,d/=ps[j];\n  > \t\t\t\tpid*=pi[j][ct];\n  > \t\t\t}\n  > \t\t\tsum=(sum+1ll*qpow(n,n/i)*pid%p)%p;\n  > \t\t\tif(i*i!=n)\n  > \t\t\t{\n  > \t\t\t\td=n/i,pid=1;\n  > \t\t\t\tfor(int j=1;j<=cp;j++)\n  > \t\t\t\t{\n  > \t\t\t\t\tint ct=0;\n  > \t\t\t\t\twhile(d%ps[j]==0) ct++,d/=ps[j];\n  > \t\t\t\t\tpid*=pi[j][ct];\n  > \t\t\t\t}\n  > \t\t\t\tsum=(sum+1ll*qpow(n,i)*pid%p)%p;\n  > \t\t\t}\n  > \t\t}\n  > \t}\n  > \tsum=1ll*sum*qpow(n,p-2)%p;\n  > \tprintf(\"%d\\n\",sum);\n  > }\n  > \n  > int main()\n  > {\n  > \tinit();\n  > \tint T;\n  > \tscanf(\"%d\",&T);\n  > \twhile(T-->0) slove();\n  > \treturn 0;\n  > }\n  > ```\n\n  </p></details>\n\n- [【2023NOI模拟赛27】美术作业](../【2023NOI模拟赛27】美术作业 做题记录)\n\n- [洛谷题目列表&tag=Polya 定理](https://www.luogu.com.cn/problem/list?keyword=&tag=248&page=1)\n",
			"tags": [{"name":"学习笔记"},{"name":"数学"},{"name":"数论"},{"name":"组合计数"}],
			"title": "群论入门",
			"link": "https://exber.qzz.io/post/%E7%BE%A4%E8%AE%BA%E5%85%A5%E9%97%A8",
			"date": "2023-07-11 20:53:23"
		},
	
		{
			"abstract": "> 有一些鱼和一个一条鱼宽的长条鱼缸（鱼在鱼缸中只能排成一条直线）。若鱼缸中相邻两条鱼 $a,b$ 大小分别为 $x,y$ 则：\n>\n> - $x>y$：$a$ 能吃掉 $b$；\n> - $x<y$：$b$ 能吃掉 $a$；\n> - $x=y$：$a$ 和 $b$ 都能吃掉对方；\n> \n> 一条大小为 $x$ 的鱼吃掉一条大小为 $y$ 的鱼后它的大小会增加 $y$。\n>\n> 给定 $n$ 条鱼，大小依次为 $a_1,a_2,\\dots ,a_n$。$q$ 次操作，每次操作为以下两种操作中的一种：\n>\n> - $1\\, x\\, y$：把 $a_x$ 改为 $y$；\n> - $2\\, l\\, r$：求若把 $a_l,a_{l+1},\\dots,a_r$ 依次放入鱼缸中，最后有多少条鱼可能吃光其它鱼，询问互相独立，即鱼不会真的互相吃；\n>\n> $1\\le n,q\\le 10^5$，$1\\le a_i, y\\le 10^9$，$1\\le l\\le r\\le n$。\n",
			"content": "> 有一些鱼和一个一条鱼宽的长条鱼缸（鱼在鱼缸中只能排成一条直线）。若鱼缸中相邻两条鱼 $a,b$ 大小分别为 $x,y$ 则：\n>\n> - $x>y$：$a$ 能吃掉 $b$；\n> - $x<y$：$b$ 能吃掉 $a$；\n> - $x=y$：$a$ 和 $b$ 都能吃掉对方；\n> \n> 一条大小为 $x$ 的鱼吃掉一条大小为 $y$ 的鱼后它的大小会增加 $y$。\n>\n> 给定 $n$ 条鱼，大小依次为 $a_1,a_2,\\dots ,a_n$。$q$ 次操作，每次操作为以下两种操作中的一种：\n>\n> - $1\\, x\\, y$：把 $a_x$ 改为 $y$；\n> - $2\\, l\\, r$：求若把 $a_l,a_{l+1},\\dots,a_r$ 依次放入鱼缸中，最后有多少条鱼可能吃光其它鱼，询问互相独立，即鱼不会真的互相吃；\n>\n> $1\\le n,q\\le 10^5$，$1\\le a_i, y\\le 10^9$，$1\\le l\\le r\\le n$。\n\n\n直接上线段树，不难发现区间 $[L,R]$ 中有可能对答案有贡献的鱼肯定满足以下条件中至少一个：\n\n- 能吃完 $[L,R]$ 中的其它鱼；\n- 能吃完 $[L,l_i]$ 即某个前缀中的其它鱼；\n- 能吃完 $[r_i,R]$ 即某个后缀中的其它鱼；\n\n不难发现 $l_i$ 和 $r_i$ 分别只有 $O(\\log V)$ 个，因为只有满足 $a_i>\\sum\\limits_{j=L}^{i-1}a_j$ 或 $a_i>\\sum\\limits_{j=i+1}^{R}a_j$ 的 $i$ 才有可能成为 $l_i+1$ 和 $r_{i}-1$。\n\n那么线段树上每个节点开两个 vector 维护一下这些端点就行了，具体实现看代码注释。\n\n时间复杂度 $O((n+q)\\log n\\log V)$，代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n\nusing namespace std;\n\nconst int S=100005,MS=35;\n\nstruct ndd\n{\n\tint p;         // 吃掉这个端点后最远可以吃到哪里（左端点往右吃，右端点往左吃）\n\tlong long s,v; // 吃掉这个端点可以长大多少，这个端点的值\n\tint c;         // 有多少鱼可以吃掉这个端点\n\tinline ndd(){p=s=v=c=0;}\n\tinline ndd(int x,long long y,long long z,int w){p=x,s=y,v=z,c=w;}\n};\n\nint smcl[S],smcr[S];\n\nstruct node\n{\n\tvector<ndd> lb,rb; // 前缀端点（从前到后）、后缀端点（从后到前）\n\tinline node(int x=0,long long y=0)\n\t{\n\t\tif(x==0) lb.clear(),rb.clear();\n\t\telse lb=rb={ndd(x,y,y,1)}; // 只有一条鱼的区间\n\t}\n\tinline node(vector<ndd> &rl,vector<ndd> &rr){lb=rl,rb=rr;}\n}tr[S<<2];\n\ninline node operator+(node a,node b)\n{\n\tif(a.lb.size()==0) return b;\n\tif(b.lb.size()==0) return a;\n\tvector<ndd> rl=a.lb,rr=b.rb;\n\tint al=a.lb.size(),ar=a.rb.size(),bl=b.lb.size(),br=b.rb.size();\n\t// left\n\tlong long sum=0;\n\tfor(int i=0;i<al;i++) sum+=a.lb[i].s; // 吃完左边有多大\n\tfor(ndd pre:b.lb)\n\t{\n\t\tif(sum>=pre.v) rl[rl.size()-1].s+=pre.s,rl[rl.size()-1].p=pre.p; // 这个端点可以被吃掉\n\t\telse rl.push_back(pre); // 不能被吃掉\n\t\tsum+=pre.s;\n\t}\n\t// right 同理\n\tsum=0;\n\tfor(int i=0;i<br;i++) sum+=b.rb[i].s;\n\tfor(ndd pre:a.rb)\n\t{\n\t\tif(sum>=pre.v) rr[rr.size()-1].s+=pre.s,rr[rr.size()-1].p=pre.p;\n\t\telse rr.push_back(pre);\n\t\tsum+=pre.s;\n\t}\n\t// c\n\t// 清空\n\tfor(ndd &u:rl) smcl[u.p]=0;\n\tfor(ndd &u:rr) smcr[u.p]=0;\n\t// 左区间的左端点和右区间的右端点\n\tfor(int i=0;i<al;i++) smcl[rl[i].p]+=rl[i].c;\n\tfor(int i=0;i<br;i++) smcr[rr[i].p]+=rr[i].c;\n\t// 可以吃光整个大区间的鱼特殊处理\n\tif(rl.size()==al) smcr[rr[rr.size()-1].p]+=a.lb[al-1].c;\n\tif(rr.size()==br) smcl[rl[rl.size()-1].p]+=b.rb[br-1].c;\n\t// 被左边的右端点困住，通过吃右边完成逃离\n\tsum=0;\n\tint l=0,r=0;\n\tfor(int i=0;i<ar-1;i++)\n\t{\n\t\twhile(l<=i) sum+=a.rb[l].s,l++; // 获取这些鱼被困时多大\n\t\tbool f=true;\n\t\twhile(f) // 往左往右吃\n\t\t{\n\t\t\tf=false;\n\t\t\twhile(r<bl&&sum>=b.lb[r].v) sum+=b.lb[r++].s,f=true;\n\t\t\twhile(l<ar&&sum>=a.rb[l].v) sum+=a.rb[l++].s,f=true;\n\t\t}\n\t\tif(l==ar) smcl[b.lb[r-1].p]+=a.rb[i].c; // 如果可以吃完左区间，即吃掉大区间的一个前缀\n\t\tif(r==bl) smcr[a.rb[l-1].p]+=a.rb[i].c; // 如果可以吃完右区间，即吃掉大区间的一个后缀\n\t}\n\t// 同理\n\tsum=0;\n\tl=0,r=0;\n\tfor(int i=0;i<bl-1;i++)\n\t{\n\t\twhile(l<=i) sum+=b.lb[l].s,l++;\n\t\tbool f=true;\n\t\twhile(f)\n\t\t{\n\t\t\tf=false;\n\t\t\twhile(r<ar&&sum>=a.rb[r].v) sum+=a.rb[r++].s,f=true;\n\t\t\twhile(l<bl&&sum>=b.lb[l].v) sum+=b.lb[l++].s,f=true;\n\t\t}\n\t\tif(l==bl) smcr[a.rb[r-1].p]+=b.lb[i].c;\n\t\tif(r==ar) smcl[b.lb[l-1].p]+=b.lb[i].c;\n\t}\n\tfor(ndd &u:rl) u.c=smcl[u.p];\n\tfor(ndd &u:rr) u.c=smcr[u.p];\n\treturn node(rl,rr);\n}\n\nint n,q;\nlong long a[S];\n\nvoid build(int u,int l,int r)\n{\n\tif(l==r) return tr[u]=node(l,a[l]),void();\n\tint mid=l+r>>1;\n\tbuild(u<<1,l,mid),build(u<<1|1,mid+1,r);\n\ttr[u]=tr[u<<1]+tr[u<<1|1];\n}\n\nvoid upd(int u,int l,int r,int pos,long long y)\n{\n\tif(l==r) return tr[u]=node(l,a[l]=y),void();\n\tint mid=l+r>>1;\n\tif(pos<=mid) upd(u<<1,l,mid,pos,y);\n\telse upd(u<<1|1,mid+1,r,pos,y);\n\ttr[u]=tr[u<<1]+tr[u<<1|1];\n}\n\nvoid que(int u,int l,int r,int L,int R,node &res)\n{\n\tif(l>R||r<L) return;\n\tif(l>=L&&r<=R) return res=res+tr[u],void();\n\tint mid=l+r>>1;\n\tif(L<=mid) que(u<<1,l,mid,L,R,res);\n\tif(R>=mid+1) que(u<<1|1,mid+1,r,L,R,res);\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%lld\",&a[i]);\n\tbuild(1,1,n);\n\tscanf(\"%d\",&q);\n\twhile(q--)\n\t{\n\t\tint op,x,y;\n\t\tscanf(\"%d%d%d\",&op,&x,&y);\n\t\tif(op==1) upd(1,1,n,x,y);\n\t\telse\n\t\t{\n\t\t\tnode res;\n\t\t\tque(1,1,n,x,y,res);\n\t\t\tprintf(\"%d\\n\",res.lb[res.lb.size()-1].c);\n\t\t}\n\t}\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"数据结构"},{"name":"结论"}],
			"title": "JOISC2022K 魚 2 做题记录",
			"link": "https://exber.qzz.io/post/JOISC2022K%20%E9%AD%9A%202%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-07-11 20:48:41"
		},
	
		{
			"abstract": "",
			"content": "## Part 1  简介\n\nFFT 本质上是处理加法卷积，即 $A_iB_j$ 贡献到 $C_{i+j}$。而 FWT 则是处理位运算卷积，即 $A_iB_j$ 贡献到 $C_{i\\star j}$，其中 $\\star$ 是某种位运算。\n\nFWT 的思想与 FFT 相近，也是创造一种数列到数列的线性变换 $\\operatorname{FWT}(A)$ 满足它与它的逆变换都可以快速计算且 $\\operatorname{FWT}(A\\star B)=\\operatorname{FWT}(A)\\cdot\\operatorname{FWT}(B)$，其中 $\\cdot$ 表示两个数列对应位置相乘。\n\n有了这样的线性变换就可以先求出 $\\operatorname{FWT}(A)$ 和 $\\operatorname{FWT}(A)$，算出 $\\operatorname{FWT}(A\\star B)=\\operatorname{FWT}(A)\\cdot\\operatorname{FWT}(B)$，最后求出 $C=\\operatorname{IFWT}(A\\star B)$。\n\n本文中假定 $|A|=|B|=n$ 且 $n$ 是 $2$ 的整次幂。\n\n## Part 2 原理\n\n先来解决 $\\operatorname{FWT}(A)$ 如何求解，不妨设 $\\operatorname{FWT}(A)_i=\\sum\\limits_{j=0}^{n-1}c_{i,j}A_j$，然后探讨 $c$ 需要满足的条件。那么有：\n$$\n\\begin{aligned}\n(\\text{FWT}(A)\\cdot \\text{FWT}(B))_i&=\\sum\\limits_{j=0}^{n-1} c_{i,j}A_j\\sum\\limits_{k=0}^{n-1}c_{i,k}B_k\\\\\n&=\\sum\\limits_{j=0}^{n-1}\\sum\\limits_{k=0}^{n-1} c_{i,j}c_{i,k}A_jB_k\\\\\n\\text{FWT}(A\\star B)_i=\\text{FWT}(C)&=\\sum\\limits_{j=0}^{n-1} c_{i,j}C_j\\\\\n&=\\sum\\limits_{j=0}^{n-1}c_{i,j}\\sum\\limits_{1\\le k,l\\le n,k\\star l=j} A_kB_l\\\\\n&=\\sum\\limits_{j=0}^{n-1}\\sum\\limits_{k=0}^{n-1} c_{i,j\\star k}A_jB_k\n\\end{aligned}\n$$\n\n所以有：\n$$\nc_{i,j}c_{i,k}=c_{i,j\\star k}\n$$\n注意到由于 $\\star$ 是位运算，所以不妨钦定 $c$ 也可以拆位处理。令 $(a)_2=\\overline{a_0a_1a_2\\dots}$ 即 $a$ 的二进制表示，不妨钦定 $c$ 满足 $c_{i,j}=c_{i_0,j_0}c_{i_1,j_1}c_{i_2,j_2}\\dots$，这样做的好处是只要知道 $c_{0/1,0/1}$ 就可以求出 $c_{i,j}$，而且也有：\n$$\nc_{i_l,j_l}c_{i_l,k_l}=c_{i_l,j_l\\star k_l}\\Leftrightarrow c_{i,j}c_{i,k}=c_{i,j\\star k}\n$$\n但是暴力求 $\\text{FWT}(A)$ 是 $O(n^2)$ 的，考虑优化，令 $a'$ 为 $a$ 去掉二进制最高位的数，按位折半即有：\n$$\n\\begin{aligned}\n\\text{FWT}(A)_i&=\\sum\\limits_{j=0}^{\\frac{n}{2}-1} c_{i_0,j_0}c_{i',j'}A_{j}+\\sum\\limits_{j=\\frac{n}{2}}^{n-1} c_{i_0,j_0}c_{i',j'}A_{j}\\\\\n&=c_{i_0,0}\\sum\\limits_{j=0}^{\\frac{n}{2}-1} c_{i',j'}A_{j}+c_{i_0,1}\\sum\\limits_{j=\\frac{n}{2}}^{n-1} c_{i',j'}A_{j}\n\\end{aligned}\n$$\n那么考虑 $i_0$ 的取值，有：\n$$\n\\text{FWT}(A)_i=\\begin{cases}\nc_{0,0}\\sum\\limits_{j=0}^{\\frac{n}{2}-1} c_{i',j'}A_{j}+c_{0,1}\\sum\\limits_{j=\\frac{n}{2}}^{n-1} c_{i',j'}A_{j}&0\\le i\\le \\frac{n}{2}-1\\\\\nc_{1,0}\\sum\\limits_{j=0}^{\\frac{n}{2}-1} c_{i',j'}A_{j}+c_{1,1}\\sum\\limits_{j=\\frac{n}{2}}^{n-1} c_{i',j'}A_{j}&\\frac{n}{2}\\le i\\le n-1\n\\end{cases}\n$$\n设 $A0$ 为 $A$ 中下标二进制最高位为 $0$ 的部分，$A1$ 为最高位为 $1$的部分，那么有：\n$$\n\\text{FWT}(A)_i=\\begin{cases}\nc_{0,0}\\text{FWT}(A0)_i+c_{0,1}\\text{FWT}(A1)_i&0\\le i\\le \\frac{n}{2}-1\\\\\nc_{1,0}\\text{FWT}(A0)_{i-\\frac{n}{2}}+c_{1,1}\\text{FWT}(A1)_{i-\\frac{n}{2}}&\\frac{n}{2}\\le i\\le n-1\n\\end{cases}\n$$\n 假设 $n=2^m$，则可以在 $O(m2^m)$ 即 $O(n\\log n)$ 的时间复杂度内求解 $\\text{FWT(A)}$。\n\n对于 $\\text{IFWT}(A)$，只需要构造出 $c_{0/1,0/1}$ 的逆即可。\n\n## Part 3 具体实现\n\n根据 $c_{i,j}c_{i,k}=c_{i,j\\star k}$ 和 $c_{i_0,j_0}c_{i_1,j_1}=c_{2i_0+i_1,2j_0+j_1}$ 构造 $c_{0/1,0/1}$ 即可，称其为位矩阵。\n\n构造过程比较人类智慧，注意矩阵必须要有逆，即每一行和每一列都有至少一个位置不为 $0$ 且不能有两行或者两列完全一样，否则就会有维度被丢失（线性代数说法）。\n\n由于不同的位运算的 $\\text{FWT}$ 本质相同，只是 $c$ 不同，所以不妨设 $\\text{FWT}\\left(A,\\begin{bmatrix}c_{0,0}&c_{0,1}\\\\c_{1,0}&c_{1,1}\\end{bmatrix}\\right)$ 为 $A$ 在对应的 $c$ 意义下的 $\\text{FWT}$ 结果，那么有 $\\text{FWT}\\left(\\text{FWT}\\left(A,c\\right),c^{-1}\\right)=A$。\n\n### 3.1 $\\text{OR}$ 卷积\n\n考虑构造满足 $c_{i,j}c_{i,k}=c_{i,j|k}$ 且存在逆的位矩阵。\n\n$c_{0,0}c_{0,0}=c_{0,0|0}=c_{0,0}\\Rightarrow c_{0,0}\\in\\{0,1\\}$。\n\n同理，$c_{0/1,0/1}\\in\\{0,1\\}$。\n\n由于 $c_{0,0}c_{0,1}=c_{0,1}$，所以 $c_{0,0}=1,c_{0,1}=0$ 或者 $c_{0,0}=1,c_{0,1}=1$。\n\n同理，$c_{1,0}=1,c_{1,1}=0$ 或者 $c_{1,0}=1,c_{1,1}=1$。\n\n那么位矩阵就有两种构造方式：\n$$\n\\begin{bmatrix}\n1&0\\\\1&1\n\\end{bmatrix}\n\\begin{bmatrix}\n1&1\\\\1&0\n\\end{bmatrix}\n$$\n\n>**Tips：**\n>\n>观察这个位矩阵：\n>$$\n>\\begin{bmatrix}\n>1&0\\\\1&1\n>\\end{bmatrix}\n>$$\n>注意到它满足 $c_{i,j}=[i\\&j=j]$，也就是说这种情况下 $\\text{FWT}(A,c)$ 实际上相当于子集求和。\n>\n>这启发我们形如 $B_i=\\sum\\limits_{i\\star j=i}A_j$ 和 $B_i=\\sum\\limits_{i\\star j=j}A_j$ 这样的和式（$\\star$ 是某种位运算）也可以用 $\\text{FWT}$ 来快速求。\n\n由于第一个位矩阵满足 $c_{i,j}=[i\\&j=j]$，所以下面采用第一个位矩阵，则设 $c^{-1}=\\begin{bmatrix}x&y\\\\z&w\\end{bmatrix}$，则有：\n$$\n\\begin{cases}\nx+0z=1\\\\\ny+0w=0\\\\\nx+z=0\\\\\ny+w=1\n\\end{cases}\n$$\n解得：\n$$\n\\begin{cases}\nx=1\\\\\ny=0\\\\\nz=-1\\\\\nw=1\n\\end{cases}\n$$\n所以 $c^{-1}=\\begin{bmatrix}1&0\\\\-1&1\\end{bmatrix}$。\n\n### 3.2 $\\text{AND}$ 卷积\n\n$c_{0,0}c_{0,0}=c_{0,0\\&0}=c_{0,0}\\Rightarrow c_{0,0}\\in\\{0,1\\}$。\n\n同理，$c_{0/1,0/1}\\in\\{0,1\\}$。\n\n由于 $c_{0,0}c_{0,1}=c_{0,0}$，所以 $c_{0,0}=0,c_{0,1}=1$ 或 $c_{0,0}=1,c_{0,1}=1$。\n\n同理，$c_{1,0}=0,c_{1,1}=1$ 或 $c_{1,0}=1,c_{1,1}=1$。\n\n那么位矩阵就有两种构造方式：\n$$\n\\begin{bmatrix}\n0&1\\\\1&1\n\\end{bmatrix}\n\\begin{bmatrix}\n1&1\\\\0&1\n\\end{bmatrix}\n$$\n由于第一个位矩阵满足 $c_{i,j}=[i|j=2^k-1]$，所以采用第一个位矩阵，同理，待定系数法求逆得 $c^{-1}=\\begin{bmatrix}-1&1\\\\1&0\\end{bmatrix}$。\n\n### 3.3 $\\text{XOR}$ 卷积\n\n由于对于任意的 $x,y$，均有 $c_{0,0}c_{x,y}=c_{x,y}$，所以 $c_{0,0}=1$。\n\n根据 $c_{1,1}c_{1,1}=c_{1,0}$ 且矩阵不存在为 $0$ 的行，所以 $c_{1,0}$ 与 $c_{1,1}$ 均非 $0$​。\n\n根据 $c_{1,0}c_{1,0}=c_{1,0}$ 且 $c_{1,0}\\not=0$ 可得 $c_{1,0}=1$。\n\n根据，$c_{0,1}c_{0,1}=c_{1,0}$，可得 $c_{0,1}=-1$ 或 $c_{0,1}=1$。\n\n同理，$c_{1,1}c_{1,1}=c_{1,0}$，$c_{1,1}=-1$ 或 $c_{1,1}=1$。\n\n那么位矩阵就有两种构造方式：\n$$\n\\begin{bmatrix}\n1&-1\\\\1&1\n\\end{bmatrix}\n\\begin{bmatrix}\n1&1\\\\1&-1\n\\end{bmatrix}\n$$\n同样的，由于第二个位矩阵满足 $c_{i,j}=(-1)^{|i\\&j|}$（$|a|$ 为 $a$ 二进制表示中 $1$ 的个数），所以采用第二个位矩阵，求逆得 $c^{-1}=\\begin{bmatrix}\\frac{1}{2}&\\frac{1}{2}\\\\\\frac{1}{2}&-\\frac{1}{2}\\end{bmatrix}$。\n\n### 3.4 代码实现\n\n直接套\n$$\n\\text{FWT}(A)_i=\\begin{cases}\nc_{0,0}\\text{FWT}(A0)_i+c_{0,1}\\text{FWT}(A1)_i&0\\le i\\le \\frac{n}{2}-1\\\\\nc_{1,0}\\text{FWT}(A0)_{i-\\frac{n}{2}}+c_{1,1}\\text{FWT}(A1)_{i-\\frac{n}{2}}&\\frac{n}{2}\\le i\\le n-1\n\\end{cases}\n$$\n即可，[P4717 【模板】快速莫比乌斯/沃尔什变换 (FMT/FWT)](https://www.luogu.com.cn/problem/P4717) 代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int p=998244353,inv2=499122177;\n\ninline int getlen(int n)\n{\n\tint res=1;\n\twhile(res<n) res<<=1;\n\treturn res;\n}\n\nconst int ORC[2][2]={{1,0},{1,1}},IORC[2][2]={{1,0},{p-1,1}};\nconst int ANDC[2][2]={{0,1},{1,1}},IANDC[2][2]={{p-1,1},{1,0}};\nconst int XORC[2][2]={{1,1},{1,p-1}},IXORC[2][2]={{inv2,inv2},{inv2,p-inv2}};\n\ninline void FWT(int n,int a[],const int c[2][2])\n{\n\tfor(int len=2;len<=n;len<<=1)\n\t{\n\t\tint mid=len>>1;\n\t\tfor(int l=0;l<=n-len;l+=len)\n\t\t{\n\t\t\tfor(int k=0;k<mid;k++)\n\t\t\t{\n\t\t\t\tint x=a[l+k],y=a[l+mid+k];\n\t\t\t\ta[l+k]=(1ll*c[0][0]*x%p+1ll*c[0][1]*y%p)%p;\n\t\t\t\ta[l+mid+k]=(1ll*c[1][0]*x%p+1ll*c[1][1]*y%p)%p;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint n;\nint a[1<<17],b[1<<17],c[1<<17];\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tn=1<<n;\n\tfor(int i=0;i<n;i++) scanf(\"%d\",&a[i]);\n\tfor(int i=0;i<n;i++) scanf(\"%d\",&b[i]);\n\tFWT(n,a,ORC),FWT(n,b,ORC);\n\tfor(int i=0;i<n;i++) c[i]=1ll*a[i]*b[i]%p;\n\tFWT(n,c,IORC);\n\tfor(int i=0;i<n;i++) printf(\"%d \",c[i]);\n\tprintf(\"\\n\");\n\tFWT(n,a,IORC),FWT(n,b,IORC);\n\t\n\tFWT(n,a,ANDC),FWT(n,b,ANDC);\n\tfor(int i=0;i<n;i++) c[i]=1ll*a[i]*b[i]%p;\n\tFWT(n,c,IANDC);\n\tfor(int i=0;i<n;i++) printf(\"%d \",c[i]);\n\tprintf(\"\\n\");\n\tFWT(n,a,IANDC),FWT(n,b,IANDC);\n\t\n\tFWT(n,a,XORC),FWT(n,b,XORC);\n\tfor(int i=0;i<n;i++) c[i]=1ll*a[i]*b[i]%p;\n\tFWT(n,c,IXORC);\n\tfor(int i=0;i<n;i++) printf(\"%d \",c[i]);\n\tprintf(\"\\n\");\n\treturn 0;\n}\n```\n\n## Part 4 更多拓展\n\n有些时候考的往往不是裸的 $\\text{FWT}$。\n\n下文中若 $A$ 与 $B$ 为数列，$\\star$  为某种位运算，那么 $A\\star B$ 表示 $A$ 与 $B$ 在 $\\star$ 运算下的卷积结果，即 $(A\\star B)_i=\\sum\\limits_{j\\star k=i}A_jB_k$。\n\n$\\text{FWT}$ 应用时往往要利用它是线性变换来优化，即 $\\text{FWT}(A)+\\text{FWT}(B)=\\text{FWT(A+B)}$ 且 $\\text{FWT}(aA)=a\\text{FWT}(A)$。\n\n若 $A$ 只有少数项非 $0$ 则可能有分类讨论优化时间复杂度的做法。\n\n一些例题：\n\n- [CF1119H Triple](https://www.luogu.com.cn/problem/CF1119H)，[题解](../CF1119H Triple 做题记录)\n\n### 4.1 离线子集卷积\n\n$$\nC_{k}=\\sum\\limits_{i|j=k,i\\&j=0}A_iB_j=\\sum\\limits_{i\\subseteq k}A_iB_{k-i}\n$$\n\n发现 $i\\&j=0$ 很烦，但是不难发现它等价于 $|i|+|j|=|k|$（$|a|$ 表示 $a$ 二进制表示中的 $1$ 的个数），所以可以令 $SA_{i,j}=[|j|=i]A_j,SB_{i,j}=[|j|=i]B_j$，那么有：\n$$\nR_i=\\sum\\limits_{j=0}^iSA_j|SB_{i-j}\n$$\n由于 $\\text{FWT}$ 是线性变换，所以有：\n$$\nR_i=\\text{IFWT}\\left(\\sum\\limits_{j=0}^i\\text{FWT}(SA_j)\\cdot \\text{FWT}(SB_{i-j})\\right)\n$$\n答案即为 $R_{|i|,i}$，时间复杂度 $O(m^22^m)$，参考代码：（[P6097 【模板】子集卷积](https://www.luogu.com.cn/problem/P6097)）\n\n```cpp\nint main()\n{\n\tscanf(\"%d\",&n);\n\tn=1<<n;\n\tfor(int i=0;i<n;i++) scanf(\"%d\",&a[i]);\n\tfor(int i=0;i<n;i++) scanf(\"%d\",&b[i]);\n\tfor(int i=0;i<(1<<20);i++) for(int j=0;j<20;j++) popc[i]+=i>>j&1;\n\tfor(int i=0;i<=20;i++) for(int j=0;j<n;j++) sa[i][j]=(popc[j]==i)*a[j],sb[i][j]=(popc[j]==i)*b[j];\n\tfor(int i=0;i<=20;i++) FWT(n,sa[i],ORC),FWT(n,sb[i],ORC);\n\tfor(int i=0;i<=20;i++) for(int j=0;j<=i;j++) for(int k=0;k<(1<<20);k++) r[i][k]=(r[i][k]+1ll*sa[j][k]*sb[i-j][k]%p)%p;\n\tfor(int i=0;i<=20;i++) FWT(n,r[i],IORC);\n\tfor(int i=0;i<n;i++) printf(\"%d \",r[popc[i]][i]);\n\tprintf(\"\\n\");\n\treturn 0;\n}\n```\n\n### 4.2 半在线子集卷积\n\n$$\nC_k=B_k\\sum\\limits_{i|j=k,i\\&j=0,i\\not=k}C_iA_j=B_k\\sum\\limits_{i\\subset k}C_iA_{k-i}\n$$\n\n和离线子集卷积类似，令 $SA_{i,j}=[|j|=i]A_j,SC_{i,j}=[|j|=i]C_j$，那么有：\n$$\n\\begin{aligned}\nSC_{i}&=B\\cdot\\sum\\limits_{k=0}^{i-1}SC_k|SA_{i-k}\\\\\n&=B\\cdot\\text{IFWT}\\left(\\sum\\limits_{j=0}^i\\text{FWT}(SC_j)\\cdot \\text{FWT}(SA_{i-j})\\right)\n\\end{aligned}\n$$\n那么从小到大枚举 $i$ 计算即可。\n\n### 4.3 每一位运算法则不同\n\n> 给定一个长 $\\log n$ 的字符串，字符集为 `|&^`，表示每一位要进行的位运算。\n\n依旧是考虑：\n$$\n\\text{FWT}(A)_i=\\begin{cases}\nc_{0,0}\\text{FWT}(A0)_i+c_{0,1}\\text{FWT}(A1)_i&0\\le i\\le \\frac{n}{2}-1\\\\\nc_{1,0}\\text{FWT}(A0)_{i-\\frac{n}{2}}+c_{1,1}\\text{FWT}(A1)_{i-\\frac{n}{2}}&\\frac{n}{2}\\le i\\le n-1\n\\end{cases}\n$$\n只不过此时 $c$ 取字符串第 $\\log n$ 位对应运算的那个矩阵。\n\n```cpp\ninline void FWT(int n,int a[],int w)\n{\n\tfor(int len=2,pos=1;len<=n;len<<=1,pos++)\n\t{\n\t\tint mid=len>>1;\n\t\tint c[2][2];\n\t\tif(w==1)\n\t\t{\n\t\t\tif(str[pos]=='|') memcpy(c,ORC,sizeof(ORC));\n\t\t\tif(str[pos]=='&') memcpy(c,ANDC,sizeof(ANDC));\n\t\t\tif(str[pos]=='^') memcpy(c,XORC,sizeof(XORC));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(str[pos]=='|') memcpy(c,IORC,sizeof(IORC));\n\t\t\tif(str[pos]=='&') memcpy(c,IANDC,sizeof(IANDC));\n\t\t\tif(str[pos]=='^') memcpy(c,IXORC,sizeof(IXORC));\n\t\t}\n\t\tfor(int l=0;l<=n-len;l+=len)\n\t\t{\n\t\t\tfor(int k=0;k<mid;k++)\n\t\t\t{\n\t\t\t\tint x=a[l+k],y=a[l+mid+k];\n\t\t\t\ta[l+k]=(1ll*c[0][0]*x%p+1ll*c[0][1]*y%p)%p;\n\t\t\t\ta[l+mid+k]=(1ll*c[1][0]*x%p+1ll*c[1][1]*y%p)%p;\n\t\t\t}\n\t\t}\n\t}\n}\n```\n",
			"tags": [{"name":"学习笔记"},{"name":"数学"},{"name":"FWT"}],
			"title": "快速沃尔什变换（FWT）学习笔记",
			"link": "https://exber.qzz.io/post/%E5%BF%AB%E9%80%9F%E6%B2%83%E5%B0%94%E4%BB%80%E5%8F%98%E6%8D%A2%EF%BC%88FWT%EF%BC%89%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-07-09 21:17:00"
		},
	
		{
			"abstract": "> 有 $n$ 个数组，每个数组里有 $x$ 个 $a_i$、$y$ 个 $b_i$ 和 $z$ 个 $c_i$，保证  $0\\le a_i,b_i,c_i<2^k$。\n>\n> 对于每一个 $0\\le t<2^k$，求有多少种从 $n$ 个数组中分别选一个数的方式，使得这些数异或起来等于 $t$，对 $998244353$ 取模。\n>\n> $1\\le n\\le 10^5$，$1\\le k\\le 17$。\n",
			"content": "> 有 $n$ 个数组，每个数组里有 $x$ 个 $a_i$、$y$ 个 $b_i$ 和 $z$ 个 $c_i$，保证  $0\\le a_i,b_i,c_i<2^k$。\n>\n> 对于每一个 $0\\le t<2^k$，求有多少种从 $n$ 个数组中分别选一个数的方式，使得这些数异或起来等于 $t$，对 $998244353$ 取模。\n>\n> $1\\le n\\le 10^5$，$1\\le k\\le 17$。\n\n\n首先显然可以求出 $B_i=\\text{FWT}(A_i)$ 点乘起来再求 $\\text{IFWT}$，但是这样时间复杂度为 $O(nk2^k)$，显然会 T。\n\n发现 $B_{i,j}=C_{j,a_i}x+C_{j,b_i}y+C_{j,c_i}z$，而且 Xor 卷积满足 $C_{i,j}=(-1)^{|i\\&j|}$（$|a|$ 为 $a$ 二进制表示中 $1$ 的个数），所以有 $B_{i,j}=(-1)^{|j\\&a_i|}x+(-1)^{|j\\&b_i|}y+(-1)^{|j\\&c_i|}z$。\n\n由于异或有自反性，所以考虑令 $a_i,b_i,c_i$ 都异或上 $a_i$，最后求答案时再把下标异或上 $\\oplus a_i$。则有 $B_{i,j}=x+(-1)^{|j\\&b_i|}y+(-1)^{|j\\&c_i|}z$。\n\n此时 $B_{i,j}$ 共有四种取值，考虑对于每一个 $(\\prod B_{i})_j$ 求出每种取值分别的数量 $c1,c2,c3,c4$，则 $(\\prod B_{i})_j=(x+y+z)^{c1}(x+y-z)^{c2}(x-y+z)^{c3}(x-y-z)^{c4}$，然后做 $\\text{IFWT}$。\n\n考虑列方程求解 $c1,c2,c3,c4$，只需要列出四条一次方程即可。\n\n首先有 $c1+c2+c3+c4=n$。(1)\n\n接下来考虑利用 $B_{i,j}=x+(-1)^{|j\\&b_i|}y+(-1)^{|j\\&c_i|}z$ 的性质：\n\n- 由于 $\\text{FWT}(A)+\\text{FWT}(B)=\\text{FWT}(A+B)$，所以可以令 $F_{i,j}=[j=b_i]$，此时 $\\text{FWT}(F_i)_j=(-1)^{|j\\&b_i|}$。\n\n  那么设 $p1=\\sum\\text{FWT}(F_i)_j=\\text{FWT}(\\sum F_i)_j=\\sum (-1)^{|j\\&b_i|}$，则根据 $y$ 的系数得 $c1+c2-c3-c4=p1$。(2)\n\n- 令 $F_{i,j}=[j=c_i]$，此时 $\\text{FWT}(F_i)_j=(-1)^{|j\\&c_i|}$。\n\n  设 $p2=\\text{FWT}(\\sum F_i)_j=\\sum (-1)^{|j\\&c_i|}$，则根据 $z$ 的系数得 $c1-c2+c3-c4=p2$。(3)\n\n- 令 $F_{i,j}=[j=b_i\\oplus c_i]$，此时 $\\text{FWT}(F_i)_j=(-1)^{|j\\&b_i|}(-1)^{|j\\&c_i|}$。\n\n  设 $p3=\\text{FWT}(\\sum F_i)_j=\\sum (-1)^{|j\\&b_i|}(-1)^{|j\\&c_i|}$，则根据 $y$ 和 $z$ 的系数得 $c1-c2-c3+c4=p3$。(4)\n\n则可以列出方程：\n$$\n\\begin{cases}\nc1+c2+c3+c4=n\\\\\nc1+c2-c3-c4=p1\\\\\nc1-c2+c3-c4=p2\\\\\nc1-c2-c3+c4=p3\n\\end{cases}\n$$\n解得：\n$$\n\\begin{cases}\n2(c3+c4)=n-p1\\\\\n2(c3-c4)=p2-p3\\\\\nc1=\\frac{p1+p2+p3+n}{4}\\\\\nc2=\\frac{p1+n-p2-p3}{4}\\\\\nc3=\\frac{n-p1+p2-p3}{4}\\\\\nc4=\\frac{n-p1-p2+p3}{4}\n\\end{cases}\n$$\n$c1,c2,c3,c4$ 可以用 `long long` 存下。\n\n时间复杂度 $O(n+k2^k)$，代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int p=998244353,inv2=499122177;\n\ninline int qpow(int x,long long y)\n{\n\tint res=1;\n\tfor(;y>0;y>>=1,x=1ll*x*x%p) res=y&1?1ll*res*x%p:res;\n\treturn res;\n}\n\ninline void FWT(int n,long long a[])\n{\n\tfor(int len=2;len<=n;len<<=1)\n\t{\n\t\tint mid=len>>1;\n\t\tfor(int l=0;l<n-len+1;l+=len)\n\t\t{\n\t\t\tfor(int k=0;k<mid;k++)\n\t\t\t{\n\t\t\t\tlong long x=a[l+k],y=a[l+mid+k];\n\t\t\t\ta[l+k]=x+y;\n\t\t\t\ta[l+mid+k]=x-y;\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void IFWT(int n,int a[])\n{\n\tfor(int len=2;len<=n;len<<=1)\n\t{\n\t\tint mid=len>>1;\n\t\tfor(int l=0;l<n-len+1;l+=len)\n\t\t{\n\t\t\tfor(int k=0;k<mid;k++)\n\t\t\t{\n\t\t\t\tint x=a[l+k],y=a[l+mid+k];\n\t\t\t\ta[l+k]=(1ll*inv2*x%p+1ll*inv2*y%p)%p;\n\t\t\t\ta[l+mid+k]=(1ll*inv2*x%p+1ll*(p-inv2)*y%p)%p;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint n,k;\nint X,Y,Z;\nint sm;\nlong long F1[1<<17],F2[1<<17],F3[1<<17];\nint ans[1<<17];\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tscanf(\"%d%d%d\",&X,&Y,&Z);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint a,b,c;\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\tsm^=a,b^=a,c^=a;\n\t\tF1[b]++,F2[c]++,F3[b^c]++;\n\t}\n\tFWT(1<<k,F1),FWT(1<<k,F2),FWT(1<<k,F3);\n\tint v1=((long long)X+Y+Z)%p;\n\tint v2=((long long)X+Y-Z)%p;\n\tint v3=((long long)X-Y+Z)%p;\n\tint v4=((long long)X-Y-Z)%p;\n\tfor(int i=0;i<(1<<k);i++)\n\t{\n\t\tlong long p1=F1[i],p2=F2[i],p3=F3[i];\n\t\tlong long c1=(p1+p2+p3+n)/4;\n\t\tlong long c2=(p1+n-p2-p3)/4;\n\t\tlong long c3=(n-p1+p2-p3)/4;\n\t\tlong long c4=(n-p1-p2+p3)/4;\n\t\tans[i]=(1ll*qpow(v1,c1)*qpow(v2,c2)%p*qpow(v3,c3)%p*qpow(v4,c4)%p+p)%p;\n\t}\n\tIFWT(1<<k,ans);\n\tfor(int i=0;i<(1<<k);i++) printf(\"%d \",ans[i^sm]);\n\tprintf(\"\\n\");\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"FWT"},{"name":"数学"}],
			"title": "CF1119H Triple 做题记录",
			"link": "https://exber.qzz.io/post/CF1119H%20Triple%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-07-09 21:00:30"
		},
	
		{
			"abstract": "> 给定一个长 $n$ 的序列 $a$，从 $a$ 中选择一个子序列 $b$，使得 $\\sum ib_i$ 最大，输出这个最大值。\n>\n> $1\\le n\\le 10^5$，$0\\le |a_i|\\le 10^7$。\n",
			"content": "> 给定一个长 $n$ 的序列 $a$，从 $a$ 中选择一个子序列 $b$，使得 $\\sum ib_i$ 最大，输出这个最大值。\n>\n> $1\\le n\\le 10^5$，$0\\le |a_i|\\le 10^7$。\n\n\n考虑一个显然的 dp，设 $f_{i,j}$ 表示 $a_{[1,i]}$ 中选了 $j$ 个的最大 $\\sum ib_i$，则有转移：\n$$\nf_{i,j}=\\max(f_{i-1,j},f_{i-1,j-1}+ja_i)\n$$\n有一个神奇的结论，存在 $k$ 满足：\n$$\nf_{i,j}=\\begin{cases}\nf_{i-1,j}&j<k\\\\\nf_{i-1,j-1}+ja_i&j\\ge k\n\\end{cases}\n$$\n具体证明有点复杂，大概就是这个东西的本质是一个贪心的优化。\n那么用平衡树动态维护 $f_{i,*}$ 的差分数组即可，时间复杂度 $O(n\\log n)$。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n\nusing namespace std;\n\nconst int S=100005;\n\nstruct node\n{\n\tint ls,rs,w;\n\tint siz;\n\tlong long val,tag;\n};\n\nnode tr[S];\nint trcnt;\n\nint nnde(long long x)\n{\n\ttr[++trcnt]=(node){0,0,rand(),1,x,0};\n\treturn trcnt;\n}\n\nvoid upd(int u)\n{\n\tint ls=tr[u].ls,rs=tr[u].rs;\n\ttr[u].siz=tr[ls].siz+tr[rs].siz+1;\n}\n\nvoid dwntag(int u)\n{\n\tint ls=tr[u].ls,rs=tr[u].rs;\n\ttr[ls].val+=tr[u].tag,tr[ls].tag+=tr[u].tag;\n\ttr[rs].val+=tr[u].tag,tr[rs].tag+=tr[u].tag;\n\ttr[u].tag=0;\n}\n\nvoid split(int u,long long val,int siz,int &x,int &y)\n{\n\tif(u==0) return x=y=0,void();\n\tdwntag(u);\n\tint &ls=tr[u].ls,&rs=tr[u].rs;\n\tint sz=tr[ls].siz+siz+1;\n\tif(tr[u].val>val*sz) split(rs,val,sz,rs,y),x=u;\n\telse split(ls,val,siz,x,ls),y=u;\n\tupd(u);\n}\n\nvoid merge(int x,int y,int &u)\n{\n\tif(x==0||y==0) return u=x+y,void();\n\tdwntag(x),dwntag(y);\n\tint &xrs=tr[x].rs,&yls=tr[y].ls;\n\tif(tr[x].w<tr[y].w) merge(xrs,y,xrs),u=x;\n\telse merge(x,yls,yls),u=y;\n\tupd(u);\n}\n\nlong long getans(int u,long long &sum)\n{\n\tif(u==0) return 0;\n\tdwntag(u);\n\tlong long res=getans(tr[u].ls,sum);\n\tres=max(res,sum+=tr[u].val);\n\tres=max(res,getans(tr[u].rs,sum));\n\treturn res;\n}\n\nint n,rt;\n\nint main()\n{\n\tsrand(time(NULL));\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tlong long x;\n\t\tscanf(\"%lld\",&x);\n\t\tint rx,ry;\n\t\tsplit(rt,x,0,rx,ry);\n\t\tint k=tr[rx].siz+1;\n\t\tint pre=nnde(x*k);\n\t\ttr[ry].val+=x,tr[ry].tag+=x;\n\t\tmerge(rx,pre,rt);\n\t\tmerge(rt,ry,rt);\n\t}\n\tlong long sum=0;\n\tprintf(\"%lld\\n\",getans(rt,sum));\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"数据结构"},{"name":"DP"}],
			"title": "CF573E Bear and Bowling 做题记录",
			"link": "https://exber.qzz.io/post/CF573E%20Bear%20and%20Bowling%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-07-09 15:51:23"
		},
	
		{
			"abstract": "> 给定 $n,m$，求满足以下条件的 $n$ 个点的有向图 $G$ 的个数：\n> - $G$ 是个竞赛图，即 $G$ 没有重边和自环且对于所有 $1\\le i<j\\le n$ 均满足 $(i\\to j)\\in G$ 和 $(j\\to i)\\in G$ 中只有一个满足；\n> - 只有 $m$ 个 $(i,j)$ 满足 $1\\le i<j\\le n$ 且 $(i\\to j)\\in G$；\n> 求所有满足条件的 $G$ 中的强连通分量的个数和，对 $998244353$ 取模。\n> $1\\le n\\le 30$，$1\\le m\\le \\frac{n(n-1)}{2}$。\n",
			"content": "> 给定 $n,m$，求满足以下条件的 $n$ 个点的有向图 $G$ 的个数：\n> - $G$ 是个竞赛图，即 $G$ 没有重边和自环且对于所有 $1\\le i<j\\le n$ 均满足 $(i\\to j)\\in G$ 和 $(j\\to i)\\in G$ 中只有一个满足；\n> - 只有 $m$ 个 $(i,j)$ 满足 $1\\le i<j\\le n$ 且 $(i\\to j)\\in G$；\n> 求所有满足条件的 $G$ 中的强连通分量的个数和，对 $998244353$ 取模。\n> $1\\le n\\le 30$，$1\\le m\\le \\frac{n(n-1)}{2}$。\n\n首先有一个结论：\n\n> $n$ 个点的竞赛图 $G$ 中的 SCC（strongly connected components）个数等价于：\n>\n> > 把 $\\{1,2,3,\\dots,n\\}$ 划分为两个集合 $A$ 和 $B$（可以为空）使得 $\\forall u\\in A,v\\in B$，$(i\\to j)\\in G$ 的方案数减一\n\n证明：\n\n> 考虑缩点，缩完点后的图显然还是竞赛图且是个 DAG，那么它的拓扑序唯一，设其为 $\\{scc_1,scc_2,scc_3,\\dots,scc_{sz}\\}$，那么显然 $\\forall 0\\le i\\le sz$，$A=\\{scc_1,scc_2,\\dots,scc_i\\},B=\\{scc_{i+1},scc_{i+2},\\dots,scc_{sz}\\}$ 是合法的，这样划分一共有 $sz+1$ 种方案。\n>\n> 而其它划分方法显然不合法，得证。\n\n考虑设 $f_{i,j,k}$ 为加入了编号 $[1,i+j]$ 的点，$|A|=i,|B|=j$，从编号小的点连向编号大的点的边有 $k$ 条的方案数，那么转移考虑新加入一个编号最大的点 $i+j+1$：\n$$\n\\begin{cases}\n\\binom{i}{l}f_{i,j,k}\\to f_{i+1,j,k+j+l}\\\\\n\\binom{j}{l}f_{i,j,k}\\to f_{i,j+1,k+l}\n\\end{cases}\n$$\n答案即为 $\\sum\\limits_{i+j=n}f_{i,j,m}-\\binom{\\frac{n(n-1)}{2}}{m}$，时间复杂度 $O(n^3m)$。\n\n代码如下：\n\n```cpp\n// Problem: [ARC163D] Sum of SCC\n// Contest: Luogu\n// URL: https://www.luogu.com.cn/problem/AT_arc163_d\n// Memory Limit: 1 MB\n// Time Limit: 2000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=1005,MS=35,p=998244353;\n\nint n,m;\nint C[S][S];\nint f[MS][MS][S];\n\ninline void add(int &x,int y)\n{\n\tx+=y;\n\tif(x>=p) x-=p;\n}\n\nint main()\n{\n\tC[0][0]=1;\n\tfor(int i=1;i<=S-3;i++)\n\t{\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<=i;j++) C[i][j]=(C[i-1][j]+C[i-1][j-1])%p;\n\t}\n\tscanf(\"%d%d\",&n,&m);\n\tf[0][0][0]=1;\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<=n-i;j++)\n\t\t{\n\t\t\tfor(int k=0;k<=m;k++)\n\t\t\t{\n\t\t\t\tfor(int l=0;l<=i&&k+j+l<=m;l++) add(f[i+1][j][k+j+l],1ll*C[i][l]*f[i][j][k]%p);\n\t\t\t\tfor(int l=0;l<=j&&k+l<=m;l++) add(f[i][j+1][k+l],1ll*C[j][l]*f[i][j][k]%p);\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=0;i<=n;i++) add(ans,f[i][n-i][m]);\n\tadd(ans,p-C[n*(n-1)/2][m]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"结论"},{"name":"组合计数"},{"name":"DP"}],
			"title": "ARC163D Sum of SCC 做题记录",
			"link": "https://exber.qzz.io/post/ARC163D%20Sum%20of%20SCC%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-07-03 21:32:26"
		},
	
		{
			"abstract": ">给你一个 $n\\times n$ 的矩阵 $a$ 和一个正整数 $k$，你可以对 $a$ 进行任意次操作（可以不操作），操作的具体步骤如下：\n>\n>- 选择矩阵 $a$ 的一个正方形子矩阵；\n>- 选择一个正整数数 $x$，其中 $1\\leq x\\leq n^2$；\n>- 将子矩阵内的所有元素修改为 $x$。\n>\n>你需要求出使矩阵 $a$ 恰好包含 $k$ 个不同元素所需的最小操作次数。\n>\n>$1\\le n\\le 500,1\\le k\\le n^2$。\n",
			"content": ">给你一个 $n\\times n$ 的矩阵 $a$ 和一个正整数 $k$，你可以对 $a$ 进行任意次操作（可以不操作），操作的具体步骤如下：\n>\n>- 选择矩阵 $a$ 的一个正方形子矩阵；\n>- 选择一个正整数数 $x$，其中 $1\\leq x\\leq n^2$；\n>- 将子矩阵内的所有元素修改为 $x$。\n>\n>你需要求出使矩阵 $a$ 恰好包含 $k$ 个不同元素所需的最小操作次数。\n>\n>$1\\le n\\le 500,1\\le k\\le n^2$。\n\n\n设操作前有 $cnt$ 个不同元素，那么若 $k\\ge cnt$ 则答案一定是 $k-cnt$，因为一次操作最多增加一个不同元素。\n\n考虑 $k<cnt$ 的情况，可以证明最多只需要两次操作：\n\n- 考虑选择一个以 $(1,1)$ 为左上角的最大的正方形使得它全部替换成 $a_{1,1}$ 后 $a$ 中不同元素个数 $\\ge k$ 且最小；\n\n- 接下来这样选择第二个正方形：\n\n  ![](../post-images/1687416490220.png)\n\n  因为这个正方形可以选择与第一个的 $x$ 相同或不同，所以总有一个满足操作完之后 $a$ 中恰好有 $k$ 个不同元素；\n\n那么只用判断 $1$ 次和 $0$ 次是否可以即可，做法很显然。\n",
			"tags": [{"name":"做题记录"},{"name":"构造"},{"name":"结论"}],
			"title": "CF1720E Misha and Paintings 做题记录",
			"link": "https://exber.qzz.io/post/CF1720E%20Misha%20and%20Paintings%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-06-22 14:47:57"
		},
	
		{
			"abstract": "> 给你一个 $N\\times M$ 的矩阵，要求在每一个格子内填一个不超过 $10^8$ 的正整数，使得每一行和每一列的数的平方和仍然是一个平方数。\n>\n> $1\\le n,m\\le 100$。\n",
			"content": "> 给你一个 $N\\times M$ 的矩阵，要求在每一个格子内填一个不超过 $10^8$ 的正整数，使得每一行和每一列的数的平方和仍然是一个平方数。\n>\n> $1\\le n,m\\le 100$。\n\n\n降至了，构造矩阵等价于构造一行 $a_i$ 和一列 $b_i$，每个格子 $(i,j)$ 为 $a_ib_j$。\n\n那么行列可以分开构造，并且行列等价，所以问题转化为了构造长度为 $n$ 的整数数组 $a_i$ 满足 $1\\le a_i\\le 10^4$ 且 $\\sum a_i^2$ 是平方数。\n\n这很简单，只需要构造\n$$\n\\{4,4,4,4,\\dots,4n-5\\}\n$$\n即可，代码如下：\n\n```cpp\n// Problem: Square Table\n// Contest: Luogu\n// URL: https://www.luogu.com.cn/problem/CF417E\n// Memory Limit: 250 MB\n// Time Limit: 1000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=100005;\n\nint n,m;\nint a[S],b[S];\n\ninline void slove(int n,int a[])\n{\n\tif(n==1) return a[1]=1,void();\n\tfor(int i=1;i<=n-1;i++) a[i]=4;\n\ta[n]=4*n-5;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tslove(n,a),slove(m,b);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=m;j++) printf(\"%d \",a[i]*b[j]);\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"构造"},{"name":"数论"}],
			"title": "CF417E Square Table 做题记录",
			"link": "https://exber.qzz.io/post/CF417E%20Square%20Table%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-06-16 22:38:16"
		},
	
		{
			"abstract": ">给定一个 $n$ 个点 $m$ 条边的无向连通图（无重边自环）和一个 $1\\le k\\le n$ 的 $k$，每个点的度数至少为 $3$。你需要找到以下两个东西的其中一个：\n>\n>- 一条有 $k$ 个节点的链；\n>- $\\lceil\\frac{n}{k}\\rceil$ 个环，满足每个环的大小 $>3$ 且不是 $3$ 的倍数，且每个环都有至少一个节点在这些环中仅出现一次；\n>\n>$1\\le n\\le 2.5\\times 10^5,1\\le m\\le 5\\times 10^5,1\\le k\\le n$\n",
			"content": ">给定一个 $n$ 个点 $m$ 条边的无向连通图（无重边自环）和一个 $1\\le k\\le n$ 的 $k$，每个点的度数至少为 $3$。你需要找到以下两个东西的其中一个：\n>\n>- 一条有 $k$ 个节点的链；\n>- $\\lceil\\frac{n}{k}\\rceil$ 个环，满足每个环的大小 $>3$ 且不是 $3$ 的倍数，且每个环都有至少一个节点在这些环中仅出现一次；\n>\n>$1\\le n\\le 2.5\\times 10^5,1\\le m\\le 5\\times 10^5,1\\le k\\le n$\n\n\n考虑 dfs 树，有一个结论是若一棵树的最大深度（根节点深度为 $1$） $< k$，则一定有至少 $\\lceil\\frac{n}{k}\\rceil$ 个叶子。\n\n> 若叶子个数小于 $\\lceil\\frac{n}{k}\\rceil$，那么由于所有叶子的深度都 $<k$，所以所有叶子的深度之和一定 $<n$，这显然做不到，因为一个点会至少贡献 $1$。\n\n那么考虑在 dfs 树最大深度 $<k$ 选出 $\\lceil\\frac{n}{k}\\rceil$ 个环，保证每个叶子至多仅出现一次。由于每个点的度数都 $\\ge 3$ 且无重边，所以设某个叶子 $u$ 的深度为 $du$，其中一条返祖边连接的点深度为 $da$，另一条返祖边深度为 $db$，且 $du>da>db$，则：\n\n- 有三个包含 $u$ 和这两个祖先的环，长度分别为：$du-da+1$、$du-db+1$、$da-db+2$；\n- 前两个不能选当且仅当 $du-da\\equiv du-db\\equiv 2\\pmod 3$ 即 $da\\equiv db\\pmod 3$，而这时第三个恰好能选；\n- 所以这三个环中一定有一个环满足条件；\n\n那么求一次 dfs 树即可。\n\n时间复杂度 $O(n)$。\n\n代码如下：\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=1000005;\n\nint n,m,k;\nint esum,to[S],nxt[S],h[S];\nbool vis[S],f[S];\nint dep[S],fat[S];\n\ninline void add(int x,int y)\n{\n\tto[++esum]=y;\n\tnxt[esum]=h[x];\n\th[x]=esum;\n}\n\nvoid dfs(int u)\n{\n\tvis[u]=true;\n\tf[u]=true;\n\tfor(int i=h[u];i;i=nxt[i])\n\t{\n\t\tint v=to[i];\n\t\tif(!vis[v]) f[u]=false,dep[v]=dep[u]+1,fat[v]=u,dfs(v);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tint tk=k;\n\tk=n/k+!!(n%k);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y),add(y,x);\n\t}\n\tdep[1]=1;\n\tdfs(1);\n\tint mx=0;\n\tfor(int i=1;i<=n;i++) if(dep[i]>dep[mx]) mx=i;\n\tif(dep[mx]>=k)\n\t{\n\t\tputs(\"PATH\");\n\t\tprintf(\"%d\\n\",k);\n\t\tfor(int i=1;i<=k;i++) printf(\"%d \",mx),mx=fat[mx];\n\t\tprintf(\"\\n\");\n\t}\n\telse\n\t{\n\t\tputs(\"CYCLES\");\n\t\tfor(int u=1;u<=n&&tk>0;u++)\n\t\t{\n\t\t\tif(f[u])\n\t\t\t{\n\t\t\t\ttk--;\n\t\t\t\tint a=0,b=0;\n\t\t\t\tfor(int i=h[u];i;i=nxt[i])\n\t\t\t\t{\n\t\t\t\t\tint v=to[i];\n\t\t\t\t\tif(v==fat[u]) continue;\n\t\t\t\t\tif(a==0) a=v;\n\t\t\t\t\telse b=v;\n\t\t\t\t}\n\t\t\t\tif(dep[a]<dep[b]) swap(a,b);\n\t\t\t\tif((dep[u]-dep[a]+1)%3!=0)\n\t\t\t\t{\n\t\t\t\t\tprintf(\"%d\\n\",dep[u]-dep[a]+1);\n\t\t\t\t\tint x=u;\n\t\t\t\t\twhile(x!=a) printf(\"%d \",x),x=fat[x];\n\t\t\t\t\tprintf(\"%d\\n\",a);\n\t\t\t\t}\n\t\t\t\telse if((dep[u]-dep[b]+1)%3!=0)\n\t\t\t\t{\n\t\t\t\t\tprintf(\"%d\\n\",dep[u]-dep[b]+1);\n\t\t\t\t\tint x=u;\n\t\t\t\t\twhile(x!=b) printf(\"%d \",x),x=fat[x];\n\t\t\t\t\tprintf(\"%d\\n\",b);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tprintf(\"%d\\n\",dep[a]-dep[b]+2);\n\t\t\t\t\tint x=a;\n\t\t\t\t\twhile(x!=b) printf(\"%d \",x),x=fat[x];\n\t\t\t\t\tprintf(\"%d %d\\n\",b,u);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"构造"},{"name":"图论"},{"name":"结论"}],
			"title": "CF1103C Johnny Solving 做题记录",
			"link": "https://exber.qzz.io/post/CF1103C%20Johnny%20Solving%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-06-13 18:15:15"
		},
	
		{
			"abstract": "> 有 $n$ 个点，每个点有 $l_i,r_i$ 两个值，有 $m$ 条有向边 $(s_i,t_i)$，你要给每个点确定一个权值 $a_i$，满足以下条件：\n> \n> - $a_i$ 是 $n$ 的排列；\n> - 对于所有 $1\\le i\\le m$ 均有 $a_{s_i}<a_{t_i}$；\n> - 对于所有 $1\\le i\\le n$ 均有 $l_i\\le a_i\\le r_i$；\n> \n> 判断无解。\n> \n> $2\\le n\\le 2\\times 10^5$，$0\\le m\\le \\min(n(n-1),4\\times 10^5)$，$i\\not=j\\Rightarrow s_i\\not=s_j$。\n",
			"content": "> 有 $n$ 个点，每个点有 $l_i,r_i$ 两个值，有 $m$ 条有向边 $(s_i,t_i)$，你要给每个点确定一个权值 $a_i$，满足以下条件：\n> \n> - $a_i$ 是 $n$ 的排列；\n> - 对于所有 $1\\le i\\le m$ 均有 $a_{s_i}<a_{t_i}$；\n> - 对于所有 $1\\le i\\le n$ 均有 $l_i\\le a_i\\le r_i$；\n> \n> 判断无解。\n> \n> $2\\le n\\le 2\\times 10^5$，$0\\le m\\le \\min(n(n-1),4\\times 10^5)$，$i\\not=j\\Rightarrow s_i\\not=s_j$。\n\n不难发现若不是 DAG 则无解。\n\n观察到 $r_{s_i}$ 实际上可以和 $r_{t_i}-1$ 取 $\\min$，因为 $a_{s_i}<a_{t_i}$。那么先倒着拓扑一遍求出取完 $\\min$ 的 $r_i$。\n\n先来考虑没有 $l_i$ 限制该怎么做，显然拓扑排序的时候每次新入队的 $r_v$ 都会大于把它入队的 $r_u$，那么使用优先队列拓扑，每次选 $r_u$ 最小的 $u$ 来拓展一定是最优的。\n\n考虑有 $l_i$ 限制的情况下怎么办，考虑建立一个“寄存器”$vec$。拓扑前先把所有入度为 $0$ 的点 $u$ 放进 $vec_{l_u}$，然后从 $1$ 到 $n$ 遍历，遍历到 $i$ 时把 $vec_i$ 内的所有元素入队，并取出一个元素 $x$，让 $ans_x=i$ 然后拓展 $x$。$v$ 入队的时候：\n\n- $l_v>i$：先存到 $vec_{l_v}$ 里；\n- $l_v\\le i$：直接入队；\n\n这样就能保证 $ans_i\\ge l_i$，消除了 $l_i$ 的限制。\n\n代码如下：\n\n```cpp\n// Problem: [ABC304Ex] Constrained Topological Sort\n// Contest: Luogu\n// URL: https://www.luogu.com.cn/problem/AT_abc304_h\n// Memory Limit: 1 MB\n// Time Limit: 3000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\\\n\n#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nconst int S=200005;\n\nint n,m;\nint l[S],r[S];\nvector<int> g1[S],g2[S];\nint ind[S];\nvector<int> idx[S];\nint ans[S];\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tg1[x].push_back(y),g2[y].push_back(x);\n\t}\n\tfor(int i=1;i<=n;i++) scanf(\"%d%d\",&l[i],&r[i]);\n\tqueue<int> q;\n\tfor(int i=1;i<=n;i++) ind[i]=g1[i].size();\n\tfor(int i=1;i<=n;i++) if(ind[i]==0) q.push(i);\n\twhile(!q.empty())\n\t{\n\t\tint u=q.front();\n\t\tq.pop();\n\t\tfor(int v:g2[u])\n\t\t{\n\t\t\tr[v]=min(r[v],r[u]-1);\n\t\t\tif(--ind[v]==0) q.push(v);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++) if(ind[i]!=0) return puts(\"No\"),0;\n\tpriority_queue<pair<int,int>> q2;\n\tfor(int i=1;i<=n;i++) ind[i]=g2[i].size();\n\tfor(int i=1;i<=n;i++) if(ind[i]==0) idx[l[i]].push_back(i);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j:idx[i]) q2.push(make_pair(-r[j],j));\n\t\tif(q2.empty()) return puts(\"No\"),0;\n\t\tint u=q2.top().second;\n\t\tq2.pop();\n\t\tans[u]=i;\n\t\tfor(int v:g1[u])\n\t\t{\n\t\t\tif(--ind[v]==0)\n\t\t\t{\n\t\t\t\tif(l[v]>i) idx[l[v]].push_back(v);\n\t\t\t\telse q2.push(make_pair(-r[v],v));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++) if(ans[i]<l[i]||ans[i]>r[i]) return puts(\"No\"),0;\n\tputs(\"Yes\");\n\tfor(int i=1;i<=n;i++) printf(\"%d \",ans[i]);\n\tprintf(\"\\n\");\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"杂题"},{"name":"贪心"},{"name":"图论"},{"name":"结论"}],
			"title": "ABC304Ex Constrained Topological Sort 做题记录",
			"link": "https://exber.qzz.io/post/ABC304Ex%20Constrained%20Topological%20Sort%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-06-06 13:41:17"
		},
	
		{
			"abstract": "> 给定 $n$ 和字符集大小 $k$ 以及一个 $0\\sim n-1$ 的排列 $sa$，求有多少个长 $n$，字符集大小 $k$ ，从 $0$ 开始标号的字符串 $s$ 满足把 $a=\\{0,1,2,\\dots,n-1\\}$ 按照 $s_{[i,n-1]}$ 字典序排序后满足 $a=sa$。\n>\n> 即生成的后缀数组是 $sa$。\n>\n> $1\\le n,k\\le 2\\times 10^5$。\n",
			"content": "> 给定 $n$ 和字符集大小 $k$ 以及一个 $0\\sim n-1$ 的排列 $sa$，求有多少个长 $n$，字符集大小 $k$ ，从 $0$ 开始标号的字符串 $s$ 满足把 $a=\\{0,1,2,\\dots,n-1\\}$ 按照 $s_{[i,n-1]}$ 字典序排序后满足 $a=sa$。\n>\n> 即生成的后缀数组是 $sa$。\n>\n> $1\\le n,k\\le 2\\times 10^5$。\n\n\n首先设 $rk$ 为满足 $sa_{rk_i}=i$ 的数组，即 $s_{[i,n-1]}$ 的排名。\n\n那么观察 $sa_i$ 和 $sa_{i+1}$，必有 $s_{sa_i}\\le s_{sa_{i+1}}$。考虑什么时候能取到等号，显然 $rk_{sa_i+1}<rk_{sa_{i+1}+1}$ 时才行。\n\n那么统计出能取等号的位置个数 $cnt$，则答案为 $\\sum\\limits_{i=0}^{cnt}\\binom{cnt}{i}\\binom{k}{n-i}=\\binom{cnt+k}{n}$。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=400005,p=998244353;\n\nint n,k,a[S],b[S];\nint fra[S],inv[S];\n\ninline int qpow(int x,int y)\n{\n\tint res=1;\n\tfor(;y>0;y>>=1,x=1ll*x*x%p) res=y&1?1ll*res*x%p:res;\n\treturn res;\n}\n\ninline int C(int n,int m)\n{\n\tif(n<m) return 0;\n\treturn 1ll*fra[n]*inv[n-m]%p*inv[m]%p;\n}\n\nint main()\n{\n\tfra[0]=1;\n\tfor(int i=1;i<=S-3;i++) fra[i]=1ll*fra[i-1]*i%p;\n\tinv[S-3]=qpow(fra[S-3],p-2);\n\tfor(int i=S-3;i>=1;i--) inv[i-1]=1ll*inv[i]*i%p;\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]),b[++a[i]]=i;\n\tb[n+1]=0;\n\tint cnt=0;\n\tfor(int i=1;i<=n-1;i++) cnt+=b[a[i]+1]<b[a[i+1]+1];\n\tprintf(\"%d\\n\",C(cnt+k,n));\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"结论"},{"name":"字符串"}],
			"title": "CF1526E Oolimry and Suffix Array 做题记录",
			"link": "https://exber.qzz.io/post/CF1526E%20Oolimry%20and%20Suffix%20Array%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-06-01 18:19:07"
		},
	
		{
			"abstract": "> 一开始黑板上有一个正奇数 $x\\ (3\\le x<10^6)$，每次你可以选定黑板上已有的正整数 $a,b$（可以相等），将 $a+b$ 或 $a \\oplus b$ 写在黑板上，其中 $\\oplus$ 表示异或运算，最终目标是将 $1$ 写在黑板上。要求写数字不超过 $10^5$ 次且写上的数字不超过 $5*10^{18}$ 。\n",
			"content": "> 一开始黑板上有一个正奇数 $x\\ (3\\le x<10^6)$，每次你可以选定黑板上已有的正整数 $a,b$（可以相等），将 $a+b$ 或 $a \\oplus b$ 写在黑板上，其中 $\\oplus$ 表示异或运算，最终目标是将 $1$ 写在黑板上。要求写数字不超过 $10^5$ 次且写上的数字不超过 $5*10^{18}$ 。\n\n首先设 $x$ 的二进制最高位是 $2^y$，那么一定有 $\\gcd(2^{y-1}x\\oplus x,x)=1$，因为 $2^{y-1}x\\oplus x=2^{y-1}x+x-2^y$，而：\n$$\n\\gcd(2^{y-1}x+x-2^y,x)=\\gcd((-2^y)\\operatorname{mod} x,x)=1\n$$\n不妨设 $tx=2^{y-1}x\\oplus x$，那么我的想法是用 $\\operatorname{exgcd}$ 解出 $(a+ad)\\times x+(b+ad)\\times tx=ad(x+tx)+1$ 使得 $0\\le a+ad,b+ad$。但是 $a+ad$ 和 $b+ad$ 和 $x$ 与 $tx$ 是一个级别的，而 $tx$ 是 $10^{12}$ 级别的，那么 $(b+ad)\\times tx$ 是 $10^{24}$ 级别，超出了范围限制。\n\n看题解后发现不需要那么麻烦，只需要找到 $tx^{-1}\\operatorname{mod} x$ 就行了。这样构造出的解是 $10^{18}$ 级别，刚刚好。\n\n似乎还有另一种不断消除最高位的方法：\n\n> 首先设 $x$ 的二进制最高位为 $2^{hi}$，那么令 $y=2^{hi-1}x$ 即最低位与最高位对齐：\n>\n> ```\n> x = 000111\n> 000111 + 000111 = 001110, 001110 + 001110 = 011100\n> y = 011100\n> ```\n> 然后设 $z=x\\oplus y$，消掉 $x$ 的最高位：\n>\n> ```\n> 011100 ^ 000111 = 011011\n> z = 011011\n> ```\n>\n> 接下来设 $h=z+y$，使得后面是 $x$，前面是 $2(y-1)$：\n>\n> ```\n> 011011 + 011100 = 110111\n> h = 110111\n> ```\n>\n> 然后设 $w=h\\oplus x$，取得 $2(y-1)$：\n>\n> ```\n> 110111 ^ 000111 = 110000\n> h = 110000\n> ```\n>\n> 接下来令 $k=w\\oplus 2y$，取得 $2^{hi+1}$：\n>\n> ```\n> 011100 + 011100 = 111000\n> 111000 ^ 110000 = 001000\n> k = 001000\n> ```\n>\n> 那么接下来就好办了，通过 $k$ 与 $y$ 取得 $2^{hi}$ 即可：\n>\n> ```\n> 011100 ^ 001000 = 010100\n> 001000 + 001000 = 010000\n> 010100 ^ 010000 = 000100\n> 000111 ^ 000100 = 000011\n> ```\n>\n> 这样就成功地消除了最高位。\n\n\n代码如下：（利用互质的方法）\n\n```cpp\n// Problem: Xum\n// Contest: Luogu\n// URL: https://www.luogu.com.cn/problem/CF1427E\n// Memory Limit: 250 MB\n// Time Limit: 2000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=100005;\n\nstruct node\n{\n\tint tpe;\n\tlong long x,y;\n}ans[S];\n\nlong long x;\nint tot;\n\ninline void add(int tpe,long long x,long long y){ans[++tot]=(node){tpe,x,y};}\n\ninline long long calcphi(long long x)\n{\n\tlong long px=x;\n\tfor(long long i=2;i*i<=x;i++)\n\t{\n\t\tif(x%i==0) px=px/i*(i-1);\n\t\twhile(x%i==0) x/=i;\n\t}\n\tif(x>1) px=px/x*(x-1);\n\treturn px;\n}\n\ninline long long qpow(long long x,long long y,long long p)\n{\n\tx%=p;\n\tlong long res=1;\n\tfor(;y>0;y>>=1,x=x*x%p) res=y&1?res*x%p:res;\n\treturn res;\n}\n\ninline void fstmul(long long a,long long b)\n{\n\tlong long res=0;\n\tfor(;b>0;b>>=1,add(1,a,a),a+=a) res=b&1?add(1,res,a),res+a:res;\n}\n\nint main()\n{\n\tscanf(\"%lld\",&x);\n\tadd(2,x,x);\n\tint cnt=0;\n\tlong long tx=x;\n\twhile(tx>0) tx>>=1,cnt++;\n\tfstmul(x,1<<cnt-1);\n\tadd(2,x,x*(1<<cnt-1)),tx=x^(x*(1<<cnt-1));\n\tlong long val=qpow(tx,calcphi(x)-1,x);\n\tfstmul(tx,val),tx*=val;\n\tfstmul(x,tx/x);\n\tlong long a=tx/x*x,b=tx;\n\tif(a&1) add(1,a,x),a+=x,add(1,b,x),b+=x;\n\tadd(2,a,b);\n\tprintf(\"%d\\n\",tot);\n\tfor(int i=1;i<=tot;i++)\n\t{\n\t\tif(ans[i].tpe==1) printf(\"%lld + %lld\\n\",ans[i].x,ans[i].y);\n\t\tif(ans[i].tpe==2) printf(\"%lld ^ %lld\\n\",ans[i].x,ans[i].y);\n\t}\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"构造"}],
			"title": "CF1427E Xum 做题记录",
			"link": "https://exber.qzz.io/post/CF1427E%20Xum%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-05-28 12:15:52"
		},
	
		{
			"abstract": "> 给定 $n$ 和两个长 $n$ 的 $01$ 串 $S$ 与 $T$。\n>\n> 设入栈序列为 $S$，出栈序列为 $T$ 的所有栈操作序列中，$T_1$ 可能对应的 $S$ 中的下标集合为 $A$。\n>\n> 求 $\\sum\\limits_{x\\in A}x$。\n>\n> 例如 $S=100$，$T=001$ 时答案为 $5$，因为共有 $2$ 种栈操作序列满足入栈序列为 $S$，出栈序列为 $T$：\n>\n> - 进，进，进，出，出，出，此时 $T_1$ 来自 $S_3$；\n> - 进，进，出，进，出，出，此时 $T_1$ 来自 $S_2$；\n>\n> 所以答案为 $3+2=5$。\n>\n> $1\\le n\\le 5\\times 10^6$。\n",
			"content": "> 给定 $n$ 和两个长 $n$ 的 $01$ 串 $S$ 与 $T$。\n>\n> 设入栈序列为 $S$，出栈序列为 $T$ 的所有栈操作序列中，$T_1$ 可能对应的 $S$ 中的下标集合为 $A$。\n>\n> 求 $\\sum\\limits_{x\\in A}x$。\n>\n> 例如 $S=100$，$T=001$ 时答案为 $5$，因为共有 $2$ 种栈操作序列满足入栈序列为 $S$，出栈序列为 $T$：\n>\n> - 进，进，进，出，出，出，此时 $T_1$ 来自 $S_3$；\n> - 进，进，出，进，出，出，此时 $T_1$ 来自 $S_2$；\n>\n> 所以答案为 $3+2=5$。\n>\n> $1\\le n\\le 5\\times 10^6$。\n\n\n首先有个结论，对于任意两个 $0$ 的个数相等且 $1$ 的个数相等的 $01$ 序列 $A$ 与 $B$，总有合法的栈操作序列满足入栈序列为 $A$ 且出栈序列为 $B$。\n\n证明十分简单，考虑贪心，从左往右逐位考虑 $A$，设当前出栈序列已经匹配 $j$ 个，则若栈顶元素 $x\\not=B_{j+1}$ 且 $A_i\\not=B_{j+1}$ 则 $A_i$ 入栈， 否则 $j\\to j+1$。这样栈中不会同时出现两种不同元素，一定可以构造出来。\n\n考虑从 $1$ 开始，逐个确定 $S_i$ 是否有可能去到 $T_1$。先不考虑 $S_i\\not= T_1$ 的情况，那么若 $S_i$ 去了 $T_1$，则 $S_i$ 出栈时 $S_{[1,i-1]}$ 一定都在栈中。\n\n所以可以找到 $i\\le j\\le pos_{i-1}$ 且 $S_{[i,j]}$ 中 $0$ 的个数等于 $T_{[1,j-i+1]}$ 中 $0$ 的个数的最大的 $j$，令 $pos_i=j$；找不到则 $pos_i=-1$，求出 $pos_i$ 后可以这样构造：\n\n![](../post-images/1684567431053.png)\n\n那么显然答案即为 $\\sum\\limits_{pos_i\\not=-1}i$，问题变成求解 $pos_i$，双指针即可，时间复杂度 $O(n)$。\n\n代码如下：\n\n```cpp\n// Problem: B. Cilantro\n// Contest: XXII Open Cup, Grand Prix of Korea\n// URL: https://codeforces.com/gym/103371/problem/B\n// Memory Limit: 1024 MB\n// Time Limit: 500 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=5000005;\n\nint n;\nchar a[S],b[S];\nint sa[S],sb[S];\nint pos[S];\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tscanf(\"%s%s\",a+1,b+1);\n\tfor(int i=1;i<=n;i++) sa[i]=sa[i-1]+(a[i]=='Y'),sb[i]=sb[i-1]+(b[i]=='Y');\n\tfor(int i=1,r=n;i<=n;i++)\n\t{\n\t\twhile(r>=i&&sa[r]-sa[i-1]!=sb[r-i+1]) r--;\n\t\tpos[i]=r;\n\t}\n\tlong long ans=0;\n\tfor(int i=1;i<=n;i++) if(pos[i]>=i&&a[i]==b[1]) ans+=i;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"结论"}],
			"title": "GYM103371B Cilantro 做题记录",
			"link": "https://exber.qzz.io/post/GYM103371B%20Cilantro%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-05-20 14:55:34"
		},
	
		{
			"abstract": "> 有一个 $n\\times n$ 的棋盘，你要在上面放最少数量的”半皇后“，使得每个格子都能被攻击到。\n>\n> 一个位于 $(x,y)$ 的 ”半皇后“ 能攻击到 $(a,b)$ 当且仅当满足以下条件中至少一个：\n>\n> - $a=x$；\n> - $b=y$；\n> - $a-b=x-y$；\n>\n> 输出方案。\n>\n> $1\\le n\\le 10^5$。\n",
			"content": "> 有一个 $n\\times n$ 的棋盘，你要在上面放最少数量的”半皇后“，使得每个格子都能被攻击到。\n>\n> 一个位于 $(x,y)$ 的 ”半皇后“ 能攻击到 $(a,b)$ 当且仅当满足以下条件中至少一个：\n>\n> - $a=x$；\n> - $b=y$；\n> - $a-b=x-y$；\n>\n> 输出方案。\n>\n> $1\\le n\\le 10^5$。\n\n\n设有 $k$ 个”半皇后“ 就能攻击到所有格子，那么首先不考虑斜着的攻击，则横竖攻击覆盖之后还剩下 $(n-k)\\times (n-k)$ 的子矩阵没有被攻击到，需要使用斜着的攻击。\n\n考虑这个子矩阵的第一行第一列，一共有 $2n-2k-1$ 个格子，并且每个格子所在的对角线都不同，并且只要用斜着的攻击覆盖到这些格子就能覆盖完整个子矩阵。\n\n所以至少需要 $2n-2k-1$ 个”半皇后“才能斜着覆盖这些格子，那么可以列出不等式 $2n-2k-1\\le k$，所以 $k\\ge \\frac{2n-1}{3}$，那么 $k$ 的理论下界就是 $\\left\\lceil \\frac{2n-1}{3}\\right\\rceil$。\n\n考虑怎么构造能取到这个下界，显然若 $n\\equiv 2\\pmod 3$ 则可以直接这样构造：\n\n![](../post-images/1684500487686.png)\n\n而若 $n\\not\\equiv 2\\pmod 3$ 就可以在左上角或者右下角放来变成 $n\\equiv 2\\pmod 3$ 的情况。\n\n代码如下：\n\n```cpp\n// Problem: Half Queen Cover\n// Contest: Luogu\n// URL: https://www.luogu.com.cn/problem/CF1667C\n// Memory Limit: 250 MB\n// Time Limit: 1000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nint n;\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tprintf(\"%d\\n\",(n*2-1)/3+((n*2-1)%3!=0));\n\tif(n==1) return puts(\"1 1\"),0;\n\tint f=0;\n\tif(n%3==0) printf(\"%d %d\\n\",1,1),n--,f=1;\n\telse if(n%3==1) printf(\"%d %d\\n\",1,1),printf(\"%d %d\\n\",n,n),n-=2,f=1;\n\tint cnt=(n*2-1)/3;\n\tfor(int i=1;i<=cnt/2;i++) printf(\"%d %d\\n\",f+n-cnt+cnt/2-i+1,f+n-cnt+i);\n\tfor(int i=1;i<=(cnt+1)/2;i++) printf(\"%d %d\\n\",f+n-(cnt+1)/2+i,f+n-i+1);\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"构造"},{"name":"数学"}],
			"title": "CF1667C Half Queen Cover 做题记录",
			"link": "https://exber.qzz.io/post/CF1667C%20Half%20Queen%20Cover%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-05-19 20:46:59"
		},
	
		{
			"abstract": "> 给定 $n$，求满足以下条件的集合 $S\\in\\{0,1,2,\\dots,2^n-1\\}$ 的个数：\n>\n> 对于所有 $S$ 的非空子集 $T\\in S$，$T$ 均满足以下条件中的至少一个：\n>\n> - $|T|$ 是奇数；\n> - $T$ 中元素的异或和非零；\n>\n> 对 $998244353$ 取模。\n>\n> $1\\le n\\le 2\\times 10^5$。\n",
			"content": "> 给定 $n$，求满足以下条件的集合 $S\\in\\{0,1,2,\\dots,2^n-1\\}$ 的个数：\n>\n> 对于所有 $S$ 的非空子集 $T\\in S$，$T$ 均满足以下条件中的至少一个：\n>\n> - $|T|$ 是奇数；\n> - $T$ 中元素的异或和非零；\n>\n> 对 $998244353$ 取模。\n>\n> $1\\le n\\le 2\\times 10^5$。\n\n\n不难发现只要把每个元素都加上 $2^n$，条件就转化为 $S$ 的所有非空子集的异或和均不为 $0$。\n\n考虑一个一个元素加入，假设现在 $S$ 中有 $i$ 个元素，则这 $i$ 个元素任意组合出来的 $2^i$ 个元素一定两两不同，其中有 $2^{i-1}$ 个元素第 $n+1$ 位为 $1$，那么新插入的 $x$ 就有 $2^n-2^{i-1}$ 种方案。\n\n注意第一个元素有 $2^n$ 种方案。\n\n但是这样插入是有序的，集合是无序的，所以需要乘上 $\\frac{1}{(|S|)!}$\n\n也就是说，答案为：\n$$\n\\sum\\limits_{k=0}^{n+1} \\frac{2^n\\prod\\limits_{i=1}^{k-1}(2^n-2^{i-1})}{k!}\n$$\n上界是 $n+1$ 是因为插入多于 $n$ 个元素后集合中必然能异或出 $0$（线性基满了），这个东西很容易快速维护。\n\n代码如下：\n\n```cpp\n// Problem: [ARC146C] Even XOR\n// Contest: Luogu\n// URL: https://www.luogu.com.cn/problem/AT_arc146_c\n// Memory Limit: 1 MB\n// Time Limit: 2000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int p=998244353,S=200005;\n\nint n,pw2[S],prod[S];\n\ninline int qpow(int x,int y)\n{\n\tint res=1;\n\tfor(;y>0;y>>=1,x=1ll*x*x%p) res=y&1?1ll*res*x%p:res;\n\treturn res;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tpw2[0]=1;\n\tfor(int i=1;i<=n+1;i++) pw2[i]=1ll*pw2[i-1]*2%p;\n\tprod[0]=pw2[n];\n\tfor(int i=1;i<=n;i++) prod[i]=1ll*prod[i-1]*(pw2[n]-pw2[i-1]+p)%p;\n\tint ans=1; // k=0\n\tfor(int k=1,fra=1;k<=n+1;k++)\n\t{\n\t\tfra=1ll*fra*k%p;\n\t\tans=(ans+1ll*prod[k-1]*qpow(fra,p-2)%p)%p;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"数学"},{"name":"组合计数"}],
			"title": "ARC146C Even XOR 做题记录",
			"link": "https://exber.qzz.io/post/ARC146C%20Even%20XOR%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-05-15 18:15:45"
		},
	
		{
			"abstract": "",
			"content": "### 算法简介\n\nBoruvka 算法是一种用来求解最小生成树的算法，它的流程如下：\n\n1. 刚开始每个点自己为一个连通块，接下来执行步骤 2 至 3 直到所有点在同一个连通块中；\n2. 对于每个连通块 $i$，找到距离它最近，不在连通块中且与连通块有直接连边的点 $to_i$，记离 $to_i$ 最近的连通块中的点为 $ou_i$；\n3. 对于每个连通块 $i$，若 $ou_i$ 与 $to_i$ 不在同一连通块中，则在生成树中新增边 $(ou_i,to_i)$，合并 $ou_i$ 和 $to_i$ 所在的连通块；\n\n这样每次合并连通块后连通块个数至少会减半，所以时间复杂度是 $O((T+n)\\log n)$ 的，其中 $T$ 是步骤 $2$ 的时间复杂度。\n\n这个算法在最小生成树板子上的表现平平无奇，但是却十分擅长处理边很多的图（稠密图）的最小生成树问题。\n\n### 经典例题\n\n##### [AT_cf17_final_j Tree MST](https://www.luogu.com.cn/problem/AT_cf17_final_j)\n\n> 给定一棵 $n$ 个节点的树，现有有一张完全图，两点 $x,y$ 之间的边长为 $w_x+w_y+dis_{x,y}$，其中 $dis$ 表示树上两点的距离。\n>\n> 求完全图的最小生成树。\n>\n> $n \\leq 2 \\times 10^5$。\n\n<details><summary>题解</summary><p>\n\n直接上 Boruvka，找 $ou_i$ 和 $to_i$ 可以做一次 up and down DP。注意到 $x$ 到其它点的路径可以看作是向上走再向下走，那么跑两次 dfs。第一遍 dfs 从根把信息上推，求出每个节点距离其子树内**最近**和**与最近点不在一个连通块的最近的点**；第二遍 dfs 把信息下放，下放到 $x$ 的时候就能求出距离 $x$ 最近的与 $x$ 不在一个连通块中的点。\n\n时间复杂度 $O(n\\log n)$。\n\n代码如下：\n\n```cpp\n// Problem: Tree MST\n// Contest: Luogu\n// URL: https://www.luogu.com.cn/problem/AT_cf17_final_j\n// Memory Limit: 256 MB\n// Time Limit: 5000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nconst int S=500005;\n\nint n;\nlong long w[S];\nint esum,to[S],nxt[S],h[S];\nlong long c[S],dep[S];\nint col[S];\nint ansid[S];\nlong long ans[S];\n\nstruct node\n{\n\tint id;\n\tint id0,id1;\n\tlong long mn0,mn1;\n\tinline void init()\n\t{\n\t\tid=id0=id1=0;\n\t\tmn0=mn1=1e17;\n\t}\n\tinline void operator+=(node &b)\n\t{\n\t\tvector<pair<long long,int>> vec;\n\t\tvec.push_back(make_pair(mn0,id0));\n\t\tvec.push_back(make_pair(mn1,id1));\n\t\tvec.push_back(make_pair(b.mn0,b.id0));\n\t\tvec.push_back(make_pair(b.mn1,b.id1));\n\t\tsort(vec.begin(),vec.end());\n\t\tid0=vec[0].second,mn0=vec[0].first;\n\t\tfor(int i=1;i<4;i++)\n\t\t{\n\t\t\tif(col[vec[i].second]!=col[id0])\n\t\t\t{\n\t\t\t\tid1=vec[i].second,mn1=vec[i].first;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}dp[S];\n\ninline void add(int x,int y,long long w)\n{\n\tto[++esum]=y;\n\tc[esum]=w;\n\tnxt[esum]=h[x];\n\th[x]=esum;\n}\n\nvoid initdep(int u,int fa)\n{\n\tfor(int i=h[u];i;i=nxt[i])\n\t{\n\t\tint v=to[i];\n\t\tif(v==fa) continue;\n\t\tdep[v]=dep[u]+c[i];\n\t\tinitdep(v,u);\n\t}\n}\n\nvoid updfs(int u,int fa)\n{\n\tdp[u].init();\n\tdp[u].id=u;\n\tdp[u].id0=u,dp[u].mn0=dep[u]+w[u];\n\tfor(int i=h[u];i;i=nxt[i])\n\t{\n\t\tint v=to[i];\n\t\tif(v==fa) continue;\n\t\tupdfs(v,u);\n\t\tdp[u]+=dp[v];\n\t}\n}\n\nvoid dwndfs(int u,int fa)\n{\n\tif(fa==0)\n\t{\n\t\tdp[u].mn0-=dep[u]*2;\n\t\tdp[u].mn1-=dep[u]*2;\n\t}\n\tif(col[u]!=col[dp[u].id0])\n\t{\n\t\tansid[u]=dp[u].id0;\n\t\tans[u]=dep[u]+w[u]+dp[u].mn0;\n\t}\n\telse\n\t{\n\t\tansid[u]=dp[u].id1;\n\t\tans[u]=dep[u]+w[u]+dp[u].mn1;\n\t}\n\tfor(int i=h[u];i;i=nxt[i])\n\t{\n\t\tint v=to[i];\n\t\tif(v==fa) continue;\n\t\tdp[v].mn0-=dep[v]*2;\n\t\tdp[v].mn1-=dep[v]*2;\n\t\tdp[v]+=dp[u];\n\t\tdwndfs(v,u);\n\t}\n}\n\nint fnd(int u)\n{\n\treturn col[u]==u?u:col[u]=fnd(col[u]);\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%lld\",&w[i]);\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tint x,y;\n\t\tlong long w;\n\t\tscanf(\"%d%d%lld\",&x,&y,&w);\n\t\tadd(x,y,w),add(y,x,w);\n\t}\n\tinitdep(1,0);\n\tfor(int i=1;i<=n;i++) col[i]=i;\n\tlong long rss=0;\n\twhile(1)\n\t{\n\t\tfor(int i=1;i<=n;i++) col[i]=fnd(i);\n\t\tbool f=true;\n\t\tfor(int i=1;i<=n;i++) f&=col[i]==col[1];\n\t\tif(f) break;\n\t\tupdfs(1,0);\n\t\tdwndfs(1,0);\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tint rt=fnd(i);\n\t\t\tif(ans[i]<ans[rt]) ans[rt]=ans[i],ansid[rt]=ansid[i];\n\t\t}\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tint rt=fnd(i);\n\t\t\tif(rt!=fnd(ansid[rt]))\n\t\t\t{\n\t\t\t\tcol[rt]=fnd(ansid[rt]);\n\t\t\t\trss+=ans[rt];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",rss);\n\treturn 0;\n}\n```\n</p></details>\n\n##### [CF888G Xor-MST](https://www.luogu.com.cn/problem/CF888G)\n\n##### [CF1550F Jumping Around](https://www.luogu.com.cn/problem/CF1550F)\n\n##### [CF1648E Air Reform](https://www.luogu.com.cn/problem/CF1648E)\n\n##### [CF1305G Kuroni and Antihype](https://www.luogu.com.cn/problem/CF1305G)\n\n<details><summary>题解</summary><p>\n\n加入超级源点 $0$，令边 $(x,y)$ 的边权为 $a_x+a_y$，那么答案即为最大生成树的边权和减去 $\\sum a_i$。\n\n那么直接 Brouvka，每次维护子集最大值、和最大值不在同一个连通块的最大值即可。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=200005,LM=1<<18;\n\nint n,a[S];\nint fa[S];\nint mu[S],mv[S];\n\nint fnd(int x){return fa[x]==x?x:fa[x]=fnd(fa[x]);}\n\nstruct node\n{\n\tint x,y;\n\tnode(){x=y=n;}\n\tinline void init(){x=y=n;}\n\tinline node operator+(node b)\n\t{\n\t\tnode re;\n\t\tint res[4]={x,y,b.x,b.y};\n\t\tsort(res,res+4,[&](int x,int y){return a[x]>a[y];});\n\t\tre.x=res[0],re.y=n;\n\t\tfor(int i=1;i<4;i++)\n\t\t{\n\t\t\tif(fnd(res[i])!=fnd(res[0]))\n\t\t\t{\n\t\t\t\tre.y=res[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn re;\n\t}\n}mx[LM];\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\ta[++n]=0;\n\tfor(int i=1;i<=n;i++) fa[i]=i;\n\tlong long ans=0;\n\twhile(1)\n\t{\n\t\tfor(int i=0;i<LM;i++) mx[i].init();\n\t\tfor(int i=1;i<=n;i++) mx[a[i]].x=i;\n\t\tfor(int i=0;i<LM;i++)\n\t\t{\n\t\t\tfor(int j=0;(1<<j)<=i;j++)\n\t\t\t{\n\t\t\t\tif(i>>j&1) mx[i]=mx[i]+mx[i^(1<<j)];\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++) mu[i]=mv[i]=-1;\n\t\tfor(int u=1;u<=n;u++)\n\t\t{\n\t\t\tint rt=fnd(u);\n\t\t\tint v=mx[a[u]^(LM-1)].x;\n\t\t\tif(fnd(v)==rt) v=mx[a[u]^(LM-1)].y;\n\t\t\tif(fnd(v)==rt) continue;\n\t\t\tif(mu[rt]==-1||a[u]+a[v]>a[mu[rt]]+a[mv[rt]]) mu[rt]=u,mv[rt]=v;\n\t\t}\n\t\tbool f=true;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(fa[i]==i)\n\t\t\t{\n\t\t\t\tint u=mu[i],v=mv[i];\n\t\t\t\tif(u==-1) continue;\n\t\t\t\tif(fnd(u)==fnd(v)) continue;\n\t\t\t\tf=false;\n\t\t\t\tans+=a[u]+a[v];\n\t\t\t\tfa[fnd(u)]=fnd(v);\n\t\t\t}\n\t\t}\n\t\tif(f) break;\n\t}\n\tfor(int i=1;i<=n;i++) ans-=a[i];\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n```\n</p></details>\n",
			"tags": [{"name":"学习笔记"},{"name":"图论"},{"name":"小技巧"}],
			"title": "Boruvka 算法 学习笔记",
			"link": "https://exber.qzz.io/post/Boruvka%20%E7%AE%97%E6%B3%95%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-05-03 15:07:55"
		},
	
		{
			"abstract": "> 给定一个整数 $K$。求一个 $K$ 的正整数倍 $S$，使得 $S$ 的数位累加和最小。\n> \n> $2 \\le K \\le {10}^5$。\n",
			"content": "> 给定一个整数 $K$。求一个 $K$ 的正整数倍 $S$，使得 $S$ 的数位累加和最小。\n> \n> $2 \\le K \\le {10}^5$。\n\n考虑一位一位填，$\\overline{AB}=A\\times 10+B$，所以可以在 $\\operatorname{mod} k$ 的意义下运算，从 $x$ 向 $10x+b\\operatorname{mod} k$（$0\\le b\\le 9$）连权值为 $b$ 的有向边。答案即为 $1\\to 0$ 的最短路长度 $+1$。\n\n注意到这是最短路，所以实际上从 $x$ 向 $10x$ 连权值为 $0$ 的有向边，向 $x+1$ 连权值为 $1$ 的有向边也可以，因为最短路时个位进位一定不优，但是最长路就不能这样建边。这样建边的好处是可以 01 bfs $O(n)$ 求解。\n\n注意 01 bfs 每个点的最短路会更新至多两次。\n\n代码如下：\n\n```cpp\n// Problem: [ABC077D] Small Multiple\n// Contest: Luogu\n// URL: https://www.luogu.com.cn/problem/AT_arc084_b\n// Memory Limit: 256 MB\n// Time Limit: 2000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n#include <iostream>\n#include <cstdio>\n#include <deque>\n#include <cstring>\n\nusing namespace std;\n\nconst int S=200005;\n\nint n,dis[S];\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tdeque<int> q;\n\tdis[1]=1;\n\tq.push_back(1);\n\twhile(!q.empty())\n\t{\n\t\tint u=q.front();\n\t\tq.pop_front();\n\t\tint v=u*10%n;\n\t\tif(dis[v]==0||dis[u]<dis[v])\n\t\t{\n\t\t\tdis[v]=dis[u];\n\t\t\tq.push_front(v);\n\t\t}\n\t\tv=(u+1)%n;\n\t\tif(dis[v]==0||dis[u]+1<dis[v])\n\t\t{\n\t\t\tdis[v]=dis[u]+1;\n\t\t\tq.push_back(v);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dis[0]);\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"图论"},{"name":"构造"}],
			"title": "AT_arc084_b [ABC077D] Small Multiple 做题记录",
			"link": "https://exber.qzz.io/post/AT_arc084_b%20%5BABC077D%5D%20Small%20Multiple%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-05-02 19:03:04"
		},
	
		{
			"abstract": "",
			"content": "## Part 1 前言\n\n生成函数的变换是把一个生成函数变成另一个生成函数的一些式子，这些式子往往具有某种组合意义。\n\n在本文中，我们讨论的是球盒模型，即统计在**若干个盒子**中**放 $n$ 个小球**的方案数的问题。\n\n## Part 2 一些约定\n\n- $F(x)=\\sum\\limits_{i=0}^\\infin f_ix^i$，$G(x)=\\sum\\limits_{i=0}^\\infin f_i\\frac{x^i}{i!}$：参与变换的生成函数，即 $f_i$ 的 OGF 与 EGF，$f_i$ 的意义是有 $f_i$ 种方式把 $i$ 个球放进同一个盒子中；\n- 一般认为 $f_0=0$，即不能存在空盒子；\n- $[x^n]H(x)$：若 $H(x)$ 为 OGF，则代表 $H(x)$ 中 $x^n$ 的系数；若 $H(x)$ 为 EGF，则代表 $H(x)$ 中 $\\frac{x^n}{n!}$ 的系数。简单的说就是我们要求的答案；\n\n## Part 3 各种生成函数的变换\n\n#### 球无标号，盒有标号：不知道叫什么变换\n\n最简单，根据 OGF 乘法的定义，枚举球一共占用了多少个盒子，有：\n$$\n\\begin{aligned}\n\\operatorname{???}(F(x))&=\\sum\\limits_{i=0}^\\infin F(x)^i\\\\\n&=\\frac{1}{1-F(x)}\n\\end{aligned}\n$$\n\n\n#### 球有标号，盒有标号：$\\operatorname{Invert}$ 变换\n\n也可以叫 $\\operatorname{SEQ}$ 变换。\n\n根据 EGF 乘法的定义，枚举球一共占用了多少个盒子，有：\n$$\n\\begin{aligned}\n\\operatorname{Invert}(G(x))&=\\sum\\limits_{i=0}^\\infin G(x)^i\\\\\n&=\\frac{1}{1-G(x)}\n\\end{aligned}\n$$\n\n#### 球有标号，盒无标号：$\\operatorname{Exp}$ 变换\n\n根据 EGF 乘法的定义，枚举球一共占用了多少个盒子，但这样盒子是有标号的。注意到每种标号方式都会被算到恰好一次，所以要除掉盒子个数的阶乘：\n$$\n\\begin{aligned}\n\\operatorname{Exp}(G(x))&=\\sum\\limits_{i=0}^\\infin \\frac{G(x)^i}{i!}\\\\\n&=\\exp(G(x))\n\\end{aligned}\n$$\n\n#### 球无标号，盒无标号：$\\operatorname{Weigh}\\&\\operatorname{Euler}$ 变换\n\n##### $\\operatorname{Weigh}$ 变换\n\n*放的球一样多，放球的方式也一样的盒子只能出现一次。*\n\n类似 $01$ 背包，放 $i$ 个球的盒子有 $f_i$ 种，每种只能出现一次，那么有：\n$$\n\\operatorname{Weigh}(F(x))=\\prod\\limits_{i=0}^\\infin (1+x^i)^{f_i}\\\\\n$$\n即枚举盒子大小，然后因为有 $f_i$ 种这样的盒子所以要乘那么多次 $1+x^i$。\n\n这个东西不好化简，考虑 $\\ln$ 再 $\\exp$，要注意 $\\ln(1+x)=-\\sum\\limits_{i=1}^\\infin\\frac{(-1)^{i}(i-1)!x^i}{i!}=-\\sum\\limits_{i=1}^\\infin\\frac{(-x)^i}{i}$：\n$$\n\\begin{aligned}\n\\ln(\\operatorname{Weigh}(F(x)))&=\\sum\\limits_{i=0}^\\infin f_i\\ln(1+x^i)\\\\\n&=-\\sum\\limits_{i=0}^\\infin f_i\\sum\\limits_{j=1}^\\infin\\frac{(-x^i)^j}{j}\\\\\n&=-\\sum\\limits_{i=1}^\\infin \\frac{(-1)^i}{i}\\sum\\limits_{j=0}^\\infin f_jx^{ij}\\\\\n&=-\\sum\\limits_{i=1}^\\infin \\frac{(-1)^i}{i}F(x^i)\\\\\n\\end{aligned}\n$$\n那么：\n$$\n\\operatorname{Weigh}(F(x))=\\exp\\left(-\\sum\\limits_{i=1}^\\infin \\frac{(-1)^i}{i}F(x^i)\\right)\n$$\n\n##### $\\operatorname{Euler}$ 变换\n\n*无限制。*\n\n类似 Weigh，大小和放球方式都相同的盒子一起处理，相当于处理排序后的盒子。同种盒子允许有任意个可以通过套一层 Invert 变换来实现：\n$$\n\\mathcal{E}(F(x))=\\prod\\limits_{i=0}^\\infin \\left(\\frac{1}{1-x^i}\\right)^{f_i}\\\\\n$$\n同样是 $\\ln$ 再 $\\exp$：\n$$\n\\begin{aligned}\n\\ln(\\mathcal{E}(F(x)))&=\\sum\\limits_{i=0}^\\infin f_i\\ln\\left(\\frac{1}{1-x^i}\\right)\\\\\n&=-\\sum\\limits_{i=0}^\\infin f_i\\ln(1-x^i)\\\\\n&=\\sum\\limits_{i=0}^\\infin f_i\\sum\\limits_{j=1}^\\infin\\frac{x^{ij}}{j}\\\\\n&=\\sum\\limits_{i=1}^\\infin \\frac{F(x^i)}{i}\n\\end{aligned}\n$$\n所以：\n$$\n\\mathcal{E}(F(x))=\\exp\\left(\\sum\\limits_{i=1}^\\infin \\frac{F(x^i)}{i}\\right)\n$$\n\n#### 复合变换\n\n考虑另一个 OGF $H(x)=\\sum\\limits_{i=0}^\\infin h_ix^i$，考虑复合函数 $H(F(x))$ 和 $H(G(x))$ 的意义：\n\n- $[x^n]H(F(x))=[x^n]\\sum\\limits_{i=0}^\\infin h_iF(x)^i$：$n$ 个**无标号小球**放入**若干个有标号盒子**中，每个盒子放 $i$ 个小球均有 $[x^i]F(x)$ 种方案。这若干个盒子放入**一个大箱子**中，大箱子中放 $i$ 个盒子有 $h_i$ 种方案；\n- $[x^n]H(G(x))=[x^n]\\sum\\limits_{i=0}^\\infin h_iG(x)^i$：$n$ 个**有标号小球**放入**若干个有标号盒子**中，每个盒子放 $i$ 个小球均有 $[x^i]G(x)$ 种方案。这若干个盒子放入**一个大箱子**中，大箱子中放 $i$ 个盒子有 $h_i$ 种方案；\n\n注意 $H(x)$ 也可以是 EGF，并且可以复合再复合。\n\n比较经典的是有标号有根树的 EGF $T(x)$ 复合上任意生成函数。\n\n## Part 4 各种变换的计算\n\n- $\\operatorname{???}(x)$ 和 $\\operatorname{Invert}(x)$：求逆即可；\n\n- $\\operatorname{Exp}(x)$：直接多项式 exp；\n\n- $\\operatorname{Weigh}(x)$ 和 $\\mathcal{E}(x)$：暴力调和级数；\n\n- 复合变换：\n\n  牛顿迭代。以有标号有根树的 EGF $T(x)=1+\\sum\\limits_{i=1}^\\infin i^{i-1}\\frac{x^i}{i!}$ 为例，考虑另一个生成函数 $H(x)$（不管是 OGF 还是 EGF），求解 $T(H(x))$。\n\n  显然有 $T(x)=x\\exp(T(x))$，那么有 $T(H(x))=H(x)\\exp(T(H(x)))$。\n\n  根据牛迭式子，构造 $P(A(x))=A(x)-H(x)\\exp(A(x))$。\n\n  $P(A(x))$ 很好算，但是求导的时候要注意实际上求的是关于 $A(x)$ 的偏导，即把 $A(x)$ 外的东西都看作常数，所以有：$P'(A(x))=1-H(x)\\exp(A(x))$。\n\n  那么牛顿迭代求解即可。\n\n  求出来 $T(H(x))$ 后可以 $O(n)$ 算出有标号无根树复合 $H(x)$ 的结果，这样就可以算点双边双什么的了。 \n\n## Part 5 拓展应用\n\n#### 无标号有根树计数\n\n设无标号有根树个数的 OGF 为 $T(x)$，那么显然有 $T(x)=x\\mathcal{E}(T(x))=x\\exp\\left(\\sum\\limits_{i=1}^\\infin \\frac{T(x^i)}{i}\\right)$。那么构造 $P(T(x))=\\ln\\left(\\frac{T(x)}{x}\\right)-\\sum\\limits_{i=1}^\\infin \\frac{T(x^i)}{i}$。\n\n注意到牛迭的前提是已知 $T_*(x)\\equiv T(x)\\pmod{x^\\frac{n}{2}}$，要求 $\\frac{P(T_*(x))}{P'(T_*(x))}\\pmod{x^n}$。那么显然 $B(x)=\\sum\\limits_{i\\ge 2}^\\infin \\frac{T_*(x^i)}{i}\\mod{x^n}$ 是已知的，则有：\n$$\nP(T_*(x))\\equiv \\ln\\left(\\frac{T_*(x)}{x}\\right)-T_*(x)-B(x)\\pmod{x^n}\\\\\nP'(T_*(x))\\equiv \\frac{1}{T_*(x)}-T_*(x)\\pmod{x^n}\\\\\n$$\n发现 $[x^0]T_*(x)=0$，直接牛迭会解出 $0$，所以考虑用牛迭求解 $A(x)=\\frac{T(x)}{x}$：\n$$\nP(A_*(x))\\equiv \\ln\\left(A_*(x)\\right)-xA_*(x)-B(x)\\pmod{x^n}\\\\\nP'(A_*(x))\\equiv \\frac{1}{A_*(x)}-x\\pmod{x^n}\\\\\n$$\n\n\n注意到 $B(x)$ 可以在倍增的时候动态调和级数维护，所以 $\\ln$ 加上两次求逆，再动态维护 $B(x)$ 即可。\n\n时间复杂度 $O(n\\log n)$，常数略大。\n\n这个东西变成无根也很简单，只要减掉根不是重心的情况即可。\n",
			"tags": [{"name":"学习笔记"},{"name":"数学"},{"name":"组合计数"},{"name":"多项式、生成函数"}],
			"title": "生成函数变换学习笔记",
			"link": "https://exber.qzz.io/post/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%8F%98%E6%8D%A2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-05-02 10:53:41"
		},
	
		{
			"abstract": "> 给定 $n$，求\n> \n> $\\sum\\limits_{m>0,a_i>0,\\sum a_i=n}\\prod_{i=1}^m F_{a_i}$\n> \n> 对 $10^9 + 7$ 取模。\n> \n> $1\\le n\\le 10^{100}$。\n",
			"content": "> 给定 $n$，求\n> \n> $\\sum\\limits_{m>0,a_i>0,\\sum a_i=n}\\prod_{i=1}^m F_{a_i}$\n> \n> 对 $10^9 + 7$ 取模。\n> \n> $1\\le n\\le 10^{100}$。\n\n$$\n\\begin{aligned}\nF(x)&=x^2F(x)+xF(x)+x\\\\\nx&=(1-x-x^2)F(x)\\\\\nF(x)&=\\frac{x}{1-x-x^2}\n\\end{aligned}\n$$\n\n$$\n\\begin{aligned}\nG(x)&=G(x)F(x)+F(x)\\\\\nG(x)(1-F(x))&=F(x)\\\\\nG(x)&=\\frac{F(x)}{1-F(x)}\\\\\nG(x)&=\\frac{\\frac{x}{1-x-x^2}}{1-\\frac{x}{1-x-x^2}}\\\\\nG(x)&=\\frac{\\frac{x}{1-x-x^2}}{\\frac{1-2x-x^2}{1-x-x^2}}\\\\\nG(x)&=\\frac{x}{1-2x-x^2}\\\\\n\\end{aligned}\n$$\n\n$$\n\\begin{aligned}\n\\text{设 }\\frac{x}{1-2x-x^2}&=\\frac{b}{1-ax}+\\frac{d}{1-cx}\\\\\n&=\\frac{b-cbx+d-dax}{1-cx-ax+acx^2}\\\\\n&=\\frac{(b+d)+(-cb-da)x}{1+(c+a)x+acx^2}\\\\\n\\end{aligned}\n$$\n\n$$\n\\begin{cases}\nb+d=0\\\\\n-cb-da=1\\\\\nc+a=-2\\\\\nac=-1\n\\end{cases}\n$$\n\n解得：（其实有两组解，但本质相同）\n$$\n\\begin{cases}\nc=1+\\sqrt2\\\\\na=1-\\sqrt2\\\\\nd=\\frac{\\sqrt2}{4}\\\\\nb=\\frac{-\\sqrt2}{4}\n\\end{cases}\n$$\n所以：\n$$\n\\begin{aligned}\n\\frac{x}{1-2x-x^2}&=\\frac{b}{1-ax}+\\frac{d}{1-cx}\\\\\n&=-\\frac{\\sqrt2}{4}\\sum\\limits_{i=0}^\\infin(1-\\sqrt2)^ix^i+\\frac{\\sqrt2}{4}\\sum\\limits_{i=0}^\\infin(1+\\sqrt2)^ix^i\\\\\n\\end{aligned}\n$$\n所以：\n$$\ng_n=\\frac{\\sqrt2}{4}((1+\\sqrt2)^n-(1-\\sqrt2)^n)\n$$\n代码如下：\n\n```cpp\n// Problem: P4451 [国家集训队]整数的lqp拆分\n// Contest: Luogu\n// URL: https://www.luogu.com.cn/problem/P4451\n// Memory Limit: 125 MB\n// Time Limit: 1000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int p=1000000007,sq2=59713600;\n\ninline int qpow(int x,int y)\n{\n\tint res=1;\n\tfor(;y>0;y>>=1,x=1ll*x*x%p) res=y&1?1ll*res*x%p:res;\n\treturn res;\n}\n\nint n;\n\ninline int read()\n{\n\tint s=0,c=getchar();\n\twhile(c<'0'||c>'9') c=getchar();\n\twhile(c>='0'&&c<='9') s=(1ll*s*10+c-48)%(p-1),c=getchar();\n\treturn s;\n}\n\nint main()\n{\n\tn=read();\n\tprintf(\"%d\\n\",1ll*sq2*qpow(4,p-2)%p*(qpow(1+sq2,n)-qpow(1-sq2+p,n)+p)%p);\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"数学"},{"name":"组合计数"},{"name":"多项式、生成函数"}],
			"title": "P4451 [国家集训队]整数的lqp拆分 做题记录",
			"link": "https://exber.qzz.io/post/P4451%20%5B%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%5D%E6%95%B4%E6%95%B0%E7%9A%84lqp%E6%8B%86%E5%88%86%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-04-24 12:50:41"
		},
	
		{
			"abstract": "",
			"content": "## Part 2 指数型生成函数 EGF（$\\mathtt{E}$xponential $\\mathtt{G}$enerating $\\mathtt{F}$unction）\n\n指数型生成函数的特征函数是 $f_i(x)=\\frac{x^i}{i!}$。\n\n#### 2.0 形式幂级数形式\n\nEGF 的特征函数是 $f_i(x)=\\frac{x^i}{i!}$，那么 EGF 的形式幂级数形式即为：\n$$\nF(x)=\\sum\\limits_{i=0}^\\infin a_i\\frac{x^i}{i!}\n$$\n\n#### 2.1 EGF 的一些运算的意义\n\n为了方便计算，**规定原序列的负数项为 $0$，负数的阶乘是正无穷（抛弃带有 $\\frac{1}{(-1)!}$ 之类的系数的项）**。\n\n假设有两个序列 $a$，$b$ 和它们的 EGF $F(x)$，$G(x)$，那么：\n\n- 相加减\n  $$\n  \\begin{aligned}\n  H(x)&=F(x)\\pm G(x)\\\\\n  &=\\sum\\limits_{i=0}^\\infin (a_i\\pm b_i)\\frac{x^i}{i!}\n  \\end{aligned}\n  $$\n  相当于是 $a$ 和 $b$ 对应项相加减的序列 $c_i=a_i\\pm b_i$ 的 EGF；\n\n- 求导\n  $$\n  \\begin{aligned}\n  F'(x)&=\\sum\\limits_{i=0}^\\infin a_i\\frac{ix^{i-1}}{i!}\\\\\n  &=\\sum\\limits_{i=0}^\\infin a_i\\frac{x^{i-1}}{(i-1)!}\\\\\n  &=\\sum\\limits_{i=0}^\\infin a_{i+1}\\frac{x^i}{i!}\\\\\n  \\end{aligned}\n  $$\n  相当于是把原序列整体左移了一位；\n\n- 积分\n  $$\n  \\begin{aligned}\n  \\int F(x)dx&=\\int \\sum\\limits_{i=0}^\\infin a_i\\frac{x^i}{i!}dx\\\\\n  &=C+\\sum\\limits_{i=0}^\\infin a_i\\frac{x^{i+1}}{(i+1)i!}\\\\\n  &=C+\\sum\\limits_{i=0}^\\infin a_i\\frac{x^{i+1}}{(i+1)!}\\\\\n  &=C+\\sum\\limits_{i=0}^\\infin a_{i-1}\\frac{x^i}{i!}\\\\\n  \\end{aligned}\n  $$\n  相当于是把原序列整体右移了一位；\n\n- 相乘\n  $$\n  \\begin{aligned}\n  F(x)G(x)&=\\left(\\sum\\limits_{i=0}^\\infin a_i\\frac{x^i}{i!}\\right)\\left(\\sum\\limits_{i=0}^\\infin b_i\\frac{x^i}{i!}\\right)\\\\\n  &=\\sum\\limits_{i=0}^\\infin x^i\\sum\\limits_{j=0}^i a_jb_{i-j}\\frac{1}{j!(i-j)!}\\\\\n  &=\\sum\\limits_{i=0}^\\infin \\frac{x^i}{i!}\\sum\\limits_{j=0}^i a_jb_{i-j}\\frac{i!}{j!(i-j)!}\\\\\n  &=\\sum\\limits_{i=0}^\\infin \\frac{x^i}{i!}\\sum\\limits_{j=0}^i \\binom{i}{j}a_jb_{i-j}\\\\\n  \\end{aligned}\n  $$\n  相当于是 $c_i=\\sum\\limits_{j=0}^i\\binom{i}{j}a_jb_{i-j}$ 的 EGF，组合意义如下：\n\n  > $c_i$ 表示把 $i$ 个**有标号小球**放入 $A$ 和 $B$ 两个**有标号无序集合**中，其中 $A$ 集合中放 $i$ 个球的方案数是 $a_i$，$B$ 集合中放 $i$ 个球的方案数是 $b_i$。\n\n#### 2.2 封闭形式\n\n$\\{1,1,1,\\dots\\}$ 的 EGF 是 $F(x)=\\sum\\limits_{i=0}^\\infin\\frac{x^i}{i}$，注意到这就是 $e^x$ 在 $x=0$ 处的泰勒展开，那么它的封闭形式即为 $e^x$。\n\n同理，$\\{1,p,p^2,p^3,\\dots\\}$ 的 EGF 的封闭形式即为 $e^{px}$。\n\n由于 $\\frac{x^i}{i!}$ 只能利用泰勒展开化为有限的封闭形式，所以往往要先将原序列转化为多个等比数列的和。\n\n#### 2.3 一些常见数列的 EGF 的封闭形式\n$$\na=\\{c,cp,cp^2,cp^3,\\dots\\}\\\\\na=\\{1,-1,1,-1,\\dots\\}\\\\\na=\\{1,0,1,0,1,\\dots\\}\\\\\na=\\{0,1,0,1,0,\\dots\\}\\\\\na_i=n^{\\underline{i}}\\text{ 即 }a_i=n(n-1)(n-2)\\dots(n-i+1)\\text{，}n\\text{ 是给定的常数}\\\\\na_0=0,a_i=(-1)^{i-1}(i-1)!\\\\\na_0=0,a_i=(i-1)!\\\\\na=\\{1,0,-1,0,1,0,-1,0,\\dots\\}\\\\\na=\\{0,1,0,-1,0,1,0,-1,\\dots\\}\\\\\n$$\n\n\n\n****\n\n第一个：\n$$\nF(x)=c\\sum\\limits_{i=0}^\\infin p^i\\frac{x^i}{i!}=c\\sum\\limits_{i=0}^\\infin \\frac{(px)^i}{i!}=c\\cdot e^{px}\n$$\n第二个：\n$$\nF(x)=\\sum\\limits_{i=0}^\\infin (-1)^i\\frac{x^i}{i!}=\\sum\\limits_{i=0}^\\infin\\frac{(-x)^i}{i!}=e^{-x}\n$$\n第三个：\n$$\na_i=\\frac{1+(-1)^i}{2}\\\\\nF(x)=\\frac{\\sum\\limits_{i=0}^\\infin \\frac{x^i}{i!}+\\sum\\limits_{i=0}^\\infin\\frac{(-x)^i}{i!}}{2}=\\frac{e^x+e^{-x}}{2}\n$$\n第四个：\n$$\na_i=\\frac{1-(-1)^i}{2}\\\\\nF(x)=\\frac{\\sum\\limits_{i=0}^\\infin \\frac{x^i}{i!}-\\sum\\limits_{i=0}^\\infin\\frac{(-x)^i}{i!}}{2}=\\frac{e^x-e^{-x}}{2}\n$$\n第五个：\n$$\n\\begin{aligned}\nF(x)&=\\sum\\limits_{i=0}^n n^{\\underline i}\\frac{x^i}{i!}\\\\\n&=\\sum\\limits_{i=0}^n\\binom{n}{i}x^i\\\\\n&=(x+1)^n\n\\end{aligned}\n$$\n第六个：\n$$\n\\text{考虑 }\\ln(x+1)\\text{ 在 } x=0 \\text{ 附近的泰勒展开：}\\\\\n\\begin{aligned}\n\\ln(x+1)&=\\sum\\limits_{i=0}^{\\infin}\\ln^{(i)}(1)\\frac{x^{i}}{i!}\\\\\n&=\\sum\\limits_{i=1}^{\\infin}(-1)^{i-1}(i-1)!\\frac{x^{i}}{i!}\\\\\n\\end{aligned}\\\\\n\\text{所以}\\\\\nF(x)=\\sum\\limits_{i=1}^{\\infin}(-1)^{i-1}(i-1)!\\frac{x^{i}}{i!}=\\ln(x+1)\n$$\n第七个：\n$$\n\\text{考虑 }-\\ln(1-x)\\text{ 在 } x=0 \\text{ 附近的泰勒展开，换元可得：}\\\\\n-\\ln(1-x)=\\sum\\limits_{i=1}^{\\infin}\\frac{x^{i}}{i}\\\\\n\\text{所以}\\\\\nF(x)=\\sum\\limits_{i=1}^{\\infin}(i-1)!\\frac{x^{i}}{i!}=-\\ln(1-x)\n$$\n第八个：\n$$\n\\text{考虑 } \\cos(x) \\text{ 在 } x=0 \\text{ 处的泰勒展开：}\\\\\n\\begin{aligned}\n\\cos(x)&=\\sum\\limits_{i=0}^{\\infin} \\cos^{i}(0)\\frac{x^i}{i!}\\\\\n&=\\sum\\limits_{i=0}^{\\infin}(-1)^i\\frac{x^{2i}}{(2i)!}\\\\\n\\end{aligned}\\\\\n\\text{所以}\\\\\nF(x)=\\sum\\limits_{i=0}^{\\infin}a_i\\frac{x^{i}}{i!}=\\cos(x)\n$$\n第九个：\n$$\n\\text{考虑 } \\sin(x) \\text{ 在 } x=0 \\text{ 处的泰勒展开：}\\\\\n\\begin{aligned}\n\\sin(x)&=\\sum\\limits_{i=0}^{\\infin} \\sin^{i}(0)\\frac{x^i}{i!}\\\\\n&=\\sum\\limits_{i=0}^{\\infin}(-1)^i\\frac{x^{2i+1}}{(2i+1)!}\\\\\n\\end{aligned}\\\\\n\\text{所以}\\\\\nF(x)=\\sum\\limits_{i=0}^{\\infin}a_i\\frac{x^{i}}{i!}=\\sin(x)\n$$\n##### 2.3.1 简单例题 [POJ 3734 Blocks](https://vjudge.csgrandeur.cn/problem/POJ-3734)\n\n> 有红、黄、蓝、绿四种砖块，每种都有无限块，同色的砖块是一样的。\n>\n> 你要选出 $n$（$1\\le n\\le 10^7$）块砖砌出一堵高度为 $1$ 的墙（一条墙），问满足以下条件的不同的墙的个数：\n>\n> - 红色砖块只能用偶数个；\n> - 黄色砖块只能用偶数个；\n>\n> 对 $10007$ 取模。\n\n由于要求排列个数且砖块内部互不区分但是不同色的砖块互相区分，所以应选用 EGF。\n\n观察到求出各种砖块的 EGF 再卷起来即可。\n\n蓝色和绿色砖块的 EGF 显然是 $\\sum\\limits_{i=0}^\\infin \\frac{x^i}{i!}=e^x$。\n\n红色和黄色砖块的 EGF 则是 $\\frac{\\sum\\limits_{i=0}^\\infin ((-1)^i+1)\\frac{x^i}{i!}}{2}=\\frac{\\sum\\limits_{i=0}^\\infin \\frac{(-x)^i}{i!}+\\sum\\limits_{i=0}^\\infin \\frac{x^i}{i!}}{2}=\\frac{e^{-x}+e^x}{2}$。\n\n全部卷起来：\n$$\n\\begin{aligned}\nANS(x)&=e^x\\times e^x\\times\\frac{e^{-x}+e^x}{2}\\times \\frac{e^{-x}+e^x}{2}\\\\\n&=e^{2x}\\times \\frac{e^{-2x}+2+e^{2x}}{4}\\\\\n&=\\frac{1+2e^{2x}+e^{4x}}{4}\\\\\n\\end{aligned}\n$$\n根据 $\\sum\\limits_{i=0}^\\infin cp^i\\frac{x^i}{i!}=ce^{px}$ 展开：\n$$\n\\begin{aligned}\nANS(x)&=\\frac{1+2\\sum\\limits_{i=0}^\\infin 2^i\\frac{x^i}{i!}+\\sum\\limits_{i=0}^\\infin 4^i\\frac{x^i}{i!}}{4}\\\\\n&=\\frac{1+2\\sum\\limits_{i=0}^\\infin 2^i\\frac{x^i}{i!}+\\sum\\limits_{i=0}^\\infin 4^i\\frac{x^i}{i!}}{4}\\\\\n&=\\frac{1}{4}+\\sum\\limits_{i=0}^\\infin 2^{i-1}4^{i-1}\\frac{x^i}{i!}\\\\\n\\end{aligned}\n$$\n由于 $\\frac{1}{4}$ 是常数项，属于 $x^0$，而 $n\\ge 1$，所以不用管它，那么答案即为 $2^{n-1}4^{n-1}$，直接快速幂即可。\n\n### 2.4 EGF 的 EXP 的组合意义\n\n考虑一个序列 $g$ 和它的 EGF $G(x)=\\sum\\limits_{i=0}^\\infin g_i\\frac{x^i}{i!}$，这里我们默认 $g_0=0$，因为这是可以计算 $\\exp$ 的前提条件。那么$[x^n]G(x)=g_n$ 的组合意义如下：\n\n> 把 $n$ 个**有标号**小球放入一个无序集合内的方案数。\n\n考虑 EGF 乘法的组合意义，那么 $[x^n]G^k(x)=[x^n](G(x))^k$ 的组合意义如下：\n\n> 把 $n$ 个**有标号**小球放入 $k$ 个**有标号**的**非空**无序集合内的方案数，每个集合中放 $i$ 个小球的方案数都是 $g_i$。\n\n那么 $[x^n]\\sum\\limits_{k=1}^\\infin G^k(x)$ 的组合意义自然是：\n\n> 把 $n$ 个**有标号**小球放入**若干**个**有标号**的**非空**无序集合内的方案数，每个集合中放 $i$ 个小球的方案数都是 $g_i$。\n\n考虑 $[x^n]\\frac{G^k(x)}{k!}$ 的组合意义，除掉的 $k!$ 相当于去掉了集合之间的顺序：\n\n>把 $n$ 个**有标号**小球放入 $k$ 个**无标号**的**非空**无序集合内的方案数，每个集合中放 $i$ 个小球的方案数都是 $g_i$。\n\n那么 $[x^n]\\sum\\limits_{k=1}^\\infin \\frac{G^k(x)}{k!}$ 的组合意义自然是：\n\n> 把 $n$ 个**有标号**小球放入**若干**个**无标号**的**非空**无序集合内的方案数，每个集合中放 $i$ 个小球的方案数都是 $g_i$。\n\n注意到这就是 $\\exp(G(x))$ 的定义，所以 $[x^n]\\exp(G(x))$ 的组合意义就是：\n\n> 把 $n$ 个**有标号**小球放入**若干**个**无标号**的**非空**无序集合内的方案数，每个集合中放 $i$ 个小球的方案数都是 $g_i$。\n\n### 2.5 EGF 的应用\n\n##### 2.5.1 圆排列计数\n\n>圆排列：排在圆上的排列，旋转之后本质相同。\n\n设 $f_n$ 表示 $n$ 的排列的个数，容易发现 $f_n=n!$。设 $F(x)$ 为 $f$ 的 EGF，那么有 $F(x)=\\sum\\limits_{i=0}^\\infin i!\\frac{x^i}{i!}=\\sum\\limits_{i=0}^\\infin x^i$。\n\n设 $g_n$ 表示 $n$ 的圆排列的个数，那么由于环旋转之后是本质相同的，所以有 $g_n=\\frac{n!}{n}=(n-1)!$，特别的，$g_0=0$。设 $G(x)$ 为 $g$ 的 EGF，那么有 $G(x)=\\sum\\limits_{i=1}^\\infin (i-1)!\\frac{x^i}{i!}=\\sum\\limits_{i=1}^\\infin\\frac{x^i}{i}$。\n\n观察到有 $F(x)=\\frac{1}{1-x}$，$G(x)=-\\ln(1-x)=\\ln(\\frac{1}{1-x})$，所以有 $G(x)=\\ln(F(x))$。\n\n组合意义上的解释是，考虑一个长度为 $n$ 排列 $p$，从 $i$ 向 $p_i$ 连一条有向边，那么由于每个点的入度和出度都是 $1$，所以最后一定会形成若干个环，并且环的方案和排列组成双射。由于大小为 $x$ 的环的方案数都是 $g_x$，所以有 $F(x)=\\exp(G(x))$。\n\n##### 2.5.2 错排列计数\n\n> 错排列：满足 $p_i\\not= i$ 的排列。\n\n设 $f_n$ 表示 $n$ 的错排列的个数，$g_n$ 表示 $n$ 的圆排列的个数，$F(x)$、$G(x)$ 分别为 $f$、$g$ 的 EGF，根据之前的推导有 $G(x)=-\\ln(1-x)$。\n\n那么观察到错排列就相当于是变成若干个环后不存在大小为 $1$ 的环，那么设 $G_*(x)=G(x)-x$ 即让大小为 $1$ 的环的方案数为 $0$，显然有 $G_*(x)=-\\ln(1-x)-x$，$F(x)=\\exp(G_*(x))=\\exp(-\\ln(1-x)-x)$。\n\n##### 2.5.3 简单例题：不动点\n\n> 求满足以下条件的 $n$ 个点有向图的个数：\n>\n> - 每个点出度为 $1$；\n> - 从每个点出发，走 $k$ 步后到达的点和走 $k-1$ 步后到达的点一样；\n>\n> $1\\le n\\le 2\\times 10^6,1\\le k\\le 3$。\n\n不难发现满足条件的图是一个基环树森林，并且森林中的基环树的根都是一个自环，所以实际上图是一个森林。且森林中的树的深度小于等于 $k$。\n\n那么设 $f_{n,m}$ 表示 $n$ 个点的深度不超过 $m$ 的有根树的个数，显然有 $f_{1,1}=1$，设 $F_m(x)=\\sum\\limits_{i=0}^\\infin f_{i,m}\\frac{x^i}{i!}$ 也就是 $f$ 关于 $n$ 的 EGF。那么由于根的不同子树不用考虑顺序，所以有 $F_m(x)=x\\times \\exp(F_{m-1}(x))$ 其中乘 $x$ 是因为要算上根的 EGF $\\frac{x^1}{1!}$。\n\n接下来就要把这些有根树组合起来，答案即为 $[x^n]\\exp(F_k(x))$。\n\n### 经典例题\n\n##### [CF891E Lust](https://www.luogu.com.cn/problem/CF891E)\n\n有个结论，$ans$ 每次增加的量等于 $\\prod a_i$ 减少的量，那么设 $a_i$ 减少了 $b_i$，那么 $ans$ 即为 $\\prod a_i-\\prod (a_i-b_i)$。\n\n那么设 $a_i$ 的 EGF 为 $F_i(x)=\\sum\\limits_{j=0}^\\infin (a_i-j)\\frac{x^j}{j!}$，则答案即为 $\\prod a_i-\\frac{[x^k]\\prod F_i(x)}{n^k}$。\n\n分母可以 $O(n)$ 算，所以问题的难点在于 $[x^k]\\prod F_i(x)$，注意到有：\n$$\n\\begin{aligned}\nF_i(x)&=\\sum\\limits_{j=0}^\\infin (a_i-j)\\frac{x^j}{j!}\\\\\n&=\\sum\\limits_{j=0}^\\infin a_i\\frac{x^j}{j!}-\\sum\\limits_{j=0}^\\infin j\\frac{x^j}{j!}\\\\\n&=a_i\\sum\\limits_{j=0}^\\infin\\frac{x^j}{j!}-x\\sum\\limits_{j=1}^\\infin \\frac{x^{j-1}}{(j-1)!}\\\\\n&=(a_i-x)e^x\n\\end{aligned}\n$$\n那么有：\n$$\n[x^k]\\prod F_i(x)=[x^k]\\left(e^{nx}\\prod (a_i-x)\\right)\n$$\n由于 $n\\le 5000$，所以 $\\prod (a_i-x)$ 的每一项系数 $c_0+c_1x^1+\\dots$ 可以 $O(n^2)$ 算出来，然后根据 $[x^k]e^{nx}=n^k$，可以直接 $O(n^2)$ 暴力卷积算出 $[x^k]\\prod F_i(x)$。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=5005,p=1000000007;\n\nint n,k,a[S];\nint c[S],tmp[S];\n\ninline int qpow(int x,int y)\n{\n\tint res=1;\n\tfor(;y>0;y>>=1,x=1ll*x*x%p) res=y&1?1ll*res*x%p:res;\n\treturn res;\n}\n\ninline int C(int n,int m)\n{\n\tif(n<m||n<0||m<0) return 0;\n\tint re=1,div=1;\n\tfor(int i=n;i>=n-m+1;i--) re=1ll*re*i%p;\n\tfor(int i=1;i<=m;i++) div=1ll*div*i%p;\n\treturn 1ll*re*qpow(div,p-2)%p;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tc[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<=n;j++) tmp[j]=c[j];\n\t\tfor(int j=0;j<=n;j++) c[j]=1ll*c[j]*a[i]%p;\n\t\tfor(int j=0;j<=n-1;j++) c[j+1]=(c[j+1]-tmp[j]+p)%p;\n\t}\n\tfor(int i=0,fra=1;i<=n;i++) fra=1ll*fra*max(i,1)%p,c[i]=1ll*fra*c[i]%p;\n\tint prod=0;\n\tfor(int i=k;i>=k-n&&i>=0;i--) prod=(prod+1ll*qpow(n,i)*c[k-i]%p*C(k,k-i)%p)%p;\n\tint mul=1;\n\tfor(int i=1;i<=n;i++) mul=1ll*mul*a[i]%p;\n\tint ans=(mul-1ll*prod*qpow(qpow(n,k),p-2)%p+p)%p;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"学习笔记"},{"name":"数学"},{"name":"组合计数"},{"name":"多项式、生成函数"}],
			"title": "指数型生成函数入门",
			"link": "https://exber.qzz.io/post/%E6%8C%87%E6%95%B0%E5%9E%8B%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%85%A5%E9%97%A8",
			"date": "2023-04-20 16:39:50"
		},
	
		{
			"abstract": "> 你有 $n$ 个数 $a_1,a_2,\\dots,a_n$ 要进行 $k$ 次操作，每次随机选择一个数 $x \\in [1,n]$，把 $a_x$ 减一，并将答案增加除 $a_x$ 外所有数的乘积。  \n> \n> 求最终答案的期望，答案对 $10^9 + 7$ 取模。\n> \n> $1\\le n\\le 5000$。\n",
			"content": "> 你有 $n$ 个数 $a_1,a_2,\\dots,a_n$ 要进行 $k$ 次操作，每次随机选择一个数 $x \\in [1,n]$，把 $a_x$ 减一，并将答案增加除 $a_x$ 外所有数的乘积。  \n> \n> 求最终答案的期望，答案对 $10^9 + 7$ 取模。\n> \n> $1\\le n\\le 5000$。\n\n有个结论，$ans$ 每次增加的量等于 $\\prod a_i$ 减少的量，那么设 $a_i$ 减少了 $b_i$，那么 $ans$ 即为 $\\prod a_i-\\prod (a_i-b_i)$。\n\n那么设 $a_i$ 的 EGF 为 $F_i(x)=\\sum\\limits_{j=0}^\\infin (a_i-j)\\frac{x^j}{j!}$，则答案即为 $\\prod a_i-\\frac{[x^k]\\prod F_i(x)}{n^k}$。\n\n分母可以 $O(n)$ 算，所以问题的难点在于 $[x^k]\\prod F_i(x)$，注意到有：\n$$\n\\begin{aligned}\nF_i(x)&=\\sum\\limits_{j=0}^\\infin (a_i-j)\\frac{x^j}{j!}\\\\\n&=\\sum\\limits_{j=0}^\\infin a_i\\frac{x^j}{j!}-\\sum\\limits_{j=0}^\\infin j\\frac{x^j}{j!}\\\\\n&=a_i\\sum\\limits_{j=0}^\\infin\\frac{x^j}{j!}-x\\sum\\limits_{j=1}^\\infin \\frac{x^{j-1}}{(j-1)!}\\\\\n&=(a_i-x)e^x\n\\end{aligned}\n$$\n那么有：\n$$\n[x^k]\\prod F_i(x)=[x^k]\\left(e^{nx}\\prod (a_i-x)\\right)\n$$\n由于 $n\\le 5000$，所以 $\\prod (a_i-x)$ 的每一项系数 $c_0+c_1x^1+\\dots$ 可以 $O(n^2)$ 算出来，然后根据 $[x^k]e^{nx}=n^k$，可以直接 $O(n^2)$ 暴力卷积算出 $[x^k]\\prod F_i(x)$。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=5005,p=1000000007;\n\nint n,k,a[S];\nint c[S],tmp[S];\n\ninline int qpow(int x,int y)\n{\n\tint res=1;\n\tfor(;y>0;y>>=1,x=1ll*x*x%p) res=y&1?1ll*res*x%p:res;\n\treturn res;\n}\n\ninline int C(int n,int m)\n{\n\tif(n<m||n<0||m<0) return 0;\n\tint re=1,div=1;\n\tfor(int i=n;i>=n-m+1;i--) re=1ll*re*i%p;\n\tfor(int i=1;i<=m;i++) div=1ll*div*i%p;\n\treturn 1ll*re*qpow(div,p-2)%p;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tc[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<=n;j++) tmp[j]=c[j];\n\t\tfor(int j=0;j<=n;j++) c[j]=1ll*c[j]*a[i]%p;\n\t\tfor(int j=0;j<=n-1;j++) c[j+1]=(c[j+1]-tmp[j]+p)%p;\n\t}\n\tfor(int i=0,fra=1;i<=n;i++) fra=1ll*fra*max(i,1)%p,c[i]=1ll*fra*c[i]%p;\n\tint prod=0;\n\tfor(int i=k;i>=k-n&&i>=0;i--) prod=(prod+1ll*qpow(n,i)*c[k-i]%p*C(k,k-i)%p)%p;\n\tint mul=1;\n\tfor(int i=1;i<=n;i++) mul=1ll*mul*a[i]%p;\n\tint ans=(mul-1ll*prod*qpow(qpow(n,k),p-2)%p+p)%p;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"数学"},{"name":"概率、期望"},{"name":"组合计数"},{"name":"多项式、生成函数"},{"name":"结论"}],
			"title": "CF891E Lust 做题记录",
			"link": "https://exber.qzz.io/post/CF891E%20Lust%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-04-19 20:44:00"
		},
	
		{
			"abstract": "> 给定一个长 $n$，值域 $[1,n]$ 的数组 $a$，定义 $a$ 的排列（任意打乱元素顺序后的数组）$b$ 的价值为最小的操作次数使得 $b=a$，一次操作可以：\n>\n> - 选定两个 $1\\le i<j\\le n$，交换 $b_i$ 和 $b_j$；\n>\n> F1：给定 $a$，构造价值最大的 $b$；\n>\n> F2：给定 $a$ 和 $b$，判断 $b$ 的价值是否最大；\n>\n> $1\\le n\\le 2\\times 10^5$。\n",
			"content": "> 给定一个长 $n$，值域 $[1,n]$ 的数组 $a$，定义 $a$ 的排列（任意打乱元素顺序后的数组）$b$ 的价值为最小的操作次数使得 $b=a$，一次操作可以：\n>\n> - 选定两个 $1\\le i<j\\le n$，交换 $b_i$ 和 $b_j$；\n>\n> F1：给定 $a$，构造价值最大的 $b$；\n>\n> F2：给定 $a$ 和 $b$，判断 $b$ 的价值是否最大；\n>\n> $1\\le n\\le 2\\times 10^5$。\n\nF1 的做法很简单，先考虑 $a$ 各不相同的情况。那么对于一个 $b$，设 $n$ 个点的有向图 $G$ 构造方法如下：\n\n- 从 $i$ 向 $b_i$ 在 $a$ 中的位置 $j$ 连一条有向边；\n\n那么 $b$ 的价值即为 $n-G\\text{ 中的环个数}$。\n\n考虑 $a$ 会相同的情况，那么无非就是 $S=\\{i,b_i=x\\}$ 和 $T=\\{i,a_i=x\\}$ 之间的 $|S|$ 条有向边可以任意确定，只要保证 $S$ 中的每个点都有出边，$T$ 中的每个点都有入边即可。\n\n注意到若 $G$ 中的两个点 $x,y$ 在同一个环中且满足 $b_x=b_y$，则可以通过交换 $x,y$ 的出边来把这个环分裂成两个环，这显然不花费操作次数。所以价值最大的 $b$ 一定满足 $b_i$ 相同的 $i$ 不在同一个环内，那么直接乱构造就行了。\n\n代码如下：\n\n```cpp\nint n,m,a[S];\nvector<int> vec[S],cir[S];\nint ans[S];\n\ninline void slove()\n{\n\tread(n);\n\tfor(int i=1;i<=n;i++) read(a[i]);\n\tfor(int i=1;i<=n;i++) vec[i].clear(),cir[i].clear();\n\tfor(int i=1;i<=n;i++) vec[a[i]].pb(i);\n\tm=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint id=0;\n\t\tfor(int v:vec[i]) cir[++id].pb(v);\n\t\tm=max(m,id);\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint ct=cir[i].size();\n\t\tfor(int j=0;j<ct;j++)\n\t\t{\n\t\t\tint u=cir[i][j],v=cir[i][(j+1)%ct];\n\t\t\tans[u]=a[v];\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++) write(ans[i],' ');\n\twrite('\\n');\n}\n```\n\n\n\nF2 其实也挺简单的，注意到合法的 $b$ 对应 $G$ 中环的个数一定等于 $a$ 中出现次数最多的数的出现次数，那么把出现次数最多的数删掉，如果剩下的数能构成环，则 $b$ 不合法。\n\n判环直接弄个虚点 $ct$，建 $(i\\in S)\\to ct$，$ct\\to (i\\in T)$，然后拓扑判环集可。\n\n代码如下：\n\n```cpp\nint n,a[S],b[S];\nvector<int> va[S],vb[S];\nint cnt[S];\nvector<int> g[S];\nint ind[S];\nqueue<int> q;\n\ninline void slove()\n{\n\tread(n);\n\tfor(int i=1;i<=n;i++) read(a[i]);\n\tfor(int i=1;i<=n;i++) read(b[i]);\n\tfor(int i=1;i<=n;i++) va[i].clear(),vb[i].clear();\n\tfor(int i=1;i<=n;i++) va[a[i]].pb(i),vb[b[i]].pb(i);\n\tfor(int i=1;i<=n;i++) cnt[i]=0;\n\tint mx=0;\n\tfor(int i=1;i<=n;i++) mx=max(mx,++cnt[a[i]]);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(cnt[i]==mx)\n\t\t{\n\t\t\tva[i].clear(),vb[i].clear();\n\t\t\tbreak;\n\t\t}\t\n\t}\n\tfor(int i=1;i<=n+n;i++) g[i].clear(),ind[i]=0;\n\tint cnt=n;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcnt++;\n\t\tfor(int id:vb[i]) g[id].pb(cnt),ind[cnt]++;\n\t\tfor(int id:va[i]) g[cnt].pb(id),ind[id]++;\n\t}\n\twhile(!q.empty()) q.pop();\n\tfor(int i=1;i<=n+n;i++) if(ind[i]==0) q.push(i);\n\twhile(!q.empty())\n\t{\n\t\tint u=q.front();\n\t\tq.pop();\n\t\tfor(int v:g[u]) if(--ind[v]==0) q.push(v);\n\t}\n\tfor(int i=1;i<=n+n;i++) if(ind[i]!=0) return puts(\"WA\"),void();\n\tputs(\"AC\");\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"构造"},{"name":"图论"}],
			"title": "CF1672F2 Checker for Array Shuffling 做题记录",
			"link": "https://exber.qzz.io/post/CF1672F2%20Checker%20for%20Array%20Shuffling%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-04-18 20:15:36"
		},
	
		{
			"abstract": "> 给定一个 $1\\sim n$ 的排列 $p$。  \n> \n> 对于一个 $1\\sim n$ 的排列 $q$，定义其权值为：\n> \n> $$|q_1-p_{q_2}|+|q_2-p_{q_3}|+|q_3-p_{q_4}|+\\cdots+|q_{n-1}-p_{q_n}|+|q_n-p_{q_1}|$$\n> \n> 找出 **任意一个** 权值最小化的 $1\\sim n$ 的排列 $q$。\n> \n> $2\\le n\\le 200$。\n",
			"content": "> 给定一个 $1\\sim n$ 的排列 $p$。  \n> \n> 对于一个 $1\\sim n$ 的排列 $q$，定义其权值为：\n> \n> $$|q_1-p_{q_2}|+|q_2-p_{q_3}|+|q_3-p_{q_4}|+\\cdots+|q_{n-1}-p_{q_n}|+|q_n-p_{q_1}|$$\n> \n> 找出 **任意一个** 权值最小化的 $1\\sim n$ 的排列 $q$。\n> \n> $2\\le n\\le 200$。\n\n设 $w_{q_{i\\operatorname{mod}n+1}}=q_i$，那么我们要最小化的东西就变成了 $\\sum\\limits_{i=1}^n|w_i-p_i|$。\n\n一个朴素的想法是让 $w_i=p_i$，但是注意到 $i\\to w_i$ 必须要形成一个大环，也就是说 $w$ 导出的置换环只能有一个，所以 $w_i=p_i$ 可能不合法。\n\n那么考虑调整，找到 $w_i$ 和 $w_j$ 在值域上相邻且 $i$ 和 $j$ 来自不同置换环的 $(i,j)$，注意到 $|w_i-w_j|$ 一定是 $1$。这时交换 $w_i$ 和 $w_j$ 就可以以 $2$ 的代价合并两个置换环。这样构造的答案是 $2(c-1)$，其中 $c$ 是 $w$ 的置换环个数。\n\n容易证明这个是下界。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nconst int S=205;\n\nint n,a[S];\nint cnt,bel[S];\nbool vis[S];\nvector<int> vec[S];\npair<int,int> pri[S];\nint b[S],nxt[S];\n\ninline void slove()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]),b[i]=a[i];\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcnt=0;\n\t\tfor(int j=1;j<=n;j++) vis[j]=false,vec[j].clear();\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tif(!vis[j])\n\t\t\t{\n\t\t\t\tvec[++cnt].push_back(j);\n\t\t\t\tbel[j]=cnt;\n\t\t\t\tvis[j]=true;\n\t\t\t\tj=a[j];\n\t\t\t\twhile(!vis[j])\n\t\t\t\t{\n\t\t\t\t\tvec[cnt].push_back(j);\n\t\t\t\t\tbel[j]=cnt;\n\t\t\t\t\tvis[j]=true;\n\t\t\t\t\tj=a[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=1;j<=n;j++) pri[j]=make_pair(a[j],j);\n\t\tsort(pri+1,pri+n+1);\n\t\tfor(int j=1;j<=n-1;j++)\n\t\t{\n\t\t\tint x=pri[j].second,y=pri[j+1].second;\n\t\t\tif(bel[x]!=bel[y])\n\t\t\t{\n\t\t\t\tswap(a[x],a[y]);\n\t\t\t\tswap(b[x],b[y]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++) nxt[b[i]]=i;\n\tprintf(\"%d \",1);\n\tint u=nxt[1];\n\twhile(u!=1)\n\t{\n\t\tprintf(\"%d \",u);\n\t\tu=nxt[u];\n\t}\n\tprintf(\"\\n\");\n}\n\nint main()\n{\n\tint T;\n\tscanf(\"%d\",&T);\n\twhile(T-->0) slove();\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"构造"}],
			"title": "CF1685D1 Permutation Weight (Easy Version) 做题记录",
			"link": "https://exber.qzz.io/post/CF1685D1%20Permutation%20Weight%20%28Easy%20Version%29%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-04-15 16:59:41"
		},
	
		{
			"abstract": "> 你需要一棵 $n$ 个节点的有根树，节点编号为 $[0,1,...,n-1]$，其中 $0$ 是根节点，且对于任何非根节点 $v$，它的父节点的标号 $p(v)$ 要比它的标号 $v$ 要小。\n> \n> 工厂里所有的树都是用竹子做的（可能不准确但不影响题意理解），这种竹子是有根的树，且每个节点只有一个子节点（除了叶子节点没有子节点），也就是说，它是直线形的。加工前，竹子的顶点可以随意标注。\n> \n> 要加工竹子为一棵树，可以进行这样的操作：选择任意一个不是根节点且父节点也不是根节点的节点 $v$，将它的父节点变成原先父节点的父节点即 $p(p(v))$，而其它节点的父节点都保持不变，$v$ 的子树也不会改变。\n> \n> 效率是至关重要的，所以在加工出所需要的树的前提下你应当最小化操作数。现在请你构造任何最优的操作序列以生成所需要的树\n> \n> 注意：加工出的结果树的标签必须和所需要的树的标签一致，即根节点标签相同，其它所有具有相同标签的子节点 $v$，其父节点标签$p(v)$也应相同。\n> \n> 数据保证任何输入都至少有一种可行的方案，且最优操作序列最多包含 $10^6$ 个操作。\n> \n> $2\\le n\\le 10^5$。\n",
			"content": "> 你需要一棵 $n$ 个节点的有根树，节点编号为 $[0,1,...,n-1]$，其中 $0$ 是根节点，且对于任何非根节点 $v$，它的父节点的标号 $p(v)$ 要比它的标号 $v$ 要小。\n> \n> 工厂里所有的树都是用竹子做的（可能不准确但不影响题意理解），这种竹子是有根的树，且每个节点只有一个子节点（除了叶子节点没有子节点），也就是说，它是直线形的。加工前，竹子的顶点可以随意标注。\n> \n> 要加工竹子为一棵树，可以进行这样的操作：选择任意一个不是根节点且父节点也不是根节点的节点 $v$，将它的父节点变成原先父节点的父节点即 $p(p(v))$，而其它节点的父节点都保持不变，$v$ 的子树也不会改变。\n> \n> 效率是至关重要的，所以在加工出所需要的树的前提下你应当最小化操作数。现在请你构造任何最优的操作序列以生成所需要的树\n> \n> 注意：加工出的结果树的标签必须和所需要的树的标签一致，即根节点标签相同，其它所有具有相同标签的子节点 $v$，其父节点标签$p(v)$也应相同。\n> \n> 数据保证任何输入都至少有一种可行的方案，且最优操作序列最多包含 $10^6$ 个操作。\n> \n> $2\\le n\\le 10^5$。\n\n考虑时光倒流，把给定的树变成一条链。\n\n显然答案下界是 $n-\\text{树高}$，因为每次操作最多让树高增加 $1$。\n\n那么每次找到深度最浅的分叉，把最高的那个子树接到其它随便一个子树上即可。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <set>\n\nusing namespace std;\n\nconst int S=500005;\n\nint n,fat[S];\nset<int> g[S];\nint dep[S];\nint tot,ans[S];\nint cnt,a[S];\n\nvoid dfs(int u)\n{\n\tdep[u]=0;\n\tfor(int v:g[u])\n\t{\n\t\tdfs(v);\n\t\tdep[u]=max(dep[u],dep[v]);\n\t}\n\tdep[u]++;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=2;i<=n;i++) scanf(\"%d\",&fat[i]),fat[i]++;\n\tfor(int i=2;i<=n;i++) g[fat[i]].insert(i);\n\tdfs(1);\n\tint u=1;\n\ta[++cnt]=u;\n\twhile(!g[u].empty())\n\t{\n\t\tif(g[u].size()>1)\n\t\t{\n\t\t\tint lst=0;\n\t\t\tfor(int v:g[u]) if(dep[v]>dep[lst]) lst=v;\n\t\t\tg[u].erase(lst);\n\t\t\twhile(!g[u].empty())\n\t\t\t{\n\t\t\t\tint v=*g[u].begin();\n\t\t\t\tans[++tot]=lst;\n\t\t\t\tg[u].erase(v);\n\t\t\t\tg[v].insert(lst);\n\t\t\t\tdep[v]=max(dep[v],dep[lst]+1);\n\t\t\t\tlst=v;\n\t\t\t}\n\t\t\tg[u].insert(lst);\n\t\t}\n\t\tu=*g[u].begin();\n\t\ta[++cnt]=u;\n\t}\n\tfor(int i=1;i<=n;i++) printf(\"%d \",a[i]-1);\n\tprintf(\"\\n\");\n\tprintf(\"%d\\n\",tot);\n\tfor(int i=tot;i>=1;i--) printf(\"%d \",ans[i]-1);\n\tprintf(\"\\n\");\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"构造"}],
			"title": "CF1225F Tree Factory 做题记录",
			"link": "https://exber.qzz.io/post/CF1225F%20Tree%20Factory%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-04-15 16:55:51"
		},
	
		{
			"abstract": "",
			"content": "### 值域树状数组求 $k-th$\n\n这里以第 $k$ 小为例。\n\n首先不难发现一定会有 $k-1$ 个数比第 $k$ 小的数小，那么只需要找到最大的满足 $[-\\inf,pos]$ 中数的个数等于 $k-1$ 的 $pos$，答案即为 $pos+1$。\n\n考虑倍增求出 $pos$，显然由于树状数组维护的区间的长度是 $2$ 的次幂，所以可以从大往小枚举 $2$ 的次幂 $2^p$ 并尝试加上这段区间。\n\n<details><summary>具体实现</summary><p>\n\n```cpp\ninline int kth(int k) // 这里假设值域 [1,n]\n{\n\tk--;\n\tint pos=0,sum=0;\n\tfor(int j=20;j>=0;j--) // 需要保证 2^j>=n\n\t{\n\t\tif(pos+(1<<j)<=n&&sum+tr[pos+(1<<j)]<=k)\n\t\t{\n\t\t\tsum+=tr[pos+(1<<j)];\n\t\t\tpos+=1<<j;\n\t\t}\n\t}\n\tif(sum!=k-1)\n\t{\n\t\treturn -1; // 没有\n\t}\n\treturn pos+1>n?-1:pos+1; // pos+1>n 也是没有的情况\n}\n```\n\n</p></details>\n\n### 值域倍增分块\n\n经常用于解决把所有 $a_i> x$ 的 $a_i$ 减去 $x$ 之类的东西。\n\n例题：[P7447 [Ynoi2007] rgxsxrs](https://www.luogu.com.cn/problem/P7447)\n\n<details><summary>题解</summary><p>\n\n> 把值域分成 $[2^k,2^{k+1})$ 这样的 $\\log$ 个块，那么每次修改就找到 $x$ 所在的块 $[2^y,2^{y+1})$：\n> \n> - 对于所有满足 $z>y$ 的 $[2^z,2^{z+1})$：这些块将会集体减掉 $x$，那么维护每一块的最小值，暴力让该跌落的值跌落到更低的块；\n> - 对于所有满足 $z<y$ 的 $[2^z,2^{z+1})$：这些块没有任何改变；\n> - 对于 $[2^y,2^{y+1})$：这一块中所有满足 $a_i>x$ 的 $a_i$ 都会跌落到更低的块，那么维护块内最大值暴力让该跌落的值跌落；\n> \n> 由于每个数最多只会跌落 $\\log V$ 次，所以时间复杂度为 $O(m\\log V\\log n+n\\log V)$。\n\n</p></details>\n\n更多例题：\n\n- [CF702F T-Shirts](https://www.luogu.com.cn/problem/CF702F)\n- [CF1515I Phoenix and Diamonds](https://www.luogu.com.cn/problem/CF1515I)\n- [P4587 [FJOI2016]神秘数](https://www.luogu.com.cn/problem/P4587)\n- [LOJ3527 地牢游戏](https://vjudge.csgrandeur.cn/problem/LibreOJ-3527)\n\n### 减半报警器\n\n用于解决类似这样的问题：\n\n> 维护一个数据结构，刚开始给了一些范围，每个范围有对应的权值。每次把包含一个点的范围的权值减去 $x$，维护每个范围的权值最早被减完的时刻。\n\n例题：[Codeforces GYM 102452I](https://codeforces.com/gym/102452/problem/I)\n\n> 有 $n$ 个国家，每个国家有权值 $w_i$ 和若干个（$\\le 3$）观测点。有 $q$ 次操作，每次会将所有能观测到 $x$ 的国家的 $w_i$ 减去 $y$。你要求出每个国家的权值第一次被减完是在第几次操作。\n\n<details><summary>题解</summary><p>\n\n> 观测点个数为 $1$ 的情况是最简单的，直接把 $w_i$ 挂到观测点上即可；\n>\n> 观测点个数为 $2$ 比较复杂，设这两个观测点为 $x$ 和 $y$，把 $\\lceil\\frac{w_i}{2}\\rceil$ 挂到 $x$ 上，$\\lceil\\frac{w_i}{2}\\rceil$ 挂到 $y$ 上。这样两边都没减完则 $w_i$ 一定没被减完，有一边被减完则判一下 $w_i$ 是否被减完，若没减完则重新平均分配。注意到每次 $w_i$ 至少减半，所以最多重新分配 $\\log V$ 次，均摊时间复杂度 $O(n\\log V)$；\n>\n> 观测点个数 $3$ 的情况和观测点个数为 $2$ 的情况一样，只需要把 $w_i$ 平均分成三份，注意到每次重新分配会让 $w_i$ 变成原来的 $\\frac{2}{3}$，那么均摊时间复杂度为 $O(n\\log_{1.5}V)$。\n>\n> 每次操作的时间复杂度为 $O(\\log n)$，那么总时间复杂度即为 $O(q\\log n+n\\log_{1.5}V)$。\n\n</p></details>\n\n注意挂的一定是向上取整的值，否则会出现 $(1,0,0)$ 这种尴尬情况。\n\n例题 2：[Codeforces GYM 104065B](https://codeforces.com/gym/104065/problem/B)\n\n> 你要邀请 $n$ 个人来参加会议，一个人同意参加当且仅当已经有至少 $k_i$ 个编号在 $[l_i,r_i]$ 内的人来参加，问最多能有多少个人参加。\n>\n> 也就是说你要确定一个邀请人的顺序。\n\n<details><summary>题解</summary><p>\n\n> 转换后的题意相当于给定了 $m$ 个区间，第 $i$ 个区间的权值为 $k_i$，你需要动态维护这样的过程：\n>\n> - 找到 $k_i\\le 0$ 的某个区间 $i$；\n> - 把它删掉，答案加一，同时将所有包含 $i$ 的区间的 $k_i$ 都减去 $1$；\n>\n> 考虑所有区间都包含某个位置 $p$ 的特殊情况，那么每个区间都可以被分成 $[l_i,p]$ 和 $[p+1,r_i]$ 两段。可以把 $k_i$ 平均分到这两段上，每一次修改操作相当于找到左边的一个后缀或者右边的一个前缀减掉 $1$。\n>\n> 这样若一个区间的某一边被减完了则重新分配剩下的 $k_i$，每次至少减半，均摊时间复杂度为 $O(n\\log V)$。\n>\n> 用线段树动态维护这个东西，每次区间减，暴力找到需要重构的区间编号即可。\n>\n> 若所有区间没有包含共同的位置，那么可以把区间分成三类：\n>\n> - 包含 $\\lfloor\\frac{n}{2}\\rfloor$ 的；\n> - 在 $\\lfloor\\frac{n}{2}\\rfloor$ 左边的；\n> - 在 $\\lfloor\\frac{n}{2}\\rfloor$ 右边的；\n>\n> 这是一个类似线段树的结构，那么分治下去，每次修改都不断往 $x$ 的方向走，改一下包含当前分治中心 $mid$  的区间。\n>\n> 一次修改会分治 $O(\\log n)$ 次，每次分治的时间复杂度为 $O(\\log n)$，那么总的时间复杂度即为 $O(n\\log^2n+n\\log V)$。\n\n</p></details>\n\n更多例题：\n\n- [P7603 [THUPC2021] 鬼街](https://www.luogu.com.cn/problem/P7603)\n- [Codeforces GYM 102331F](https://codeforces.com/gym/102331/problem/F)\n- 【2025NOI模拟赛27】防御\n\n### 支配\n\n>  $x$ 满足的条件包含 $y$ 满足的条件，并且 $x$ 的值比 $y$ 的优，那么 $y$ 就没有存在的必要了。\n>\n> ——《单调队列》\n\n#### 关于距离的支配\n\n##### 序列上\n\n[CF765F Souvenirs](https://www.luogu.com.cn/problem/CF765F) / [CF1793F Rebrending](https://www.luogu.com.cn/problem/CF1793F)\n\n<details><summary>题解</summary><p>\n\n> CF 自己抄自己，两道题一模一样。\n>\n> 先假设只有 $i<j$ 且 $a_i<a_j$ 的 $(i,j)$ 有贡献，另一种取值再跑一次即可。\n>\n> 注意到若 $(i1,j1)$ 和 $(i2,j2)$（$i1<j2$，$i2<j2$）若满足 $a_{i1}-a_{j1}\\le a_{i2}-a_{j2}$ 且 $i1\\ge i2$，$j1\\le j2$ 则$(i2,j2)$ 被 $(i1,j1)$ 完全包含了，即 $(i1,j1)$ 支配了 $(i2,j2)$，所以只用统计 $(i1,j1)$ 的贡献。\n>\n> 固定 $i$，考虑找到所有有用的 $j$。设 $S_i=\\{j|(i,j)\\text{ 未被支配}\\}$，考虑增量求解 $S_i$，设 $p=\\max\\{j|j\\in S_i\\}$，那么 $k$（$k>p$）想要加入 $S_i$ 就必须满足：\n>\n> - $a_k-a_i<a_p-a_i\\Rightarrow a_k<a_p$；\n> - $a_k-a_i<|a_p-a_k|\\Rightarrow a_k-a_i<a_p-a_k\\Rightarrow a_k<\\frac{a_p+a_i}{2}$；\n>\n> 所以 $|S_i|$ 是 $\\log V$ 级别的，那么未被支配的 $(i,j)$ 也就只有 $n\\log V$ 个。\n>\n> 接下来就变成二维数点问题了，扫描线即可，时间复杂度 $O((q+n\\log V)\\log n)$。\n\n</p></details>\n\n##### 树上\n\n[P9058 [Ynoi2004] rpmtdq](https://www.luogu.com.cn/problem/P9058)\n\n<details><summary>题解</summary><p>\n\n> 考虑点分治，对于来自分治中心 $rt$ 不同两个子树中的两个点 $x,y$，显然有 $\\operatorname{dis}(x,y)=\\operatorname{dis}(x,rt)+\\operatorname{dis}(y,rt)$。\n>\n> 那么不妨设 $a_u=\\operatorname{dis}(u,rt)$，显然点对 $(i,j)$（$i<j$）未被支配当且仅当对于所有 $i<k<j$ 都有 $a_i+a_j<a_i+a_k$ 且 $a_i+a_j<a_k+a_j$。稍加化简可得 $a_i<a_k,a_j<a_k$，$\\max(a_i,a_j)<a_k$，那么只有 $a_i$ 的前驱后继会和 $i$ 构成支配，所以每层分治每个点只会组成 $O(1)$ 个支配对，那么总支配对个数是 $O(n\\log n)$ 的。\n>\n> 接下来就变成二维数点问题了，扫描线即可，时间复杂度 $O((q+n\\log V)\\log n)$。\n\n</p></details>\n\n#### 一些特殊的支配\n\n##### Mex 支配\n\n对于一个长度为 $n$ 的序列 $a$，设 $b_{l,r}=\\text{mex}_{l\\le i\\le r}\\{a_i\\}$，有性质：\n\n1. $b_{l,r}\\ge b_{l+1,r}$，证明显然；\n\n2. $b_{*,r}\\to b_{*,r+1}$ 相当于把所有 $b_{i,r}=a_{r+1}$ 的 $b_{i,r}$ 都修改为大于 $a_{r+1}$ 的数，由第一个性质，需要被修改的 $i$ 一定是在一个区间内，所以根据颜色段均摊的经典结论，所有 $r$ 造成的总修改数是 $O(n)$ 级别的；\n\n3. 满足不存在 $[l',r']\\subset [l,r],b_{l',r'}=b_{l,r}$ 的区间 $[l,r]$ 个数最多有 $2n$ 个。\n\n   <details><summary>证明</summary><p>\n\n   > 对于每个满足条件的 $[l,r]$，显然 $a_l\\not=a_r$，不妨假定 $a_l>a_r$（另一种情况对称）。\n   >\n   > 现在来证明对于每个 $l$，都只有一个 $r$ 满足 $r>l,a_l>a_r$ 且 $[l,r]$ 满足条件。\n   >\n   > 考虑反证，设存在 $l<r1<r2$ 满足 $a_l>a_{r1},a_l>a_{r2}$ 且 $[l,r1]$ 与 $[l,r2]$ 均满足条件。显然由于 $[l,r1]$ 满足条件，一定有 $b_{l,r1}>a_l$。由于 $a_l>a_{r2}$，所以有 $b_{l,r1}>a_{r2}$，那么显然 $[l,r2-1]\\sub [l,r2]$ 且 $b_{l,r2}=b_{l,r2-1}$，所以 $[l,r2]$ 不满足条件，矛盾。\n   >\n   > 那么对于每个位置 $i$，它作为 $a_{l}$ 和 $a_r$ 中最小值时最多有一个合法区间，作为最大值时也最多有一个合法区间，所以合法区间个数最多有 $2n$ 个。\n   >\n   > Q.E.D.\n   \n   </p></details>\n\n#### 更多例题\n\n- [P8528 [Ynoi2003] 铃原露露](https://www.luogu.com.cn/problem/P8528)\n- [P9060 [Ynoi2002] Goedel Machine](https://www.luogu.com.cn/problem/P9060)\n\n### 三维计数技巧\n\n> 对于满足某些条件的有序三元组 $(i,j,k)$ 且固定 $k$ 和 $j$ 后合法的 $i$ 在一段区间内时，可以考虑枚举 $k$ 同时维护每个 $j$ 对应的 $i$ 的合法区间 $[l_j,r_j]$。\n\n例题：[Nasty Donchik](https://codeforces.com/group/Uo1lq8ZyWf/contest/265564/problem/C)\n\n> 题意：给定序列 $a_1,a_2,\\dots,a_n$，求有多少有序三元组 $(i,j,k)$ 满足 $i\\le j<k$ 且 $a_{[i,j]}$ 中出现的数集以及 $a_{[j+1,k]}$ 中出现的数放入两个不可重集后两个集合相等。\n\n<details><summary>题解</summary><p>\n\n> 固定 $k$ 和 $j$ 后显然 $i$ 是在一个区间内的，考虑维护 $l_p$ 和 $r_p$ 表示 $j=p$ 时 $i$ 的上界和下界减一，则固定 $k$ 后的答案即为 $\\sum\\limits_{j=1}^{k-1}\\max(r_j-l_j,0)$。那么设 $L_i=\\max\\{j|j<i,a_j=a_i\\},R_i=\\min\\{j|j>i,a_j=a_i\\}$，则有 $l_j=\\max\\{i|i\\le j,R_i>k\\},r_j=\\min\\{L_i|j<i\\le k\\}$。\n>\n> 考虑 $k\\to k+1$ 后对 $l_j$ 和 $r_j$ 的影响，注意到 $l_j$ 单调递增且 $r_j$ 单调递增，而 $k\\to k+1$ 对 $l_j$ 的影响是删去了 $R_i=k+1$ 的元素，体现为后缀取 $\\min$ 即区间赋值；对 $r_j$ 的影响则是加入了 $L_{k+1}$，也体现为后缀取 $\\min$ 即区间赋值。注意到由于两个东西都是单调递增的，所以可以用线段树来维护。\n>\n> 时间复杂度 $O(n\\log n)$。\n\n</p></details>\n\n更多例题：\n\n- [GYM102900J Octasection](https://codeforces.com/gym/102900/problem/J)\n\n### 区间修改区间历史和线段树\n\n考虑给线段树上每个点维护一个一次函数 $f(x)=kx+b$，$f(x)$ 为 $x$ 时的历史和。\n\n单点修改区间查询是好做的，找到要修改的点，设在时刻 $y$ **结束后**要修改为 $k'$，那么把那个点的一次函数修改为 $f(x)=k'x+y(k-k')+b$ 即可。\n\n区间修改区间查询分为两种情况：\n\n- 区间加区间查询：很好做，给 $k$ 和 $b$ 打 tag 即可；\n- 区间赋值区间查询：\n  注意到此时区间内 $k$ 不同则无法一起修改，那么维护区间 $k$ 最小值 $mnk$ 和最大值 $mxk$。对于一个需要被修改的区间，若 $mnk\\not=mxk$ 则递归左右儿子修改，否则直接打 tag 修改。\n  这样做时间复杂度均摊是 $O(n+q\\log n)$ 的，其中 $n$ 为序列长度，$q$ 为操作数。因为刚开始最多有 $n$ 个区间需要额外往下递归，每次修改最多会让 $\\log n$ 个区间在以后的修改中需要额外往下递归，所以总共需要额外往下递归的区间是 $O(n+q\\log n)$ 的；\n\n例题：\n\n- [【2022NOI模拟赛01】漏网之鱼](https://www.ckjweb.tk/post/2022noi-mo-ni-sai-01-lou-wang-zhi-yu-zuo-ti-ji-lu/)\n- [CF1824D LuoTianyi and the Function](https://www.luogu.com.cn/problem/CF1824D)\n\n### set 维护连续段\n\n颜色段均摊若用线段树维护则会把一个连续段拆成 $\\log$ 个，总连续段个数变为 $O(n\\log n)$。\n\n而用 set 维护则总连续段个数是 $O(n)$ 的，并且很好写。\n\n代码如下：\n\n```cpp\nstruct seg\n{\n\tint l,r,x;\n\tinline bool operator<(const seg &b)const{return l<b.l;}\n};\n\ntypedef set<seg>::iterator iter;\nset<seg> st;\n\ninline iter split(int p)\n{\n\titer x=st.lower_bound((seg){p,0,0});\n\tif(x!=st.end()&&x->l==p) return x;\n\tx--;\n\tseg vx=*x;\n\tst.erase(x);\n\tst.insert((seg){vx.l,p-1,vx.x});\n\treturn st.insert((seg){p,vx.r,vx.x}).first;\n}\n\ninline void ins(int lb,int rb,int x)\n{\n\tsplit(lb);\n\titer l,r=prev(split(rb+1));\n\tl=st.lower_bound((seg){lb,0,0});\n\titer pr=l,ed=next(r);\n\twhile(pr!=ed)\n\t{\n\t\t// a_{[pr->l,pr->r]} = x\n\t\tst.erase(pr++);\n\t}\n\tst.insert((seg){lb,rb,p});\n}\n```\n\n### 摩尔投票\n\n可以用来求集合中出现次数**可能**严格大于 $\\lfloor\\frac{r-l+1}{k}\\rfloor$ 的 $k-1$ 个数。\n\n为什么是可能呢，因为它的原理如下：\n\n> 每次选 $k$ 个互不相同的数，将它们从集合中删去，剩下的至多 $k-1$ 种数就是答案。\n\n这是显然的，因为答案一定不会被删去（出现次数比其它数出现次数总和的 $\\frac{1}{k-1}$ 还多），而答案至多只有 $k-1$ 个。\n\n这个东西满足可加性，维护两个集合最后剩下的 $k-1$ 个数即可。\n\n那么可以做区间修改区间查询众数了。\n\n没见过想不到。\n\n例题：[P3765 总统选举](https://www.luogu.com.cn/problem/P3765)\n\nNOI 考过：[P8496 [NOI2022] 众数](https://www.luogu.com.cn/problem/P8496)\n\n模拟赛考过：【2024NOIP模拟赛73】数数\n\n### 函数复合扫描线\n\n> 给定一个函数的序列 $f_i$，每次给定一个输入 $x$ 和一个区间 $[l,r]$，查询 $f_r(f_{r-1}(f_{r-2}(\\dots f_l(x)\\dots)))$，即对 $x$ 依次应用区间内函数后的结果。\n\n这种题有一个套路就是离线，然后从左往右扫描函数序列，动态维护一个集合 $S$：\n\n- 遇到查询左端点的时候将 $x$ 加入 $S$，并保存好 $x$ 在 $S$ 中的指针；\n- 扫过一个 $i$ 就将 $S$ 中元素集体应用 $f_i$；\n- 遇到查询右端点就拿出指针查询 $x$ 的最终值；\n\n”保存指针“：由于 $S$ 一般要用某些数据结构维护，而 $x$ 会不断改变，所以需要维护 $x$ 在对应数据结构中的指针（例如平衡树的节点编号）。\n\n例题：\n\n- [QOJ # 8672. 排队](https://qoj.ac/problem/8672)\n- [P9999 [Ynoi2000] tmostnrq](https://www.luogu.com.cn/problem/P9999)\n- [CF1172F Nauuo and Bug](https://www.luogu.com.cn/problem/CF1172F)\n",
			"tags": [{"name":"学习笔记"},{"name":"小技巧"},{"name":"数据结构"}],
			"title": "一些数据结构技巧",
			"link": "https://exber.qzz.io/post/%E4%B8%80%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%8A%80%E5%B7%A7",
			"date": "2023-04-15 16:52:12"
		},
	
		{
			"abstract": "> 有 $n$ 个人，最开始每个人手中有 $1$ 颗绿宝石，每天晚上，会随机选一个绿宝石分裂为两个。\n> \n> 求 $d$ 个晚上后绿宝石数量最多的 $r$ 个人的绿宝石数和的期望值。\n> \n> $1 \\le n,d \\le 500$，$1 \\le r\\le n$。\n",
			"content": "> 有 $n$ 个人，最开始每个人手中有 $1$ 颗绿宝石，每天晚上，会随机选一个绿宝石分裂为两个。\n> \n> 求 $d$ 个晚上后绿宝石数量最多的 $r$ 个人的绿宝石数和的期望值。\n> \n> $1 \\le n,d \\le 500$，$1 \\le r\\le n$。\n\n设 $dp_{i,j}$ 表示把 $j$ 划分成 $i$ 个有标号非负整数相加的方案数，转移考虑枚举 $\\ge 1$ 的数的个数：\n$$\ndp_{i,j}=\\sum\\limits_{k=1}^{\\min(i,j)}\\binom{i}{k}dp_{k,j-k}\n$$\n设 $pd_{i,j}$ 表示把 $j$ 划分成 $i$个有标号非负整数相加的所有方案中前 $r$ 大的数的和，转移类似：\n$$\npd_{i,j}=\\sum\\limits_{k=1}^{\\min(i,j)}\\binom{i}{k}(pd_{k,j-k}+\\min(k,r)\\times dp_{k,j-k})\n$$\n 最后答案即为 $\\frac{pd_{n,d}+r}{dp_{n,d}}$，由于神秘原因，所以开 long double 即可。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=505;\n\nint n,d,r;\nlong double C[S][S],dp[S][S],pd[S][S];\n\nint main()\n{\n\tfor(int i=0;i<=S-3;i++)\n\t{\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<=i;j++) C[i][j]=C[i-1][j]+C[i-1][j-1];\n\t}\n\tscanf(\"%d%d%d\",&n,&d,&r);\n\tdp[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tdp[i][0]=1;\n\t\tfor(int j=1;j<=d;j++)\n\t\t{\n\t\t\tfor(int k=1;k<=i&&k<=j;k++)\n\t\t\t{\n\t\t\t\tdp[i][j]+=C[i][k]*dp[k][j-k];\n\t\t\t\tpd[i][j]+=C[i][k]*(pd[k][j-k]+min(k,r)*dp[k][j-k]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%Lf\\n\",pd[n][d]/dp[n][d]+r);\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"数学"},{"name":"概率、期望"},{"name":"DP"},{"name":"组合计数"}],
			"title": "P6944 [ICPC2018 WF]Gem Island 做题记录",
			"link": "https://exber.qzz.io/post/P6944%20%5BICPC2018%20WF%5DGem%20Island%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-04-15 16:49:30"
		},
	
		{
			"abstract": "> 有一段长为 $l$ 的线段，有 $n$ 个区间，左右端点在 $[0,l)$ 间均匀随机（可能不是整数）\n> \n> 求期望被至少 $k$ 段区间覆盖的长度，对 $998244353$ 取膜。\n> \n> $1\\leq k \\leq n \\leq 2000$，$1\\leq l\\leq 10^9$。\n",
			"content": "> 有一段长为 $l$ 的线段，有 $n$ 个区间，左右端点在 $[0,l)$ 间均匀随机（可能不是整数）\n> \n> 求期望被至少 $k$ 段区间覆盖的长度，对 $998244353$ 取膜。\n> \n> $1\\leq k \\leq n \\leq 2000$，$1\\leq l\\leq 10^9$。\n\n首先显然问题与值域 $[0,1]$ 是等价的，因为期望是线性的，可以乘上 $l$，并且实数闭区间和开区间是等价的。\n\n设 $f(x)$ 为 $x$ 这个位置被覆盖至少 $k$ 次的概率，那么答案即为 $\\int_0^1f(x)dx$。 \n\n考虑一个转化，设 $X$ 是一个 $[0,1]$ 中的随机变量，那么 $X$ 被覆盖至少 $k$ 次的概率就是 $\\frac{\\int_0^1f(x)dx}{1}=\\int_0^1f(x)dx$ 即答案。所以问题变成求 $[0,1]$ 中随机一个位置被覆盖至少 $k$ 次的概率。\n\n不难发现，由于是实数，所以我们并不关心 $X$ 和区间端点的具体取值，只关心它们的相对位置。那么把这 $2n+1$ 个位置拉出来，区间左端点看作左括号，区间右端点看作右括号，设 $dp_{i,j,0/1}$ 表示考虑完前 $i$ 个位置，有 $j$ 个左括号未匹配，没放/放 $X$ 的方案数。那么有转移：\n$$\n\\begin{cases}dp_{i,j,f}\\to dp_{i+1,j+1,f}\\\\j\\times dp_{i,j,f}\\to dp_{i+1,j-1,f}&j>0\\\\\ndp_{i,j,f}\\to dp_{i+1,j,1}&j\\ge k,f=0\\end{cases}\n$$\n$dp_{2n+1,0,1}$ 除掉总的方案数即为要求的 $\\int_0^1f(x)dx$，这个东西乘上 $l$ 就是答案。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nconst int S=2005,p=998244353;\n\nint n,k,l;\nint dp[2][S*2][2],pd[2][S*2];\n\ninline void add(int &x,int y)\n{\n\tx+=y;\n\tif(x>=p) x-=p;\n}\n\ninline int qpow(int x,int y)\n{\n\tint res=1;\n\tfor(;y>0;y>>=1,x=1ll*x*x%p) res=y&1?1ll*res*x%p:res;\n\treturn res;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&k,&l);\n\tdp[0][0][0]=pd[0][0]=1;\n\tfor(int i=0;i<=n*2;i++)\n\t{\n\t\tint u=i&1,v=i+1&1;\n\t\tmemset(dp[v],0,sizeof(dp[v]));\n\t\tmemset(pd[v],0,sizeof(pd[v]));\n\t\tfor(int j=0;j<=i;j++)\n\t\t{\n\t\t\tfor(int f=0;f<=1;f++)\n\t\t\t{\n\t\t\t\tif(dp[u][j][f]==0) continue;\n\t\t\t\tadd(dp[v][j+1][f],dp[u][j][f]);\n\t\t\t\tif(j>0) add(dp[v][j-1][f],1ll*dp[u][j][f]*j%p);\n\t\t\t\tif(j>=k&&f==0) add(dp[v][j][1],dp[u][j][f]);\n\t\t\t}\n\t\t\tadd(pd[v][j+1],pd[u][j]);\n\t\t\tif(j>0) add(pd[v][j-1],1ll*pd[u][j]*j%p);\n\t\t}\n\t}\n\t// printf(\"%d / %d\\n\",dp[n*2+1&1][0][1],1ll*pd[n*2&1][0]*(n*2+1)%p);\n\tprintf(\"%d\\n\",1ll*dp[n*2+1&1][0][1]*qpow(1ll*pd[n*2&1][0]*(n*2+1)%p,p-2)%p*l%p);\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"数学"},{"name":"DP"},{"name":"概率、期望"}],
			"title": "CF1153F Serval and Bonus Problem 做题记录",
			"link": "https://exber.qzz.io/post/CF1153F%20Serval%20and%20Bonus%20Problem%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-04-15 16:45:52"
		},
	
		{
			"abstract": "> 给两个包含 `A`,`B`,`?` 的串，`?` 可以填 `A` 或 `B`，求所有情况下下面这个东西的和，对 $10^9+7$ 取模：\n> \n> - 统计有多少对长度 $\\le n$ 的 $01$ 串 $(S,T)$ 使得把所有 `A` 换成 $S$，`B` 换成 $T$ 后两个串相等；\n> \n> 两个串的长度 $\\le 3\\times 10^5$。\n为了方便，设 $|a|=n,|b|=m$，原来的 $n$ 设为 $k$。\n",
			"content": "> 给两个包含 `A`,`B`,`?` 的串，`?` 可以填 `A` 或 `B`，求所有情况下下面这个东西的和，对 $10^9+7$ 取模：\n> \n> - 统计有多少对长度 $\\le n$ 的 $01$ 串 $(S,T)$ 使得把所有 `A` 换成 $S$，`B` 换成 $T$ 后两个串相等；\n> \n> 两个串的长度 $\\le 3\\times 10^5$。\n为了方便，设 $|a|=n,|b|=m$，原来的 $n$ 设为 $k$。\n\n首先有：\n\n![](../post-images/1681548014495.png)\n\n那么 $s$ 和 $t$ 一定是由一个小串 $c$ 不断重复得到的，其中 $|c|=\\gcd(|s|,|t|)$。\n\n先不管问号，设 $a$ 中的 `A` 比 $b$ 中的 `A` 多 $x$ 个，$b$ 中的 `B` 比 $a$ 中的 `B` 多 $y$ 个，那么显然有限制 $x\\times |s|=y\\times |t|$。显然若 $x$ 和 $y$ 异号则无解，否则可以让 $x$ 和 $y$ 都取绝对值。接下来分类讨论：\n\n- $x=y=0$：\n\n  此时 $|s|$ 和 $|t|$ 可以取任意值，那么答案为：\n  $$\n  \\begin{aligned}\n  &\\sum\\limits_{i=1}^k\\sum\\limits_{j=1}^k2^{\\gcd(i,j)}\\\\\n  &=\\sum\\limits_{d=1}^{k}2^d\\sum\\limits_{i=1}^{\\lfloor\\frac{k}{d}\\rfloor}\\sum\\limits_{j=1}^{\\lfloor\\frac{k}{d}\\rfloor}[\\gcd(i,j)=1]\\\\\n  &=\\sum\\limits_{d=1}^{k}2^d\\sum\\limits_{i=1}^{\\lfloor\\frac{k}{d}\\rfloor}\\mu(i)\\left(\\left\\lfloor\\frac{k}{di}\\right\\rfloor\\right)^2\n  \\end{aligned}\n  $$\n  直接整除分块，时间复杂度 $O(k)$。\n\n- $x=0$ 且 $y\\not=0$ 或 $x\\not=0$ 且 $y=0$：方程无解。\n\n- $x>0,y>0$：\n\n  若 $x$ 和 $y$ 不互质则可以同时除掉 $\\gcd(x,y)$，方程显然仍然成立，所以下面默认 $x$ 和 $y$ 互质。\n  因为 $x$ 和 $y$ 互质，所以有 $|s|=y\\times w,|t|=x\\times w$，$w$ 的取值范围是 $[1,\\lfloor\\frac{k}{y}\\rfloor]\\cap[1,\\lfloor\\frac{k}{x}\\rfloor]=[1,\\lfloor\\frac{k}{\\max(x,y)}\\rfloor]$，答案即为 $\\sum\\limits_{i=1}^{\\lfloor\\frac{k}{\\max(x,y)}\\rfloor}2^i$。\n\n现在考虑有问号的情况，先设 $x,y$ 的答案为 $f(x,y)$，设 $a$ 原来有 $aa$ 个 `A`，$ab$ 个 `B`，$aq$ 个 `?`，$b$ 原来有 $ba$ 个 `A`，$bb$ 个 `B`，$bq$ 个 `?` 那么有：\n$$\n\\begin{aligned}\nans&=\\sum\\limits_{i=0}^{aq}\\sum\\limits_{j=0}^{bq}\\binom{aq}{i}\\binom{bq}{j}f(aa+i-ba-j,bb+bq-j-ab-aq+i)\\\\\n&=\\sum\\limits_{i=-bq}^{aq}f(aa-ba+i,m-ba-n+aa+i)\\sum\\limits_{j=0}^{bq}\\binom{bq}{j}\\binom{aq}{i+j}\\\\\n&=\\sum\\limits_{i=-bq}^{aq}f(aa-ba+i,m-ba-n+aa+i)\\sum\\limits_{j=0}^{bq}\\binom{bq}{j}\\binom{aq}{aq-i-j}\\\\\n&=\\sum\\limits_{i=-bq}^{aq}f(aa-ba+i,m-ba-n+aa+i)\\binom{bq+aq}{aq-i}\\\\\n\\end{aligned}\n$$\n$f(0,0)$ 单独算一下，其他的 $f$ 均可 $O(1)$ 算出，那么时间复杂度 $O(n)$。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nconst int S=2000005,p=1000000007;\n\nint n,m,k;\nchar a[S],b[S];\nint aa,ab,aq,ba,bb,bq;\nbool nop[S];\nint tot,prime[S];\nint mu[S],sum[S];\nint fra[S],inv[S];\nint _2sum[S];\n\ninline int qpow(int x,int y)\n{\n\tint res=1;\n\tfor(;y>0;y>>=1,x=1ll*x*x%p) res=y&1?1ll*res*x%p:res;\n\treturn res;\n}\n\ninline int C(int n,int m)\n{\n\tif(n<0||m<0||n<m) return 0;\n\treturn 1ll*fra[n]*inv[n-m]%p*inv[m]%p;\n}\n\ninline int gcd(int x,int y)\n{\n\tint t=x%y;\n\twhile(t!=0) x=y,y=t,t=x%y;\n\treturn y;\n}\n\ninline int g(int n)\n{\n\tint res=0;\n\tfor(int l=1;l<=n;l++)\n\t{\n\t\tint r=min(n,n/(n/l));\n\t\tint val=((long long)sum[r]-sum[l-1]+p)%p;\n\t\tres=(res+1ll*val*(n/l)%p*(n/l)%p)%p;\n\t\tl=r;\n\t}\n\treturn res;\n}\n\ninline int f(int x,int y)\n{\n\tif(x==0&&y==0)\n\t{\n\t\tint res=0;\n\t\tfor(int l=1;l<=k;l++)\n\t\t{\n\t\t\tint r=min(k,k/(k/l));\n\t\t\tint val=((long long)_2sum[r]-_2sum[l-1]+p)%p;\n\t\t\tres=(res+1ll*val*g(k/l)%p)%p;\n\t\t\tl=r;\n\t\t}\n\t\treturn res;\n\t}\n\telse\n\t{\n\t\tint g=gcd(x,y);\n\t\tx/=g,y/=g;\n\t\treturn ((long long)_2sum[k/max(x,y)]-_2sum[0]+p)%p;\n\t}\n}\n\nint main()\n{\n\tscanf(\"%s%s%d\",a+1,b+1,&k);\n\tn=strlen(a+1),m=strlen(b+1);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\taa+=a[i]=='A';\n\t\tab+=a[i]=='B';\n\t\taq+=a[i]=='?';\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tba+=b[i]=='A';\n\t\tbb+=b[i]=='B';\n\t\tbq+=b[i]=='?';\n\t}\n\tnop[0]=nop[1]=true;\n\tmu[1]=1;\n\tfor(int i=2;i<=S-3;i++)\n\t{\n\t\tif(!nop[i])\n\t\t{\n\t\t\tprime[++tot]=i;\n\t\t\tmu[i]=-1;\n\t\t}\n\t\tfor(int j=1;j<=tot;j++)\n\t\t{\n\t\t\tif(i*prime[j]>S-3) break;\n\t\t\tnop[i*prime[j]]=true;\n\t\t\tmu[i*prime[j]]=mu[i]*mu[prime[j]];\n\t\t\tif(i%prime[j]==0)\n\t\t\t{\n\t\t\t\tmu[i*prime[j]]=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=S-3;i++) sum[i]=((long long)sum[i-1]+mu[i]+p)%p;\n\tfra[0]=1;\n\tfor(int i=1;i<=S-3;i++) fra[i]=1ll*fra[i-1]*i%p;\n\tinv[S-3]=qpow(fra[S-3],p-2);\n\tfor(int i=S-3;i>=1;i--) inv[i-1]=1ll*inv[i]*i%p;\n\t_2sum[0]=1;\n\tfor(int i=1,tmp=1;i<=S-3;i++)\n\t{\n\t\ttmp=2ll*tmp%p;\n\t\t_2sum[i]=(_2sum[i-1]+tmp)%p;\n\t}\n\tint ans=0;\n\tfor(int i=-bq;i<=aq;i++)\n\t{\n\t\tint x=aa-ba+i,y=m-ba-n+aa+i;\n\t\tif((x<0&&y>0)||(x>0&&y<0)) continue;\n\t\tx=abs(x),y=abs(y);\n\t\tif((x==0||y==0)&&x+y>0) continue;\n\t\t// printf(\"%d %d %d\\n\",x,y,f(x,y));\n\t\tans=(ans+1ll*f(x,y)*C(bq+aq,aq-i)%p)%p;\n\t}\n\tbool fl=n==m;\n\tfor(int i=1;i<=n;i++) fl&=a[i]==b[i]||a[i]=='?'||b[i]=='?';\n\tif(fl)\n\t{\n\t\tint cnt=0;\n\t\tfor(int i=1;i<=n;i++) cnt+=a[i]=='?'&&b[i]=='?';\n\t\tans=((long long)ans-1ll*f(0,0)*qpow(2,cnt)%p+p)%p;\n\t\tint val=((long long)_2sum[k]-_2sum[0]+p)%p;\n\t\tans=(ans+1ll*val*val%p*qpow(2,cnt)%p)%p;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"数学"},{"name":"组合计数"},{"name":"结论"},{"name":"字符串"},{"name":"数论"}],
			"title": "CF794G Replace All 做题记录",
			"link": "https://exber.qzz.io/post/CF794G%20Replace%20All%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-04-15 16:39:48"
		},
	
		{
			"abstract": "> 给你两个可重集 $A, B$，$A, B$ 的元素个数都为 $n$，它们中每个元素的大小 $x\\in [1,n]$。请你分别找出 $A$ 的一个子集和 B$ 的一个子集，使得它们中的元素之和相等。输出方案。\n> \n> $1\\le n\\leq 10^6$。\n",
			"content": "> 给你两个可重集 $A, B$，$A, B$ 的元素个数都为 $n$，它们中每个元素的大小 $x\\in [1,n]$。请你分别找出 $A$ 的一个子集和 B$ 的一个子集，使得它们中的元素之和相等。输出方案。\n> \n> $1\\le n\\leq 10^6$。\n\n\n直接考虑子序列是做不了的，那么不妨加强限制，考虑子段。\n\n发现值域是序列的长度 $n$，这启发我们想到抽屉原理。设 $sa$ 和 $sb$ 是两个序列的前缀和，不妨假设 $sa_n\\le sb_n$，设 $pos_i$ 表示最大的满足 $sb_x\\le sa_i$ 的 $x$，那么总有 $pos_i=n$ 或者 $sb_{pos_i+1}-sa_i>0$。后者移项得 $sa_i-sb_{pos_i}<b_{pos_i+1}$，而 $pos_i=n$ 的情况则由于 $sa_n<sb_n$ 所以有 $sa_i-sb_{pos_i}=0$。由于 $b_{pos_i+1}$ 的最大值为 $n$，所以总有 $sa_i-sb_{pos_i}<n$。\n\n注意到只要找到一个四元组 $(l1,r1,l2,r2)$，满足 $0\\le l1<r1\\le n,0\\le l2<r2\\le n$ 且 $a_{l1}-b_{l2}=a_{r1}-b_{r2}$ 则 $[l1+1,r1]$ 和 $[l2+1,r2]$ 就是一个合法的解。而 $sa_i-sb_{pos_i}$ 共有 $n$ 种取值，$i$ 却有 $n+1$ 种取值，所以总能找到两对相等的 $sa_i-sb_{pos_i}$。并且由于 $sa_i$ 互不相同，所以这两对的 $pos_i$ 也互不相同，所以找出来的是合法的解。\n\n那么用个桶记录每个 $sa_i-sb_{pos_i}$ 对应的 $i$ 即可，时间复杂度 $O(n)$。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=1000005;\n\nint n;\nbool flg;\nint a[S],b[S];\nlong long sa[S],sb[S];\nint pos[S],val[S];\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&b[i]);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tsa[i]=sa[i-1]+a[i];\n\t\tsb[i]=sb[i-1]+b[i];\n\t}\n\tif(sa[n]>sb[n])\n\t{\n\t\tflg=true;\n\t\tswap(a,b);\n\t\tswap(sa,sb);\n\t}\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tif(i>0) pos[i]=pos[i-1];\n\t\twhile(pos[i]<n&&sb[pos[i]+1]<=sa[i]) pos[i]++;\n\t\tval[i]=-1;\n\t}\n\tint l1=-1,r1=-1,l2=-1,r2=-1;\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tint pre=sa[i]-sb[pos[i]];\n \t\tif(val[pre]!=-1)\n \t\t{\n \t\t\tif(!flg)\n \t\t\t{\n \t\t\t\tl1=val[pre],r1=i;\n \t\t\t\tl2=pos[val[pre]],r2=pos[i];\n \t\t\t}\n \t\t\telse\n \t\t\t{\n \t\t\t\tl1=pos[val[pre]],r1=pos[i];\n \t\t\t\tl2=val[pre],r2=i;\n \t\t\t}\n \t\t}\n\t\telse val[pre]=i;\n\t}\n\tif(l1>r1) swap(l1,r1);\n\tif(l2>r2) swap(l2,r2);\n\tl1++,l2++;\n\tprintf(\"%d\\n\",r1-l1+1);\n\tfor(int i=l1;i<=r1;i++) printf(\"%d \",i);\n\tprintf(\"\\n%d\\n\",r2-l2+1);\n\tfor(int i=l2;i<=r2;i++) printf(\"%d \",i);\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"构造"}],
			"title": "CF618F Double Knapsack 做题记录",
			"link": "https://exber.qzz.io/post/CF618F%20Double%20Knapsack%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-04-15 16:36:05"
		},
	
		{
			"abstract": "",
			"content": "## Part 1 公共部分\n\n### 1.1 定义\n\n- 补图：\n  - **无向图** $G$ 的补图中存在一条边 $(x,y)$ 当且仅当 $G$ 中不存在边 $(x,y)$\n  - **有向图** $G$ 的补图中存在一条边 $x\\to y$ 当且仅当 $G$ 中不存在边 $x\\to y$；\n- 子图：图中**某些点和它们之间的边**构成的新图；\n- 链覆盖：把图划分为若干条链的方案；\n- 反链：满足 $\\forall x,y\\in S$，$x$ 不能到达 $y$ 且 $y$ 不能到达 $x$ 的点集 $S$。\n\n### 1.2 定理\n\n- 最小链覆盖等于最长反链\n\n  <details><summary>证明</summary><p>\n\n  > 考虑不得不用两条链覆盖的结构，即一个分叉，显然不同分支上的点不能相互到达，那么最长反链中的每个点都可以代表一条链。\n  >\n  > Q.E.D.\n\n  </p></details>\n\n- 最长链等于最小反链覆盖\n\n  <details><summary>证明</summary><p>\n\n  > 对于一条链，链上的任意两点都不能被放到同一个反链中，所以最小反链覆盖不大于最长链。\n  >\n  > 而对于两条链同一个位置的点，显然要么是同一个点，要么可以放到同一个反链中，所以最小反链覆盖等于最长链。\n  >\n  > Q.E.D.\n\n  </p></details>\n\n- 最小链覆盖等于点数减去拆点二分图的最大匹配\n\n  <details><summary>证明</summary><p>\n\n  > 二分图每匹配一对点，就相当于合并了两条链。\n  >\n  > Q.E.D.\n  \n  </p></details>\n\n## Part 2 无向图\n\n### 2.1 定义\n\n- 点的邻点：**无向图**中，$v$ 为点 $u$ 的邻点当且仅当它们有边直接相连，$N(u)$ 为 $u$ 的邻点集；\n- 团：**无向图**中满足点两两之间都有连边的点集；\n- 独立集：**无向图**中满足点两两之间没有连边的点集；\n- 直径：**无向图**中所有点对的最短路的最大值；\n- 点覆盖：**无向图**中所有边两端的点都至少有一个在其中的点集；\n\n### 2.2 定理\n\n- 最大团等于补图的最大独立集\n\n  <details><summary>证明</summary><p>\n\n  > 原图的一个团内的点显然在补图上两两没有连边，所以原图的最大团在补图上一定是独立集。\n  >\n  > 反过来即可证明补图的最大独立集在原图上一定是团。\n  >\n  > Q.E.D.\n\n  </p></details>\n\n- 无向图中 $1$ 到其它点最短路的最大值 $dis$ 和图的直径 $d$ 满足 $\\lceil\\frac{d}{2}\\rceil\\le dis \\le d$\n\n  <details><summary>证明</summary><p>\n\n  > $dis\\le d$ 显然，$\\lceil\\frac{d}{2}\\rceil\\le dis$​ 则是因为要先走到直径上，再走到直径的两个端点。\n  >\n  > Q.E.D.\n  \n  </p></details>\n### 2.3 二分图\n\n#### 2.3.1 定义\n\n- 二分图：**无向图**，满足可以分成左部点集 $S$ 和右部点集 $T$ 使得对于所有边 $(u,v)$ 都有 $u\\in S,v\\in T$ 或 $u\\in T,v\\in S$；\n- 拆点二分图：把每个点拆成入点和出点，对于一条边 $x\\to y$，在二分图中连一条从 $x$ 的出点到 $y$ 的入点的边；\n- $k-$正则二分图：所有点的度数都为 $k$ 的**二分图**，易知 $k-$正则二分图中 $|S|=|T|$；\n- 匹配：**二分图**中满足每个点度数都是 $1$ 的子图；\n- 完美匹配：某一部中的点都在其中的匹配；\n\n#### 2.3.2 定理\n\n- 二分图最小点覆盖等于最大匹配：\n\n  <details><summary>证明</summary><p>\n\n  > 网络流，源点向每个左部点连流量为 $1$ 的边，左部点向原图中有连边的右部点连流量为 $\\infin$ 的边，右部点向汇点连流量为 $1$​ 的边，最小割等于最大流。\n  >\n  > Q.E.D.\n\n  </p></details>\n\n- 二分图最大独立集等于**点数**减去**最小点覆盖**：\n\n  <details><summary>证明</summary><p>\n\n  > 每条边都至少有一个端点在最小点覆盖中，那么把最小点覆盖中的点删掉后就是最大独立集了。\n  >\n  > Q.E.D.\n\n  </p></details>\n  \n- $k-$正则二分图可以被拆解为 $k$ 组完美匹配\n\n  <details><summary>证明</summary><p>\n  \n  > 归纳：\n  >\n  > - $1-$正则二分图显然满足；\n  > - $k-$正则二分图满足 Hall 定理：$\\forall A\\subseteq S$，$A$ 连出去的边集 $EA$ 是 $N(A)$ 连出去的边集 $EB$ 的子集，所以 $|EA|\\le |EB|$，那么显然 $k|A|\\le k|N(A)|$，$|A|\\le |N(A)|$；\n  > - 由于 $k-$二分图满足 $|S|=|T|$，所以找到 $k-$二分图的一组完美后去掉它可以转化为 $(k-1)-$正则二分图；\n  >\n  > Q.E.D.\n  \n  </p></details>\n#### 2.3.3 Hall 定理\n\n##### 2.3.3.1 基本形式\n\n> 对于左部点集为 $S$，右部点集为 $T$ 的二分图 $G$，其存在大小为 $|S|$ 的匹配的充要条件为：\n>\n> - $\\forall A\\subseteq S,|\\cup_{u\\in A}N(u)|\\ge|A|$\n\n<details><summary>证明</summary><p>\n\n> 必要性显然，充分性考虑反证。\n>\n> 若满足了基本 Hall 定理但是不存在大小为 $|S|$ 的匹配，则一定存在一个 $u\\in S$ 满足 $u$ 不在最大匹配中，那么 $\\forall v\\in N(u)$，$v$ 一定在最大匹配中。\n>\n> 考虑匈牙利算法，对于每一个 $v$，都不断找到它匹配的点 $b_v$，把 $b_v$ 当作 $u$ 继续进行这个过程。设遍历过的 $u$ 的集合为 $B$（包含刚开始的那个 $u$），则若 $\\forall u\\in B$，$N(u)$ 中都不存在未被匹配的点，那么一定有 $|N(B)|=|B|-1$，即只有刚开始的那个 $u$ 找不到和它匹配的点。与定理相悖。\n>\n> Q.E.D.\n\n</p></details>\n\n##### 2.3.3.2 拓展形式\n\n> 对于左部点集为 $S$，右部点集为 $T$ 的二分图 $G$，其最大匹配为：\n>\n> - $|S|-\\max\\left(\\max\\limits_{A\\subseteq S}\\{|A|-|\\cup_{u\\in A}N(u)|\\},0\\right)$\n\n证明是简单的。\n\n> 对于类似这样的二分网络流图，即源点向左边第 $i$ 个点连一条流量 $a_i$ 的边，左边第 $i$ 个点向右边第 $j$ 个点连一条流量 $c_{i,j}$ 的边，右边第 $i$ 个点向汇点连一条流量 $b_{i}$ 的边：\n>\n> ![](../post-images/1694762754666.png)\n>\n> 它左边的所有点能满流（经过左边第 $i$ 个点的流量为 $a_i$）当且仅当以下条件成立：\n>\n> - 设左边点集合为 $S$，则 $\\forall T\\subseteq S,\\sum\\limits_{u\\in T}a_u\\le\\sum\\limits_{u\\in N(T)}\\min\\left(b_u,\\sum\\limits_{v\\in T} c_{v,u}\\right)$；\n>\n> 即与 $T$ 相连的右边点集能承受的总流量要至少为 $T$ 中点输出的总流量。\n\n<details><summary>证明</summary><p>\n\n> 把基本形式证明中的匈牙利换成 EK（每次暴力找一条增广路）即可。\n\n</p></details>\n\n##### 2.3.3.3 点和区间匹配形\n\n> 数轴上有 $n$ 个点和 $n$ 个区间，一个点能匹配一个区间当且仅当这个点被这个区间包含。\n>\n> 存在大小为 $n$ 的匹配当且仅当：\n>\n> - 把值域离散化到 $[1,n]$ 后，对于所有区间 $[l,r]$，被 $[l,r]$ 完全包含的区间个数 $\\le r-l+1$；\n\n<details><summary>证明</summary><p>\n\n> 考虑反证。\n>\n> 对于区间集合 $S$，若 $|S|>|\\cup_{u\\in S} [l_u,r_u]|$ 且 $\\cup_{u\\in S} [l_u,r_u]$ 可以分成若干个极长的不交且不相邻区间 $[lb_1,rb_1],[lb_2,rb_2],\\dots,[lb_k,rb_k]$，则设 $A_i=\\{x|x\\in S,[l_x,r_x]\\subseteq [lb_i,rb_i]\\}$。\n>\n> 注意到对于任意不同的 $i,j$，必然有 $A_i\\cap A_j=\\emptyset$，也就是说，对于任意不同的 $i,j$，$A_i\\cap A_j=\\emptyset$ 且 $(\\cup_{u\\in A_i} [l_u,r_u])\\cap(\\cup_{u\\in A_j} [l_u,r_u])=\\emptyset$。\n>\n> 所以对于任意不同的 $i,j$，$A_i$ 和 $A_j$ 独立。\n>\n> 那么必然存在某个 $i$ 满足 $|A_i|>|\\cup_{u\\in A_i} [l_u,r_u]|$，此时区间 $\\cup_{u\\in A_i} [l_u,r_u]$ 不合法。\n>\n> Q.E.D.\n\n</p></details>\n\n##### 2.3.3.4 例题\n\n- [CF1519F Chests and Keys](https://www.luogu.com.cn/problem/CF1519F) | [题解](../CF1519F Chests and Keys 做题记录)\n- [P6519 [CEOI2010 day1] bodyguards](https://www.luogu.com.cn/problem/P6519)\n- [CF1718D Permutation for Burenka](https://www.luogu.com.cn/problem/CF1718D) | [题解](../CF1718D Permutation for Burenka 做题记录)\n\n### 2.4 生成树\n\n#### 2.4.1 定义\n\n- 生成树：**无向图** $G$ 的一个边集，满足所有点都可以通过该边集联通且该边集的边数最小；\n- 最小生成树：边权和最小的生成树；\n- dfs 树：所有非树边两端的节点都互为祖孙关系的生成树；\n- 本源环：**dfs 树**中只有一条非树边的环；\n\n#### 2.4.2 定理\n\n- 所有最小生成树中每种边权的边的条数对应相等：\n\n  <details><summary>证明</summary><p>\n  \n  > 考虑 Kruskal 算法的过程，显然边权小的边会选尽量多条。\n  >\n  > Q.E.D.\n  \n  </p></details>\n  \n  例题：\n  \n  - [P4208 [JSOI2008] 最小生成树计数](https://www.luogu.com.cn/problem/P4208)\n  \n- 所有简单环都可以由任意生成树中的若干本源环异或得出：\n\n  <details><summary>证明</summary><p>\n\n  > 每个简单环都等价于环中非树边对应的本源环异或起来。\n  >\n  > Q.E.D.\n\n  </p></details>\n\n  例题：\n\n  - [P4151 [WC2011] 最大XOR和路径](https://www.luogu.com.cn/problem/P4151)\n  - [CF19E Fairy](https://www.luogu.com.cn/problem/CF19E) | [题解](../CF19E Fairy 做题记录)\n\n## Part3 有向图\n\n### 3.1 定义\n\n- 强连通子图：**有向图**的满足所有点对都能互相到达的子图；\n- SCC：**有向图**的极大强连通子图（即加入任意节点都不强连通的强连通子图）；\n\n### 3.2 偏序图\n\n#### 3.2.1 定义\n\n- 偏序图：**有向图**，满足若存在边 $x\\to y$ 和边 $y\\to z$ 则存在边 $x\\to z$；\n\n#### 3.2.2 定理\n\n- 偏序图上的独立集和反链等价\n\n  <details><summary>证明</summary><p>\n\n  > 考虑反证，设独立集中有两个点 $x,y$ 满足 $x$ 能到达 $y$，由于偏序图满足 $x$ 能到达 $y$ 则存在边 $x\\to y$，所以 $x,y$​ 不能同时存在于独立集中。\n  >\n  > Q.E.D.\n  \n  </p></details>\n\n### 3.3 竞赛图\n\n#### 3.3.1 定义\n\n- 竞赛图：**有向图**，满足可以由点数相同的完全图定向得到；\n\n#### 3.3.2 定理\n\n- 竞赛图缩点（把每个 SCC 都缩成一个大点）后，满足拓扑序唯一且每个大点向它拓扑序中后面的所有大点都有连边\n\n- 把竞赛图中的点按出度从小到大排序后，每个 SCC 对应一个区间\n\n  <details><summary>证明</summary><p>\n  \n  > 竞赛图缩点后，满足拓扑序唯一且每个大点向它拓扑序中后面的所有大点都有连边。\n  >\n  > 也就是说对于每个 SCC，设拓扑序在它后面的 SCC 共有 $m$ 个点，则这个 SCC 中的每个点都会向这 $m$ 个点连一条边。\n  >\n  > 而一个大小为 $k$ 的 SCC 中的点向这个 SCC 内部的其它点最多连 $k-1$ 条边。\n  >\n  > 所以把所有点按出度从小到大排序相当于把 SCC 按照拓扑序从后往前排序，每个 SCC 对应一个区间。\n  >\n  > Q.E.D.\n  \n  </p></details>\n  \n- 竞赛图中的 SCC 个数即为其中的点按出度 $d_u$ 从小到大排序后满足 $\\sum\\limits_{j=1}^id_j=\\binom{i}{2}$ 的 $i$ 的个数\n  \n  <details><summary>证明</summary><p>\n  \n  > 根据上一条定理的证明，把所有点按出度从小到大排序后相当于把 SCC 按照拓扑序从后往前排序，每个 SCC 对应一个区间。\n  >\n  > 那么 $\\sum\\limits_{j=1}^id_j=\\binom{i}{2}$ 的区间 $[1,i]$ 与拓扑序的后缀构成双射。\n  >\n  > Q.E.D.\n  \n  题外话：不难发现 Sum of SCC 那题的结论和这个本质相同。\n  \n  </p></details>\n\n  例题：\n  \n  - [[ARC163D] Sum of SCC](https://www.luogu.com.cn/problem/AT_arc163_d) | [题解](../ARC163D Sum of SCC 做题记录/)\n  \n  - [CF1779E Anya's Simultaneous Exhibition](https://www.luogu.com.cn/problem/CF1779E)\n  - [QOJ5407 基础图论练习题](https://qoj.ac/problem/5407)\n",
			"tags": [{"name":"学习笔记"},{"name":"图论"},{"name":"小技巧"}],
			"title": "一些图论的定理",
			"link": "https://exber.qzz.io/post/%E4%B8%80%E4%BA%9B%E5%9B%BE%E8%AE%BA%E7%9A%84%E5%AE%9A%E7%90%86",
			"date": "2023-04-15 16:35:15"
		},
	
		{
			"abstract": "> 给出数组 $a$ ,你可以改变每个数的正负，求逆序对数最少是多少。\n> \n> $1\\le n\\le 2000$，$|a_i|\\le 10^5$。\n",
			"content": "> 给出数组 $a$ ,你可以改变每个数的正负，求逆序对数最少是多少。\n> \n> $1\\le n\\le 2000$，$|a_i|\\le 10^5$。\n\n考虑一对 $(i,j)$（$i<j$）对逆序对个数的贡献：\n\n- $|a_i|>|a_j|$：有贡献当且仅当 $a_i$ 取 $|a_i|$；\n- $|a_i|<|a_j|$：有贡献当且仅当 $a_j$ 取 $-|a_j|$；\n- $|a_i|=|a_j|$：有贡献当且仅当 $a_i$ 取 $|a_i|$，$a_j$ 取 $-|a_j|$ 且 $a_i\\not=0,a_j\\not=0$；\n\n暂时先不考虑第三种情况，不难发现 $(i,j)$ 的贡献和 $a_i$、$a_j$ 中绝对值最大的那个的取值直接挂钩，那么 $a_x$ 对逆序对个数的贡献为：\n\n- $a_x=|a_x|$ 时：$i<x$ 且 $|a_i|<|a_x|$ 的 $i$ 的个数；\n- $a_x=-|a_x|$ 时：$i>x$ 且 $|a_i|<|a_x|$ 的 $i$ 的个数；\n\n所以有一个显然的贪心：每个 $x$ 都从这两个值中取最小的累加进答案。容易发现如果不存在 $|a_i|=|a_j|$ 的 $(i,j)$ 则这个贪心一定是正确的，因为每个 $x$ 的贡献是独立的。\n\n若存在 $|a_i|=|a_j|$ 的 $(i,j)$，这个贪心其实也是对的。因为对于所有 $|a_i|=w$，在原序列中一定存在一个分界点 $k$，满足 $i\\le k$ 的 $a_i$ 是负数，$i>k$ 的 $a_i$ 是正数。因为 $a_x$ 贡献的取值一定是单调的。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=100005;\n\nint n,a[S],id[S];\nint tr[S];\n\ninline void add(int pos,int val)\n{\n\tfor(int i=pos;i<=n;i+=i&-i) tr[i]+=val;\n}\n\ninline int que(int pos)\n{\n\tint res=0;\n\tfor(int i=pos;i>=1;i-=i&-i) res+=tr[i];\n\treturn res;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]),a[i]=abs(a[i]),id[i]=i;\n\tsort(id+1,id+n+1,[&](int x,int y){return a[x]<a[y];});\n\tlong long ans=0;\n\tfor(int i=1,j=0;i<=n;i++)\n\t{\n\t\twhile(j<i&&a[id[j+1]]!=a[id[i]]) add(id[++j],1);\n\t\tans+=min(que(id[i]),j-que(id[i]));\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"构造"}],
			"title": "CF351E Jeff and Permutation 做题记录",
			"link": "https://exber.qzz.io/post/CF351E%20Jeff%20and%20Permutation%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-04-15 16:32:45"
		},
	
		{
			"abstract": "> 场上 $2N$ 个整数， Alice，Bob 轮流取数， Alice 先手，如果最终 Alice 取出数的和取模 $M$ 和 Bob 取出来数的和相等，那么 Bob 获胜，否则 Alice 获胜。\n> \n> 两个人绝对聪明，求哪个人会获胜。\n> \n> - $1 \\leq N \\leq 2 \\times 10^5$\n> - $2 \\leq M \\leq 10^9$\n> - $0 \\leq A_i \\leq M - 1$\n",
			"content": "> 场上 $2N$ 个整数， Alice，Bob 轮流取数， Alice 先手，如果最终 Alice 取出数的和取模 $M$ 和 Bob 取出来数的和相等，那么 Bob 获胜，否则 Alice 获胜。\n> \n> 两个人绝对聪明，求哪个人会获胜。\n> \n> - $1 \\leq N \\leq 2 \\times 10^5$\n> - $2 \\leq M \\leq 10^9$\n> - $0 \\leq A_i \\leq M - 1$\n\n考虑最后剩下两个数 $a,b$ 且的情况，显然此时 `Alice` 先手。设此时两人的数的和分别为 $x$ 和 $y$，那么 `Bob` 胜当且仅当 $x+a\\equiv y+b\\pmod M$ 且 $x+b\\equiv y+a\\pmod M$，两式相加减可以把条件转化为 $2x\\equiv 2y\\pmod M$ 且 $x-y\\equiv y-x\\pmod M$ 且 $2a\\equiv 2b\\pmod M$ 且 $a-b\\equiv b-a\\pmod M$。观察到只有以下几种情况满足条件：\n\n- $x\\equiv y\\pmod M$ 且 $a\\equiv b\\pmod M$；\n- $M$ 为偶数且 $x+\\frac{M}{2}\\equiv y\\pmod M$ 且 $a+\\frac{M}{2}\\equiv b\\pmod M$；\n\n那么不难发现若能把 $A_i$ 分成若干组 $x\\equiv y\\pmod M$ 和**偶数**组 $x+\\frac{M}{2}\\equiv y\\pmod M$（$M$ 是偶数时）则 `Bob` 必胜，因为可以取和 `Alice` 取的那个数组成一组的那个数。\n\n考虑证明这个条件是充要的，即证明其他情况 `Alice` 必胜。其实很好证明，只要让 `Alice` 模仿 `Bob` 操作，`Bob` 取能组成一组的她就取这一组中的另一个，`Bob` 取零散的 `Alice` 也取零散的，这样最后剩下的两个数字一定不能组成一组，并且零散的数字互相组成 $M$ 来消掉的情况 `Alice` 也可以通过一些微调来避免，所以这时 `Alice` 必胜。\n\n代码如下：\n\n```cpp\n// Problem: [ARC148D] mod M Game\n// Contest: Luogu\n// URL: https://www.luogu.com.cn/problem/AT_arc148_d\n// Memory Limit: 1 MB\n// Time Limit: 2000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <set>\n\nusing namespace std;\n\nconst int S=400005;\n\nint n,m,a[S];\nset<int> st;\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n*2;i++) scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n*2;i++)\n\t{\n\t\tif(st.count(a[i])) st.erase(a[i]);\n\t\telse st.insert(a[i]);\n\t}\n\tint cnt=0;\n\tfor(int x:st)\n\t{\n\t\tif(m&1) return puts(\"Alice\"),0;\n\t\tif(!st.count((x+m/2)%m)) return puts(\"Alice\"),0;\n\t\tcnt++;\n\t}\n\tcnt/=2;\n\tputs((cnt&1)?\"Alice\":\"Bob\");\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"博弈论"}],
			"title": "AT_arc148_d [ARC148D] mod M Game 做题记录",
			"link": "https://exber.qzz.io/post/AT_arc148_d%20%5BARC148D%5D%20mod%20M%20Game%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-04-15 16:25:46"
		},
	
		{
			"abstract": "",
			"content": "## Part 1 普通型生成函数 OGF（$\\mathtt{O}$rdinary $\\mathtt{G}$enerating $\\mathtt{F}$unction）\n\n普通型生成函数的特征函数是 $f_i(x)=x^i$。\n\n#### 1.0 形式幂级数形式\n\n回到生成函数的定义：\n$$\nF(x)=\\sum\\limits_{i=0}^\\infin a_if_i(x)\n$$\nOGF 的特征函数是 $f_i(x)=x^i$，也就是说，OGF 总是可以写成这样的形式：\n$$\nF(x)=\\sum\\limits_{i=0}^\\infin a_ix^i\n$$\n由于 $x$ 是无关紧要的，只是一个形式，并且这种写法带次幂，所以它被叫做**形式幂级数形式**。\n\n注意到这种形式可以很方便地将生成函数还原回序列，所以**从生成函数还原到序列之前往往要先化为形式幂级数形式**。\n\n#### 1.1 OGF 的一些运算的意义\n\n为了方便运算，所以生成函数往往**规定原序列的负数项为 $0$**。\n\n假设有两个序列 $a$，$b$ 和它们的 OGF $F(x)$，$G(x)$，那么：\n\n- 相加\n\n  $$\n  \\begin{aligned}\n  H(x)&=F(x)+G(x)\\\\\n  &=\\sum\\limits_{i=0}^\\infin (a_i+b_i)x^i\n  \\end{aligned}\n  $$\n\n  相当于是 $a$ 和 $b$ 对应项相加的序列 $c_i=a_i+b_i$ 的 OGF；\n\n- 相减\n\n  $$\n  \\begin{aligned}\n  H(x)&=F(x)-G(x)\\\\\n  &=\\sum\\limits_{i=0}^\\infin (a_i-b_i)x^i\n  \\end{aligned}\n  $$\n\n  相当于是 $a$ 和 $b$ 对应项相减的序列 $c_i=a_i-b_i$ 的 OGF；\n\n- 乘 $x$\n\n  $$\n  \\begin{aligned}\n  xF(x)&=\\sum\\limits_{i=0}^\\infin a_ix^{i+1}\\\\\n  &=\\sum\\limits_{i=0}^\\infin a_{i-1}x^{i}\n  \\end{aligned}\n  $$\n  相当于把原序列整体右移一位；\n\n- 相乘\n\n  $$\n  \\begin{aligned}\n  H(x)&=F(x)G(x)\\\\\n  &=\\left(\\sum\\limits_{i=0}^\\infin a_ix^i\\right)\\left(\\sum\\limits_{i=0}^\\infin b_ix^i\\right)\\\\\n  &=\\sum\\limits_{i=0}^\\infin x^i\\sum\\limits_{j=0}^ia_jb_{i-j}\n  \\end{aligned}\n  $$\n\n  相当于是 $c_i=\\sum\\limits_{j=0}^ia_jb_{i-j}$ 的 OGF。组合意义如下：\n\n  > $c_i$ 表示把 $i$ 个**无标号小球**放入 $A$ 和 $B$ 两个**有标号无序集合**中，其中 $A$ 集合中放 $i$ 个球的方案数是 $a_i$，$B$ 集合中放 $i$ 个球的方案数是 $b_i$。\n\n#### 1.2 封闭形式\n\n$a=\\{1,1,\\dots\\}$ 这个数列的 OGF 的形式幂级数形式是 $F(x)=\\sum\\limits_{i=0}^\\infin x^i$，考虑用更简洁的方法表示 $F(x)$：\n$$\n\\text{令 } G_n(x)=\\sum\\limits_{i=0}^nx^i\\\\\n\\begin{aligned}\n&G_{n+1}(x)-G_n(x)\\\\\n&=x^{n+1}\\\\\n&=1+xG_n(x)-G_n(x)\\\\\n&=1+(x-1)G_n(x)\n\\end{aligned}\\\\\n\\text{所以}\\\\\n1+(x-1)G_n(x)=x^{n+1}\\\\\nG_n(x)=\\frac{x^{n+1}-1}{x-1}\\\\\n\\text{代入 }n=\\infin,-1<x<1\\\\\nF(x)=G_{\\infin}(x)=\\frac{-1}{x-1}=\\frac{1}{1-x}\\\\\n$$\n也就是说，当 $-1<x<1$ 时，$F(x)=\\frac{1}{1-x}$，这种**“最简形式”**被定义为生成函数的**封闭形式**。由于我们并不关心 $x$ 的取值，所以可以认为 $F(x)=\\frac{1}{x-1}$。注意到封闭形式有利于对生成函数进行各种运算，所以**往往要把生成函数化为封闭形式再进行各种推导**。\n\n总结一下，利用生成函数来对数列进行各种推导主要分成以下几步：\n\n1. 确定特征函数，写出数列对应的生成函数的形式幂级数形式；\n2. 根据生成函数的形式幂级数形式求出它的封闭形式；\n3. 对所有要参加推导的数列都重复前两步以确定它们的生成函数的封闭形式；\n4. 根据题目的需要，对这些封闭形式进行各种运算；\n5. 将运算的结果还原回形式幂级数形式，获得答案序列；\n\n#### 1.3 一些常见数列的 OGF 的封闭形式\n\n$$\na=\\{y,yp,yp^2,yp^3,yp^4,\\dots\\}\\\\\na=\\{0,1,1,1,1,\\dots\\}\\\\\na=\\{0,1,0,1,0,\\dots\\}\\\\\na=\\{1,2,3,4,5,\\dots\\}\\\\\na_i=\\binom{n}{i}\\qquad n\\text{ 是给定的常数}\\\\\na_i=\\binom{n+i}{n}\\qquad n\\text{ 是给定的常数}\\\\\na_i=a_{i-1}+a_{i-2},a_0=1,a_1=1\\qquad\\text{并推导出通项公式}\\\\\na_i=\\sum\\limits_{j=0}^{i-1}a_{j}a_{i-j-1},a_0=1\n$$\n\n****\n\n第一个：\n$$\n\\begin{aligned}\nF(x)&=y\\sum\\limits_{i=0}^\\infin p^ix^i\\\\\n&=y(1+xpF(x))\\\\\n&=\\frac{y}{1-xp}\n\\end{aligned}\n$$\n第二个：\n$$\n\\begin{aligned}\nF(x)&=\\sum\\limits_{i=1}^{\\infin}x^i\\\\\n&=x\\sum\\limits_{i=0}^{\\infin}x^i\\\\\n&=\\frac{x}{1-x}\\\\\n\\end{aligned}\n$$\n第三个：\n$$\n\\begin{aligned}\nF(x)&=\\sum\\limits_{i=0}^{\\infin}[i=2j+1]x^i\\\\\n&=\\sum\\limits_{i=0}^{\\infin}x^{2i+1}\\\\\n&=x\\sum\\limits_{i=0}^{\\infin}(x^2)^i\\\\\n&=\\frac{x}{1-x^2}\\\\\n\\end{aligned}\n$$\n第四个：\n$$\n\\,\n\\begin{aligned}\nF(x)&=\\sum\\limits_{i=0}^{\\infin}(i+1)x^i\\\\\n&=\\sum\\limits_{i=0}^{\\infin}ix^i+\\sum\\limits_{i=0}^{\\infin}x^i\\\\\n&=xF(x)+\\frac{1}{1-x}\n\\end{aligned}\\\\\n(1-x)F(x)=\\frac{1}{1-x}\\\\\nF(x)=\\frac{1}{(1-x)^2}\n$$\n第五个：\n$$\n\\begin{aligned}\nF(x)&=\\sum\\limits_{i=0}^{n}\\binom{n}{i}x^i\\\\\n&=(1+x)^i\\\\\n\\end{aligned}\n$$\n第六个：\n\n>考虑组合意义，$\\binom{n+i}{n}$ 相当于把 $n+i+1$ 个相同的小球放进 $n+1$ 个不同的盒子里的方案数，相当于 $x_1+x_2+\\dots+x_{n+1}=i$ 的不同非负整数解的个数，相当于 $n+1$ 个 $F(x)=\\sum\\limits_{i=0}^{\\infin}x^i$ 乘起来即 $\\left(\\sum\\limits_{i=0}^{\\infin}x^i\\right)^{n+1}$，写成封闭形式即为 $(\\frac{1}{1-x})^{n+1}=\\frac{1}{(1-x)^{n+1}}$。\n>\n>所以 $F(x)=\\frac{1}{(1-x)^{n+1}}$。\n\n第七个：\n\n>$a_i$ 就是斐波那契数列的第 $i$ 项。\n>\n>显然有 $F(x)=xF(x)+x^2F(x)-xa_0+a_0+xa_1=1+xF(x)+x^2F(x)$，解得 $F(x)=\\frac{1}{1-x-x^2}$。\n>\n>进一步的，我们可以推导出 $a_i$ 的通项公式：\n>$$\n>\\begin{aligned}\n>F(x)&=\\frac{1}{1-x-x^2}\\\\\n>&=\\sum\\limits_{i=0}^\\infin (x+x^2)^i\\\\\n>&=\\sum\\limits_{i=0}^\\infin \\sum\\limits_{j=0}^i \\binom{i}{j}x^{i+j}\\\\\n>&=\\sum\\limits_{i=0}^\\infin x^i\\sum\\limits_{j=0}^i \\binom{i-j}{j}\\\\\n>\\end{aligned}\n>$$\n>即 $a_i=\\sum\\limits_{j=0}^i \\binom{i-j}{j}$。\n>\n>但是这个式子是 $O(n)$ 的，并不是我们熟悉的带 $\\sqrt 5$ 的神秘 $O(1)$ 通项。\n>\n>下面将用另一种方式推出 $O(1)$ 的通项，考虑一类我们熟悉的 OGF —— $yF(x)=\\sum\\limits_{i=0}^\\infin p^iyx^i=\\frac{y}{1-xp}$，由于斐波那契数列的生成函数的封闭形式是 $\\frac{1}{1-x-x^2}$，所以需要至少两个这样的 OGF 加起来通分之后才能出现最高次项，那么设：\n>$$\n>\\begin{aligned}\n>\\frac{1}{1-x-x^2}&=\\frac{A}{1-ax}+\\frac{B}{1-bx}\\\\\n>&=\\frac{A(1-bx)+B(1-ax)}{(1-ax)(1-bx)}\\\\\n>&=\\frac{A+B-(aB+Ab)x}{1-(a+b)x+abx^2}\\\\\n>\\end{aligned}\n>$$\n>所以有：\n>$$\n>\\begin{cases}\n>aB+Ab=0\\\\\n>A+B=1\\\\\n>a+b=1\\\\\n>ab=-1\n>\\end{cases}\n>$$\n>解得：\n>$$\n>\\begin{cases}\n>a=\\frac{1-\\sqrt 5}{2}\\\\\n>b=\\frac{1+\\sqrt 5}{2}\\\\\n>A=\\frac{1}{2}-\\frac{\\sqrt 5}{10}\\\\\n>B=\\frac{1}{2}+\\frac{\\sqrt 5}{10}\n>\\end{cases}\n>$$\n>所以有\n>$$\n>\\begin{aligned}\n>F(x)&=\\sum\\limits_{i=0}^\\infin \\left((\\frac{1}{2}-\\frac{\\sqrt 5}{10})(\\frac{1-\\sqrt 5}{2})^i+(\\frac{1}{2}+\\frac{\\sqrt 5}{10})(\\frac{1+\\sqrt 5}{2})^i\\right)x^i\\\\\n>&=\\sum\\limits_{i=0}^\\infin \\left(\\frac{(1-\\frac{\\sqrt 5}{5})(\\frac{1-\\sqrt 5}{2})^i+(1+\\frac{\\sqrt 5}{5})(\\frac{1+\\sqrt 5}{2})^i}{2}\\right)x^i\\\\\n>\\end{aligned}\n>$$\n\n第八个：\n\n> $a_i$ 就是卡特兰数的第 $i$ 项。\n>\n> 发现这个递推式很像卷积，所以考虑用卷积构造它的生成函数。\n>\n> 设 $F(x)=\\sum\\limits_{i=0}^\\infin a_ix^i$，则有：\n> $$\n> \\begin{aligned}\n> F(x)&=1+\\sum\\limits_{i=1}^\\infin x^i\\sum\\limits_{j=0}^{i-1}a^ja^{i-j-1}\\\\\n> &=1+x\\sum\\limits_{i=0}^\\infin x^i\\sum\\limits_{j=0}^ia^ja^{i-j}\\\\\n> &=1+xF^2(x)\\\\\n> &=\\frac{1\\pm\\sqrt{1+4x}}{2x}\n> \\end{aligned}\n> $$\n>\n> 现在的问题是取哪个根，我们将其分子有理化：\n> $$\n> F(x)=\\frac{2}{1\\pm\\sqrt{1+4x}}\n> $$\n> 代入 $x=0$，这样 $F(x)=a_0=1$，显然若分母应取 $1+\\sqrt{1+4x}=2$，所以 $F$ 的封闭形式为 $F(x)=\\frac{1-\\sqrt{1+4x}}{2x}$。\n\n#### 1.4 应用\n\n#### 1.4.0 [BZOJ3028 食物](https://darkbzoj.cc/problem/3028)\n\n> 在许多不同种类的食物中选出 $n$ 个，每种食物的限制如下：\n>\n> 1. 承德汉堡：偶数个\n> 2. 可乐：$0$ 个或 $1$ 个\n> 3. 鸡腿：$0$ 个，$1$ 个或 $2$ 个\n> 4. 蜜桃多：奇数个\n> 5. 鸡块：$4$ 的倍数个\n> 6. 包子：$0$ 个，$1$ 个，$2$ 个或 $3$ 个\n> 7. 土豆片炒肉：不超过一个。\n> 8. 面包：$3$ 的倍数个\n>\n> 每种食物都是以“个”为单位，只要总数加起来是 $n$ 就算一种方案。对于给出的 $n$ 你需要计算出方案数，对 $10007$（质数）取模。\n\n考虑对每种食物构造多项式，由于两种食物选出 $n$ 个的方案数的生成函数就是它们的生成函数的卷积，所以多种食物总共选出 $n$ 个的方案数的生成函数就是他们的生成函数全部卷到一起的结果。\n\n接下来问题就变为求出每种食物的生成函数的封闭形式然后乘起来，最后还原回形式幂级数形式，得到答案。\n\n这里给出每种食物的生成函数的封闭形式：\n\n1. $\\frac{1}{1-x^2}$\n2. $1+x$\n3. $1+x+x^2=\\frac{1-x^3}{1-x}$\n4. $\\frac{x}{1-x^2}$\n5. $\\frac{1}{1-x^4}$\n6. $1+x+x^2+x^3=\\frac{1-x^4}{1-x}$\n7. $1+x$\n8. $\\frac{1}{1-x^3}$\n\n接下来要把它们乘起来：\n$$\n\\begin{aligned}\n&\\frac{(1+x)(1-x^3)x(1-x^4)(1+x)}{(1-x^2)(1-x)(1-x^2)(1-x^4)(1-x)(1-x^3)}\\\\\n&=\\frac{(1+x)x(1+x)}{(1-x^2)(1-x)(1-x^2)(1-x)}\\\\\n&=\\frac{(1+x)x(1+x)}{(1-x)(1+x)(1-x)(1-x)(1+x)(1-x)}\\\\\n&=\\frac{x}{(1-x)(1-x)(1-x)(1-x)}\\\\\n&=\\frac{x}{(1-x)^4}\\\\\n\\end{aligned}\n$$\n考虑到 $\\frac{x}{(1-x)^4}=x(\\frac{1}{1-x})^4$，相当于四个 $\\{1,1,1,1,1,\\dots\\}$ 的生成函数乘起来再让系数整体右移一位，也就是 $x\\sum\\limits_{i=0}^\\infin\\binom{i+3}{3}x^i=\\sum\\limits_{i=0}^\\infin\\binom{i+2}{3}x^i$，那么答案即为 $\\binom{n+2}{3}$。\n\n#### 1.4.1 [P6078 \\[CEOI2004] Sweets](https://www.luogu.com.cn/problem/P6078)\n\n第 $i$ 种糖果的生成函数显然是 $\\frac{1-x^{m_i+1}}{1-x}$，答案的生成函数就是 $\\frac{\\prod\\limits_{i=1}^n 1-x^{m_i+1}}{(1-x)^n}$。\n\n考虑暴力展开，显然由于 $a_i=\\binom{n+i}{n}$ 的生成函数的封闭形式就是 $\\frac{1}{(1-x)^{n+1}}$，所以答案的生成函数可以化为：\n$$\n\\left(\\prod\\limits_{i=1}^n 1-x^{m_i+1}\\right)\\sum\\limits_{i=0}^\\infin \\binom{n+i-1}{i}x^i\n$$\n前面的部分可以 $O(2^n)$ 暴力求出 $x$ 的所有指数对应的系数 $y_ix^{k_i}$，那么对于所有二元组 $(y_i,k_i)$，它对答案的贡献即为：\n$$\n\\begin{aligned}\n&y_i\\sum\\limits_{j=a-i}^{b-k_i} \\binom{n+j-1}{j}\\\\\n&=y_i\\left(\\sum\\limits_{j=0}^{b-k_i} \\binom{n-1+j}{j}-\\sum\\limits_{j=0}^{a-k_i-1} \\binom{n-1+j}{j}\\right)\\\\\n&=y_i\\left(\\binom{n-1+b-k_i+1}{b-k_i}-\\binom{n-1+a-k_i-1+1}{a-k_i-1}\\right)\\\\\n&=y_i\\left(\\binom{n+b-k_i}{b-k_i}-\\binom{n+a-k_i-1}{a-k_i-1}\\right)\\\\\n&=y_i\\left(\\binom{n+b-k_i}{n}-\\binom{n+a-k_i-1}{n}\\right)\\\\\n\\end{aligned}\n$$\n注意到组合数可以直接暴力 $O(n)$ 计算（$\\binom{n}{m}=\\frac{n!}{m!(n-m)!}$，由于 $m!$ 很小，所以可以暴力计算 $n\\times (n-1)\\times(n-2)\\times\\dots\\times(n-m+1)\\mod 2004m!$ 然后除以 $m!$ 再模 $2004$），时间复杂度即为 $O(n2^n)$。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=15,p=2004;\n\nint n,a,b;\nint m[S];\n\ninline int C(int n,int m)\n{\n\tif(n<0||m<0||m>n) return 0;\n\tlong long mod=p;\n\tlong long r1=1,r2=1;\n\tfor(int i=1;i<=m;i++) r1*=i,mod*=i;\n\tfor(int i=n;i>=n-m+1;i--) r2=r2*i%mod;\n//\tprintf(\"C(%d %d)=%d\\n\",n,m,r2/r1);\n\treturn r2/r1%p;\n}\n\nint dfs(int i,int y,int k)\n{\n\tif(i==n+1) return (y*(C(n+b-k,n)-C(n+a-k-1,n))+p)%p;\n\treturn (dfs(i+1,y,k)+dfs(i+1,-y,k+m[i]+1))%p;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&a,&b);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&m[i]);\n\tprintf(\"%d\\n\",dfs(1,1,0));\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"学习笔记"},{"name":"数学"},{"name":"组合计数"},{"name":"多项式、生成函数"}],
			"title": "普通型生成函数入门",
			"link": "https://exber.qzz.io/post/%E6%99%AE%E9%80%9A%E5%9E%8B%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%85%A5%E9%97%A8",
			"date": "2023-04-15 14:29:26"
		},
	
		{
			"abstract": "",
			"content": "## 前言\n\n> A：你知道当 $n$ 很大的时候怎么快速求 $\\binom{n}{0}-\\binom{n}{1}+\\binom{n}{2}-\\dots+(-1)^n\\binom{n}{n}$ 吗？\n>\n> B：这不是二项式定理的逆运用吗？$(1-1)^n=\\sum\\limits_{i=0}^n(-1)^i\\binom{n}{i}=\\binom{n}{0}-\\binom{n}{1}+\\binom{n}{2}-\\dots+(-1)^n\\binom{n}{n}$，所以原式为 $0$。\n\n上面这种情景其实是经常出现的，很多时候一些数列的操作往往可以被“压缩”成一些简洁式子的运算。\n\n也就是说，可以**用函数来表示数列**，然后把数列上奇奇怪怪的操作转化为我们熟知的各种运算，最后从运算后的函数还原回数列，求出想要的答案。具体的，可以随便选一些“特征函数”$f_i(x)$，然后定义：\n$$\nF(x)=\\sum\\limits_{i=0}^\\infin a_if_i(x)\n$$\n为数列 $a$ 的“生成函数”（也可以叫做母函数）。\n\n虽然但是，$f_i(x)$ 并不是怎么指定都可以让 $F(x)$ 有足以解出题目的性质的，所以生成函数也**根据 $f_i(x)$ 分为几种**。\n\n需要注意的是，$F(x)$ 的参数 $x$ 是无关紧要的，$x$ 取何值并不影响从生成函数还原到数列的过程。所以通常**为了令生成函数收敛都会取 $-1<x<1$**。\n\n## Part 1 普通型生成函数 OGF（$\\mathtt{O}$rdinary $\\mathtt{G}$enerating $\\mathtt{F}$unction）\n\n[链接](../普通型生成函数入门/)。\n\n## Part 2 指数型生成函数 EGF（$\\mathtt{E}$xponential $\\mathtt{G}$enerating $\\mathtt{F}$unction）\n\n[链接](../指数型生成函数入门/)。\n\n## Part 3 生成函数变换\n\n[链接](../生成函数变换学习笔记)。\n\n## Part 4 一些练习\n\n#### 4.1 有标号无向简单连通图计数\n\n[P4841 [集训队作业2013]城市规划](https://www.luogu.com.cn/problem/P4841)\n\n设 $f_i$ 为 $i$ 个点的有标号无向简单连通图的数量， $g_i$ 为 $i$ 个点的有标号无向简单图的数量，$F(x)$、$G(x)$ 为这两个数列的 EGF，那么有：\n$$\nG(x)=\\exp(F(x))\n$$\n因为所有无向简单图都可以被分成若干互不区分的连通块。\n\n$f_i$ 很好求，有 $f_i=2^{\\binom{i}{2}}$，那么由于有 $\\ln(G(x))=F(x)$ 所以直接上多项式 $\\ln$ 即可。\n\n#### 4.2 有标号二分图计数\n\n[P7364 有标号二分图计数](https://www.luogu.com.cn/problem/P7364)\n\n设 $f_i$ 为 $i$ 个点的有标号二分图数量， $g_i$ 为 $i$ 个点的有标号连通二分图，$F(x)$、$G(x)$ 为这两个数列的 EGF，那么有：\n$$\nF(x)=\\exp(G(x))\n$$\n设 $h_i$ 为 $i$ 个点的有标号黑白染色图数量，$H(x)$ 为它的 EGF，显然有：\n$$\nh_i=\\sum\\limits_{j=0}^i \\binom{i}{j}2^{j(i-j)}\n$$\n容易发现，一个有标号连通二分图只有两种染色方案，那么有：\n$$\nH(x)=\\exp(2G(x))\\\\\n$$\n\n由于 $F(x)=\\exp(G(x))$，所以 $F(x)=\\sqrt{H(x)}$。注意到 $xy=\\binom{x+y}{2}-\\binom{x}{2}-\\binom{y}{2}$ 所以 $H(x)$ 可以卷积求，多项式开根是 $O(n\\log n)$ 的，那么总的时间复杂度为 $O(n\\log n)$。\n\n#### 4.3 有标号毛毛虫计数\n\n> 毛毛虫：一种特殊的树，满足存在一条路径，使得任何一个点到路径的距离不超过 $1$。\n\n考虑一节一节”组装“毛毛虫，显然单独一节毛毛虫是一个菊花，其 EGF 为 $G(x)=\\sum\\limits_{i=1}^\\infin i\\frac{x^i}{i!}$\n\n但是头和尾要特殊考虑，因为端点节只有一个点时会被端点前面那一节连出来很多点的情况算上。\n\n那么不妨强制钦定端点节至少由两个点组成，那么端点节的 EGF 为 $B(x)=\\sum\\limits_{i=2}^\\infin i\\frac{x^i}{i!}$。\n\n那么答案的 EGF 即为：\n$$\n\\begin{aligned}\nF(x)&=B(x)^2\\frac{1}{2}\\sum\\limits_{i=0}^{\\infin}A^i(x)\\\\\n&=B(x)^2\\frac{1}{2}\\sum\\limits_{i=0}^{\\infin}A^i(x)\\\\\n&=\\frac{B(x)^2}{2(1-A(x))}\\\\\n\\end{aligned}\n$$\n注意菊花和 $n\\le 2$ 的情况要特判。\n\n#### 4.4 有标号 DAG 计数\n\n> DAG：有向无环图。\n\n[P6295 有标号 DAG 计数](https://www.luogu.com.cn/problem/P6295)\n\n考虑不断加入入度为 $0$ 的点集，设 $f_n$ 为 $n$ 个点的 DAG 个数，那么有：\n\n$$\nf_n=\\sum\\limits_{i=1}^{n}\\binom{n}{i}2^{i(n-i)}f_{n-i}\n$$\n但是这样 $G=\\{1\\to 3,2\\to 3\\}$  会被算重，发现一个点集 $S$ 的所有子集 $T\\subseteq S$ 都会把 $S$ 算一次，那么根据：\n\n$$\n(1-1)^n=\\sum\\limits_{i=0}^n (-1)^i\\binom{n}{i}=[n=0]\\\\\n\\sum\\limits_{i=1}^n (-1)^{i-1}\\binom{n}{i}=[n\\not=0]\\\\\n$$\n所以有容斥：\n\n$$\nf_n=\\sum\\limits_{i=1}^{n}(-1)^{i-1}\\binom{n}{i}2^{i(n-i)}f_{n-i}\n$$\n\n由于 $xy=\\binom{x+y}{2}-\\binom{x}{2}-\\binom{y}{2}$，所以这个东西可以直接分治 NTT。\n\n考虑设 $F(x)=\\sum\\limits_{i=0}^\\infin \\frac{f_i}{i!2^{\\binom{i}{2}}}x^i$，$G(x)=\\sum\\limits_{i=1}^\\infin\\frac{(-1)^{i-1}}{i!2^{\\binom{i}{2}}}x^i$，那么有：\n$$\n\\begin{aligned}\nF(x)&\\equiv F(x)G(x)+1\\pmod{x^n}\\\\\nF(x)&\\equiv \\frac{1}{1-G(x)}\\pmod{x^n}\n\\end{aligned}\n$$\n那么求逆就行了，优化掉了一个 $\\log$。\n\n但是洛谷上的题要求图必须弱联通，所以需要再 $\\ln$ 一下。\n",
			"tags": [{"name":"学习笔记"},{"name":"数学"},{"name":"组合计数"},{"name":"多项式、生成函数"}],
			"title": "生成函数入门",
			"link": "https://exber.qzz.io/post/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%85%A5%E9%97%A8",
			"date": "2023-04-15 14:28:39"
		},
	
		{
			"abstract": "> 给定 $n$ 个数 $[1,2,3,\\ldots,n]$ 和两个正整数 $k$ 和 $x$。\n> \n> 将这些数分成恰好 $k$ 组使得每组的异或和都是 $x$。具体地，每个数都必须出现在恰好一组内。\n> \n> $1\\le k\\le n\\le 2\\cdot 10^5$，$1\\le x\\le 10^9$。\n",
			"content": "> 给定 $n$ 个数 $[1,2,3,\\ldots,n]$ 和两个正整数 $k$ 和 $x$。\n> \n> 将这些数分成恰好 $k$ 组使得每组的异或和都是 $x$。具体地，每个数都必须出现在恰好一组内。\n> \n> $1\\le k\\le n\\le 2\\cdot 10^5$，$1\\le x\\le 10^9$。\n\n首先考虑无解情况，显然若 $1\\oplus2\\oplus 3\\oplus\\dots\\oplus n\\not=[k\\operatorname{mod}2=1]x$ 则无解，还有一个不那么显然的是若 $1,2,3,\\dots n$ 中 $x$ 的最高位为 $1$ 的数的个数比 $k$ 小也无解。\n\n接下来考虑构造解，显然由于 $x\\oplus x\\oplus x=x$ 且 $1\\oplus2\\oplus 3\\oplus\\dots\\oplus n=[k\\operatorname{mod}2=1]x$，所以只要最大化分的组数就行了。\n\n首先若 $1\\le x\\le n$ 则显然 $x$ 单独分一组最优。\n\n接下来设 $x$ 的最高位为 $2^k$，那么每一组中都至少要有一个数二进制第 $k$ 位为 $1$，不妨设二进制第 $k$ 位为 $1$ 且不是 $x$ 的数的集合为 $S$，那么对于所有 $y\\in S$，都有 $x\\oplus y<y$，且对于任意两个不同的 $a\\in S,b\\in S$，$x\\oplus a$ 和 $x\\oplus b$ 都不同，所以每个 $a\\in S$ 都可以找到一个唯一对应的数 $b=x\\oplus a$ 组成一组 $\\{a,b\\}$。\n\n这样分组之后显然所有二进制第 $k$ 位为 $1$ 的数都单独在一个组，没被分组的数中一定没有二进制第 $k$ 位为 $1$ 的了，所以这样分组是最优的，并且剩下的所有数异或起来为 $0$。所以剩下的数可以一起并入任意一组。\n\n设当前分的组数为 $m$，那么有 $m\\equiv k\\pmod 2$，所以可以不断利用 $x\\oplus x\\oplus x=x$ 来合并多余的组，最终一定能得到 $k$ 组。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=200005;\n\nint n,k,x;\nbool vis[S];\n\ninline void slove()\n{\n\tscanf(\"%d%d%d\",&n,&k,&x);\n\tint sum=0;\n\tfor(int i=1;i<=n;i++) sum^=i;\n\tif(sum!=(k&1)*x) return puts(\"NO\"),void();\n\tint higbit=-1,tmp=x;\n\twhile(tmp>0) tmp>>=1,higbit++;\n\tint cnt=0;\n\tfor(int i=1;i<=n;i++) if(i>>higbit&1) cnt++;\n\tif(cnt<k) return puts(\"NO\"),void();\n\tfor(int i=1;i<=n;i++) vis[i]=false;\n\tputs(\"YES\");\n\tint tot=0;\n\tif(tot==k-1)\n\t{\n\t\tcnt=0;\n\t\tfor(int i=1;i<=n;i++) if(!vis[i]) cnt++;\n\t\tprintf(\"%d \",cnt);\n\t\tfor(int i=1;i<=n;i++) if(!vis[i]) printf(\"%d \",i);\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\tif(x<=n) vis[x]=true,printf(\"1 %d\\n\",x),tot++;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(tot==k-1)\n\t\t{\n\t\t\tcnt=0;\n\t\t\tfor(int i=1;i<=n;i++) if(!vis[i]) cnt++;\n\t\t\tprintf(\"%d \",cnt);\n\t\t\tfor(int i=1;i<=n;i++) if(!vis[i]) printf(\"%d \",i);\n\t\t\tprintf(\"\\n\");\n\t\t\treturn;\n\t\t}\n\t\tif(!vis[i]&&(i>>higbit&1))\n\t\t{\n\t\t\tvis[i]=vis[x^i]=true;\n\t\t\tprintf(\"2 %d %d\\n\",i,x^i);\n\t\t\ttot++;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint T;\n\tscanf(\"%d\",&T);\n\twhile(T-->0) slove();\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"构造"},{"name":"数学"}],
			"title": "CF1787E The Harmonization of XOR 做题记录",
			"link": "https://exber.qzz.io/post/CF1787E%20The%20Harmonization%20of%20XOR%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-04-15 14:27:03"
		},
	
		{
			"abstract": "> 一个 $n$ 层的金字塔，你能进行两种操作。\n> \n> 给某个点染色，代价是 $3$。给某一个底边是金字塔的底边的子三角形染色，，代价是 $\\text{点数}+2$。\n> \n> 现在有 $m$ 个黑点，求出把所有黑点染色所需的最小代价。\n> \n> $1\\le n,m\\le 10^5$。\n",
			"content": "> 一个 $n$ 层的金字塔，你能进行两种操作。\n> \n> 给某个点染色，代价是 $3$。给某一个底边是金字塔的底边的子三角形染色，，代价是 $\\text{点数}+2$。\n> \n> 现在有 $m$ 个黑点，求出把所有黑点染色所需的最小代价。\n> \n> $1\\le n,m\\le 10^5$。\n\n模拟赛的时候读错题了……\n\n首先可以把金字塔向左对齐，并且把行数从下到上重新编号（$x\\to n-x+1$），这样问题就变成了选一个点染色或者选一个“到底”的直角三角形染色。\n\n从左向右一列一列考虑，假设考虑到 $i$，显然左上角在 $i$ 这一列前面的所有直角三角形都处理完了，并且这些直角三角形会在当前列即以后留下一个“小尖”：\n\n![](../post-images/1681539662085.png)\n\n那么有一个显然的 dp，设 $dp_{i,j}$ 表示处理完前 $i$ 列，所有直角三角形在第 $i$ 列的左上角最高为 $j$（即“小尖”和在第 $i$ 列选的直角三角形覆盖了第 $i$ 列 $j$ 以下的所有点）需要的最少花费。\n\n转移枚举当前列选的直角三角形即可，前缀最小值加上后缀和可以优化到 $O(n^2)$。\n\n不难发现，答案上界是 $3m$，也就是说选择的直角三角形的左上角的高度 $x$ 不会大于 $\\sqrt{6m}\\approx 774$，所以时间复杂度可以优化到 $O(774n)$，加上滚动数组优化即可通过本题。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n\nusing namespace std;\n\nconst int S=100005,MS=785;\n\nint n,m,lim;\nvector<int> pos[S];\nint dp[2][MS];\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tlim=min(n,MS-3);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tpos[y].push_back(n-x+1);\n\t}\n\tfor(int i=1;i<=n;i++) sort(pos[i].begin(),pos[i].end());\n\tmemset(dp,127,sizeof(dp));\n\tdp[0][0]=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint u=i&1,v=i-1&1;\n\t\tmemset(dp[u],127,sizeof(dp[u]));\n\t\tint k=0,siz=pos[i].size();\n\t\tdp[u][0]=dp[v][0]+(siz-k)*3;\n\t\tfor(int j=0,k=0;j+1<=lim&&j<=n-i+1;j++)\n\t\t{\n\t\t\twhile(k<pos[i].size()&&pos[i][k]<=j) k++;\n\t\t\tdp[u][j]=min(dp[u][j],dp[v][j+1]+(siz-k)*3);\n\t\t}\n\t\tk=0;\n\t\tint mn=min(dp[v][0],dp[v][1]);\n\t\tfor(int j=1;j<=lim&&j<=n-i+1;j++)\n\t\t{\n\t\t\twhile(k<pos[i].size()&&pos[i][k]<=j) k++;\n\t\t\tif(j+1<=lim) mn=min(mn,dp[v][j+1]);\n\t\t\tdp[u][j]=min(dp[u][j],mn+j*(j+1)/2+2+(siz-k)*3);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",min(dp[n&1][0],dp[n&1][1]));\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"DP"}],
			"title": "CF354D Transferring Pyramid 做题记录",
			"link": "https://exber.qzz.io/post/CF354D%20Transferring%20Pyramid%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-04-15 14:20:23"
		},
	
		{
			"abstract": "> 给出长度为 $n$ 的 `01` 序列 $a_{1\\sim n}$，**序列中有偶数个 `1`**。NIT 和 TIN 轮流做以下操作，NIT 先手：\n> \n> - 选择位置 $i\\ (1\\le i\\le n)$，满足区间 $[1,i]$ 中有奇数个 `1`。再选择位置 $j\\ (i<j\\le n)$。将 $a_i,a_j$ 都取反（即，`0` 变 `1`，`1` 变 `0`）\n> \n> 当整个序列中的所有元素都变为 `0` 时，当前轮到的人就无法操作，他就输了。假设 NIT 和 TIN 都*绝顶*聪明，谁会赢？可以证明，游戏总会结束。\n> \n> $n$ 可能很大，但序列中 $1$ 的个数不超过 $2\\times 10^5$。\n> \n> `01` 序列的输入方式是 $m$ 个**递增**的正整数，描述这些 `1` 的下标，下标从 $1$ 开始。\n> \n> $1\\le n\\le 10^{18}$，$2 \\le m\\le 10^6$。保证 $m$ 是偶数，保证为 `1` 的下标是递增顺序给出的。\n",
			"content": "> 给出长度为 $n$ 的 `01` 序列 $a_{1\\sim n}$，**序列中有偶数个 `1`**。NIT 和 TIN 轮流做以下操作，NIT 先手：\n> \n> - 选择位置 $i\\ (1\\le i\\le n)$，满足区间 $[1,i]$ 中有奇数个 `1`。再选择位置 $j\\ (i<j\\le n)$。将 $a_i,a_j$ 都取反（即，`0` 变 `1`，`1` 变 `0`）\n> \n> 当整个序列中的所有元素都变为 `0` 时，当前轮到的人就无法操作，他就输了。假设 NIT 和 TIN 都*绝顶*聪明，谁会赢？可以证明，游戏总会结束。\n> \n> $n$ 可能很大，但序列中 $1$ 的个数不超过 $2\\times 10^5$。\n> \n> `01` 序列的输入方式是 $m$ 个**递增**的正整数，描述这些 `1` 的下标，下标从 $1$ 开始。\n> \n> $1\\le n\\le 10^{18}$，$2 \\le m\\le 10^6$。保证 $m$ 是偶数，保证为 `1` 的下标是递增顺序给出的。\n\n妙妙题。\n\n不难发现，操作相当于移动 $1$。不妨设 $b_i=n-a_i$，游戏即转化为所有 $b_i$ 均为 $0$ 时无法操作。\n\n1. $a_i=1$ 的情况：\n   1. $a_j=0$，相当于让 $b_i\\to b_i-(j-i)$；\n   2. $a_j=1$，相当于让 $b_i\\to 0$，$b_j\\to 0$；\n\n2. $a_i=0$ 的情况：\n   1. $a_j=0$，相当于新建两个 $b_{m+1}=n-i$ 和 $b_{m+2}=n-j$；\n   2. $a_j=1$，相当于让 $b_j\\to b_j+(j-i)$；\n\n下面将证明这个游戏等价于 Nim 游戏，即先手必胜当且仅当 $\\oplus_ib_i\\not=0$。\n\n设当前异或和为 $x$，则：\n\n- 1.1 相当于 Nim 游戏的正常操作；\n- 1.2 相当于让 $b_i\\to b_i-(j-i)$，由于存在 $b_j=b_i-(j-i)$，所以这两个在异或和中抵消了，相当于都变成了 $0$；\n\n并且不难发现 “$[1,i]$ 区间有奇数个 $1$” 这个限制是没有任何用的，因为 Nim 游戏中从 $x\\not=0$ 转移到 $x=0$ 的操作方法是找到一个二进制最高位和 $x$ 的最高位相同的 $b_k$，并让它减去 $b_k-(x\\oplus b_k)$。设最大的满足条件的 $k$ 为 $p$，则满足 $b_i>b_p$ 的 $i$ 一定有偶数个，那么此时操作 $b_p$ 即可。\n\n那么注意到 $a_i=1$ 的情况已经涵盖了 Nim 游戏的所有合法操作，下面来证明 $a_i=0$ 的情况不会出现。不难发现 $a_i=0$ 的操作出现的目的一定是停在 $x=0$ 的情况，那么只需要考虑操作产生的贡献有没有可能是 $0$ 即可：\n\n- 2.1 中 $n-i$ 一定不等于 $n-j$，贡献一定不为 $0$；\n- 2.2 中 贡献还是一定不为 $0$；\n\n所以 $a_i=0$ 的操作一定不会出现。\n\n综上，证毕。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=200005;\n\nint n,m;\nint a[S];\n\ninline void slove()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++) scanf(\"%d\",&a[i]);\n\tint ans=0;\n\tfor(int i=1;i<=m;i++) ans^=n-a[i];\n\tputs(ans==0?\"TIN\":\"NIT\");\n}\n\nint main()\n{\n\tint T;\n\tscanf(\"%d\",&T);\n\twhile(T-->0) slove();\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"数学"},{"name":"博弈论"}],
			"title": "P9003 [RC-07] Game Theory 做题记录",
			"link": "https://exber.qzz.io/post/P9003%20%5BRC-07%5D%20Game%20Theory%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-04-15 14:06:44"
		},
	
		{
			"abstract": "",
			"content": "**后缀树（数据结构）和本文中的后缀树其实不是一个东西，更规范的叫法应该是 parent 树，但是由于 $S$ 的后缀树就是其反串的 parent 树，所以并没有加以区分**。\n\n## 前言\n\nSAM（后缀自动机） 是一种强大的数据结构，在应用上可以完全包含 SA（后缀数组），往往比 SA 好写好调且时间复杂度更优。\n\n本文借鉴了 [后缀自动机(SAM)奶妈式教程 - 一铭君一 - 博客园 (cnblogs.com)](https://www.cnblogs.com/zaza-zt/p/15419181.html)（算法思想、实现、技巧）和 [后缀自动机 - star_road_xyz - 博客园 (cnblogs.com)](https://www.cnblogs.com/starroadxyz/p/17077259.html)（状态个数、转移个数证明）。\n\n为了表述方便，这里为本文规定一些记号：\n\n- $|S|$：字符串 $S$ 的长度；\n- $V$：字符集大小；\n\n## 基本定义\n\n1. SAM 是一个 DAG，它的**节点被称作“状态”，边被称作“转移”**；\n2. SAM 有一个初始状态 $rt$（代表空串），所有其它状态都能通过转移从 $rt$ 到达；\n3. 每个转移会被标记上字符集中的一个字符（类似边权），从**一个状态出发的所有转移的字符互不相同**；\n4. 存在**至少一个**终止状态，从 $rt$ 出发到终止状态的每一条路径上的所有转移依次拼接得到的字符串都是原串的后缀，也就是说**原串的每个后缀都能表示成从 $rt$ 到终止状态的路径**；\n5. SAM 是满足上述条件中**状态数最少**的 DAG；\n\n****\n\n**一些记号**\n\n- $S$：要被建 SAM 的原串；\n\n- $rt$：SAM 的初始状态（空串对应状态）；\n- $to_{u,ch}$ 从状态 $u$ 出发的，被标记上字符 $ch$ 的转移；\n\n## SAM 的优势\n\n不难发现，从 $rt$ 到SAM 上的每个状态路径上的字符拼接起来都是原串某个后缀的一个前缀，这意味着**原串的每个子串都能表示成从 $rt$ 到某个状态的路径**。\n\n虽然大多数 SAM 能做的操作 SA 也能做，但是线性 SA 的 DC3 算法常数巨大，并且 SA 性质较少，应用时通常需要一些较为复杂的数据结构辅助，这些数据结构相应也会提高时间复杂度。但**建立字符串 $S$ 对应的 SAM 的时空复杂度仅为 $O(|S|)$**，并且 SAM 有着更好的性质。\n\n综上，SAM 不失为一种十分优秀的字符串算法。\n\n## $\\operatorname{endpos}$ 和 $\\operatorname{endpos}$ 等价类\n\n使用 $\\operatorname{endpos}$ 等价类压缩时空就是 SAM 保持优秀时间复杂度的原因。\n\n记 $\\operatorname{endpos}(s)$ 表示 $s$ 在 $S$ 中每次出现的结尾位置的集合（下标从 $1$ 开始），例如：\n\n```\nS: abab\ns:           a    b,ab   ba,aba  bab,abab\nendpos(s): {1,3}  {2,4}   {3}       {4}\n```\n\n不难发现，某些字符串的 $\\operatorname{endpos}$ 是相同的，例如例子中的 `b` 和 `ab`。那么不妨**将所有 $\\operatorname{endpos}(s)=A$ 的归到同一个等价类中，记 $\\operatorname{endpos'}(A)=\\{s|\\operatorname{endpos(s)=A}\\}$**。\n\n在 SAM 中，**一个状态表示的并不是具体的某个字符串，而是一个等价类**。\n\n****\n\n**一些记号**：\n\n- $\\operatorname{endpos}(s)$：$s$ 在 $S$ 中每次出现的结尾位置的集合（下标从 $1$ 开始）；\n- $\\operatorname{endpos'}(A)$：$\\{s|\\operatorname{endpos(s)=A}\\}$ 即 $\\operatorname{endpos}(s)=A$ 的 $s$ 构成的集合；\n- $E(u)$：状态 $u$ 代表的等价类；\n- $\\operatorname{sta}(s)$：字符串 $s$ 所属的等价类对应的状态；\n\n## $\\operatorname{endpos}$ 等价类的一些性质\n\n> **引理  1**\n>\n> 考虑两个非空字符串 $s1,s2$，满足 $|s1|\\ge|s2|$。\n>\n> 1. 若 $\\operatorname{endpos}(s1)=\\operatorname{endpos}(s2)$，则 $s2$ 是 $s1$ 的后缀，且 $s2$ 在且仅在 $s1$ 在 $S$ 中出现时作为它的后缀出现；\n>\n> 2. 若 $s2$ 是 $s1$ 的后缀，且 $s2$ 在且仅在 $s1$ 在 $S$ 中出现时作为它的后缀出现，那么 $\\operatorname{endpos}(s1)=\\operatorname{endpos}(s2)$；\n\n证明是显然的。\n\n>**引理  2**\n>\n>考虑两个非空字符串 $s1,s2$，满足 $|s1|\\ge|s2|$。\n>\n>1. 若 $s2$ 是 $s1$ 的后缀，那么 $\\operatorname{endpos}(s1)\\subseteq\\operatorname{endpos}(s2)$；\n>\n>2. 若 $s2$ 不是 $s1$ 的后缀，那么 $\\operatorname{endpos}(s2)\\cap\\operatorname{endpos}(s1)=\\varnothing$；\n\n第一条是因为 $s1$ 每次出现 $s2$ 都必然会出现。\n\n第二条是因为若 $s2$ 是 $s1$ 的子串且存在 $p$ 满足 $p\\in \\operatorname{endpos}(s1)$ 且 $p\\in \\operatorname{endpos}(s2)$ 则 $s1$ 和 $s2$ 都一定会在 $p$ 处结束，$s2$ 必定是 $s1$ 的子串，和假设矛盾，得证。\n\n> **引理 3**\n>\n> 考虑一个 $\\operatorname{endpos}$ 等价类 $A=\\operatorname{endpos}'(E)$。\n>\n> 1. $A$ 中不包含两个长度相同但本质不同的字符串；\n> 2. 对于 $A$ 中任意两个字符串，短的那个一定是长的那个的真后缀，也就是说 $A$ 中所有字符串都是最长的那个的后缀；\n> 3. 设 $l,r$ 分别为 $A$ 中最短和最长的字符串的长度，则 $\\{|s|,s\\in A\\}=[l,r]\\cap \\mathbb{N}^+$，即 $l,r$ 之间的每种长度的串都会出现恰好一次；\n\n第一条可以由引理 1 推出，第二条可以由引理 2 推出，考虑第三条的证明。\n\n不难发现只有可能是等号右边的集合的某个元素没在等号左边的集合中出现。那么设 $d\\in ([l,r]\\cap \\mathbb{N}^+)$ 且 $d\\notin\\{|s|,s\\in A\\}$。由于第二条，所以可以设长度为 $d$ 的字符串为 $s^d$，则由于引理 2，有 $A\\subseteq\\operatorname{endpos}(s^d)$。\n\n此时若 $A\\subset \\operatorname{endpos}(s^d)$，则 $s^d$ 的所有子串的 $\\operatorname{endpos}$ 都会不等于 $A$。由于第二条，$t\\in ([l,d]\\cap\\mathbb{N^+})$ 的所有 $t$ 均满足 $A\\subset \\operatorname{endpos(s^t)}$，那么 $l$ 将会等于 $d+1$，和 $d\\in ([l,r]\\cap \\mathbb{N}^+)$ 矛盾，得证。\n\n****\n\n**一些记号**：\n\n- $\\operatorname{long}(u)$：$\\operatorname{endpos}'(\\operatorname{E}(u))$ 中最长的字符串；\n- $\\operatorname{len(u)}$：$|\\operatorname{long}(\\operatorname{E}(u))|$ 即 $\\operatorname{endpos}'(\\operatorname{E}(u))$ 中最长的字符串的长度；\n- $\\operatorname{short}(u)$：$\\operatorname{endpos}'(\\operatorname{E}(u))$ 中最短的字符串；\n- $\\operatorname{slen(u)}$：$|\\operatorname{short}(\\operatorname{E}(u))|$ 即 $\\operatorname{endpos}'(\\operatorname{E}(u))$ 中最短的字符串的长度；\n\n## 后缀指针 $\\operatorname{link}$ 和后缀树\n\n设 $A=E(u)$ 即状态 $u$ 代表的等价类，$w$ 为 $\\operatorname{long}(u)$ 最长的满足 $w\\notin A$ 的一个后缀，$v$ 为 $\\operatorname{sta}(w)$ 即 $w$ 所属等价类对应的状态（由 SAM 的定义可知这个状态一定存在），$\\operatorname{link}(u)$ 即为 $v$。特别的，$rt$ 没有 $\\operatorname{link}$ 指针。\n\n根据引理 3，**从状态 $u$ 出发不断跳 $\\operatorname{link}$ 到 $rt$ 路径上所有状态的等价类并起来就是 $\\operatorname{long}(u)$ 的所有后缀**，所以 $\\operatorname{link}$ 也叫后缀指针。\n\n> **引理 5**\n>\n> 对于一个状态 $u$，设 $\\operatorname{link}(u)=v$。\n>\n> 1. $\\operatorname{long}(v)$ 是 $\\operatorname{short}(u)$ 的长度为 $\\operatorname{slen}(u)-1$ 的后缀；\n> 2. $\\operatorname{E}(u)\\subsetneq \\operatorname{E}(v)$；\n\n第一条可以由引理 3 得出，第二条可以由引理 2 和 $\\operatorname{link}$ 指针的定义得出。\n\n需要注意的是，利用这个引理，SAM 中的**每个状态便只需要记录等价类中的最长串**。\n\n> **引理 6**\n>\n> 把状态看作节点，则所有有向边 $u\\to\\operatorname{link(u)}$ 构成一棵以 $rt$ 为根的内向树（后缀树）。\n\n首先由于所有状态不断跳 $\\operatorname{link}$ 总能跳回 $rt$（空串是所有字符串的后缀），所以“后缀图”一定连通。\n\n然后由于只有 $rt$ 没有 $\\operatorname{link}$ 指针，所以“后缀图”的边数恰好等于点数减 $1$，所以“后缀图”是一棵树。\n\n****\n\n**一些记号**：\n\n- $\\operatorname{link}(u)$：设 $A=E(u)$ 即状态 $u$ 代表的等价类，$w$ 为 $\\operatorname{long}(A)$ 最长的满足 $w\\notin A$ 的一个后缀，$v$ 为 $\\operatorname{sta}(w)$ 即 $w$ 所属等价类对应的状态（由 SAM 的定义可知这个状态一定存在），$\\operatorname{link}(u)$ 即为 $v$。特别的，$rt$ 没有 $\\operatorname{link}$ 指针；\n\n## 小结\n\n在开始介绍如何构造 SAM 前，我们先小结一下：\n\n- 原串 $S$ 的每一个子串可以根据 $\\operatorname{endpos}$ 来划分为若干个等价类，每个等价类对应一个状态；\n- 对于每个状态 $u$，$\\operatorname{E}(u)$ 中包含了 $\\operatorname{long(u)}$ 长度从 $\\operatorname{slen}(u)$ 到 $\\operatorname{len}(u)$ 的所有后缀（引理 3）；\n- 从状态 $u$ 出发不断跳 $\\operatorname{link}$ 到 $rt$ 路径上所有状态的等价类并起来就是 $\\operatorname{long}(u)$ 的所有后缀（引理 3 推出）；\n- 设 $A=E(u)$ 即状态 $u$ 代表的等价类，$w$ 为 $\\operatorname{long}(A)$ 最长的满足 $w\\notin A$ 的一个后缀，$v$ 为 $\\operatorname{sta}(w)$ 即 $w$ 所属等价类对应的状态（由 SAM 的定义可知这个状态一定存在），则 $\\operatorname{link}(u)$ 即为 $v$。特别的，$rt$ 没有 $\\operatorname{link}$ 指针。所有 $\\operatorname{link}$ 指针构成一棵以 $rt$ 为根的内向树，称之为后缀树（引理 6）；\n\n## SAM 的构造\n\n构造 SAM 的算法是一个动态的算法。一开始 SAM 中只存在一个代表空串的状态 $rt$，没有任何转移。通过**依次插入原串 $S$ 中的每一个字符来动态维护 SAM**。\n\n这里将给出算法流程、解释、时空复杂度分析和 C++ 代码。\n\n**算法流程**\n\n一开始 SAM 中只存在一个编号为 $0$ 的状态 $rt$。为了方便，我们钦定 $\\operatorname{long}(rt)=0$，$\\operatorname{link}(rt)=-1$。\n\n现在任务是给 SAM 维护的字符串的末尾新加入一个字符 $c$，流程如下：\n\n1. 设上一次加入字符后整个整个字符串 $S$ 对应的状态为 $lst$，即 $\\operatorname{long}(lst)=S$；\n2. 创建一个新的状态 $pre$，并且令 $\\operatorname{len}(pre)=\\operatorname{len}(lst)+1$；\n3. 从 $lst$ 开始不断跳 $\\operatorname{link}$，如果当前状态 $u$ 没有标记 $c$ 的转移，那么令 $to_{u,c}=pre$；\n4. 如果跳到了 $rt$ 并且 $rt$ 也没有标记 $c$ 的转移，那么令 $to_{rt,c}=pre$，$\\operatorname{link}(pre)=0$（指向状态 $rt$），转到 8；\n5. 否则停止跳 $\\operatorname{link}$，并设当前跳到的状态为 $p$，$to_{p,c}$ 为 $q$；\n6. 若 $\\operatorname{len(q)}=\\operatorname{len}(p)+1$，令 $\\operatorname{link}(pre)=q$；\n7. 否则：\n   1. 复制 $q$ 到一个新的状态 $cpy$（只复制 $\\operatorname{link}$ 以及 $to_{q,*}$）；\n   2. 令 $\\operatorname{len}(cpy)=\\operatorname{len}(p)+1,\\operatorname{link}(pre)=cpy$；\n   3. 从 $p$ 开始不断跳 $\\operatorname{link}$，设当前跳到的状态为 $u$，则：\n      - 若 $u=-1$ 或 $to_{u,c}\\not=q$，停止跳 $\\operatorname{link}$；\n      - 否则令 $to_{u,c}=cpy$；\n   4. 令 $\\operatorname{link}(q)=cpy$，转到 8；\n8. 令 $lst=pre$，插入操作完成；\n\n**算法解释**\n\n为了表述方便，设 $S1$ 为插入 $c$ 之前的 $S$，$S2$ 为插入 $c$ 之后的 $S$ 即 $S1+c$。\n\n1. 为之后的操作做准备；\n\n2. 插入字符 $c$ 后，$\\operatorname{endpos}(S2)=\\{|S1|+1\\}$ 一定会成为一个新的等价类，所以需要分配新的状态 $pre$ 来代表它。而 $\\operatorname{len}(pre)$ 一定是 $|S1|+1$，$lst$ 中最长的字符串显然就是 $S1$，所以令 $\\operatorname{len}(pre)=\\operatorname{len}(lst)+1$；\n\n3. 考虑新建转移到 $pre$，不断枚举 $S1$ 的后缀，如果还没有标记为 $c$ 的转移就可以新建标记为 $c$ 的转移到 $pre$；\n\n4. 跳到 $rt$ 还没结束代表字符 $c$ 是第一次出现，因为 $rt$ 没有到 $c$ 的转移表明 $S1$ 不存在 $c$ 这个子串，那么 $\\operatorname{link}(pre)$ 自然要指向状态 $rt$，因为 $S2$ **不存在非空真后缀**；\n\n5. 为之后的操作做准备，注意此时所有到 $pre$ 的转移已处理完成，接下来的所有步骤都是在处理 $\\operatorname{link}(pre)$；\n\n6. 若 $E(q)$ 中最长的那个就是 $\\operatorname{long}(p)+c$ 即 $S1$ 的某个后缀加上字符 $c$，那么 $\\operatorname{long}(q)$ 就**一定是 $S2$ 最长的真后缀**，所以可以让 $\\operatorname{link}(pre)$ 指向 $q$；\n\n7. 否则一定有 $\\operatorname{len}(q)>\\operatorname{len}(p)$。发现所有 $A=\\{s|s\\in E(q),|s|\\le \\operatorname{len}(p)+1\\}$  中的字符串一定**是 $S1$ 的某个后缀加上字符 $c$**，而 $B=E(q)-A$ 中的一定不是。那么 **$A$ 中的字符串的 $\\operatorname{endpos}$ 集合一定会加入元素 $|S2|$，$B$ 中的则一定不会，所以 $A$ 和 $B$ 不再属于同一个等价类**。\n\n   此时就需要分裂 $q$ 代表的等价类。具体的，创建一个新的状态 $cpy$，把 $q$ 的所有“出边”都复制过去。\n\n   接下来的工作就是让 $cpy$ 表示 $A$，原来的 $q$ 表示 $B$。\n\n   首先 $A$ 中最长的字符串的长度显然是 $\\operatorname{len}(p)+1$，那么令 $\\operatorname{len}(cpy)=\\operatorname{len}(p)+1$，而 $B$ 中最长的字符串没有改变，所以无需对 $\\operatorname{len}(q)$ 进行任何操作。\n\n   接下来不难发现 $\\operatorname{long}(cpy)$ 一定是 $S2$ 的最长的真后缀，所以令 $\\operatorname{link}(pre)$ 指向 $cpy$。\n\n   然后遍历 $p$ 所有的后缀的状态 $u$。因为 $\\operatorname{len}(u)\\le \\operatorname{len}(p)$，所以若 $u$ 有标记 $c$ 的转移到 $q$，那么转移得到的字符串一定属于 $A$，所以让 $to_{u,c}=cpy$；否则 $U=\\operatorname{endpos}(s+c|s\\in \\operatorname{E}(u))$ 一定包含且不等于 $Q=\\operatorname{endpos}(s\\in E(q))$，那么 $\\operatorname{long}(u)$ 的后缀的 $\\operatorname{endpos}$ 集合更不可能满足要求，所以可以停止跳 $\\operatorname{link}$。\n\n   最后由于 $\\operatorname{long}(cpy)$ 一定是 $\\operatorname{long}(q)$ 的最长真后缀，所以令 $\\operatorname{link}(q)$ 指向 $cpy$；\n\n8. 更新 $lst$，为之后的插入做准备；\n\n**复杂度分析**\n\n记 $n=|S|$。\n\n- 状态数和转移数\n\n  不难发现，除第一次之外每次插入最多会新建两个状态，所以状态数**上限为 $2n-1$**。\n\n  而转移会分为两种：\n\n  - $\\operatorname{link}$：由于构成内向树，所以上限为 $2n-2$；\n\n  - $to$：\n\n    考虑先随便拎出一棵以 $rt$ 为根的外向生成树，下面来证明非树边数量 $\\le n$。\n\n    对于一条非树边 $u\\to v$（设 $v=to_{u,c}$），设 $s1$ 为生成树上 $rt$ 到 $u$ 的链构成的字符串，$s2$ 为 $v$ 往后不停走字典序最小的边直到不能走的路径构成的字符串。\n\n    考察字符串 $s1+c+s2$，很显然它是 $S$ 的一个后缀，否则就还能继续走下去。那么这是一个非树边到 $S$ 的后缀的映射。\n\n    而不难发现 $c$ 是 $s1+c+s2$ 对应的路径上第一条非树边，所以这个映射是双向的，即一一对应。\n\n    故非树边条数 $\\le |S|=n$；\n\n  那么转移数的上限为 $5n-3$，实际上很难卡满。\n\n-  空间复杂度\n\n  由于状态数上限为 $2n-1$，转移数上限为 $3n-2$，所以空间复杂度为 $O(n)$。\n\n  特别的，若字符集较小，那么往往**采用数组存储 $to$，此时空间复杂度为 $O(nV)$**。\n\n  若字符集较大，往往**采用可持久化线段树来存储 $to$，此时空间复杂度为 $O(n\\log V)$**。\n\n- 时间复杂度\n\n  较难证明的部分是两个跳 $\\operatorname{link}$ 的步骤。不难发现，步骤 3 跳的总次数和转移数相当，所以是 $O(n)$ 的。\n\n  而步骤 7.3 就有点复杂了，注意到有一个引理：\n\n  > **引理**\n  >\n  > 对于一个状态 $u$，设 $A=\\{(v,c)|to_{v,c}=u\\}$ 即其所有入边。\n  >\n  > 那么 $\\forall (v_i,c_i)\\in A$，$c_i$ 相同，$v_i$ 在后缀树上形成一条链（$v_i$ 中的字符串互为后缀）。\n  >\n  > 且 $\\text{len}(u)=\\max\\limits_{(v,c)\\in A}\\{\\text{len}(v)+1\\},\\text{slen}(u)=\\min\\limits_{(v,c)\\in A}\\{\\text{slen}(v)+1\\}$。\n  \n  这是显然的，因为一个状态中的字符串一定互为后缀，并且 SAM 包含了原串的所有子串。\n  \n  注意到 $cpy$ 的所有入边只会在 7.3 中产生，并且每跳一次 $\\text{link}$ 都会使得：\n  \n  - $\\text{slen}(u)$ 减少；\n  - $\\text{slen}(cpy)$ 减少；\n  - $\\text{len}(\\text{link}(cpy))$ 减少；\n  \n  并且由于 $cpy=\\text{link}(pre)$，并且 $pre$ 会成为新的 $lst$，所以 7.3 中每跳一次 $\\text{link}$ 都会使得 $\\text{len}(\\text{link}(\\text{link}(lst)))$ 减少。\n  \n  考虑一次插入操作最多使 $\\text{len}(\\text{link}(\\text{link}(pre)))$ 增加多少：\n  \n  - 若执行了步骤 6，即 $\\text{link}(pre)$ 变为 $q$，则 $p$ 最深也是 $\\text{link}(lst)$。\n  \n    根据引理，$\\text{link}(q)$ 的入边 $(v_i,c_i)$ 一定满足 $v_i$ 在 $\\text{link}(lst)$ 的 $\\text{link}$ 链上，并且 $v_i$ 为 $\\text{link}(lst)$ 的祖先，则 $\\text{len}(v_i)\\le \\text{len}(\\text{link}(\\text{link}(lst)))$，那么 $\\text{len}(\\text{link}(\\text{link}(pre)))\\le \\text{len}(\\text{link}(\\text{link}(lst)))+1$；\n  \n    ![](../post-images/1709124294150.png)\n  \n  - 若执行了步骤 7，由于 $\\text{link}(pre)=cpy$，$\\text{link}(cpy)=\\text{link(q)}$，所以重复步骤 6 的证明，$\\text{len}(\\text{link}(\\text{link}(pre)))\\le \\text{len}(\\text{link}(\\text{link}(lst)))+1$；\n  \n  综上，每次插入操作 $\\text{len}(\\text{link}(\\text{link}(lst)))$ 最多加 $1$，而每次执行 7.3 都会让其减少至少 $1$，那么 7.3 的总执行次数是 $O(n)$ 的。\n  \n  所以**构建 SAM 的时间复杂度为 $O(nk)$（其中 $k$ 是访问和修改 $to$ 的时间复杂度，若使用数则为 $O(1)$，使用可持久化线段树为 $O(\\log V)$）**。\n\n<details><summary>代码</summary><p>\n\n\n```cpp\nconst int S=1000005,V=26; // 字符串最大长度，字符集大小\n\nstruct SAM\n{\n\tint tot,lst;\n\tint len[S*2],to[S*2][V],link[S*2]; // 记得开两倍\n\tinline void init() // 初始化\n\t{\n\t\tfor(int i=0;i<=tot;i++)\n\t\t{\n\t\t\tlen[i]=link[i]=0;\n\t\t\tmemset(to[i],0,sizeof(to[i]));\n\t\t}\n\t\ttot=lst=0;\n\t\tlink[0]=-1; // 记得让 link(rt)=-1\n\t}\n\tinline void ins(int c) // 在末尾插入一个字符\n\t{\n        // 新建状态（第 1、2 步）\n\t\tint pre=++tot;\n\t\tlen[pre]=len[lst]+1;\n        // 处理到 pre 的转移（第 3 步）\n\t\tint p=lst;\n\t\twhile(p!=-1&&to[p][c]==0) to[p][c]=pre,p=link[p];\n\t\tif(p==-1) link[pre]=0; // 第 4 步\n\t\telse\n\t\t{\n\t\t\tint q=to[p][c]; // 第 5 步\n\t\t\tif(len[q]==len[p]+1) link[pre]=q; // 无需分裂（第 6 步）\n\t\t\telse // 分裂状态 q（第 7 步）\n            {\n                // 复制 q 到新状态 cpy，令 link(pre)=cpy（7.1、7.2）\n\t\t\t\tint cpy=++tot;\n\t\t\t\tlen[cpy]=len[p]+1;\n\t\t\t\tmemcpy(to[cpy],to[q],sizeof(to[q]));\n\t\t\t\tlink[cpy]=link[q];\n\t\t\t\tlink[pre]=cpy;\n                // 处理到 cpy 的转移（7.3）\n\t\t\t\twhile(p!=-1&&to[p][c]==q) to[p][c]=cpy,p=link[p];\n\t\t\t\tlink[q]=cpy; // 令 link(q)=cpy（7.4）\n\t\t\t}\n\t\t}\n\t\tlst=pre; // 第 8 步\n\t}\n};\n```\n</p></details>\n\n## 一些额外信息的求解\n\n值得注意的是，这些信息的求解的时间复杂度均为 $O(n)$。\n\n- 结束标记\n\n  只需要在构建完 SAM 后，从 $lst$ 出发不断跳 $\\operatorname{link}$，把经过的状态全都打上标记即可。\n\n- 建立后缀树\n\n  只需要在构建完 SAM 后，对于所有 $1\\le u$ 的 $u$，在 $\\operatorname{link}(u)$ 的儿子列表中加入 $u$ 即可。\n\n- 两个子串的最长公共后缀\n\n  找到这两个子串所属的状态 $x,y$，它们的最长公共后缀所属的状态 $z$ 即为 $x,y$ 在后缀树上的 $\\operatorname{LCA}$。\n\n- $|\\operatorname{E}(u)|$（每个节点对应的等价类中的字符串个数）\n\n  由于引理 3，$|\\operatorname{E}(u)|$ 即为 $\\operatorname{len}(u)-\\operatorname{len}(\\operatorname{link}(u))$。\n\n- $siz_u=|\\operatorname{endpos}(s)|,s\\in\\operatorname{E}(u)$（每个节点对应的等价类中的字符串出现的次数）\n\n  构建 SAM 时让 $siz_{pre}=1$，注意到这样标记的实际上是 $S$ 的每个前缀，一个子串的出现次数等于它是多少个前缀的后缀，所以构建完成后只需要在后缀树上求一次子树 $siz$ 和即可。\n  \n  注意复制节点的时候无需复制 $siz$，因为一个等价类中最长的那个字符串才有可能是 $S$ 的前缀，而这个最长的字符串一定在分裂之后的 $E(q)$ 中。\n\n  <details><summary>代码</summary><p>\n  \n  ```cpp\n  const int S=1000005,V=26;\n  \n  struct SAM\n  {\n  \tint tot,lst;\n  \tint len[S*2],to[S*2][V],link[S*2];\n  \tvector<int> son[S*2]; // 后缀树中每个状态的儿子\n  \tint siz[S*2]; // 每个状态代表的等价类中每个字符串出现了几次\n  \tinline void init() // 初始化\n  \t{\n  \t\tfor(int i=0;i<=tot;i++)\n  \t\t{\n  \t\t\tlen[i]=link[i]=siz[i]=0;\n  \t\t\tmemset(to[i],0,sizeof(to[i]));\n  \t\t\tson[i].clear();\n  \t\t}\n  \t\ttot=lst=0;\n  \t\tlink[0]=-1;\n  \t}\n  \tinline void ins(int c) // 在末尾插入一个字符\n  \t{\n  \t\tint pre=++tot;\n  \t\tlen[pre]=len[lst]+1;\n  \t\tsiz[pre]=1; // 标记\n  \t\tint p=lst;\n  \t\twhile(p!=-1&&to[p][c]==0) to[p][c]=pre,p=link[p];\n  \t\tif(p==-1) link[pre]=0;\n  \t\telse\n  \t\t{\n  \t\t\tint q=to[p][c];\n  \t\t\tif(len[q]==len[p]+1) link[pre]=q;\n  \t\t\telse\n  \t\t\t{\n  \t\t\t\tint cpy=++tot;\n  \t\t\t\tlen[cpy]=len[p]+1;\n  \t\t\t\tmemcpy(to[cpy],to[q],sizeof(to[q]));\n  \t\t\t\tlink[cpy]=link[q];\n  \t\t\t\tlink[pre]=cpy;\n  \t\t\t\twhile(p!=-1&&to[p][c]==q) to[p][c]=cpy,p=link[p];\n  \t\t\t\tlink[q]=cpy;\n  \t\t\t}\n  \t\t}\n  \t\tlst=pre;\n  \t}\n  \tinline void build() // 建后缀树\n  \t{\n  \t\tfor(int i=1;i<=tot;i++) son[link[i]].push_back(i);\n  \t}\n  \tvoid getsiz(int u=0) // dfs 求子树和\n  \t{\n  \t\tfor(int v:son[u])\n  \t\t{\n  \t\t\tgetsiz(v);\n  \t\t\tsiz[u]+=siz[v];\n  \t\t}\n  \t}\n  };\n  ```\n  </p></details>\n  \n- $mnr_u=\\min\\limits_{v\\in \\operatorname{endpos}(s),s\\in\\operatorname{E}(u)} v$（每个节点对应的等价类中的字符串的最早出现的右端点）\n\n  和 $siz_u$ 一样，构建时每个前缀的 $mnr$ 就是这个前缀的长度，构建完后在后缀树上求子树 $\\min$ 即可。\n\n## 经典例题\n\n### [P3804 【模板】后缀自动机 (SAM)](https://www.luogu.com.cn/problem/P3804)\n\n注意到状态 $u$ 下的所有字符串出现次数均为 $siz_u$，显然选最长的最优，那么求出 $siz$ 后对所有 $siz_u>1$ 的 $u$ 的 $len_u\\times siz_u$ 取 $\\max$ 即可。\n\n<details><summary>代码</summary><p>\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nconst int S=1000005,V=26;\n\nstruct SAM\n{\n\tint tot,lst;\n\tint len[S*2],to[S*2][V],link[S*2];\n\tvector<int> son[S*2];\n\tint siz[S*2];\n\tinline void init()\n\t{\n\t\tfor(int i=0;i<=tot;i++)\n\t\t{\n\t\t\tlen[i]=link[i]=siz[i]=0;\n\t\t\tmemset(to[i],0,sizeof(to[i]));\n\t\t\tson[i].clear();\n\t\t}\n\t\ttot=lst=0;\n\t\tlink[0]=-1;\n\t}\n\tinline void ins(int c)\n\t{\n\t\tint pre=++tot;\n\t\tlen[pre]=len[lst]+1;\n\t\tsiz[pre]=1;\n\t\tint p=lst;\n\t\twhile(p!=-1&&to[p][c]==0) to[p][c]=pre,p=link[p];\n\t\tif(p==-1) link[pre]=0;\n\t\telse\n\t\t{\n\t\t\tint q=to[p][c];\n\t\t\tif(len[q]==len[p]+1) link[pre]=q;\n\t\t\telse\n\t\t\t{\n\t\t\t\tint cpy=++tot;\n\t\t\t\tlen[cpy]=len[p]+1;\n\t\t\t\tmemcpy(to[cpy],to[q],sizeof(to[q]));\n\t\t\t\tlink[cpy]=link[q];\n\t\t\t\tlink[pre]=cpy;\n\t\t\t\twhile(p!=-1&&to[p][c]==q) to[p][c]=cpy,p=link[p];\n\t\t\t\tlink[q]=cpy;\n\t\t\t}\n\t\t}\n\t\tlst=pre;\n\t}\n\tinline void build()\n\t{\n\t\tfor(int i=1;i<=tot;i++) son[link[i]].push_back(i);\n\t}\n\tvoid getsiz(int u=0)\n\t{\n\t\tfor(int v:son[u])\n\t\t{\n\t\t\tgetsiz(v);\n\t\t\tsiz[u]+=siz[v];\n\t\t}\n\t}\n};\n\nint n;\nchar a[S];\nSAM sam;\n\nint main()\n{\n\tscanf(\"%s\",a+1);\n\tn=strlen(a+1);\n\tsam.init();\n\tfor(int i=1;i<=n;i++) sam.ins(a[i]-'a');\n\tsam.build();\n\tsam.getsiz();\n\tlong long ans=0;\n\tfor(int i=0;i<=sam.tot;i++) if(sam.siz[i]>1) ans=max(ans,1ll*sam.len[i]*sam.siz[i]);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n```\n</p></details>\n\n### [P4070 [SDOI2016]生成魔咒](https://www.luogu.com.cn/problem/P4070)\n\n考虑新加入的字符会产生多少个新的非空子串，设加入新字符之前的长度为 $lstlen$，那么只有 $\\operatorname{endpos}'(\\{lstlen+1\\})$ 中的字符串是新的非空子串。\n\n考虑哪个状态代表的等价类是 $\\operatorname{endpos}'(\\{lstlen+1\\})$，显然只有新加入的状态 $pre$ 是。$pre$ 中的字符串个数很好求，即为 $\\operatorname{len}(pre)-\\operatorname{len}(\\operatorname{link}(pre))$。\n\n那么每次让答案累加上 $\\operatorname{len}(pre)-\\operatorname{len}(\\operatorname{link}(pre))$ 即可。\n\n<details><summary>代码</summary><p>\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <map>\n\nusing namespace std;\n\nconst int S=100005;\n\nstruct SAM\n{\n\tint tot,len[S*2],link[S*2];\n\tmap<int,int> to[S*2];\n\tint lst;\n\tinline void init()\n\t{\n\t\tfor(int i=0;i<=tot;i++) len[i]=link[i]=0,to[i].clear();\n\t\tlink[0]=-1;\n\t}\n\tinline void ins(int c)\n\t{\n\t\tint pre=++tot;\n\t\tlen[pre]=len[lst]+1;\n\t\tint p=lst;\n\t\twhile(p!=-1&&to[p].find(c)==to[p].end()) to[p][c]=pre,p=link[p];\n\t\tif(p==-1) link[pre]=0;\n\t\telse\n\t\t{\n\t\t\tint q=to[p][c];\n\t\t\tif(len[q]==len[p]+1) link[pre]=q;\n\t\t\telse\n\t\t\t{\n\t\t\t\tint cpy=++tot;\n\t\t\t\tlen[cpy]=len[p]+1;\n\t\t\t\tto[cpy]=to[q],link[cpy]=link[q];\n\t\t\t\tlink[pre]=cpy;\n\t\t\t\twhile(p!=-1&&to[p][c]==q) to[p][c]=cpy,p=link[p];\n\t\t\t\tlink[q]=cpy;\n\t\t\t}\n\t\t}\n\t\tlst=pre;\n\t}\n};\n\nSAM sam;\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tsam.init();\n\tlong long ans=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tsam.ins(x);\n\t\tans+=sam.len[sam.lst]-sam.len[sam.link[sam.lst]];\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n}\n```\n</p></details>\n\n### [P3975 [TJOI2015]弦论](https://www.luogu.com.cn/problem/P3975)\n\n双倍经验：[SP7258 SUBLEX - Lexicographical Substring Search](https://www.luogu.com.cn/problem/SP7258)\n\n原串 $S$ 的每个子串都能表示为从 $rt$ 到某个状态的路径，那么在 SAM 的反 DAG 上跑一边 bfs，求出每个状态出发有多少个子串，然后逐位确定即可。\n\n如果 $k=1$ 每个状态的权值就是 $siz_u$，否则就是 $1$。\n\n<details><summary>代码</summary><p>\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nconst int S=500005,V=26;\n\nstruct SAM\n{\n\tint tot;\n\tint len[S*2],to[S*2][V],link[S*2];\n\tvector<int> son[S*2];\n\tint siz[S*2];\n\tint lst;\n\tinline void init()\n\t{\n\t\tfor(int i=0;i<=tot;i++)\n\t\t{\n\t\t\tlen[i]=link[i]=siz[i]=0;\n\t\t\tmemset(to[i],0,sizeof(to[i]));\n\t\t\tson[i].clear();\n\t\t}\n\t\ttot=lst=0;\n\t\tlink[0]=-1;\n\t}\n\tinline void ins(int c)\n\t{\n\t\tint pre=++tot;\n\t\tlen[pre]=len[lst]+1;\n\t\tsiz[pre]=1;\n\t\tint p=lst;\n\t\twhile(p!=-1&&to[p][c]==0) to[p][c]=pre,p=link[p];\n\t\tif(p==-1) link[pre]=0;\n\t\telse\n\t\t{\n\t\t\tint q=to[p][c];\n\t\t\tif(len[q]==len[p]+1) link[pre]=q;\n\t\t\telse\n\t\t\t{\n\t\t\t\tint cpy=++tot;\n\t\t\t\tlen[cpy]=len[p]+1;\n\t\t\t\tmemcpy(to[cpy],to[q],sizeof(to[q]));\n\t\t\t\tlink[cpy]=link[q];\n\t\t\t\tlink[pre]=cpy;\n\t\t\t\twhile(p!=-1&&to[p][c]==q) to[p][c]=cpy,p=link[p];\n\t\t\t\tlink[q]=cpy;\n\t\t\t}\n\t\t}\n\t\tlst=pre;\n\t}\n\tinline void build()\n\t{\n\t\tfor(int i=1;i<=tot;i++) son[link[i]].push_back(i);\n\t}\n\tvoid getsiz(int u=0)\n\t{\n\t\tfor(int v:son[u])\n\t\t{\n\t\t\tgetsiz(v);\n\t\t\tsiz[u]+=siz[v];\n\t\t}\n\t}\n};\n\nint n,t;\nlong long k;\nchar a[S];\nSAM sam;\nvector<int> to[S*2];\nint ind[S*2];\nlong long cnt[S*2];\n\nint main()\n{\n\tscanf(\"%s\",a+1);\n\tn=strlen(a+1);\n\tscanf(\"%d%lld\",&t,&k);\n\tsam.init();\n\tfor(int i=1;i<=n;i++) sam.ins(a[i]-'a');\n\tsam.build();\n\tsam.getsiz();\n\tfor(int i=0;i<=sam.tot;i++)\n\t{\n\t\tfor(int j=0;j<V;j++)\n\t\t{\n\t\t\tint v=sam.to[i][j];\n\t\t\tif(v!=0) to[v].push_back(i),ind[i]++;\n\t\t}\n\t}\n\tqueue<int> q;\n\tfor(int i=0;i<=sam.tot;i++)\n\t{\n\t\tcnt[i]=t?sam.siz[i]:1;\n\t\tif(ind[i]==0) q.push(i);\n\t}\n\tcnt[0]=0;\n\twhile(!q.empty())\n\t{\n\t\tint u=q.front();\n\t\tq.pop();\n\t\tfor(int v:to[u])\n\t\t{\n\t\t\tcnt[v]+=cnt[u];\n\t\t\tif(--ind[v]==0) q.push(v);\n\t\t}\n\t}\n\tif(k>cnt[0]) return puts(\"-1\"),0;\n\tint u=0;\n\twhile(k>0)\n\t{\n\t\tfor(int i=0;i<V;i++)\n\t\t{\n\t\t\tint v=sam.to[u][i];\n\t\t\tif(v==0) continue;\n\t\t\tif(cnt[v]<k) k-=cnt[v];\n\t\t\telse\n\t\t\t{\n\t\t\t\tk-=t?sam.siz[v]:1;\n\t\t\t\tprintf(\"%c\",'a'+i);\n\t\t\t\tu=v;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n```\n</p></details>\n\n### [P4248 [AHOI2013]差异](https://www.luogu.com.cn/problem/P4248)\n\n建反串的 SAM，在后缀树上 dp 即可。\n\n### [SP1811 LCS - Longest Common Substring](https://www.luogu.com.cn/problem/SP1811)\n\n对于这种多个字符串的问题，通常是要用广义 SAM 来做，但是这里介绍一种“伪广义 SAM”。\n\n考虑把输入的两个字符串 $A$ 和 $B$ 在中间加入一个分隔符 `#` 后拼接起来加入 SAM，即 $A+\\#+B$ 这样。加入的过程中若当前字符属于 $A$ 则给加入后 $S$ 对应的状态打上 $A$ 标记，否则打上 $B$ 标记，最后在后缀树上让每个点的标记都贡献到它的祖先上。\n\n这样一来所有同时被打上 $A$ 和 $B$ 标记的状态中的字符串都是 $A$ 和 $B$ 的公共子串，那么统计这些状态的 $\\operatorname{len}$ 的最大值即可。\n\n[SP1812 LCS2 - Longest Common Substring II](https://www.luogu.com.cn/problem/SP1812) 这题也类似，不过要注意分隔符要两两不同，要不然带分隔符的子串可能也会被打上标记。\n\n<details><summary>代码</summary><p>\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n\nusing namespace std;\n\nconst int S=500005,V=27;\n\nstruct SAM\n{\n\tint tot;\n\tint len[S*2],to[S*2][V],link[S*2];\n\tvector<int> son[S*2];\n\tbool app[2][S*2];\n\tint lst;\n\tinline void init()\n\t{\n\t\tfor(int i=0;i<=tot;i++)\n\t\t{\n\t\t\tlen[i]=link[i]=0;\n\t\t\tmemset(to[i],0,sizeof(to[i]));\n\t\t\tapp[0][i]=app[1][i]=false;\n\t\t\tson[i].clear();\n\t\t}\n\t\ttot=lst=0;\n\t\tlink[0]=-1;\n\t}\n\tinline void ins(int c,int tpe)\n\t{\n\t\tint pre=++tot;\n\t\tlen[pre]=len[lst]+1;\n\t\tapp[tpe][pre]=true;\n\t\tint p=lst;\n\t\twhile(p!=-1&&to[p][c]==0) to[p][c]=pre,p=link[p];\n\t\tif(p==-1) link[pre]=0;\n\t\telse\n\t\t{\n\t\t\tint q=to[p][c];\n\t\t\tif(len[q]==len[p]+1) link[pre]=q;\n\t\t\telse\n\t\t\t{\n\t\t\t\tint cpy=++tot;\n\t\t\t\tlen[cpy]=len[p]+1;\n\t\t\t\tmemcpy(to[cpy],to[q],sizeof(to[q]));\n\t\t\t\tlink[cpy]=link[q];\n\t\t\t\tlink[pre]=cpy;\n\t\t\t\twhile(p!=-1&&to[p][c]==q) to[p][c]=cpy,p=link[p];\n\t\t\t\tlink[q]=cpy;\n\t\t\t}\n\t\t}\n\t\tlst=pre;\n\t}\n\tinline void build()\n\t{\n\t\tfor(int i=1;i<=tot;i++) son[link[i]].push_back(i);\n\t}\n\tinline void calctag(int u=0)\n\t{\n\t\tfor(int v:son[u])\n\t\t{\n\t\t\tcalctag(v);\n\t\t\tfor(int i=0;i<=1;i++) app[i][u]|=app[i][v];\n\t\t}\n\t}\n};\n\nint n,m;\nchar a[S],b[S];\nSAM sam;\n\nint main()\n{\n\tscanf(\"%s%s\",a+1,b+1);\n\tn=strlen(a+1),m=strlen(b+1);\n\tsam.init();\n\tfor(int i=1;i<=n;i++) sam.ins(a[i]-'a',0);\n\tsam.ins(26,1);\n\tfor(int i=1;i<=m;i++) sam.ins(b[i]-'a',1);\n\tsam.build();\n\tsam.calctag();\n\tint ans=0;\n\tfor(int i=0;i<=sam.tot;i++) if(sam.app[0][i]&&sam.app[1][i]) ans=max(ans,sam.len[i]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n</p></details>\n\n### [P3649 [APIO2014] 回文串](https://www.luogu.com.cn/problem/P3649)\n\n有两种做法。\n\n- Manacher + SAM\n\n  前置知识：[Manacher](https://www.luogu.com.cn/blog/251130/manacher-suan-fa-xue-xi-bi-ji)。\n\n  由于 $S$ 的本质不同回文子串个数上限是 $|S|$，所以可以建出 SAM 之后跑 Manacher 找到每个本质不同回文子串 $S_{[l_i,r_i]}$，再从 $S_{[1,r_i]}$ 这个前缀对应的状态开始倍增跳 $\\operatorname{link}$ 找到 $S_{[l_i,r_i]}$ 对应的等价类并统计答案。\n  \n  时间复杂度 $O(n\\log n)$。\n  \n- SAM\n\n  建 SAM 时维护每个状态中的字符串的最后出现位置 $mx_u$，建完 SAM 后在 SAM 上跑反串 $S'$ 和 $S$ 的所有子串的匹配。假设跑到 $S'_{[1,n-l+1]}$ 时匹配到了状态 $u$，匹配长度为 $len$。那么若 $mx_u\\in[l,l+len-1]$：\n\n  ![](../post-images/1681531539397.png)\n\n  此时绿色部分 $S_{[l,mx_u]}$ 一定是回文串，并且它的出现次数一定是 $siz_u$ 即状态 $u$ 中的每个字符串出现的次数。\n\n  只统计 $S_{[l,mx_u]}$ 是不够全面的，还需要不断跳 $u$ 的 $\\operatorname{link}$ 直到 $mx_u\\notin [l,l+len-1]$ 或 $\\operatorname{len}(u)< mx_u-l+1$，因为这些状态中的字符串 $S_{[l,mx_u]}$ 也是回文串。\n\n  注意到 $mx$ 一样的 $u$ 只有 $\\operatorname{len}(u)$ 最小的才会有贡献，所以可以用倍增跳 $\\operatorname{link}$。\n  \n  不难发现一个子串只会被统计一次，所以时间复杂度即为 $O(n\\log n)$。\n  \n  另外似乎还有一种做法即跳 $\\operatorname{link}$ 时给跳过的状态打上标记，下一次不跳。这种做法时间复杂度是 $O(n)$ 的，但是正确性不是很显然。\n\n虽然第二种做法很难写，但是可以增加对 SAM 的理解。所以我写了第二种做法，然后 BZOJ 过了洛谷一直 MLE……\n\n<details><summary>代码（第二种做法）</summary><p>\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <map>\n\nusing namespace std;\n\nconst int S=300001,V=26,BS=20;\n\nstruct SAM\n{\n\tint tot;\n\tint len[S*2],link[S*2];\n\tmap<char,int> to[S*2];\n\tvector<int> son[S*2];\n\tint siz[S*2],mx[S*2];\n\tvector<int> fa[S*2];\n\tint lst;\n\tinline void init()\n\t{\n\t\tfor(int i=0;i<=tot;i++)\n\t\t{\n\t\t\tlen[i]=link[i]=siz[i]=mx[i]=0;\n\t\t\tto[i].clear();\n\t\t\tson[i].clear();\n\t\t\tfa[i].clear();\n\t\t}\n\t\tlink[0]=-1;\n\t\ttot=lst=0;\n\t}\n\tinline void ins(int c,int pp)\n\t{\n\t\tint pre=++tot;\n\t\tlen[pre]=len[lst]+1;\n\t\tsiz[pre]=1,mx[pre]=pp;\n\t\tint p=lst;\n\t\twhile(p!=-1&&to[p][c]==0) to[p][c]=pre,p=link[p];\n\t\tif(p==-1) link[pre]=0;\n\t\telse\n\t\t{\n\t\t\tint q=to[p][c];\n\t\t\tif(len[q]==len[p]+1) link[pre]=q;\n\t\t\telse\n\t\t\t{\n\t\t\t\tint cpy=++tot;\n\t\t\t\tlen[cpy]=len[p]+1;\n\t\t\t\tto[cpy]=to[q];\n\t\t\t\tlink[cpy]=link[q];\n\t\t\t\tlink[pre]=cpy;\n\t\t\t\twhile(p!=-1&&to[p][c]==q) to[p][c]=cpy,p=link[p];\n\t\t\t\tlink[q]=cpy;\n\t\t\t}\n\t\t}\n\t\tlst=pre;\n\t}\n\tinline void build()\n\t{\n\t\tfor(int i=1;i<=tot;i++) son[link[i]].push_back(i);\n\t}\n\tvoid dfs(int u=0)\n\t{\n\t\tif(u!=0)\n\t\t{\n\t\t\tfa[u].push_back(link[u]);\n\t\t\tfor(int i=1;i<=BS;i++)\n\t\t\t{\n\t\t\t\tif(fa[u][i-1]==-1) break;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tint fat=fa[u][i-1];\n\t\t\t\t\tif(fa[fat].size()<=i-1) break;\n\t\t\t\t\telse fa[u][i]=fa[fat][i-1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int v:son[u])\n\t\t{\n\t\t\tdfs(v);\n\t\t\tsiz[u]+=siz[v],mx[u]=max(mx[u],mx[v]);\n\t\t}\n\t\tvector<int>().swap(son[u]); // 释放 vector 空间\n\t}\n};\n\nint n;\nchar a[S];\nSAM sam;\n\nint main()\n{\n\tscanf(\"%s\",a);\n\tn=strlen(a);\n\tsam.init();\n\tfor(int i=0;i<n;i++) sam.ins(a[i]-'a',i);\n\tsam.build();\n\tsam.dfs();\n\tint u=0,len=0;\n\tlong long ans=0;\n\tfor(int i=n-1;i>=0;i--)\n\t{\n\t\twhile(u!=-1&&sam.to[u][a[i]-'a']==0)\n\t\t{\n\t\t\tu=sam.link[u];\n\t\t\tif(u!=-1) len=sam.len[u];\n\t\t}\n\t\tif(u==-1) u=0,len=0;\n\t\telse u=sam.to[u][a[i]-'a'],len++;\n\t\tint r=i+len-1,v=u;\n\t\twhile(sam.mx[v]<=r&&sam.len[v]>=sam.mx[v]-i+1)\n\t\t{\n\t\t\tfor(int j=BS;j>=0;j--)\n\t\t\t{\n\t\t\t\tif(sam.fa[v].size()>j&&sam.mx[sam.fa[v][j]]==sam.mx[v]&&sam.len[sam.fa[v][j]]>=sam.mx[v]-i+1) v=sam.fa[v][j];\n\t\t\t}\n\t\t\tif(sam.mx[v]>=i) ans=max(ans,1ll*(sam.mx[v]-i+1)*sam.siz[v]);\n\t\t\tif(sam.fa[v].size()>0) v=sam.fa[v][0];\n\t\t\telse break;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n```\n</p></details>\n\n### [P5685 [JSOI2013]快乐的 JYY](https://www.luogu.com.cn/problem/P5685)\n\n双倍经验：[P5555 秩序魔咒](https://www.luogu.com.cn/problem/P5685)\n\n和上一题差不多，建完“伪广义” SAM 之后跑 manacher+哈希求出 $A$ 的所有本质不同的回文子串 $[l,r]$，然后找到 $A_{[1,r]}$ 即前缀 $r$ 对应的 SAM 上的状态，倍增找到 $A_{[l,r]}$ 所在的状态，然后统计答案即可。\n\n<details><summary>代码</summary><p>\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nconst int S=100005,V=27,BS=25,bse=31,p1=998244353,p2=1000000007;\n\nstruct SAM\n{\n\tint tot;\n\tint len[S*4],to[S*4][V],link[S*4];\n\tvector<int> suf,son[S*4];\n\tint siz[2][S*4];\n\tint fa[S*4][BS+1];\n\tint lst;\n\tinline void init()\n\t{\n\t\tfor(int i=0;i<=tot;i++)\n\t\t{\n\t\t\tlen[i]=link[i]=siz[0][i]=siz[1][i]=0;\n\t\t\tmemset(to[i],0,sizeof(to[i]));\n\t\t\tvector<int>().swap(son[i]);\n\t\t}\n\t\tvector<int>().swap(suf);\n\t\ttot=lst=0;\n\t\tlink[0]=-1;\n\t\tsuf.push_back(0);\n\t}\n\tinline void ins(int c,int tpe)\n\t{\n\t\tint pre=++tot;\n\t\tlen[pre]=len[lst]+1;\n\t\tsuf.push_back(pre);\n\t\tsiz[tpe][pre]=1;\n\t\tint p=lst;\n\t\twhile(p!=-1&&to[p][c]==0) to[p][c]=pre,p=link[p];\n\t\tif(p==-1) link[pre]=0;\n\t\telse\n\t\t{\n\t\t\tint q=to[p][c];\n\t\t\tif(len[q]==len[p]+1) link[pre]=q;\n\t\t\telse\n\t\t\t{\n\t\t\t\tint cpy=++tot;\n\t\t\t\tlen[cpy]=len[p]+1;\n\t\t\t\tmemcpy(to[cpy],to[q],sizeof(to[q]));\n\t\t\t\tlink[cpy]=link[q];\n\t\t\t\tlink[pre]=cpy;\n\t\t\t\twhile(p!=-1&&to[p][c]==q) to[p][c]=cpy,p=link[p];\n\t\t\t\tlink[q]=cpy;\n\t\t\t}\n\t\t}\n\t\tlst=pre;\n\t}\n\tinline void build()\n\t{\n\t\tfor(int i=1;i<=tot;i++) son[link[i]].push_back(i);\n\t}\n\tvoid calctag(int u=0)\n\t{\n\t\tfa[u][0]=link[u];\n\t\tfor(int i=1;i<=BS;i++)\n\t\t{\n\t\t\tint tp=fa[u][i-1];\n\t\t\tif(tp==-1) fa[u][i]=-1;\n\t\t\telse fa[u][i]=fa[tp][i-1];\n\t\t}\n\t\tfor(int v:son[u])\n\t\t{\n\t\t\tcalctag(v);\n\t\t\tfor(int j=0;j<=1;j++) siz[j][u]+=siz[j][v];\n\t\t}\n\t}\n};\n\nint n,m;\nchar a[S],b[S];\nSAM sam;\nchar str[S*2];\nint ext[S*2];\nint pw1[S],pw2[S];\nint s1[S],s2[S];\nset<pair<int,int>> st;\n\ninline pair<int,int> calchash(int l,int r)\n{\n\treturn make_pair(\n\t(s1[r]-1ll*s1[l-1]*pw1[r-l+1]%p1+p1)%p1,\n\t(s2[r]-1ll*s2[l-1]*pw2[r-l+1]%p2+p2)%p2);\n}\n\nint main()\n{\n\tscanf(\"%s%s\",a+1,b+1);\n\tsam.init();\n\tn=strlen(a+1),m=strlen(b+1);\n\tfor(int i=1;i<=n;i++) sam.ins(a[i]-'A',0);\n\tsam.ins(26,1);\n\tfor(int i=1;i<=m;i++) sam.ins(b[i]-'A',1);\n\tsam.build();\n\tsam.calctag();\n\tpw1[0]=1,pw2[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tpw1[i]=1ll*pw1[i-1]*bse%p1;\n\t\tpw2[i]=1ll*pw2[i-1]*bse%p2;\n\t\ts1[i]=(1ll*s1[i-1]*bse%p1+a[i]-'A'+1)%p1;\n\t\ts2[i]=(1ll*s2[i-1]*bse%p2+a[i]-'A'+1)%p2;\n\t}\n\tfor(int i=1;i<=n;i++) str[i*2]=a[i];\n\tn=n*2+1;\n\tfor(int i=1;i<=n;i+=2) str[i]='#';\n\tstr[0]='@',str[n+1]='$';\n\tlong long ans=0;\n\tfor(int i=1,pos=0;i<=n;i++)\n\t{\n\t\tif(pos+ext[pos]>i) ext[i]=min(pos+ext[pos]-i,ext[pos-(i-pos)]);\n\t\twhile(str[i-ext[i]]==str[i+ext[i]])\n\t\t{\n\t\t\text[i]++;\n\t\t\tif(str[i-ext[i]+1]=='#'&&ext[i]>1)\n\t\t\t{\n\t\t\t\tint len=ext[i]-1;\n\t\t\t\tint rb=i/2+len/2;\n\t\t\t\tpair<int,int> pir=calchash(rb-len+1,rb);\n\t\t\t\tif(st.count(pir)==0)\n\t\t\t\t{\n\t\t\t\t\tst.insert(pir);\n\t\t\t\t\tint u=sam.suf[rb];\n\t\t\t\t\tif(sam.len[sam.link[u]]+1>len)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int j=BS;j>=0;j--)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint to=sam.fa[u][j];\n\t\t\t\t\t\t\tif(to!=-1&&sam.link[to]!=-1&&sam.len[sam.link[to]]+1>len) u=to;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tu=sam.fa[u][0];\n\t\t\t\t\t}\n\t\t\t\t\tans+=1ll*sam.siz[0][u]*sam.siz[1][u];\n//\t\t\t\t\tfor(int j=rb-len+1;j<=rb;j++) printf(\"%c\",a[j]);\n//\t\t\t\t\tprintf(\" : %d * %d\\n\",sam.siz[0][u],sam.siz[1][u]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(i+ext[i]>pos+ext[pos]) pos=i;\n\t\t\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n```\n</p></details>\n",
			"tags": [{"name":"学习笔记"},{"name":"字符串"},{"name":"数据结构"}],
			"title": "SAM（后缀自动机）学习笔记",
			"link": "https://exber.qzz.io/post/SAM%EF%BC%88%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%EF%BC%89%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-04-15 12:04:09"
		},
	
		{
			"abstract": "> 题目链接：[UniversalOJ 228 基础数据结构练习题](https://vjudge.csgrandeur.cn/problem/UniversalOJ-228)\n> \n> 你需要维护一个数据结构，支持以下三种操作：\n>\n> - `1 l r k` 给 $i\\in[l,r]$ 的所有 $a_i$ 加上 $k$；\n> - `2 l r` 对于 $i\\in[l,r]$ 的所有 $a_i$，令其变为 $\\lfloor\\sqrt a_i\\rfloor$；\n> - `3 l r` 查询 $\\sum\\limits_{i=l}^r a_i$；\n>\n> 序列长度为 $n$，操作次数为 $q$，值域为 $V$。\n>\n> $1\\le n,q\\le 10^5$，$1\\le V\\le 10^9$。\n",
			"content": "> 题目链接：[UniversalOJ 228 基础数据结构练习题](https://vjudge.csgrandeur.cn/problem/UniversalOJ-228)\n> \n> 你需要维护一个数据结构，支持以下三种操作：\n>\n> - `1 l r k` 给 $i\\in[l,r]$ 的所有 $a_i$ 加上 $k$；\n> - `2 l r` 对于 $i\\in[l,r]$ 的所有 $a_i$，令其变为 $\\lfloor\\sqrt a_i\\rfloor$；\n> - `3 l r` 查询 $\\sum\\limits_{i=l}^r a_i$；\n>\n> 序列长度为 $n$，操作次数为 $q$，值域为 $V$。\n>\n> $1\\le n,q\\le 10^5$，$1\\le V\\le 10^9$。\n\n\n不难发现，$\\left\\lfloor\\sqrt{\\left\\lfloor\\sqrt{\\left\\lfloor\\sqrt{\\left\\lfloor\\sqrt{\\left\\lfloor\\sqrt{10^9}\\right\\rfloor}\\right\\rfloor}\\right\\rfloor}\\right\\rfloor}\\right\\rfloor=1$，也就是说，值域内一个数变为 $1$ 所需的开根次数可以看作是一个很小的常数。这样若没有区间加操作，我们就可以每次暴力找到区间内非 $1$ 的数，暴力地一个一个处理，这就是 [P4145 上帝造题的七分钟 2 / 花神游历各国](https://www.luogu.com.cn/problem/P4145) 的做法。\n\n但是本题有了区间加操作，这使得直接暴力找的时间复杂度退化为 $O(qn)$。但是考虑到因为 $a-b=(\\sqrt a - \\sqrt b)(\\sqrt a+\\sqrt b)$，所以开一次根至少会让区间极差变为之前的一半，而当开根退化为区间减的时候就可以快速维护了。\n\n考虑一次区间加对时间复杂度的贡献，由于 $[l,r]$ 操作只会影响到包含 $l$ 和包含 $r$ 的 $O(\\log n)$ 个区间，每个区间至多增加 $O(\\log V)$，所以时间复杂度为 $O(q\\log n\\log V)$，足以通过本题。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\nconst int S=100005;\n\nint n,m;\nlong long a[S];\nlong long mn[S<<2],mx[S<<2],sm[S<<2],tg[S<<2];\n\ninline void upd(int u)\n{\n\tmn[u]=min(mn[u<<1],mn[u<<1|1]);\n\tmx[u]=max(mx[u<<1],mx[u<<1|1]);\n\tsm[u]=sm[u<<1]+sm[u<<1|1];\n}\n\ninline void adtg(int u,int l,int r,long long val)\n{\n\tmn[u]+=val;\n\tmx[u]+=val;\n\tsm[u]+=val*(r-l+1);\n\ttg[u]+=val;\n}\n\ninline void dwtg(int u,int l,int r)\n{\n\tint mid=l+r>>1;\n\tadtg(u<<1,l,mid,tg[u]),adtg(u<<1|1,mid+1,r,tg[u]);\n\ttg[u]=0;\n}\n\nvoid built(int u,int l,int r)\n{\n\ttg[u]=0;\n\tif(l==r) return mn[u]=mx[u]=sm[u]=a[l],void();\n\tint mid=l+r>>1;\n\tbuilt(u<<1,l,mid),built(u<<1|1,mid+1,r);\n\tupd(u);\n}\n\n\nvoid add(int u,int l,int r,int L,int R,long long val)\n{\n\tif(l>R||r<L) return;\n\tif(l>=L&&r<=R) return adtg(u,l,r,val);\n\tdwtg(u,l,r);\n\tint mid=l+r>>1;\n\tif(L<=mid) add(u<<1,l,mid,L,R,val);\n\tif(R>=mid+1) add(u<<1|1,mid+1,r,L,R,val);\n\tupd(u);\n}\n\nvoid updat(int u,int l,int r,int L,int R)\n{\n\tif(l>R||r<L) return;\n\tif(l>=L&&r<=R)\n\t{\n\t\tlong long mnd=mn[u]-(long long)sqrt(mn[u]),mxd=mx[u]-(long long)sqrt(mx[u]);\n\t\tif(mnd==mxd) adtg(u,l,r,-mnd);\n\t\telse\n\t\t{\n\t\t\tdwtg(u,l,r);\n\t\t\tint mid=l+r>>1;\n\t\t\tupdat(u<<1,l,mid,L,R),updat(u<<1|1,mid+1,r,L,R);\n\t\t\tupd(u);\n\t\t}\n\t\treturn;\n\t}\n\tdwtg(u,l,r);\n\tint mid=l+r>>1;\n\tif(L<=mid) updat(u<<1,l,mid,L,R);\n\tif(R>=mid+1) updat(u<<1|1,mid+1,r,L,R);\n\tupd(u);\n}\n\nlong long que(int u,int l,int r,int L,int R)\n{\n\tif(l>R||r<L) return 0;\n\tif(l>=L&&r<=R) return sm[u];\n\tdwtg(u,l,r);\n\tint mid=l+r>>1;\n\tlong long res=0;\n\tif(L<=mid) res+=que(u<<1,l,mid,L,R);\n\tif(R>=mid+1) res+=que(u<<1|1,mid+1,r,L,R);\n\treturn res;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++) scanf(\"%lld\",&a[i]);\n\tbuilt(1,1,n);\n\twhile(m--)\n\t{\n\t\tint op,l,r;\n\t\tscanf(\"%d%d%d\",&op,&l,&r);\n\t\tif(op==1)\n\t\t{\n\t\t\tlong long v;\n\t\t\tscanf(\"%lld\",&v);\n\t\t\tadd(1,1,n,l,r,v);\n\t\t}\n\t\telse if(op==2) updat(1,1,n,l,r);\n\t\telse printf(\"%lld\\n\",que(1,1,n,l,r));\n\t}\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"数据结构"},{"name":"结论"}],
			"title": "UniversalOJ 228 基础数据结构练习题 做题记录",
			"link": "https://exber.qzz.io/post/UniversalOJ%20228%20%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%83%E4%B9%A0%E9%A2%98%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-04-15 12:02:52"
		},
	
		{
			"abstract": "> Alice 和 Bob 在一棵 $n$ 个点的树上玩游戏，第 $i$ 个节点上有 $a_i$ 个石子，每轮可以选择一个深度至少为 $k$ 的节点并移动任意多石子到其 $k$ 级祖先处，对每个结点询问如果将其作为根谁会赢。\n> \n> $n\\le 10^5 , k\\le 20 , a_i\\le 10^9$。\n",
			"content": "> Alice 和 Bob 在一棵 $n$ 个点的树上玩游戏，第 $i$ 个节点上有 $a_i$ 个石子，每轮可以选择一个深度至少为 $k$ 的节点并移动任意多石子到其 $k$ 级祖先处，对每个结点询问如果将其作为根谁会赢。\n> \n> $n\\le 10^5 , k\\le 20 , a_i\\le 10^9$。\n\n首先不难发现 $k>1$ 相当于拆成了多棵树，那么考虑 $k=1$ 时一些特殊情况下先手必胜的条件：\n\n- 菊花：此时是经典的 Nim 游戏，先手必胜当且仅当 $\\oplus_{u\\not=root}a_u\\not=0$；\n- 链（其实就是阶梯 Nim 游戏）：把节点按照深度的奇偶性分成两类（根节点深度为 $0$），深度为奇数的叫奇节点，深度为偶数的叫偶节点。那么对偶节点进行操作是没用的，因为后手可以模仿先手的操作，把先手移去奇节点的石子都往前移到下一个偶节点，最后移到无法移动的根节点，先手还是先手。所以可以把在奇节点上的操作看作是丢掉了一些石子，那么先手必胜当且仅当 $\\oplus_{dep_u\\equiv 1\\pmod 2}a_u\\not=0$；\n\n考虑将链的情况推广一下，不难发现，对于任意一棵树，链情况的结论都成立。所以 $k=1$ 时先手必胜当且仅当 $\\oplus_{dep_u\\equiv 1\\pmod 2}a_u\\not=0$。\n\n对于 $k>1$ 的情况，拆成多棵 $k=1$ 的树做，先手必胜当且仅当 $\\oplus_{i\\in tree}\\oplus_{dep_{i,u}\\equiv 1\\pmod 2}a_{i,u}\\not=0$。\n\n简单换根 dp 即可。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=200005;\n\nint n,k;\nint a[S];\nint esum,to[S],nxt[S],h[S];\nint dp[S][25][2],pd[S][25][2],ans[S];\n\ninline void add(int x,int y)\n{\n\tto[++esum]=y;\n\tnxt[esum]=h[x];\n\th[x]=esum;\n}\n\nvoid dfs1(int u,int fa)\n{\n\tdp[u][0][1]=a[u];\n\tfor(int i=h[u];i;i=nxt[i])\n\t{\n\t\tint v=to[i];\n\t\tif(v==fa) continue;\n\t\tdfs1(v,u);\n\t\tdp[u][0][0]^=dp[v][k-1][1];\n\t\tdp[u][0][1]^=dp[v][k-1][0];\n\t\tfor(int j=1;j<k;j++)\n\t\t{\n\t\t\tdp[u][j][0]^=dp[v][j-1][0];\n\t\t\tdp[u][j][1]^=dp[v][j-1][1];\n\t\t}\n\t}\n}\n\nvoid dfs2(int u,int fa)\n{\n\tif(u==1)\n\t{\n\t\tfor(int i=0;i<k;i++) pd[u][i][0]=dp[u][i][0],pd[u][i][1]=dp[u][i][1];\n\t}\n\telse\n\t{\n\t\tpd[u][0][0]=pd[fa][k-1][1]^dp[u][(k-2+k)%k][k==1?0:1];\n\t\tpd[u][0][1]=pd[fa][k-1][0]^dp[u][(k-2+k)%k][k==1?1:0];\n\t\tfor(int i=1;i<k;i++)\n\t\t{\n\t\t\tpd[u][i][0]^=pd[fa][i-1][0]^dp[u][(i-2+k)%k][i==1?1:0];\n\t\t\tpd[u][i][1]^=pd[fa][i-1][1]^dp[u][(i-2+k)%k][i==1?0:1];\n\t\t}\n\t\tfor(int i=0;i<k;i++) pd[u][i][0]^=dp[u][i][0],pd[u][i][1]^=dp[u][i][1];\n\t}\n\tfor(int i=0;i<k;i++) ans[u]^=pd[u][i][0];\n//\tprintf(\"%d %d\\n\",pd[u][0][0],pd[u][0][1]);\n\tfor(int i=h[u];i;i=nxt[i])\n\t{\n\t\tint v=to[i];\n\t\tif(v==fa) continue;\n\t\tdfs2(v,u);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y),add(y,x);\n\t}\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tdfs1(1,0),dfs2(1,0);\n\tfor(int i=1;i<=n;i++) printf(\"%d \",ans[i]==0?0:1);\n\tprintf(\"\\n\");\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"博弈论"}],
			"title": "CF1498F Christmas Game 做题记录",
			"link": "https://exber.qzz.io/post/CF1498F%20Christmas%20Game%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-04-15 11:58:46"
		},
	
		{
			"abstract": "> 给定长度为 $n$ 的颜色序列 $a_i$，每次你可以选择任意长度的**连续且颜色相同**的一段位置，将其全部变成任意同一种颜色，问你最少总共需要多少次操作才能使得整个序列颜色相同。\n> \n> **限制：** 每一种颜色初始时在序列中最多只有20个位置（是该种颜色）。\n> \n> $n\\le 3000$，$a_i \\le n$，$\\sum n \\le 3000$。\n",
			"content": "> 给定长度为 $n$ 的颜色序列 $a_i$，每次你可以选择任意长度的**连续且颜色相同**的一段位置，将其全部变成任意同一种颜色，问你最少总共需要多少次操作才能使得整个序列颜色相同。\n> \n> **限制：** 每一种颜色初始时在序列中最多只有20个位置（是该种颜色）。\n> \n> $n\\le 3000$，$a_i \\le n$，$\\sum n \\le 3000$。\n\n首先不难发现连续一段相同的颜色的格子可以缩成一个格子，那么不妨先缩到相邻的两个格子颜色不同。\n\n考虑某一段格子 $[l,r]$ 最后被涂成的颜色，显然若 $[l,r-1]$ 涂的颜色和 $a_r$ 不同则需要花费一次操作把 $[l,r-1]$ 涂成 $a_r$，或者把 $r$ 涂成 $[l,r-1]$ 的颜色。那么不妨钦定让 $[l,r-1]$ 涂成 $a_r$，则可以设 $dp_{l,r}$ 表示 $[l,r]$ 这一段全部涂成 $a_r$ 所需的最小操作次数，那么有转移：\n$$\ndp_{l,r}=\\min\\begin{cases}dp_{l,r-1}+1\\\\dp_{l,k}+dp_{k+1,r}&a_k=a_r\\end{cases}\n$$\n由于每种颜色出现次数最多只有 $20$，所以可以预处理出每个位置前面最后一个与它颜色相同的位置来转移，时间复杂度 $O(20n^2)$。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=3005;\n\nint n,a[S];\nint m,b[S],dp[S][S];\nint pos[S],pre[S];\n\ninline void slove()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tm=0;\n\tfor(int i=1;i<=n;i++) if(a[i]!=a[i-1]) b[++m]=a[i];\n\tfor(int i=1;i<=n;i++) pos[i]=0;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tpre[i]=pos[b[i]];\n\t\tpos[b[i]]=i;\n\t}\n\tfor(int i=1;i<=m;i++) for(int j=i;j<=m;j++) dp[i][j]=1e8;\n\tfor(int i=1;i<=m;i++) dp[i][i]=0;\n\tfor(int len=2;len<=m;len++)\n\t{\n\t\tfor(int l=1;l<=m-len+1;l++)\n\t\t{\n\t\t\tint r=l+len-1;\n\t\t\tdp[l][r]=dp[l][r-1]+1;\n\t\t\tfor(int k=pre[r];k>=l;k=pre[k])\n\t\t\t{\n\t\t\t\tdp[l][r]=min(dp[l][r],dp[l][k]+dp[k+1][r]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[1][m]);\n}\n\nint main()\n{\n\tint T;\n\tscanf(\"%d\",&T);\n\twhile(T-->0) slove();\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"DP"}],
			"title": "CF1572C Paint 做题记录",
			"link": "https://exber.qzz.io/post/CF1572C%20Paint%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-04-15 11:52:16"
		},
	
		{
			"abstract": "> 给你 $n$ 颗宝石，每颗宝石都有重量和价值。要你从这些宝石中选取一些宝石，保证总重量不超过 $W$，且总价值最大，并输出最大的总价值。\n> \n> $1\\le n \\le 100$，$1\\le W,w_i,v_i \\le 2^{30}$。  \n> \n> 保证每个 $w_i$ 能写成 $a \\times 2^b\\space (a,b \\in \\mathbb N)$ 的形式，$a \\leq 10$ , $b \\leq 30$，且答案不超过 $2^{30}$。\n",
			"content": "> 给你 $n$ 颗宝石，每颗宝石都有重量和价值。要你从这些宝石中选取一些宝石，保证总重量不超过 $W$，且总价值最大，并输出最大的总价值。\n> \n> $1\\le n \\le 100$，$1\\le W,w_i,v_i \\le 2^{30}$。  \n> \n> 保证每个 $w_i$ 能写成 $a \\times 2^b\\space (a,b \\in \\mathbb N)$ 的形式，$a \\leq 10$ , $b \\leq 30$，且答案不超过 $2^{30}$。\n\n不难发现，虽然数据范围很大，但是由于 $w_i=a\\times 2^b$，$1\\le a\\le 10$。所以 $b$ 相同的 $w$ 同时除掉 $2^b$ 之后的和很小，只有 $10n$。那么不难想到按照 $b$ 分组，每组物品单独做背包，最后合并。\n\n那么设 $f_{i,j}$ 表示所有 $b=i$ 的物品，背包容量为 $j\\times 2^i$ 时的最大收益。这部分可以在 $O(300n)$ 的时间之内预处理完。\n\n考虑如何合并，设 $tot_i$ 表示 $b=i$ 的物品数量，用类似数位 dp 的思路，设 $g_{i,j}$ 表示前 $i$ 个 $b$，背包容量为 $(m\\&((1<<i)-1))+j\\times 2^i$（也就是 $m$ 的前 $i-1$ 位加上额外的 $j$ 个 $2^i$）时的最大收益。这样设计状态的好处在于可以处理低位向高位借 $1$ 的情况，那么转移即为\n\n$$\ng_{i,j+k}=\\max(g_{i,j+k},f_j+g_{i-1,\\min(10\\sum\\limits_{l=0}^{i-1}tot_l,2k+((m>>(i-1))\\&1))})\n$$\n即枚举有多少个 $2^i$ 被上一位借了。\n\n这部分的时间复杂度为 $O(3000n)$，总时间复杂度 $O(4000n)$ 左右。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nconst int S=105,BS=30,MS=1005;\n\nint n,m;\nint tot[BS+5],vw[BS+5][S],vv[BS+5][S];\nint f[BS+5][MS],g[BS+5][MS];\n\nvoid slove()\n{\n\tfor(int i=0;i<=BS;i++) tot[i]=false;\n\tmemset(f,0,sizeof(f)),memset(g,0,sizeof(g));\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint w,v;\n\t\tscanf(\"%d%d\",&w,&v);\n\t\tint a=w,b=0;\n\t\twhile(a&1^1) a>>=1,b++;\n//\t\tprintf(\">> %d %d %d\\n\",a,b,v);\n\t\tvw[b][++tot[b]]=a;\n\t\tvv[b][tot[b]]=v;\n\t}\n\tfor(int i=0;i<=BS;i++)\n\t{\n\t\tfor(int j=1;j<=tot[i];j++)\n\t\t{\n\t\t\tint w=vw[i][j],v=vv[i][j];\n\t\t\tfor(int k=tot[i]*10;k>=w;k--) f[i][k]=max(f[i][k],f[i][k-w]+v);\n\t\t}\n\t}\n\t// for(int i=0;i<=10;i++)\n\t// {\n\t\t// for(int j=0;j<=20;j++) printf(\"%d \",f[i][j]);\n\t\t// printf(\"\\n\");\n\t// }\n\tfor(int i=0;i<=tot[0]*10;i++) g[0][i]=f[0][i];\n\tint sm=tot[0];\n\tfor(int i=1;i<=BS;i++)\n\t{\n\t\tsm+=tot[i];\n\t\tfor(int j=0;j<=sm*10;j++)\n\t\t{\n\t\t\tfor(int k=0;k<=j;k++)\n\t\t\t{\n\t\t\t\tg[i][j]=max(g[i][j],f[i][j-k]+g[i-1][min((sm-tot[i])*10,k*2+((m>>i-1)&1))]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",g[BS][m>>BS&1]);\n}\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==-1&&m==-1) break;\n\t\tslove();\n\t}\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"数学"},{"name":"DP"}],
			"title": "P3188 [HNOI2007]梦幻岛宝珠 做题记录",
			"link": "https://exber.qzz.io/post/P3188%20%5BHNOI2007%5D%E6%A2%A6%E5%B9%BB%E5%B2%9B%E5%AE%9D%E7%8F%A0%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-04-15 11:48:33"
		},
	
		{
			"abstract": "> 维护一个字符串集合，支持三种操作：\n> \n> 1. 加字符串\n> 2. 删字符串\n> 3. 查询集合中的所有字符串在给出的模板串中出现的次数\n> \n> 操作数 $m \\leq 3 \\times 10^5$，输入字符串总长度 $\\sum |s_i| \\leq 3\\times 10^5$。\n> \n> **本题强制在线，应该在每次输出后调用```fflush(stdout)```。你只有在输出上一个询问的答案后才能读入下一组询问。**\n",
			"content": "> 维护一个字符串集合，支持三种操作：\n> \n> 1. 加字符串\n> 2. 删字符串\n> 3. 查询集合中的所有字符串在给出的模板串中出现的次数\n> \n> 操作数 $m \\leq 3 \\times 10^5$，输入字符串总长度 $\\sum |s_i| \\leq 3\\times 10^5$。\n> \n> **本题强制在线，应该在每次输出后调用```fflush(stdout)```。你只有在输出上一个询问的答案后才能读入下一组询问。**\n\n为了叙述方便，设 $len=\\sum|s_i|$。\n\n首先容易想到字符串哈希，开桶存某个哈希值有多少个，然后暴力枚举子串判断。这样时间复杂度是 $O(len^2)$ 的。\n\n考虑优化，一个显然的做法是记录下集合内的串的长度，只枚举长度合法的字串。由于 $1+2+3+\\dots+n=\\frac{n(n+1)}2$，所以不同的长度最多只会有 $\\sqrt len$ 个，时间复杂度为 $len\\sqrt{len}$。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <set>\n#include <map>\n\nusing namespace std;\n\nconst int S=300005,bse=31,p1=998244353,p2=1000000007;\n\nint n;\nchar a[S];\nint p1p[S],p2p[S];\nint cntlen[S];\nset<int> lens;\nmap<pair<int,int>,int> cnt;\nint pre1[S],pre2[S];\n\nint main()\n{\n\tp1p[0]=p2p[0]=1;\n\tfor(int i=1;i<=S-3;i++) p1p[i]=1ll*p1p[i-1]*bse%p1,p2p[i]=1ll*p2p[i-1]*bse%p2;\n\tscanf(\"%d\",&n);\n\twhile(n-->0)\n\t{\n\t\tint tpe;\n\t\tscanf(\"%d%s\",&tpe,a+1);\n\t\tif(tpe==1)\n\t\t{\n\t\t\tint x=0,y=0;\n\t\t\tint len=strlen(a+1);\n\t\t\tcntlen[len]++;\n\t\t\tif(cntlen[len]==1) lens.insert(len);\n\t\t\tfor(int i=1;i<=len;i++)\n\t\t\t{\n\t\t\t\tx=(1ll*x*bse%p1+a[i]-'a'+1)%p1;\n\t\t\t\ty=(1ll*y*bse%p2+a[i]-'a'+1)%p2;\n\t\t\t}\n//\t\t\tprintf(\"+ %d %d\\n\",x,y);\n\t\t\tcnt[make_pair(x,y)]++;\n\t\t}\n\t\tif(tpe==2)\n\t\t{\n\t\t\tint x=0,y=0;\n\t\t\tint len=strlen(a+1);\n\t\t\tcntlen[len]--;\n\t\t\tif(cntlen[len]==0) lens.erase(len);\n\t\t\tfor(int i=1;i<=len;i++)\n\t\t\t{\n\t\t\t\tx=(1ll*x*bse%p1+a[i]-'a'+1)%p1;\n\t\t\t\ty=(1ll*y*bse%p2+a[i]-'a'+1)%p2;\n\t\t\t}\n//\t\t\tprintf(\"- %d %d\\n\",x,y);\n\t\t\tcnt[make_pair(x,y)]--;\n\t\t}\n\t\tif(tpe==3)\n\t\t{\n\t\t\tlong long ans=0;\n\t\t\tint m=strlen(a+1);\n\t\t\tfor(int i=1;i<=m;i++)\n\t\t\t{\n\t\t\t\tpre1[i]=(1ll*pre1[i-1]*bse%p1+a[i]-'a'+1)%p1;\n\t\t\t\tpre2[i]=(1ll*pre2[i-1]*bse%p2+a[i]-'a'+1)%p2;\n\t\t\t}\n\t\t\tfor(int len:lens)\n\t\t\t{\n\t\t\t\tfor(int i=len;i<=m;i++)\n\t\t\t\t{\n\t\t\t\t\tint x=(pre1[i]-1ll*pre1[i-len]*p1p[len]%p1+p1)%p1;\n\t\t\t\t\tint y=(pre2[i]-1ll*pre2[i-len]*p2p[len]%p2+p2)%p2;\n\t\t\t\t\tans+=cnt[make_pair(x,y)];\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%lld\\n\",ans);\n\t\t\tfflush(stdout);\n\t\t}\n\t}\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"杂题"},{"name":"字符串"}],
			"title": "CF710F String Set Queries 做题记录",
			"link": "https://exber.qzz.io/post/CF710F%20String%20Set%20Queries%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-04-15 11:39:37"
		},
	
		{
			"abstract": "> 给定一个 $n$ 个点 $m$ 条边的简单无向图，求其三元环个数。\n> \n> $1 \\le n \\le 10^5$，$1 \\le m \\le 2 \\times {10}^5$。\n\n> 给定一个 $n$ 个点 $m$ 条边的简单无向图，点 $i$ 有点权 $a_i$，求其所有本质不同的四元环中所有点的点权和，模 $10^9+7$。\n>\n> $1\\le n\\le 10^5$，$1\\le m\\le 2\\times 10^5$，$1\\le a_i\\le 10^9$。\n",
			"content": "> 给定一个 $n$ 个点 $m$ 条边的简单无向图，求其三元环个数。\n> \n> $1 \\le n \\le 10^5$，$1 \\le m \\le 2 \\times {10}^5$。\n\n> 给定一个 $n$ 个点 $m$ 条边的简单无向图，点 $i$ 有点权 $a_i$，求其所有本质不同的四元环中所有点的点权和，模 $10^9+7$。\n>\n> $1\\le n\\le 10^5$，$1\\le m\\le 2\\times 10^5$，$1\\le a_i\\le 10^9$。\n\n\n#### 三元环\n\n三元环等价于 $(x,y)$，$(y,z)$，$(x,z)$。\n\n考虑给原图定向，让度数大的连向度数小的，度数一样按编号。\n\n这样定向后的图一定是 DAG。\n\n有一个很暴力的想法是直接枚举 $x$，然后：\n\n- 开一个桶 $b$；\n- 枚举 $x$ 出边指向的点 $y$，枚举 $y$ 出边指向的点 $z$，$b_z\\to b_z+1$；\n- 枚举 $x$ 出边指向的点 $y$，$ans\\to ans+b_y$；\n\n这样做的时间复杂度是 $O(m\\sqrt m)$ 的。\n\n<details><summary>证明</summary><p>\n\n>设 $d_u$ 为点 $u$ 在原图中的度数。\n>\n>一条边 $x\\to y$ 对时间复杂度的贡献显然为 $out_y$ 即 $y$ 的出度。\n>\n>- $d_y\\le \\sqrt m$：由于新的图是原图定向得来的，所以 $out_y\\le d_y\\le \\sqrt m$；\n>- $d_y>\\sqrt m$：这样的点只有 $\\sqrt m$ 个；\n>\n>综上，时间复杂度为 $m\\sqrt m$。\n>\n>Q.E.D.\n\n</p></details>\n\n<details><summary>闲话</summary><p>\n\n事实上，定向时由度数小的连向度数大的点**在三元环计数中**也可行。\n\n<details><summary>证明</summary><p>\n\n>设 $d_u$ 为点 $u$ 在原图中的度数。\n>\n>一条边 $x\\to y$ 对时间复杂度的贡献显然为 $out_y$ 即 $y$ 的出度。\n>\n>- $d_y\\le \\sqrt m$：由于新的图是原图定向得来的，所以 $out_y\\le d_y\\le \\sqrt m$；\n>- $d_y>\\sqrt m$：$y$ 在新图上的出边连向的点 $z$ 一定满足 $d_z>\\sqrt m$，这样的点最多只有 $\\sqrt m$ 个，所以 $out_y\\le \\sqrt m$；\n>\n>综上，时间复杂度为 $m\\sqrt m$。\n>\n>Q.E.D.\n\n</p></details>\n\n</p></details>\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nconst int S=100005;\n\nint n,m,a[S];\nvector<int> g[S],g2[S];\nint id[S],rk[S];\nint cnt[S];\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tg[x].push_back(y),g[y].push_back(x);\n\t}\n\tfor(int i=1;i<=n;i++) id[i]=i;\n\tsort(id+1,id+n+1,[&](int x,int y){return g[x].size()<g[y].size();});\n\tfor(int i=1;i<=n;i++) rk[id[i]]=i;\n\tfor(int u=1;u<=n;u++) for(int v:g[u]) if(rk[v]<rk[u]) g2[u].push_back(v);\n\tlong long ans=0;\n\tfor(int x=1;x<=n;x++)\n\t{\n\t\tfor(int y:g2[x]) for(int z:g2[y]) cnt[z]++;\n\t\tfor(int y:g2[x]) ans+=cnt[y];\n\t\tfor(int y:g2[x]) for(int z:g2[y]) cnt[z]=0;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n\n#### 四元环\n\n四元环等价于 $(x,y),(y,z)$ 和 $(x,w),(w,z)$。\n\n按照三元环的方式给图定向，即度数大的连向度数小的。记新图为 $G'$，原图为 $G$。\n\n$G'$ 显然是 DAG，随意取它的一个拓扑序，设 $u$ 的排名为 $rk_u$。\n\n直接枚举 $x$，然后：\n\n- 开两个桶 $cnt$ 和 $sum$；\n- 在 $G’$ 中枚举 $x$ 出边指向的点 $y$，在 $G$ 中枚举 $y$ 出边指向的点 $z$：\n  - $ans\\to ans+sum_z+cnt_z\\times a_y$；\n  - 若 $rk_z<rk_x$ 则 $cnt_z\\to cnt_z+1$，$sum_z\\to sum_z+a_x+a_y+a_z$；\n- 清空两个桶；\n\n可以看成是每次删除 $rk_x$ 最大的点 $x$ 并统计答案，这样做的时间复杂度是 $O(m\\sqrt m)$ 的。\n\n证明和三元环的第一个证明是一样的。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nconst int S=100005,p=1000000007;\n\nint n,m,a[S];\nvector<int> g[S],g2[S];\nint id[S],rk[S];\nint cnt[S],bu[S];\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tg[x].push_back(y),g[y].push_back(x);\n\t}\n\tfor(int i=1;i<=n;i++) id[i]=i;\n\tsort(id+1,id+n+1,[&](int x,int y){return g[x].size()<g[y].size();});\n\tfor(int i=1;i<=n;i++) rk[id[i]]=i;\n\tfor(int u=1;u<=n;u++) for(int v:g[u]) if(rk[v]<rk[u]) g2[u].push_back(v);\n\tint ans=0;\n\tfor(int x=1;x<=n;x++)\n\t{\n\t\tfor(int y:g2[x])\n\t\t{\n\t\t\tfor(int z:g[y])\n\t\t\t{\n\t\t\t\tif(rk[z]>=rk[x]) continue;\n\t\t\t\tans=(0ll+ans+bu[z]+1ll*cnt[z]*a[y]%p)%p;\n\t\t\t\tcnt[z]++;\n\t\t\t\tbu[z]=(0ll+bu[z]+a[x]+a[y]+a[z])%p;\n\t\t\t}\n\t\t}\n\t\tfor(int y:g2[x]) for(int z:g[y]) cnt[z]=bu[z]=0;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n\n#### 闲话\n\n三元环和四元环计数的本质都是找有 $3$ 个点的简单链，那么 $n$ 个点 $m$ 条边的无向图中有 $k$ 个点的本质不同的简单链个数的级别是怎么样的呢？\n\n$k=1$：$O(n)$；\n\n$k=2$：$O(m)$；\n\n$k=3$：$O(m\\sqrt m)$；\n\n能否得出一个结论：$k\\ge 2$ 时级别是 $O((\\sqrt m)^k)$ 的？\n",
			"tags": [{"name":"图论"},{"name":"结论"},{"name":"学习笔记"},{"name":"小技巧"}],
			"title": "无向图三元环 & 四元环计数 小结",
			"link": "https://exber.qzz.io/post/%E6%97%A0%E5%90%91%E5%9B%BE%E4%B8%89%E5%85%83%E7%8E%AF%20%26%20%E5%9B%9B%E5%85%83%E7%8E%AF%E8%AE%A1%E6%95%B0%20%E5%B0%8F%E7%BB%93",
			"date": "2023-04-15 11:21:28"
		},
	
		{
			"abstract": "> 九条可怜是一个喜欢树的女孩子，她想生成两棵均有 $n$ 个节点的树。\n> \n> 第一棵树的生成方式是：\n> \n> 1. 节点 $1$ 作为树的根。\n> 2. 对于 $i \\in [2, n]$，从 $[1, i - 1]$ 中选取一个节点作为 $i$ 的父亲。\n> \n> 第二棵树的生成方式是：\n> \n> 1. 节点 $n$ 作为树的根。\n> 2. 对于 $i \\in [1, n - 1]$，从 $[i + 1, n]$ 中选取一个节点作为 $i$ 的父亲。\n> \n> 九条可怜希望对于任意 $i \\in [1, n]$，若第一棵树中的节点 $i$ 为叶子，那么第二棵树中的节点 $i$ 为非叶子；若第一棵树中的节点 $i$ 为非叶子，那么第二棵树中的节点 $i$ 为叶子。一个节点被称为叶子当且仅当没有节点的父亲是它。\n> \n> 九条可怜希望你统计生成两棵树的方案数是多少。具体地，你需要对于所有 $n \\in [2, N]$ 都计算方案数。两种方案不同当且仅当存在一棵树中的一个节点 $i$，两种方案中它的父亲不同。因为答案可能很大，你只需要输出答案对 $M$ 取模后的结果。\n> \n> $2 \\le N \\le 500$，$10 \\le M \\le 2^{30}$。\n",
			"content": "> 九条可怜是一个喜欢树的女孩子，她想生成两棵均有 $n$ 个节点的树。\n> \n> 第一棵树的生成方式是：\n> \n> 1. 节点 $1$ 作为树的根。\n> 2. 对于 $i \\in [2, n]$，从 $[1, i - 1]$ 中选取一个节点作为 $i$ 的父亲。\n> \n> 第二棵树的生成方式是：\n> \n> 1. 节点 $n$ 作为树的根。\n> 2. 对于 $i \\in [1, n - 1]$，从 $[i + 1, n]$ 中选取一个节点作为 $i$ 的父亲。\n> \n> 九条可怜希望对于任意 $i \\in [1, n]$，若第一棵树中的节点 $i$ 为叶子，那么第二棵树中的节点 $i$ 为非叶子；若第一棵树中的节点 $i$ 为非叶子，那么第二棵树中的节点 $i$ 为叶子。一个节点被称为叶子当且仅当没有节点的父亲是它。\n> \n> 九条可怜希望你统计生成两棵树的方案数是多少。具体地，你需要对于所有 $n \\in [2, N]$ 都计算方案数。两种方案不同当且仅当存在一棵树中的一个节点 $i$，两种方案中它的父亲不同。因为答案可能很大，你只需要输出答案对 $M$ 取模后的结果。\n> \n> $2 \\le N \\le 500$，$10 \\le M \\le 2^{30}$。\n\n设 $f(S)$ 表示叶子节点集合为 $S$ 时第一棵树的方案数，$g(T)$ 表示叶子节点集合为 $T$ 时第二棵树的方案数，那么有\n$$\nans=\\sum\\limits_{S\\cap T=\\varnothing,S\\cup T=\\{1,2,3,\\dots,n\\}}f(S)g(T)\n$$\n发现非叶子节点非常难处理，所以不妨设 $f'(S)$ 表示非叶子节点集合为 $S$ 是第一棵树的方案树，设 $g’(T)$ 表示非叶子节点集合为 $T$ 时第二棵树的方案数，那么有\n$$\n\\begin{aligned}\nans&=\\sum\\limits_{S\\cap T=\\varnothing,S\\cup T=\\{1,2,3,\\dots,n\\}}f(S)g(T)\\\\\n&=\\sum\\limits_{S\\cap T=\\varnothing,S\\cup T=\\{1,2,3,\\dots,n\\}}\\sum\\limits_{S'\\in S,T'\\in T}f'(S')g'(T')(-1)^{n-|S'|-|T'|}\\\\\n&=\\sum\\limits_{S'\\cap T'=\\varnothing}f'(S')g'(T')(-1)^{n-|S'|-|T'|}2^{n-|S'|-|T'|}\\,\\,\\,\\text{（}S'\\text{ 和 }T'\\text{ 之外的节点可以出现在 }S\\text{ 或 }T\\text{ 中）}\\\\\n&=\\sum\\limits_{S'\\cap T'=\\varnothing}f'(S')g'(T')(-2)^{n-|S'|-|T'|}\n\\end{aligned}\n$$\n那么设 $dp_{i,j,k}$ 表示处理到 $i$，$|S'\\cap\\{1,2,3,\\dots,i\\}|=j,|T'\\cap\\{i+1,i+2,i+3,\\dots,n\\}|=k$ 时的 $f'(S')g'(T')(-2)^{n-|S'|-|T'|}$，有转移：\n\n- $j\\times k\\times dp_{i,j,k}\\to dp_{i+1,j+1,k}$\n- $j\\times k\\times dp_{i,j,k}\\to dp_{i+1,j,k-1}$\n- $-2\\times j\\times k\\times dp_{i,j,k}\\to dp_{i+1,j,k}$\n\n边界条件 $dp_{1,1,k}=1,1\\le k\\le n-1$。\n\n答案为 $\\sum\\limits_{i=1}^{n-1}dp_{n-1,i,1}\\times i$。\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=505;\n\nint n,p;\nint dp[S][S][S];\n\ninline void addd(int &x,int y)\n{\n\tx+=y;\n\tif(x>=p) x-=p;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&p);\n\tfor(int i=1;i<=n-1;i++) dp[1][1][i]=1;\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tfor(int j=1;j<=i;j++)\n\t\t{\n\t\t\tfor(int k=1;k<=n-i;k++)\n\t\t\t{\n\t\t\t\taddd(dp[i+1][j+1][k],1ll*j*k%p*dp[i][j][k]%p);\n\t\t\t\taddd(dp[i+1][j][k-1],1ll*j*k%p*dp[i][j][k]%p);\n\t\t\t\taddd(dp[i+1][j][k],p-2ll*j*k%p*dp[i][j][k]%p);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tint ans=0;\n\t\tfor(int j=1;j<=n-1;j++) addd(ans,1ll*dp[i-1][j][1]*j%p);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"数学"},{"name":"组合计数"},{"name":"DP"}],
			"title": "P8329 [ZJOI2022] 树 做题记录",
			"link": "https://exber.qzz.io/post/P8329%20%5BZJOI2022%5D%20%E6%A0%91%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-04-15 11:18:28"
		},
	
		{
			"abstract": "> 为了提高智商，ZJY 开始学习概率论。有一天，她想到了这样一个问题：对于一棵随机生成的 $n$ 个结点的有根二叉树（所有互相不同构的形态等概率出现），它的叶子节点数的期望是多少呢？\n> \n> 判断两棵树是否同构的伪代码如下：\n> \n> ![](../post-images/1681474508176.webp)\n> \n> 对于 $100\\%$ 的数据，$1 \\le n \\le 10^9$。\n",
			"content": "> 为了提高智商，ZJY 开始学习概率论。有一天，她想到了这样一个问题：对于一棵随机生成的 $n$ 个结点的有根二叉树（所有互相不同构的形态等概率出现），它的叶子节点数的期望是多少呢？\n> \n> 判断两棵树是否同构的伪代码如下：\n> \n> ![](../post-images/1681474508176.webp)\n> \n> 对于 $100\\%$ 的数据，$1 \\le n \\le 10^9$。\n\n对于每棵 $n$ 个点的二叉树，设它有 $k$ 个叶子，那么把这 $k$ 个叶子分别删去就能得到 $k$ 棵 $n-1$ 个点的二叉树。\n\n由于每一颗 $n-1$ 个点的二叉树都能悬挂 $n$ 个新的叶子，所以每一棵 $n-1$ 个点的二叉树都会被上面的过程得到 $n$ 次。\n\n由于 $n$ 个点的有根二叉树有 $\\frac{\\binom{2n}{n}}{n+1}$ 种，所以 $n$ 个点的所有二叉树总共有 $\\binom{2n-2}{n-1}$ 个叶子，期望有 $\\frac{\\binom{2n-2}{1n-1}}{\\frac{\\binom{2n}{n}}{n+1}}=\\frac{(n+1)\\frac{(2n-2)!}{(n-1)!^2}}{\\frac{(2n)!}{n!^2}}=\\frac{(n+1)n^2}{2n(2n-1)}=\\frac{n(n+1)}{2(2n-1)}$ 个叶子。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nint n;\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tprintf(\"%.9Lf\\n\",n*(n+1)/(long double)(2*(2*n-1)));\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"数学"},{"name":"组合计数"},{"name":"概率、期望"}],
			"title": "P3978 [TJOI2015]概率论 做题记录",
			"link": "https://exber.qzz.io/post/P3978%20%5BTJOI2015%5D%E6%A6%82%E7%8E%87%E8%AE%BA%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-04-14 20:14:40"
		},
	
		{
			"abstract": "> 小 Z 正在自学量子计算机相关知识，最近他在研究量子通信章节，并遇到了一个有趣的问题。在该问题中，Alice 和 Bob 正在进行量子通信，它们的通信语言是一个大小为 $n$ 的字典 $S$，在该字典中，每一个单词 $s_i$（$1 \\le i \\le n$）都可以用一个 $\\boldsymbol{256}$ **位的** $\\boldsymbol{01}$ **串**来表示。在本题中 $s_i$ 可以通过调用函数 `gen` 来生成，选手可以在题目目录下的 `gen.cpp` 中查看，该函数的参数 `n`、`a1`、`a2` 将由输入数据给出。\n> \n> Alice 和 Bob 接下来要进行 $m$ 次通信，每次通信由 Alice 向 Bob 传输**恰好一个**字典中的单词。然而，两人使用的通信信道并不可靠，会受到噪音的干扰。更具体地，对于第 $i$ 次传输，记 Alice 传输的原单词为 $x_i$，该 $01$ 串会受噪音干扰而**翻转最多** $\\boldsymbol{k_i}$ **位**。换句话说，记 Bob 这次收到的 $01$ 串为 $y_i$，它与 $x_i$ 相比，可能有最多 $k_i$ 位是不同的，并且 $y_i$ 可能不在字典 $S$ 中出现。\n> \n> 与此同时，Bob 得知坏人 Eve 也潜入了两人的通信信道，并准备干扰两人的通信。他的干扰方式是将 Bob 收到的 $01$ 串变为任意的 $256$ 位 $01$ 串，并且这个串可能不在字典 $S$ 中出现。Eve 非常狡猾，他**不一定**会对每次通信都进行干扰。\n> \n> 现在 Bob 找来了你帮忙，对于接下来的每次通信，你需要根据 Bob 最终收到的 $01$ 串以及这次通信的噪音干扰阈值 $k_i$（$0 \\le k_i \\le 15$），判断这次通信是否有可能没有受到 Eve 的干扰（即 Bob 收到的 $01$ 串可以由字典中的某个单词翻转至多 $k_i$ 位后得到）。本次通信如果有可能没受到 Eve 干扰，请你输出 $1$，否则输出 $0$。Bob 很信任你的能力，所以你需要**在线地回答结果，具体要求见输入格式**。\n> \n> 为了降低读入用时， Bob 收到的串将用**长度为** $\\boldsymbol{64}$ **的** $\\boldsymbol{16}$ **进制串**给出，$16$ 进制串中包含数字字符 $\\texttt{0} \\sim \\texttt{9}$ 与大写英文字母 $\\texttt{A} \\sim \\texttt{F}$，其中字符 $\\texttt{A} \\sim \\texttt{F}$ 依次表示数值 $10 \\sim 15$。\n> \n> $16$ 进制串可以逐位转化为 $01$ 串，例如：`5` 对应 `0101`，`A` 对应 `1010`，`C` 对应 `1100`。\n> \n> $1 \\le n \\le 4 \\times {10}^5$，$1 \\le m \\le 1.2 \\times {10}^5$，$0 \\le k_i \\le 15$，$a_1$ 和 $a_2$ 在 $[0, 2^{64} - 1]$ 之间均匀随机生成。\n",
			"content": "> 小 Z 正在自学量子计算机相关知识，最近他在研究量子通信章节，并遇到了一个有趣的问题。在该问题中，Alice 和 Bob 正在进行量子通信，它们的通信语言是一个大小为 $n$ 的字典 $S$，在该字典中，每一个单词 $s_i$（$1 \\le i \\le n$）都可以用一个 $\\boldsymbol{256}$ **位的** $\\boldsymbol{01}$ **串**来表示。在本题中 $s_i$ 可以通过调用函数 `gen` 来生成，选手可以在题目目录下的 `gen.cpp` 中查看，该函数的参数 `n`、`a1`、`a2` 将由输入数据给出。\n> \n> Alice 和 Bob 接下来要进行 $m$ 次通信，每次通信由 Alice 向 Bob 传输**恰好一个**字典中的单词。然而，两人使用的通信信道并不可靠，会受到噪音的干扰。更具体地，对于第 $i$ 次传输，记 Alice 传输的原单词为 $x_i$，该 $01$ 串会受噪音干扰而**翻转最多** $\\boldsymbol{k_i}$ **位**。换句话说，记 Bob 这次收到的 $01$ 串为 $y_i$，它与 $x_i$ 相比，可能有最多 $k_i$ 位是不同的，并且 $y_i$ 可能不在字典 $S$ 中出现。\n> \n> 与此同时，Bob 得知坏人 Eve 也潜入了两人的通信信道，并准备干扰两人的通信。他的干扰方式是将 Bob 收到的 $01$ 串变为任意的 $256$ 位 $01$ 串，并且这个串可能不在字典 $S$ 中出现。Eve 非常狡猾，他**不一定**会对每次通信都进行干扰。\n> \n> 现在 Bob 找来了你帮忙，对于接下来的每次通信，你需要根据 Bob 最终收到的 $01$ 串以及这次通信的噪音干扰阈值 $k_i$（$0 \\le k_i \\le 15$），判断这次通信是否有可能没有受到 Eve 的干扰（即 Bob 收到的 $01$ 串可以由字典中的某个单词翻转至多 $k_i$ 位后得到）。本次通信如果有可能没受到 Eve 干扰，请你输出 $1$，否则输出 $0$。Bob 很信任你的能力，所以你需要**在线地回答结果，具体要求见输入格式**。\n> \n> 为了降低读入用时， Bob 收到的串将用**长度为** $\\boldsymbol{64}$ **的** $\\boldsymbol{16}$ **进制串**给出，$16$ 进制串中包含数字字符 $\\texttt{0} \\sim \\texttt{9}$ 与大写英文字母 $\\texttt{A} \\sim \\texttt{F}$，其中字符 $\\texttt{A} \\sim \\texttt{F}$ 依次表示数值 $10 \\sim 15$。\n> \n> $16$ 进制串可以逐位转化为 $01$ 串，例如：`5` 对应 `0101`，`A` 对应 `1010`，`C` 对应 `1100`。\n> \n> $1 \\le n \\le 4 \\times {10}^5$，$1 \\le m \\le 1.2 \\times {10}^5$，$0 \\le k_i \\le 15$，$a_1$ 和 $a_2$ 在 $[0, 2^{64} - 1]$ 之间均匀随机生成。\n\n观察到由于最多只会翻转 $15$ 位，所以可以把每个 $01$ 串都分成 $16$ 段，这样若没被那个人干扰则总会有一段和字典中的完全一样。\n\n由于数据随机，字典中合法的串的个数大概只有 $400000\\div2^{16}\\times16$ 个，这个数字大概是 $100$，所以能过。 \n",
			"tags": [{"name":"做题记录"},{"name":"构造"},{"name":"数学"}],
			"title": "P7738 [NOI2021] 量子通信 做题记录",
			"link": "https://exber.qzz.io/post/P7738%20%5BNOI2021%5D%20%E9%87%8F%E5%AD%90%E9%80%9A%E4%BF%A1%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-04-14 20:03:11"
		},
	
		{
			"abstract": "> B 君在玩一个游戏，这个游戏由 $n$ 个灯和 $n$ 个开关组成，给定这 $n$ 个灯的初始状态，下标为从 $1$ 到 $n$ 的正整数。\n> \n> 每个灯有两个状态亮和灭，我们用 $1$ 来表示这个灯是亮的，用 $0$ 表示这个灯是灭的，游戏的目标是使所有灯都灭掉。\n> \n> 但是当操作第 $i$ 个开关时，所有编号为 $i$ 的约数（包括 $1$ 和 $i$）的灯的状态都会被改变，即从亮变成灭，或者是从灭变成亮。\n> \n> B 君发现这个游戏很难，于是想到了这样的一个策略，每次等概率随机操作一个开关，直到所有灯都灭掉。\n> \n> 这个策略需要的操作次数很多，B 君想到这样的一个优化。如果当前局面，可以通过操作小于等于 $k$ 个开关使所有灯都灭掉，那么他将不再随机，直接选择操作次数最小的操作方法（这个策略显然小于等于 $k$ 步）操作这些开关。\n> \n> B 君想知道按照这个策略（也就是先随机操作，最后小于等于 $k$ 步，使用操作次数最小的操作方法）的操作次数的期望。\n> \n> 这个期望可能很大，但是 B 君发现这个期望乘以 $n$ 的阶乘一定是整数，所以他只需要知道这个整数对 $100003$ 取模之后的结果。\n> \n> $1 \\leq n \\leq 100000, 0 \\leq k \\leq n$。 \n",
			"content": "> B 君在玩一个游戏，这个游戏由 $n$ 个灯和 $n$ 个开关组成，给定这 $n$ 个灯的初始状态，下标为从 $1$ 到 $n$ 的正整数。\n> \n> 每个灯有两个状态亮和灭，我们用 $1$ 来表示这个灯是亮的，用 $0$ 表示这个灯是灭的，游戏的目标是使所有灯都灭掉。\n> \n> 但是当操作第 $i$ 个开关时，所有编号为 $i$ 的约数（包括 $1$ 和 $i$）的灯的状态都会被改变，即从亮变成灭，或者是从灭变成亮。\n> \n> B 君发现这个游戏很难，于是想到了这样的一个策略，每次等概率随机操作一个开关，直到所有灯都灭掉。\n> \n> 这个策略需要的操作次数很多，B 君想到这样的一个优化。如果当前局面，可以通过操作小于等于 $k$ 个开关使所有灯都灭掉，那么他将不再随机，直接选择操作次数最小的操作方法（这个策略显然小于等于 $k$ 步）操作这些开关。\n> \n> B 君想知道按照这个策略（也就是先随机操作，最后小于等于 $k$ 步，使用操作次数最小的操作方法）的操作次数的期望。\n> \n> 这个期望可能很大，但是 B 君发现这个期望乘以 $n$ 的阶乘一定是整数，所以他只需要知道这个整数对 $100003$ 取模之后的结果。\n> \n> $1 \\leq n \\leq 100000, 0 \\leq k \\leq n$。 \n\n不难发现按下同一个灯的开关两次相当于没按，并且一定有解，因为可以倒着跑，遇到亮着的灯直接关掉。然后不难发现这是唯一解。\n\n所以可以设 $dp_i$ 表示从 还有 $i$ 个灯的 开关按下状态 和解不同转移到有 $i-1$ 个不同的期望次数，那么有：\n$$\ndp_i=\\frac{i}{n}+\\frac{n-i}{n}(1+dp_{i+1}+dp_{i})\\\\\nndp_i=i+(n-i)(1+dp_{i+1}+dp_i)\\\\\nidp_i=i+(n-i)(1+dp_{i+1})\\\\\ndp_i=\\frac{i+(n-i)(1+dp_{i+1})}{i}\n$$\n并且有 $dp_{n}=1$。\n\n那么设当前还有 $cnt$ 个灯的开关按下状态和解不同，答案即为 $n!(k+\\sum\\limits_{i=k+1}^{cnt}dp_i)$。\n\n注意特判刚开始就满足的情况。\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=100005,p=100003;\n\nint n,k;\nint a[S];\nint cnt,dp[S];\n\ninline int qpow(int x,int y)\n{\n\tint res=1;\n\tfor(;y>0;y>>=1,x=1ll*x*x%p) res=(y&1)?1ll*res*x%p:res;\n\treturn res;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tif(a[i])\n\t\t{\n\t\t\tcnt++;\n\t\t\tfor(int j=1;j*j<=i;j++)\n\t\t\t{\n\t\t\t\tif(i%j==0)\n\t\t\t\t{\n\t\t\t\t\ta[j]^=1;\n\t\t\t\t\tif(j*j!=i) a[i/j]^=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n//\tprintf(\"%d\\n\",cnt);\n\tif(cnt<=k)\n\t{\n\t\tfor(int i=1;i<=n;i++) cnt=1ll*cnt*i%p;\n\t\tprintf(\"%d\\n\",cnt);\n\t\treturn 0;\n\t}\n\tdp[n]=1;\n\tfor(int i=n-1;i>=1;i--) dp[i]=1ll*(i+1ll*(n-i)*(1+dp[i+1])%p)*qpow(i,p-2)%p;\n\tint ans=k;\n\tfor(int i=k+1;i<=cnt;i++) ans=(ans+dp[i])%p;\n\tfor(int i=1;i<=n;i++) ans=1ll*ans*i%p;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"数学"},{"name":"概率、期望"},{"name":"DP"}],
			"title": "P3750 [六省联考 2017] 分手是祝愿 做题记录",
			"link": "https://exber.qzz.io/post/P3750%20%5B%E5%85%AD%E7%9C%81%E8%81%94%E8%80%83%202017%5D%20%E5%88%86%E6%89%8B%E6%98%AF%E7%A5%9D%E6%84%BF%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-04-14 19:54:14"
		},
	
		{
			"abstract": "",
			"content": "- 设 $f_x$ 表示达到状态 $x$ 的期望，答案即为 $f_{need}$；\n\n- 设 $f_{x,y}$ 表示从状态 $x$ 转到状态 $y$ 的期望，求答案的时候加起来；\n\n- 遇到求 $()^x$ 的时候直接二项式定理设多个 dp 数组，或者考虑 $x$ 个人同时进行一样的操作；\n\n- 考虑折线图/笛卡尔树；\n\n- 箭头 dp：\n\n  设 $dp_{i,j}$ 表示前 $i$ 个元素，有 $j$ 段。转移考虑新建段、加入某段的左边/右边、合并两段。\n\n  例题：\n\n  - [P5999 [CEOI2016] kangaroo](https://www.luogu.com.cn/problem/P5999)\n  - [CF704B Ant Man](https://www.luogu.com.cn/problem/CF704B)\n  - [LOJ2743 「JOI Open 2016」摩天大楼](https://loj.ac/p/2743)\n  - [【2023NOI模拟赛08】节日](/../post/2023noi-mu-ni-sai-08-jie-ri-zuo-ti-ji-lu)\n  - [ABC313Ex Group Photo](https://atcoder.jp/contests/abc313/tasks/abc313_h)\n\n- 非负整数划分 dp：\n\n  > 非负整数 $n$ 划分成 $m$ 个带标号非负整数的方案数。\n\n  设 $f_{i,j}$ 表示 $j$ 划分成 $i$ 个带标号非负整数的方案数，那么有 $f_{*,0}=1$。转移考虑有多少个 $\\ge 1$ 的数：\n  $$\n  f_{i,j}=\\sum\\limits_{k=1}^{\\min(i,j)}\\binom{i}{k}f_{k,j-k}\n  $$\n\n- 折线优化：\n\n  考虑某些形如 $f_{i,j}=\\max(f_{i-1,j+x}+w_1,f_{i-1,j+y}+w_2)$ 这样的只和上一列有关的 dp，可以猜想并且经常有：\n\n  > 存在某个 $k$ 满足 $f_{i,j}=\\begin{cases}f_{i-1,j+x}+w_1&j\\le k\\\\f_{i-1,j+y}+w_2&j>k\\end{cases}$\n\n  例题：\n\n  - [CF573E Bear and Bowling](https://www.luogu.com.cn/problem/CF573E)\n  - [P4331 [BalticOI 2004] Sequence 数字序列](https://www.luogu.com.cn/problem/P4331)\n  - [P7294 [USACO21JAN] Minimum Cost Paths P](https://www.luogu.com.cn/problem/P7294)\n\n- 在 dfs 序上 dp：[【2025NOI模拟赛19】b酱的果子](../【2025NOI模拟赛19】b酱的果子 做题记录)\n\n- 背包大小为 $k$ 的树形 dp 复杂度为 $O(nk)$；\n\n  <details><summary>证明</summary><p>\n\n  > 考虑现在在合并两棵子树 $x,y$。\n  >\n  > 若某一个子树大小 $\\le k$ ，复杂度显然是对的；\n  >\n  > 否则两个子树大小均 $>k$，这样的合并只会有 $O(n/k)$ 次，复杂度还是对的；\n\n  </p></details>\n\n  <details><summary>证明 2</summary><p>\n\n  > 考虑 dfs 序。\n  >\n  > 相当于枚举了所有长度 $\\le 2k$ 的区间，区间总数 $O(nk)$。\n\n  </p></details>\n",
			"tags": [{"name":"学习笔记"},{"name":"小技巧"},{"name":"DP"}],
			"title": "一些 dp 状态 & 技巧",
			"link": "https://exber.qzz.io/post/%E4%B8%80%E4%BA%9B%20dp%20%E7%8A%B6%E6%80%81%20%26%20%E6%8A%80%E5%B7%A7",
			"date": "2023-04-14 19:49:29"
		},
	
		{
			"abstract": "> 给定两个长度为 $n$ 的序列 $A,B$，满足：\n> \n> * $\\forall 1\\le i<n,A_i \\ge A_{i+1}$ \n> * $A_n\\ge \\min\\limits_{i=1}^n(B_i)$\n> \n> $\\pi$ 是一个长度为 $n$ 的排列，定义价值函数 $f(\\pi)$：\n> \n> $$\n> f(\\pi)=\\prod_{i=1}^n\\min(A_i,B_{\\pi(i)})\n> $$\n> \n> 每种排列出现的概率相等，求 $f(\\pi)$ 的期望对 $998244353$ 取模的结果。\n> \n> 即求:\n> \n> $$\n> \\left(\\dfrac{1}{n!}\\sum_\\pi f(\\pi)\\right) \\bmod 998244353\n> $$\n> \n> $1\\le n\\le 5000$，$1\\le A_i,B_i\\le 10^9$。\n",
			"content": "> 给定两个长度为 $n$ 的序列 $A,B$，满足：\n> \n> * $\\forall 1\\le i<n,A_i \\ge A_{i+1}$ \n> * $A_n\\ge \\min\\limits_{i=1}^n(B_i)$\n> \n> $\\pi$ 是一个长度为 $n$ 的排列，定义价值函数 $f(\\pi)$：\n> \n> $$\n> f(\\pi)=\\prod_{i=1}^n\\min(A_i,B_{\\pi(i)})\n> $$\n> \n> 每种排列出现的概率相等，求 $f(\\pi)$ 的期望对 $998244353$ 取模的结果。\n> \n> 即求:\n> \n> $$\n> \\left(\\dfrac{1}{n!}\\sum_\\pi f(\\pi)\\right) \\bmod 998244353\n> $$\n> \n> $1\\le n\\le 5000$，$1\\le A_i,B_i\\le 10^9$。\n\n首先不难发现顺序是没有任何影响的，所以先把 $a$ 和 $b$ 一起放到一个数组 $c$ 里从大到小排序，并把从 $a$ 来的元素染红，从 $b$ 来的元素染蓝。\n\n不难发现，问题转化为让所有红元素和蓝元素两两配对，每一对后面那个数乘起来的和。看到这种 $\\sum\\prod$ 的题就能想到提取公因数，考虑 $c_i$ 的贡献，显然只有当它和前面的元素配对的时候才会有贡献，那么我们设 $dp_{i,j}$ 表示前 $i$ 个元素，有 $j$ 个蓝元素没有配对的 $\\sum\\prod$，那么考虑 $i$ 的配对情况转移即可。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nconst int p=998244353;\nconst int S=5005;\n\nstruct node\n{\n\tint x,tpe;\n}c[S*2];\n\nint n,a[S],b[S];\nint dp[S*2][S];\n\ninline int qpow(int x,int y)\n{\n\tint res=1;\n\tfor(;y>0;y>>=1,x=1ll*x*x%p) res=(y&1)?1ll*res*x%p:res;\n\treturn res;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&b[i]);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tc[i*2-1]=(node){a[i],1};\n\t\tc[i*2]=(node){b[i],2};\n\t}\n\tsort(c+1,c+n*2+1,[&](node x,node y){return x.x>y.x;});\n//\tfor(int i=1;i<=n*2;i++) printf(\"%d %d\\n\",c[i].x,c[i].tpe);\n//\tputs(\"---------------------------------------------\");\n\tdp[0][0]=1;\n\tfor(int i=1,cnt1=0;i<=n*2;i++)\n\t{\n\t\tcnt1+=c[i].tpe==1;\n\t\tint cnt2=i-cnt1;\n\t\tfor(int j=0;j<=cnt2;j++)\n\t\t{\n\t\t\tif(c[i].tpe==1)\n\t\t\t{\n\t\t\t\tint bse=j+1;\n\t\t\t\tdp[i][j]=(dp[i-1][j]+1ll*dp[i-1][j+1]*c[i].x%p*bse%p)%p;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint bse=max(0,cnt1-(cnt2-1-j));\n\t\t\t\tdp[i][j]=1ll*dp[i-1][j]*c[i].x%p*bse%p;\n\t\t\t\tif(j>0) dp[i][j]=(dp[i][j]+dp[i-1][j-1])%p;\n\t\t\t}\n//\t\t\tprintf(\"%d \",dp[i][j]);\n\t\t}\n//\t\tprintf(\"\\n\");\n\t}\n\tint fra=1;\n\tfor(int i=1;i<=n;i++) fra=1ll*fra*i%p;\n\tprintf(\"%d\\n\",1ll*dp[n*2][0]*qpow(fra,p-2)%p);\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"数学"},{"name":"组合计数"},{"name":"DP"}],
			"title": "P8321 『JROI-4』沈阳大街 2 做题记录",
			"link": "https://exber.qzz.io/post/P8321%20%E3%80%8EJROI-4%E3%80%8F%E6%B2%88%E9%98%B3%E5%A4%A7%E8%A1%97%202%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-04-14 19:33:28"
		},
	
		{
			"abstract": "> 给定两个排列 $s$ 和 $p$，每次可以交换 $p$ 中的两个数，代价为它们间的距离，问最小代价使 $p$ 变为 $s$。输出方案。 \n> \n> $1\\le n\\le 2000$。\n",
			"content": "> 给定两个排列 $s$ 和 $p$，每次可以交换 $p$ 中的两个数，代价为它们间的距离，问最小代价使 $p$ 变为 $s$。输出方案。 \n> \n> $1\\le n\\le 2000$。\n\n遇到这种题一定要考虑答案下界和怎么取到。\n\n首先设 $pos_i=j|s_j=p_i$ 即 $p_i$ 要去的位置，那么由于 $p_i$ 应该在 $pos_i$ 而不是 $i$，并且一次交换最多可以让两个数字归位，所以答案下界为 $\\frac{\\sum\\limits_{i=1}^n|i-pos_i|}{2}$。\n\n考虑如何取到这个下界，不难发现，只要保证 $i$ 移动的时候只往 $pos_i$ 的方向移动就行了，也就是 $pos_i<i$ 的 $i$ 只向左运动，$pos_i>i$ 的 $i$ 只向右运动，$pos_i=i$ 的 $i$ 不动就行了。那么考虑按照 $pos_i$ 从大到小逐个操作，先让 $pos_i$ 大的归位，那么操作到 $i$ 的时候若 $i\\not=pos_i$ 则 $i$ 一定要向右运动，并且 $pos_i$ 一定要向左运动；而 $pos_{pos_i}$ 要么 $\\le i$，要么存在 $j\\in[pos_{pos_i},pos_i]$ 满足 $pos_j<pos_{pos_i}$。所以设 $tmp$ 为当前 $i$ 运动到的位置，我们总能找到满足 $j>tmp$ 且 $pos_j<tmp$ 的 $j$ 来让 $tmp$ 和 $j$ 交换。因为这样做每个 $i$ 都只会往 $pos_i$ 移动，所以答案取到了下界。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=2005;\n\nstruct node\n{\n\tint x,y;\n}res[S*S];\n\nint n,a[S],b[S];\nint pos[S],p[S],id[S];\nint tot;\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&b[i]);\n\tfor(int i=1;i<=n;i++) pos[b[i]]=i;\n\tint ans=0;\n\tfor(int i=1;i<=n;i++) ans+=abs((p[i]=pos[a[i]])-i);\n\tfor(int i=1;i<=n;i++) id[p[i]]=i;\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tint pp=id[i];\n\t\tfor(int j=pp+1;j<=i;j++)\n\t\t{\n\t\t\tif(p[j]<=pp)\n\t\t\t{\n\t\t\t\tres[++tot]=(node){pp,j};\n\t\t\t\tswap(p[pp],p[j]);\n\t\t\t\tswap(id[p[pp]],id[p[j]]);\n\t\t\t\tpp=j;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans/2);\n\tprintf(\"%d\\n\",tot);\n\tfor(int i=1;i<=tot;i++)\n\t{\n\t\tprintf(\"%d %d\\n\",res[i].x,res[i].y);\n\t}\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"构造"}],
			"title": "CF584E Anton and Ira 做题记录",
			"link": "https://exber.qzz.io/post/CF584E%20Anton%20and%20Ira%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-04-14 19:29:52"
		},
	
		{
			"abstract": "> 本题为交互题。\n> \n> 有一个字符串 $s$，只由字符 `a` 和 `b` 组成。每次你可以询问一个字符串，它会返回这两个字符串的编辑距离。编辑距离定义为一个字符串经过修改，删除或插入单个字符操作得到另一个字符串，两个字符串编辑距离的定义为最小的操作次数。\n> \n> 你需要在 $|s| + 2$ 次操作内求出字符串 $s$。\n> \n> $1\\le |s|\\le 300$。 \n",
			"content": "> 本题为交互题。\n> \n> 有一个字符串 $s$，只由字符 `a` 和 `b` 组成。每次你可以询问一个字符串，它会返回这两个字符串的编辑距离。编辑距离定义为一个字符串经过修改，删除或插入单个字符操作得到另一个字符串，两个字符串编辑距离的定义为最小的操作次数。\n> \n> 你需要在 $|s| + 2$ 次操作内求出字符串 $s$。\n> \n> $1\\le |s|\\le 300$。 \n\n首先可以通过询问一个 `a` 和一个 `b` 来获得字符串的长度 $n$，这需要两次操作。，然后字符串一定是若干个 `a`，每个 `a` 前面和字符串的最后面都插入了若干个 `b` 这样的，记 $A$ 为 `a` 的数量，$B$ 为 `b` 的数量，若已知 $A$ 则可以在 $A+B=n$ 次操作中得到整个字符串。\n\n接下来的问题变为怎么求 $A$，自己想一直只会暴力用 $A$ 次操作尝试，看了题解才发现可以通过询问一次全 `a` 串来求。\n\n这样做是 $n+3$ 次的，考虑优化，受到询问全 `a` 求 $A$ 的启发，不难想到可以询问一次长 $300$ 的全 `a` 串和一次长为 $300$ 的全 `b` 串来获得 $A$、$B$ 和 $n$，这样询问次数就是 $n+2$ 了。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=305;\n\nchar a[S],ans[S];\n\ninline int que(int n)\n{\n\ta[n+1]=0;\n\tprintf(\"%s\\n\",a+1);\n\tfflush(stdout);\n\tint res;\n\tscanf(\"%d\",&res);\n\treturn res;\n}\n\nint main()\n{\n\tint A,B;\n\tfor(int i=1;i<=300;i++) a[i]='a';\n\tA=300-que(300);\n\tfor(int i=1;i<=300;i++) a[i]='b';\n\tB=300-que(300);\n\tif(A==0)\n\t{\n\t\tfor(int i=1;i<=B;i++) ans[i]='b';\n\t\tans[B+1]=0;\n\t\tprintf(\"%s\\n\",ans+1);\n\t\tfflush(stdout);\n\t\treturn 0;\n\t}\n\tint pre=B,tot=0;\n\tfor(int i=1;i<=A;i++)\n\t{\n\t\twhile(pre!=0)\n\t\t{\n\t\t\tans[++tot]='b';\n\t\t\tfor(int j=1;j<=tot;j++) a[j]=ans[j];\n\t\t\tfor(int j=i;j<=A;j++) a[tot+j-i+1]='a';\n\t\t\tint re=que(tot+A-i+1);\n\t\t\tif(re<pre) pre=re;\n\t\t\telse\n\t\t\t{\n\t\t\t\ttot--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tans[++tot]='a';\n\t}\n\tfor(int i=tot+1;i<=A+B;i++) ans[i]='b';\n\tans[A+B+1]=0;\n\tprintf(\"%s\\n\",ans+1);\n\tfflush(stdout);\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"交互、通信"},{"name":"构造"}],
			"title": "CF1282D Enchanted Artifact 做题记录",
			"link": "https://exber.qzz.io/post/CF1282D%20Enchanted%20Artifact%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-04-14 19:23:31"
		},
	
		{
			"abstract": "> 给你 $n$ 个点和它们的坐标，现在给它们两两连上边，如果在同一组为黄色，不同组为蓝色。现在让你给出任意一种分组方案，使得所有长度相同的边颜色相同。\n> \n> $2 \\le n \\le 10^3$。 \n",
			"content": "> 给你 $n$ 个点和它们的坐标，现在给它们两两连上边，如果在同一组为黄色，不同组为蓝色。现在让你给出任意一种分组方案，使得所有长度相同的边颜色相同。\n> \n> $2 \\le n \\le 10^3$。 \n\n发现两点距离相等等价于两点的距离的平方相等，所以考虑距离的平方。\n\n发现要把距离分成两组，不难想到奇偶性分类。设 $\\operatorname{tpe}(x,y)=\\begin{cases}0&x\\equiv y\\pmod2\\\\1&x\\not\\equiv y\\pmod2\\end{cases}$，由于 $(x1,y1),(x2,y2)$ 的距离的平方 $(x1-x2)^2+(y1-y2)^2$ 为奇数当且仅当 $\\operatorname{tpe}(x1,y1)\\not=\\operatorname{tpe}(x2,y2)$，为偶数当且仅当 $\\operatorname{tpe}(x1,y1)=\\operatorname{tpe}(x2,y2)$，那么把 $\\operatorname{tpe}(x,y)=0$ 的 $(x,y)$ 分到一组，$tpe(x,y)=1$ 的 $(x,y)$ 分到另一组即可。\n\n但是发现 $\\operatorname{tpe}(x,y)$ 有可能都为 $0$ 或者都为 $1$，考虑到平移对距离没有影响，所以当 $\\operatorname{tpe}(x,y)=1$  时让所有 $x$ 同时加上 $1$，这样就可以只讨论 $\\operatorname{tpe}(x,y)=0$ 的情况。\n\n注意到当 $\\operatorname{tpe}(x,y)=0$ 时 $x+y\\equiv x-y\\equiv 0\\pmod2$，所以有一个很奇妙的操作：旋转并拉伸坐标系。具体的，让 $(x,y)\\to(\\frac{x+y}{2},\\frac{x-y}{2})$ 即让 $\\begin{bmatrix}x\\\\y\\end{bmatrix}\\to\\begin{bmatrix}x\\\\y\\end{bmatrix}\\times\\begin{bmatrix}\\frac{1}{2}&\\frac{1}{2}\\\\\\frac{1}{2}&-\\frac{1}{2}\\end{bmatrix}$，由于旋转操作最多进行 $\\log V$ 次，所以这样可以在 $O(n\\log V)$ 的时间复杂度内解决此题。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=100005;\n\nstruct node\n{\n\tint x,y;\n}a[S];\n\nint n;\nint tot,ans[S];\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d%d\",&a[i].x,&a[i].y);\n\twhile(1)\n\t{\n\t\ttot=0;\n\t\tfor(int j=1;j<=n;j++) if((a[j].x&1)==(a[j].y&1)) ans[++tot]=j;\n\t\tif(tot>=1&&tot<=n-1)\n\t\t{\n\t\t\tprintf(\"%d\\n\",tot);\n\t\t\tfor(int j=1;j<=tot;j++) printf(\"%d \",ans[j]);\n\t\t\tprintf(\"\\n\");\n\t\t\tbreak;\n\t\t} \n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tif((a[j].x&1)!=(a[j].y&1)) a[j].x++;\n\t\t\tint tx=a[j].x,ty=a[j].y;\n\t\t\ta[j].x=(tx+ty)/2;\n\t\t\ta[j].y=(tx-ty)/2;\n\t\t}\n\t}\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"构造"},{"name":"数学"}],
			"title": "CF1270E Divide Points 做题记录",
			"link": "https://exber.qzz.io/post/CF1270E%20Divide%20Points%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-04-14 19:17:07"
		},
	
		{
			"abstract": "> 构造 $n$ 的排列，使得其前缀积在 $mod\\,n$ 意义下两两不同。\n> \n> $1 \\leq n \\leq 10^5$。\n",
			"content": "> 构造 $n$ 的排列，使得其前缀积在 $mod\\,n$ 意义下两两不同。\n> \n> $1 \\leq n \\leq 10^5$。\n\n首先显然 $1$ 放最前面，$n$ 放最后面。并且若 $n>4$ 且 $n$ 为合数就一定无解，因为 $n$ 的所有因数都会出现，所以前缀积至少会出现两个 $0$。\n\n那么特判掉 $n\\le 4$ 的情况，考虑 $n>4$ 且 $n$ 为质数的情况。\n\n发现原排列似乎不是很好处理，于是考虑前缀积序列，考虑构造形如 $[1,2,3,4,5,\\dots,n-1,0]$ 这样的前缀积序列，显然原序列一定是这个序列的差商，即 $[1,\\frac{2}{1},\\frac{3}{2}.\\frac{4}{3},\\dots,\\frac{n-1}{n-2},n]$ 这样的。容易发现中间的分数显然和首尾两个数不同，并且中间的分数都是形如 $\\frac{x}{x-1}$ 这样的，统统减去 $1$ 之后变成了 $\\frac{1}{x-1}$，也两两不同，所以整个序列是排列，这样构造合法。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=100005;\n\nint n,ans[S];\n\ninline bool chk(int n)\n{\n\tfor(int i=2;i<=n-1;i++) if(n%i==0) return false;\n\treturn true;\n}\n\ninline int qpow(int x,int y)\n{\n\tint res=1;\n\tfor(;y>0;y>>=1,x=1ll*x*x%n) res=(y&1)?1ll*res*x%n:res;\n\treturn res;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tif(n==1) puts(\"YES\\n1\");\n\telse if(n==2) puts(\"YES\\n1\\n2\");\n\telse if(n==3) puts(\"YES\\n1\\n2\\n3\");\n\telse if(n==4) puts(\"YES\\n1\\n3\\n2\\n4\");\n\telse if(!chk(n)) puts(\"NO\");\n\telse\n\t{\n\t\tans[1]=1,ans[n]=n;\n\t\tfor(int i=2;i<=n-1;i++) ans[i]=1ll*i*qpow(i-1,n-2)%n;\n\t\tputs(\"YES\");\n\t\tfor(int i=1;i<=n;i++) printf(\"%d\\n\",ans[i]);\n\t}\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"构造"}],
			"title": "CF487C Prefix Product Sequence 做题记录",
			"link": "https://exber.qzz.io/post/CF487C%20Prefix%20Product%20Sequence%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-04-14 19:10:14"
		},
	
		{
			"abstract": "> 给定一个含有 $n$ 个正整数的序列 $a$ ，对于一次操作，你可以任选一个位置 $i$ 且满足 $a_i=i$，那么就可以移除这个元素，并将后面所有的元素向前移动一位。\n> \n> 对于每个相互独立的询问 $x,y$ 需要你求出在前 $x$ 个元素以及后 $y$ 个元素不能被移除的情况下，最多可以进行几次操作。\n> \n> $n,q \\leq 3\\times 10^5$。\n",
			"content": "> 给定一个含有 $n$ 个正整数的序列 $a$ ，对于一次操作，你可以任选一个位置 $i$ 且满足 $a_i=i$，那么就可以移除这个元素，并将后面所有的元素向前移动一位。\n> \n> 对于每个相互独立的询问 $x,y$ 需要你求出在前 $x$ 个元素以及后 $y$ 个元素不能被移除的情况下，最多可以进行几次操作。\n> \n> $n,q \\leq 3\\times 10^5$。\n\n首先不难想到让 $a_i\\to i-a_i$，这样问题就转变为每次操作可以删去 $a_i=0$ 的 $a_i$ 并且让 $a_{[i+1,n]}$ 减去 $1$。\n\n不难发现 $a_i$ 能被删掉当且仅当 $a_{[1,i-1]}$ 中有至少 $a_i$ 个能被删掉，因为删掉 $a_i$ 的这次操作可以插到删掉 $a_i$ 个数之后。\n\n发现询问相当于选一个区间 $[l,r]$ 里的 $a_i$ 出来算答案。在线不太好做，考虑离线。\n\n把询问离线到序列上，把询问按 $r$ 从小到大排序，处理到第 $i$ 个询问的时候把把 $a_{[1,r_i]}$ 都加入某个可以维护从 $i$ 开始操作的答案 $f_i$ 的数据结构里即可。\n\n考虑怎么维护 $f_i$，不难发现它具有单调性，即满足 $f_i\\ge f_{i+1}$，那么设 $k$ 满足 $f_1\\ge f_2\\ge f_3\\ge\\dots\\ge f_k\\ge a_i > f_{k+1}\\ge\\dots\\ge f_n$，则 $a_i$ 对 $f_{[1,k]}$ 都有 $1$ 的贡献。不难发现这个可以用树状数组维护，由于每次都是 $[1,x]$ 这样的区间，所以干脆直接维护每个位置减了多少次，然后找 $k$ 就可以用树状数组上二分来维护。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=300005;\n\nstruct node\n{\n\tint l,r,id;\n}que[S];\n\nint n,m;\nint a[S],c[S];\nint ans[S];\n\ninline void addt(int pos,int x)\n{\n\tfor(int i=pos;i<=n;i+=i&-i) c[i]+=x;\n}\n\ninline int quet(int pos)\n{\n\tint res=0;\n\tfor(int i=pos;i>=1;i-=i&-i) res+=c[i];\n\treturn res;\n}\n\ninline int fndk(int k)\n{\n\tint pos=0,val=0;\n\tfor(int i=20;i>=0;i--)\n\t{\n\t\tint nxt=pos+(1<<i);\n\t\tif(nxt<=n&&val+c[nxt]<=k) val+=c[nxt],pos=nxt;\n\t}\n\treturn pos;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]),a[i]=i-a[i];\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tque[i].l=x+1,que[i].r=n-y;\n\t\tque[i].id=i;\n\t}\n\tsort(que+1,que+m+1,[&](node x,node y){return x.r<y.r;});\n\tint j=1;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tfor(;j<=n&&j<=que[i].r;j++)\n\t\t{\n\t\t\tif(a[j]<0)\n\t\t\t{\n\t\t\t\taddt(1,1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint k=min(fndk(j-1-a[j]),j);\n\t\t\taddt(k+1,1);\n\t\t}\n\t\tans[que[i].id]=j-1-quet(que[i].l);\n\t}\n\tfor(int i=1;i<=m;i++) printf(\"%d\\n\",ans[i]); \n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"数据结构"}],
			"title": "CF1404C Fixed Point Removal 做题记录",
			"link": "https://exber.qzz.io/post/CF1404C%20Fixed%20Point%20Removal%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-04-14 18:58:42"
		},
	
		{
			"abstract": "> 给定 $n$ 个结点的无向完全图。每个点有一个点权为 $a_i$。连接 $i$ 号结点和 $j$ 号结点的边的边权为 $a_i\\oplus a_j$。\n> \n> 求这个图的 MST 的权值。\n> \n> $1\\le n\\le 2\\times 10^5$，$0\\le a_i< 2^{30}$。\n",
			"content": "> 给定 $n$ 个结点的无向完全图。每个点有一个点权为 $a_i$。连接 $i$ 号结点和 $j$ 号结点的边的边权为 $a_i\\oplus a_j$。\n> \n> 求这个图的 MST 的权值。\n> \n> $1\\le n\\le 2\\times 10^5$，$0\\le a_i< 2^{30}$。\n\n看到异或最小，想到 01 trie。\n\n不妨先把所有数插入 01 trie，然后问题就变成不断选 lca 来合并这些点。不难发现 lca 深度越大越好，所以可以跑一遍 dfs，遍历到 $u$ 的时候：\n\n- 若 $u$ 没有儿子，回溯；\n- 若 $u$ 只有一个儿子，往唯一的儿子递归；\n- 若 $u$ 有两个儿子，通过遍历左子树内所有的数来求合并两个子树的最小代价，给答案加上这个代价，再往两个儿子递归；\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=5000005,BS=30;\n\nint n,a[S];\nint cnt=1,son[S][2];\nint lb[S],rb[S];\nlong long ans;\n\nvoid dfs1(int u)\n{\n\tif(lb[u]==0&&rb[u]==0) lb[u]=1e8,rb[u]=0;\n\tif(son[u][0]!=0)\n\t{\n\t\tint v=son[u][0];\n\t\tdfs1(v);\n\t\tlb[u]=min(lb[u],lb[v]),rb[u]=max(rb[u],rb[v]);\n\t}\n\tif(son[u][1]!=0)\n\t{\n\t\tint v=son[u][1];\n\t\tdfs1(v);\n\t\tlb[u]=min(lb[u],lb[v]),rb[u]=max(rb[u],rb[v]);\n\t}\n}\n\ninline int que(int val,int rt,int bse)\n{\n\tint u=rt,res=0;\n\tfor(int i=bse;i>=0;i--)\n\t{\n\t\tint id=val>>i&1;\n\t\tif(son[u][id]==0) u=son[u][id^1],res+=1<<i;\n\t\telse u=son[u][id];\n\t}\n\treturn res;\n}\n\nvoid dfs2(int u,int bse)\n{\n\tif(son[u][0]!=0) dfs2(son[u][0],bse-1);\n\tif(son[u][1]!=0) dfs2(son[u][1],bse-1);\n\tif(son[u][0]!=0&&son[u][1]!=0)\n\t{\n\t\tint mn=que(a[lb[son[u][0]]],son[u][1],bse-1);\n\t\tfor(int i=lb[son[u][0]]+1;i<=rb[son[u][0]];i++) mn=min(mn,que(a[i],son[u][1],bse-1));\n\t\tans+=(long long)mn+(1<<bse);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint u=1;\n\t\tfor(int j=BS;j>=0;j--)\n\t\t{\n\t\t\tint id=a[i]>>j&1;\n\t\t\tif(son[u][id]==0) son[u][id]=++cnt;\n\t\t\tu=son[u][id];\n\t\t}\n\t\tlb[u]=rb[u]=i;\n\t}\n\tdfs1(1);\n\tdfs2(1,BS);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"数据结构"}],
			"title": "CF888G Xor-MST 做题记录",
			"link": "https://exber.qzz.io/post/CF888G%20Xor-MST%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-04-14 17:16:43"
		},
	
		{
			"abstract": "> 输入正整数 $n,m$，要求把一个 $n \\times m$ 的棋盘染成蓝色和黄色，且每行恰好有一段蓝色的格子，每列恰好有一段黄色的格子。输出总方案数对 $998244353$ 取模的结果。\n>\n> $n,m\\le2021$。\n",
			"content": "> 输入正整数 $n,m$，要求把一个 $n \\times m$ 的棋盘染成蓝色和黄色，且每行恰好有一段蓝色的格子，每列恰好有一段黄色的格子。输出总方案数对 $998244353$ 取模的结果。\n>\n> $n,m\\le2021$。\n\n\nCF *3100 虚高。\n\n显然合法的棋盘是长这样的：\n\n![](../post-images/1680916191113.png)\n\n抽象一点：\n\n![](../post-images/1680916200743.png)\n\n大概就是上面一个山坡下面一个山坡，并且两个山坡没有接触。\n\n先考虑怎么数山坡的方案数，显然可以把山坡劈成单调不降的两段，设 $dp_{i,j}$ 表示 $i$ 根柱子，最高的柱子（第 $i$ 根）高 $j$ 的方案数，显然有 $dp_{0,0}=1$，转移为：\n$$\ndp_{i,j}=\\sum\\limits_{k=0}^{j}dp_{i-1,k}\n$$\n接下来考虑拼接形成山坡，由于上面的山坡和下面的山坡不能有接触，但是每一行都必须有某一个山坡经过，所以两个山坡最高的柱子之间只有两种情况：\n\n![](../post-images/1680916210983.png)\n\n（最高的柱子交错）\n\n和：\n\n![](../post-images/1680916219715.png)\n\n（最高的柱子高度和为 $n$）\n\n交错的情况很简单，显然两根最高的柱子一定是相邻的，那么把网格劈成两半，算出 $dp2_{i,j}$ 表示上下都有 $i$ 根柱子，下面最高的那根柱子长度为 $j$，上面最高的那根柱子长度 $\\le n-j-1$ 的方案数，显然有 $dp2_{i,j}=dp_{i,j}\\times\\sum\\limits_{k=0}^{n-j-1}dp_{i,k}$。然后枚举左边的那一半有多长和上面最高的柱子的高度，和右边拼起来即可：\n$$\nans1=\\sum\\limits_{i=1}^{m-1}\\sum\\limits_{j=2}^{n-1}dp2_{i,j}\\times\\sum\\limits_{k=n-j+1}^{n-1}dp2_{m-i,k}\n$$\n高度和为 $n$ 的情况有点麻烦，不难发现上面的最高柱子区间和下面的最高柱子区间一定不相交，那么仍旧把网格劈成两半，求出 $dp3_{i,j}$ 表示一共有 $i$ 个柱子可以是最高的，最高的柱子高度为 $j$ 时山坡的方案，显然有 $dp3_{i,j}=dp_{i,j}\\times\\sum\\limits_{k=0}^{j-1}dp_{m-i,k}$。然后强制让上面最高柱子的区间右端点为 $i$，枚举下面最高柱子的区间左端点 $j$ 即可：\n$$\nans2=\\sum\\limits_{i=1}^{m-1}\\sum\\limits_{j=1}^{n-1}dp3_{i,j}\\times\\sum\\limits_{k=i+1}^{m}dp3_{m-i+1,n-j}\n$$\n答案即为 $ans=2(ans1+ans2)$ 因为上下可以反过来。\n\n不难发现所有式子都可以用前缀和优化到 $O(nm)$，那么就做完了。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nconst int S=3005,p=998244353;\n\nint n,m;\nint dp[S][S],sm[S][S];\nint sm2[S][S];\n\ninline void add(int &x,int y)\n{\n\tx+=y;\n\tif(x>=p) x-=p;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tdp[0][0]=1;\n\tfor(int i=0;i<=n;i++) sm[0][i]=1;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tfor(int j=0;j<=n;j++) dp[i][j]=sm[i-1][j];\n\t\tfor(int j=0;j<=n;j++)\n\t\t{\n\t\t\tif(j>0) sm[i][j]=sm[i][j-1];\n\t\t\tadd(sm[i][j],dp[i][j]);\n\t\t}\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tfor(int j=n-1;j>=0;j--)\n\t\t{\n\t\t\tsm2[i][j]=sm2[i][j+1];\n\t\t\tadd(sm2[i][j],1ll*dp[i][j]*sm[i][n-j-1]%p);\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=m-1;i++)\n\t{\n\t\tfor(int j=2;j<=n-1;j++)\n\t\t{\n\t\t\tint pre=1ll*dp[i][j]*sm[i][n-j-1]%p*sm2[m-i][n-j+1]%p;\n\t\t\tadd(ans,pre);\n\t\t}\n\t}\n\tmemset(sm2,0,sizeof(sm2));\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tfor(int j=1;j<=n-1;j++)\n\t\t{\n\t\t\tint pre=1ll*dp[i][j]*sm[m-i][j-1]%p;\n\t\t\tsm2[i][j]=sm2[i-1][j];\n\t\t\tadd(sm2[i][j],pre);\n\t\t}\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tfor(int j=1;j<=n-1;j++)\n\t\t{\n\t\t\tint pre=1ll*dp[i][j]*sm[m-i][j-1]%p*sm2[m-i][n-j]%p;\n\t\t\tadd(ans,pre);\n\t\t}\n\t}\n\tans=2ll*ans%p;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"数学"},{"name":"组合计数"},{"name":"DP"}],
			"title": "CF1503E 2-Coloring 做题记录",
			"link": "https://exber.qzz.io/post/CF1503E%202-Coloring%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-04-08 09:09:37"
		},
	
		{
			"abstract": "> 题目包含 $Q$ 组数据。\n> \n> 对于每一组数据，给出 $p$，使得 $n=2^p$，给出一棵 $n$ 个点的树的边，你要定出树的根，和树上的所有点权和边权，使得所有点权和边权构成一个 $1 \\sim 2 n - 1$ 的排列，且从根到**每个节点和每条边**的**简单路径**上点权和边权的异或和的**最大值最小**。输出方案。\n> \n> $1\\le p\\le 17$。\n",
			"content": "> 题目包含 $Q$ 组数据。\n> \n> 对于每一组数据，给出 $p$，使得 $n=2^p$，给出一棵 $n$ 个点的树的边，你要定出树的根，和树上的所有点权和边权，使得所有点权和边权构成一个 $1 \\sim 2 n - 1$ 的排列，且从根到**每个节点和每条边**的**简单路径**上点权和边权的异或和的**最大值最小**。输出方案。\n> \n> $1\\le p\\le 17$。\n\n首先显然答案下界是 $2^p$，因为无论如何都至少有一条简单路径的异或和二进制第 $p$ 位为 $1$。\n\n那么不妨猜测能取到下界，尝试构造并证明之。\n\n不妨设根为 $1$，令 $a_1=2^p$，接下来往下递归：\n\n- 若此时异或和为 $2^p$，那么让边权为 $2^p+c$（$c$ 是一个常数），子节点点权为 $c$，让异或和变成 $0$；\n- 若此时异或和为 $0$，那么让边权为 $c$，子节点点权为 $2^p+c$，让异或和变成 $2^p$；\n\n不难发现，这样构造除了根之外的所有节点都需要不同的 $c$，由于不同的 $c$ 共有 $n-1$ 个，所以刚好够。\n\n代码如下：\n\n```cpp\n// Problem: CF1670E Hemose on the Tree\n// Contest: Luogu\n// URL: https://www.luogu.com.cn/problem/CF1670E\n// Memory Limit: 250 MB\n// Time Limit: 2000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=500005;\n\nint p,n;\nint esum,to[S],id[S],nxt[S],h[S];\nint c;\nint a[S],b[S];\n\ninline void add(int x,int y,int idx)\n{\n\tto[++esum]=y;\n\tid[esum]=idx;\n\tnxt[esum]=h[x];\n\th[x]=esum;\n}\n\nvoid dfs(int u,int fa,bool isn)\n{\n\tfor(int i=h[u];i;i=nxt[i])\n\t{\n\t\tint v=to[i];\n\t\tif(v==fa) continue;\n\t\tc++;\n\t\tb[id[i]]=c+(isn?n:0);\n\t\ta[v]=c+(isn?0:n);\n\t\tdfs(v,u,!isn);\n\t}\n}\n\nvoid slove()\n{\n\tscanf(\"%d\",&p);\n\tn=1<<p;\n\tesum=0;\n\tfor(int i=1;i<=n;i++) h[i]=0;\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y,i),add(y,x,i);\n\t}\n\ta[1]=n;\n\tc=0;\n\tdfs(1,0,true);\n\tputs(\"1\");\n\tfor(int i=1;i<=n;i++) printf(\"%d \",a[i]);\n\tprintf(\"\\n\");\n\tfor(int i=1;i<=n-1;i++) printf(\"%d \",b[i]);\n\tprintf(\"\\n\");\n}\n\nint main()\n{\n\tint T;\n\tscanf(\"%d\",&T);\n\twhile(T-->0) slove();\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"构造"}],
			"title": "CF1670E Hemose on the Tree 做题记录",
			"link": "https://exber.qzz.io/post/CF1670E%20Hemose%20on%20the%20Tree%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-04-08 09:06:42"
		},
	
		{
			"abstract": "",
			"content": "Prufer 序列是一种常用于解决树的计数问题的序列，它是一种无根树到序列的双射。\n\n## 定义\n\n一棵无根树的 Prufer 序列是这样定义的：\n\n- 删掉叶子节点（度为 $1$）中编号最小的节点，把与它相连的节点的编号加入序列的末尾\n\n- 重复这个操作直到剩余节点数为 $2$\n\nPrufer 序列的构造过程可以看作是一层一层地把树扒开（\n\n很明显，Prufer 序列和无根树互为双射，一棵 $n$ 个节点的无根树的 Prufer 序列长度为 $n-2$。\n\n## 运用\n\n- 一棵 $n$ 个节点的无根树共有 $n^{n-2}$ 种形态，因为 Prufer 序列的每一位都可以任选；\n\n- 一棵 $n$ 个节点的**有根树**共有 $n^{n-1}$ 种形态；\n\n- 某个节点 $u$ 的度数是它在 Prufer 序列中的出现次数 $+1$；\n\n- 一棵 $m$ 个节点，第 $i$ 个节点有 $a_i$ 种**连接方式**的无根树共有 $(\\sum\\limits_{i=1}^m a_i)^{m-2}\\prod\\limits_{i=1}^m a_i$ 种；\n\n  证明如下：\n\n  考虑生成出来的树的长度为 $m-2$ 的 Prufer 序列，显然每个位置可以任选。$i$ 的度即为它在 Prufer 序列中出现的次数 $+1$，所以 $i$ 的贡献是 $a_i^{\\text{出现次数}+1}$，把 $+1$ 拉出来，变成 $(\\prod a_i^{\\text{出现次数}})(\\prod a_i)$。\n\n  所有情况下的 $\\prod a_i^{\\text{出现次数}}$ 之和显然和 $(\\sum a_i)^{m-2}$ 是等价的，得证。\n  \n- 一棵 $m$ 个节点，第 $i$ 个节点有 $a_i$ 个**接口**（只能用一次）的无根树共有 $\\dbinom{\\sum\\limits_{i=1}^ma_i-m}{m-2}(m-2)!\\prod\\limits_{i=1}^m a_i$ 种；\n\n- $n\\times m$ 的完全二分图的无根生成树共有 $n^{m-1}m^{n-1}$ 种，第 $i$ 个点有 $a_i$ 种**连接方式**或**接口**的方案数同理；\n\n  证明如下：\n\n  考虑每个点被删掉时会在序列中加入一个另一部的点，但是最后剩两个点时会停止。\n  \n  被删掉的点的顺序没关系，因为是按编号删去的。\n\n## 例题\n\n- 板子：[CF156D Clues](https://www.luogu.com.cn/problem/CF156D)\n\n- 板子：[P2290 [HNOI2004]树的计数](https://www.luogu.com.cn/problem/P2290)\n\n- 板子，但是下降幂：[ARC106F](https://atcoder.jp/contests/arc106/tasks/arc106_f)\n\n  > 设 $cnt_i$ 为 $i$ 在 Prufer 序列中的出现次数，那么答案为：\n  >\n  >\n  > $$\n  > \\begin{aligned}\n  > &\\prod d_i^{\\underline{cnt_i+1}}\\\\\n  > &=\\left(\\prod d_i\\right)\\prod (d_i-1)^{\\underline{cnt_i}}\\\\\n  > &=\\left(\\prod d_i\\right)\\left(\\sum d_i-1\\right)^{\\underline{n-2}}\\\\\n  > \\end{aligned}\n  > $$\n\n- 二分图板子：【2024NOI模拟赛24】通道\n",
			"tags": [{"name":"学习笔记"},{"name":"数学"},{"name":"组合计数"}],
			"title": "Prufer 序列学习笔记",
			"link": "https://exber.qzz.io/post/Prufer%20%E5%BA%8F%E5%88%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-04-08 09:05:12"
		},
	
		{
			"abstract": "",
			"content": "李超树是一种用来维护直线的数据结构，可以在 $O(\\log V)$ 的时间复杂度内求出所有直线中在 $x=k$ 处的最大 $y$ 取值。\n\n考虑用线段树去维护这个东西，可以让每个节点维护在它的区间中点 $x=mid$ 处 $y$ 最大的直线，每新插入一条直线时，若这条直线在 $x=mid$ 处的 $y$ 取值比 $u$ 上之前的直线小，那么分两种情况：\n\n- 当前直线的斜率 $k'$ 大于之前直线的斜率 $k$，此时这条直线往左走肯定比 $u$ 上之前的直线低，那么只能往右走，所以递归插入右儿子；\n- 当前直线的斜率 $k'$ 小于之前直线的斜率 $k$，此时这条直线往右走肯定比 $u$ 上之前的直线低，那么只能往左走，所以递归插入左儿子；\n\n否则若这条直线在 $x=mid$ 处的 $y$ 取值大于等于 $u$ 上之前的直线，那么更新 $u$ 上的直线，并且把之前 $u$ 上的直线往下插入。\n\n查询 $k$ 时不断在线段树上往 $k$ 递归，把路径上的线段在 $x=k$ 处的取值取个 $\\max$ 即可，正确性显然。\n\n注意每个节点的直线要初始化为 $y=0x+(-\\infin)$。\n\n代码如下：\n\n```cpp\nstruct node\n{\n\tint k,b;\n\tinline int slove(int x) {return k*x+b;}\n}mx[S<<2];\n\ninline void built(int u,int l,int r)\n{\n\tmx[u].k=0;\n\tmx[u].b=-1e8;\n\tif(l==r) return;\n\tint mid=l+r>>1;\n\tbuilt(u<<1,l,mid),built(u<<1|1,mid+1,r);\n}\n\nvoid ins(int u,int l,int r,node val)\n{\n\tif(l==r) return void(mx[u]=(val.slove(l)>mx[u].slove(l)?val:mx[u]));\n\tint mid=l+r>>1;\n\tint pre=val.slove(mid);\n\tif(pre>mx[u].slove(mid)) swap(val,mx[u]);\n\tif(val.k>mx[u].k) ins(u<<1|1,mid+1,r,val);\n\telse ins(u<<1,l,mid,val);\n}\n\nint que(int u,int l,int r,int x)\n{\n\tif(l==r) return mx[u].slove(x);\n\tint mid=l+r>>1;\n\tif(x<=mid) return max(mx[u].slove(x),que(u<<1,l,mid,x));\n\telse return max(mx[u].slove(x),que(u<<1|1,mid+1,r,x));\n}\n```\n",
			"tags": [{"name":"学习笔记"},{"name":"数据结构"}],
			"title": "李超线段树学习笔记",
			"link": "https://exber.qzz.io/post/%E6%9D%8E%E8%B6%85%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-04-08 08:58:50"
		},
	
		{
			"abstract": "> 给定 $n$ 和一个 $n$ 的排列 $a$，考虑以下过程：\n> \n> 维护一个初始为空的栈，然后从 $1$ 到 $n$ 枚举 $i$：\n> - $a_i$ 比栈顶严格大或栈为空，那么把 $a_i$ 加入栈中；\n> - 否则：\n>   * 把栈顶弹出，并把 $a_i$ 加入栈中。注意，你需要保证操作完成后栈中元素从底到顶严格单调递增；\n>   * 什么也不干；\n> \n> 请你求出最后栈大小的最大值。\n> \n> $1\\le n\\le 5\\times 10^5$。\n",
			"content": "> 给定 $n$ 和一个 $n$ 的排列 $a$，考虑以下过程：\n> \n> 维护一个初始为空的栈，然后从 $1$ 到 $n$ 枚举 $i$：\n> - $a_i$ 比栈顶严格大或栈为空，那么把 $a_i$ 加入栈中；\n> - 否则：\n>   * 把栈顶弹出，并把 $a_i$ 加入栈中。注意，你需要保证操作完成后栈中元素从底到顶严格单调递增；\n>   * 什么也不干；\n> \n> 请你求出最后栈大小的最大值。\n> \n> $1\\le n\\le 5\\times 10^5$。\n\n首先若设 $nxt_i=\\min\\{j|j>i\\and a_j>a_i\\}$，$dp_i$ 表示以 $a_i$ 结尾且最终序列包含 $a_i$ 的最长子序列长度，那么 $dp_i+1$ 能转移到 $dp_j$ 当且仅当 $j\\in[nxt_i,nxt_{nxt_i}-1]$ 且 $a_j>a_i$。\n\n考虑消除 $a_j>a_i$ 这个限制，一种巧妙的做法是按照 $a_i$ 从小到大枚举 $i$。消掉限制后直接用线段树维护转移即可。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nconst int S=500005;\n\nint n,a[S],pos[S];\nint top,sta[S];\nint nxt[S];\nint tag[S<<2],mx[S<<2],dp[S];\n\ninline void addtag(int u,int val)\n{\n\ttag[u]=max(tag[u],val),mx[u]=max(mx[u],val);\n}\n\ninline void dwntag(int u)\n{\n\taddtag(u<<1,tag[u]),addtag(u<<1|1,tag[u]);\n\ttag[u]=-1e8;\n}\n\nvoid upd(int u,int l,int r,int L,int R,int val)\n{\n\tif(l>R||r<L) return;\n\tif(l>=L&&r<=R)\n\t{\n\t\taddtag(u,val);\n\t\treturn;\n\t}\n\tdwntag(u);\n\tint mid=l+r>>1;\n\tif(L<=mid) upd(u<<1,l,mid,L,R,val);\n\tif(R>=mid+1) upd(u<<1|1,mid+1,r,L,R,val);\n\tmx[u]=max(mx[u<<1],mx[u<<1|1]);\n}\n\nint que(int u,int l,int r,int pos)\n{\n\tif(l==r) return mx[u];\n\tdwntag(u);\n\tint mid=l+r>>1;\n\tif(pos<=mid) return que(u<<1,l,mid,pos);\n\telse return que(u<<1|1,mid+1,r,pos);\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]),pos[a[i]]=i;\n\tpos[a[0]=0]=0;\n\tsta[top=0]=n+1;\n\tfor(int i=n;i>=0;i--)\n\t{\n\t\twhile(top>0&&a[sta[top]]<a[i]) top--;\n\t\tnxt[i]=sta[top];\n\t\tsta[++top]=i;\n\t}\n\tmemset(mx,128,sizeof(mx));\n\tmemset(tag,128,sizeof(tag));\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tint id=pos[i];\n\t\tint lb=nxt[id],rb=nxt[nxt[id]]-1;\n\t\tdp[id]=id==0?0:que(1,1,n,id);\n\t\tif(lb>rb) continue;\n\t\tif(lb<1||rb>n) continue;\n\t\tupd(1,1,n,lb,rb,dp[id]+1);\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;i++) ans=max(ans,dp[i]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"DP"}],
			"title": "【Public Judge NOIP Round 2】排序 做题记录",
			"link": "https://exber.qzz.io/post/%E3%80%90Public%20Judge%20NOIP%20Round%202%E3%80%91%E6%8E%92%E5%BA%8F%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-04-08 08:52:49"
		},
	
		{
			"abstract": "> 给一棵 $n$ 个点的树，构造 $n$ 条线段，要求每个端点都是 $[1,2n]$ 中的整数且不重复，并使得两个点 $i,j$ 在树上有边，当且仅当线段 $i,j$ 相交且不包含。\n> \n> $1 \\le n \\le 5 \\cdot 10^5$。\n",
			"content": "> 给一棵 $n$ 个点的树，构造 $n$ 条线段，要求每个端点都是 $[1,2n]$ 中的整数且不重复，并使得两个点 $i,j$ 在树上有边，当且仅当线段 $i,j$ 相交且不包含。\n> \n> $1 \\le n \\le 5 \\cdot 10^5$。\n\n不难发现两个区间相交但不包含只有两种情况：$x$ 在 $y$ 左边或者 $y$ 在 $x$ 左边，那么不妨钦定 $u$ 的区间在它父亲 $fa$ 的区间右边和 $fa$ 的区间相交，在左边和它儿子 $v$ 的区间相交，构造这样的东西：（红框是递归构造下去的儿子的子树）\n\n![](../post-images/1680914598860.png)\n\n这样递归构造一定是合法的，设节点 $u$ 的儿子个数为 $son_u$，那么 $u$ 的区间除去属于它父亲和兄弟的部分后长度只有 $son_u+1$，刚好够连接 $u$ 的所有儿子，所以没有任何位置浪费。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=1000005;\n\nint n;\nint esum,to[S],nxt[S],h[S];\nint rig,l[S],r[S];\n\ninline void add(int x,int y)\n{\n\tto[++esum]=y;\n\tnxt[esum]=h[x];\n\th[x]=esum;\n}\n\nvoid dfs(int u,int fa)\n{\n\tint cnt=0;\n\tfor(int i=h[u];i;i=nxt[i]) cnt+=to[i]!=fa;\n\trig=r[u]=rig+cnt+1;\n\tint lft=rig;\n\tfor(int i=h[u];i;i=nxt[i])\n\t{\n\t\tint v=to[i];\n\t\tif(v==fa) continue;\n\t\tl[v]=--lft;\n\t\tdfs(v,u);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y),add(y,x);\n\t}\n\trig=l[1]=1;\n\tdfs(1,0);\n\tfor(int i=1;i<=n;i++) printf(\"%d %d\\n\",l[i],r[i]);\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"构造"}],
			"title": "CF1278E Tests for problem D 做题记录",
			"link": "https://exber.qzz.io/post/CF1278E%20Tests%20for%20problem%20D%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-04-08 08:42:26"
		},
	
		{
			"abstract": "> 给定奇数 $k$ 和长度分别为 $n,m$ 的序列 $a,b$，序列 $a$ 包含所有整数 $i$ 满足 $1\\leq i\\leq n$，$b$ 是给定的单调不减的序列。\n> \n> 现在你可以进行零次或若干次操作，每次操作选择序列 $a$ 的 $k$ 个整数，然后删除这 $k$ 个数里除了他们的中位数的其他 $(k-1)$ 个数。\n> \n> 求能否通过零次或若干次操作从序列 $a$ 的到序列 $b$。能就输出 `YES`，不能输出 `NO`。\n> \n> $3\\leq n\\leq 2\\times 10^5;3\\leq k\\leq n;1\\leq m<n$，$1\\leq b_1<b_2<...<b_m\\leq n$。\n",
			"content": "> 给定奇数 $k$ 和长度分别为 $n,m$ 的序列 $a,b$，序列 $a$ 包含所有整数 $i$ 满足 $1\\leq i\\leq n$，$b$ 是给定的单调不减的序列。\n> \n> 现在你可以进行零次或若干次操作，每次操作选择序列 $a$ 的 $k$ 个整数，然后删除这 $k$ 个数里除了他们的中位数的其他 $(k-1)$ 个数。\n> \n> 求能否通过零次或若干次操作从序列 $a$ 的到序列 $b$。能就输出 `YES`，不能输出 `NO`。\n> \n> $3\\leq n\\leq 2\\times 10^5;3\\leq k\\leq n;1\\leq m<n$，$1\\leq b_1<b_2<...<b_m\\leq n$。\n\n遇到这种操作题，可以先考虑无解，然后想最后几次操作的情况，不要想太复杂。\n\n首先若由于每次操作都会删掉 $k-1$ 个数，所以 $n-m\\not\\equiv 0\\pmod{k-1}$ 一定无解。 \n\n考虑最后一次操作，不难发现，中位数一定是最后某个要留下的数，这个数左边和右边都要有 $\\frac{k-1}{2}$ 个要删掉的数。除了这 $k-1$ 个要删掉的数，其它要删掉的数都可以乱删，由于 $n-m\\equiv 0\\pmod{k-1}$，所以可以让其它要删掉的数内部自己匹配。\n\n那么只要找到某个最后要留下的数且这个数两边都至少有 $\\frac{k-1}{2}$ 个要删除的数即有解，否则无解。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=200005;\n\nint n,k,m;\nint b[S],cnt[S];\nint pre[S],suf[S];\n\ninline void slove()\n{\n\tscanf(\"%d%d%d\",&n,&k,&m);\n\tfor(int i=1;i<=m;i++) scanf(\"%d\",&b[i]);\n\tif((n-m)%(k-1)!=0) return void(puts(\"NO\"));\n\tb[0]=0,b[m+1]=n+1;\n\tfor(int i=1;i<=m+1;i++) cnt[i]=b[i]-b[i-1]-1;\n\tpre[0]=suf[m+2]=0;\n\tfor(int i=1;i<=m+1;i++) pre[i]=pre[i-1]+cnt[i];\n\tfor(int i=m+1;i>=1;i--) suf[i]=suf[i+1]+cnt[i];\n\tbool f=false;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint lft=pre[i],rig=suf[i+1];\n\t\tif(lft>=(k-1)/2&&rig>=(k-1)/2) return void(puts(\"YES\"));\n\t}\n\tputs(\"NO\");\n}\n\nint main()\n{\n\tint T;\n\tscanf(\"%d\",&T);\n\twhile(T-->0) slove();\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"构造"}],
			"title": "CF1468H K and Medians 做题记录",
			"link": "https://exber.qzz.io/post/CF1468H%20K%20and%20Medians%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-04-08 08:06:56"
		},
	
		{
			"abstract": "> 有一颗 $n$ 个节点的树 $T$ 和 $m$ 种冰淇淋，树上的第 $i$ 个节点有 $s_i$ 个冰淇淋，且所有相同种类的冰淇淋在树上构成了一个联通块。\n> \n> 构造一个新的图 $G$ ，$G$ 有 $m$ 个节点，$G$ 中的 $u,v$ 之间有边，当且仅当存在至少一个在 $T$ 上的节点满足他同时有第 $u$ 种和第 $v$ 种冰淇淋。\n> \n> 你的任务是用尽可能少的颜色种类数给 $G$ 的每一个节点染色，使得没有两个相邻的节点有相同的颜色，要求输出方案。\n> \n> 注意空的点集也被认为是一个联通块。\n> \n> $1\\le n,m\\le 3\\times 10^{5}$，$0\\le s_{i}\\le 3\\times 10^{5}$，$\\sum s_i\\le 5\\times 10^5$。\n",
			"content": "> 有一颗 $n$ 个节点的树 $T$ 和 $m$ 种冰淇淋，树上的第 $i$ 个节点有 $s_i$ 个冰淇淋，且所有相同种类的冰淇淋在树上构成了一个联通块。\n> \n> 构造一个新的图 $G$ ，$G$ 有 $m$ 个节点，$G$ 中的 $u,v$ 之间有边，当且仅当存在至少一个在 $T$ 上的节点满足他同时有第 $u$ 种和第 $v$ 种冰淇淋。\n> \n> 你的任务是用尽可能少的颜色种类数给 $G$ 的每一个节点染色，使得没有两个相邻的节点有相同的颜色，要求输出方案。\n> \n> 注意空的点集也被认为是一个联通块。\n> \n> $1\\le n,m\\le 3\\times 10^{5}$，$0\\le s_{i}\\le 3\\times 10^{5}$，$\\sum s_i\\le 5\\times 10^5$。\n\n不难发现，由于每个节点上的冰淇淋种类一定构成了一张完全子图，所以颜色数量下界为 $\\max\\limits_{i=1}^n s_i$，猜测答案一定能取到这个下界，尝试证明之。\n\n尝试归纳证明：\n\n1. 首先有且仅有一个根节点的树是合法的；\n2. 考虑根节点 $rt$，假设它的所有儿子的子树都合法，那么因为同种冰淇淋是连通的所以两端冰淇淋颜色相同的边的两端的冰淇淋一定都在 $rt$ 上出现过，颜色一定够用；\n\n综上，证毕。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nconst int S=1000005;\n\nint n,m,mx;\nvector<int> col[S];\nint esum,to[S],nxt[S],h[S];\nint ans[S];\n\ninline void add(int x,int y)\n{\n\tto[++esum]=y;\n\tnxt[esum]=h[x];\n\th[x]=esum;\n}\n\nvoid dfs(int u,int fa)\n{\n\tset<int> st;\n\tfor(int v:col[u]) st.insert(ans[v]);\n\tint cnt=1;\n\tfor(int v:col[u])\n\t{\n\t\tif(ans[v]==0)\n\t\t{\n\t\t\twhile(st.count(cnt)) cnt++;\n\t\t\tans[v]=cnt;\n\t\t\tst.insert(cnt);\n\t\t}\t\n\t}\n\tfor(int i=h[u];i;i=nxt[i])\n\t{\n\t\tint v=to[i];\n\t\tif(v==fa) continue;\n\t\tdfs(v,u);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tmx=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint cnt;\n\t\tscanf(\"%d\",&cnt);\n\t\tmx=max(mx,cnt);\n\t\twhile(cnt-->0)\n\t\t{\n\t\t\tint x;\n\t\t\tscanf(\"%d\",&x);\n\t\t\tcol[i].push_back(x);\n\t\t}\n\t}\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y),add(y,x);\n\t}\n\tdfs(1,0);\n\tprintf(\"%d\\n\",mx);\n\tfor(int i=1;i<=m;i++) printf(\"%d \",ans[i]==0?1:ans[i]);\n\tprintf(\"\\n\");\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"构造"}],
			"title": "CF804C Ice cream coloring 做题记录",
			"link": "https://exber.qzz.io/post/CF804C%20Ice%20cream%20coloring%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-04-08 07:59:32"
		},
	
		{
			"abstract": "",
			"content": "众所周知，若已知一 $n$ 次多项式 $f(x)$ 在 $x=\\{x_0,x_1,x_2,\\dots,x_n\\}$ 这 $n+1$ 个点的值  $\\{y_0,y_1,y_2,\\dots,y_n\\}$，那么就可以唯一确定这个多项式。而拉格朗日插值就是一种根据 $\\{x_0,x_1,x_2,\\dots,x_n\\}$ 和  $\\{y_0,y_1,y_2,\\dots,y_n\\}$ 求出 $f(x)$ 的算法。\n\n不难发现，若我们构造 $n+1$ 个函数 $f_{[0,n]}(x)$，满足 $g_i(x)=\\begin{cases}1&x=x_i\\\\0&x\\not=x_i\\\\??&otherwise\\end{cases}$，那么有 $f(x)=\\sum\\limits_{i=0}^n y_ig_i(x)$。\n\n考虑怎么构造 $g_i(x)$，当 $x\\not=x_i$ 时 $g_i(x)=0$ 显然可以通过让 $g_i(x)=\\prod\\limits_{j\\not=i}x-x_j$，但是当 $x=x_i$ 时 $g_i(x)=\\prod\\limits_{j\\not=i}x_i-x_j$，所以可以让这个东西除掉它，令 $g_i(x)=\\frac{\\prod\\limits_{j\\not=i}x-x_j}{\\prod\\limits_{j\\not=i}x_i-x_j}$ 即可，这样就可以满足以上两个条件。\n\n综上，有：\n$$\n\\begin{aligned}\nf(x)&=\\sum\\limits_{i=0}^n y_ig_i(x)\\\\\n&=\\sum\\limits_{i=0}^n y_i\\frac{\\prod\\limits_{j\\not=i}x-x_j}{\\prod\\limits_{j\\not=i}x_i-x_j}\\\\\n\\end{aligned}\n$$\n按照这个公式直接插值的时间复杂度是 $O(n^2)$ 的。\n\n看一道[例题](https://www.luogu.com.cn/problem/P4781)：\n\n> 给 $n+1$ 个点，请你求出经过这 $n+1$ 个点的 $n$ 次多项式 $f(x)$ 在 $x=k$ 时的取值，对 $998244353$ 取模。\n>\n> $1\\le n\\le 2\\times 10^3$。\n\n直接 $O(n^2)$ 插值然后计算即可。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=2005,p=998244353;\n\nint n,k;\nint x[S],y[S];\n\ninline int qpow(int x,int y=p-2)\n{\n\tint res=1;\n\tfor(;y>0;y>>=1,x=1ll*x*x%p) res=(y&1)?1ll*res*x%p:res;\n\treturn res;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tn--;\n\tfor(int i=0;i<=n;i++) scanf(\"%d%d\",&x[i],&y[i]);\n\tint ans=0;\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tint s1=y[i],s2=1;\n\t\tfor(int j=0;j<=n;j++) if(j!=i) s1=1ll*s1*(k-x[j])%p,s2=1ll*s2*(x[i]-x[j])%p;\n\t\tans=(ans+1ll*s1*qpow(s2)%p+p)%p;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n\n### 实际应用：求自然数幂和 $f_k(x)=\\sum\\limits_{i=1}^x i^k$\n\n首先需要证明这个东西是多项式：\n$$\n\\begin{aligned}\nf_k(x)&=\\sum\\limits_{i=1}^x i^k\\\\\n&=1+\\sum\\limits_{i=1}^{x-1} (i+1)^k\\\\\n&=1+\\sum\\limits_{i=1}^{x-1} \\sum\\limits_{j=0}^{k}\\binom{k}{j}i^j\\\\\n&=1+\\sum\\limits_{j=0}^{k}\\binom{k}{j} \\sum\\limits_{i=1}^{x-1}i^j\\\\\n&=\\sum\\limits_{i=1}^{x-1}i^k+1+\\sum\\limits_{j=0}^{k-1}\\binom{k}{j} f_{j}(x-1)\\\\\n\\end{aligned}\n$$\n\n$$\n\\sum\\limits_{i=1}^x i^k=\\sum\\limits_{i=1}^{x-1}i^k+1+\\sum\\limits_{j=0}^{k-1}\\binom{k}{j} f_{j}(x-1)\\\\\nx^k=1+\\sum\\limits_{j=0}^{k-1}\\binom{k}{j} f_{j}(x-1)\\\\\nx^k-\\binom{k}{k-1}f_{k-1}(x-1)=1+\\sum\\limits_{j=0}^{k-2}\\binom{k}{j} f_{j}(x-1)\\\\\n\\binom{k}{k-1}f_{k-1}(x-1)=x^k-1-\\sum\\limits_{j=0}^{k-2}\\binom{k}{j} f_{j}(x-1)\\\\\nf_{k-1}(x-1)=\\frac{x^k-1-\\sum\\limits_{j=0}^{k-2}\\binom{k}{j} f_{j}(x-1)}{\\binom{k}{k-1}}\\\\\n$$\n\n观察到 $f_0(x)=x$ 是个 $1$ 次多项式，所以 $f_k(x)$ 是 $k+1$ 次多项式。\n\n[例题](https://www.luogu.com.cn/problem/CF622F)：\n\n> 求 $\\sum\\limits_{i=1}^xi^k\\mod 10^9+7$。\n>\n> $1\\le x\\le 10^9,0\\le k\\le 10^6$。\n\n直接拉插即可，但是直接拉插是 $O(k^2)$ 的，所以需要一些优化。\n\n看回拉插式子：\n\n$$f(x)=\\sum\\limits_{i=0}^{k+1} y_i\\frac{\\prod\\limits_{j\\not=i}x-x_j}{\\prod\\limits_{j\\not=i}x_i-x_j}$$\n\n观察到 $x=\\{0,1,2,\\dots,k+1\\}$ 时，$\\prod\\limits_{j\\not=i}x_i-x_j$ 是两个阶乘乘起来，$\\prod\\limits_{j\\not=i}x-x_j$ 可以预处理前缀后缀积，所以可以优化到 $O(k\\log k)$ 预处理，$O(k)$ 插值计算。\n\n代码如下：\n\n```\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=1000005,p=1000000007;\n\nint n,k;\nint y[S];\nint fra[S],inv[S];\nint pre[S],suf[S];\n\ninline int qpow(int x,int y=p-2)\n{\n\tint res=1;\n\tfor(;y>0;y>>=1,x=1ll*x*x%p) res=(y&1)?1ll*res*x%p:res;\n\treturn res;\n}\n\ninline void init(int k)\n{\n\ty[0]=0;\n\tfor(int i=1;i<=k+1;i++) y[i]=(y[i-1]+qpow(i,k))%p;\n\tfra[0]=1;\n\tfor(int i=1;i<=k+1;i++) fra[i]=1ll*fra[i-1]*i%p;\n\tinv[k+1]=qpow(fra[k+1]);\n\tfor(int i=k+1;i>=1;i--) inv[i-1]=1ll*inv[i]*i%p;\n}\n\ninline int calc(int n,int k)\n{\n\tpre[0]=n;\n\tfor(int i=1;i<=k+1;i++) pre[i]=1ll*pre[i-1]*(n-i+p)%p;\n\tsuf[k+1]=(n-k-1+p)%p;\n\tfor(int i=k;i>=0;i--) suf[i]=1ll*suf[i+1]*(n-i+p)%p;\n\tint res=0;\n\tfor(int i=0;i<=k+1;i++)\n\t{\n\t\tint s1=1ll*(i==0?1:pre[i-1])*(i==k+1?1:suf[i+1])%p;\n\t\tint s2=1ll*inv[i]*((k+1-i&1)?p-inv[k+1-i]:inv[k+1-i])%p;\n\t\tres=(res+1ll*y[i]*s1%p*s2%p)%p;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tinit(k);\n\tprintf(\"%d\\n\",calc(n,k));\n\treturn 0;\n}\n```\n\n[例题2](https://www.luogu.com.cn/problem/P4593)：（原题面极其垃圾，给出正确的题面）\n\n> 小豆喜欢玩游戏，现在他在玩一个游戏遇到这样的场面，有 $n-m$ 个怪，血量为 $\\{1,2,3,\\dots,n\\}-\\{a_1,a_2,a_3,\\dots,a_m\\}$。小豆手里有无限张“亵渎”。亵渎的效果是对所有的怪造成 $1$ 点伤害，如果有怪死亡，则再次施放该法术（**再次施放不消耗额外的“亵渎”**）。我们认为血量为 $0$ 怪物死亡。\n>\n> 小豆使用一张“亵渎”会获得一定的分数，在使用一张“亵渎”之后，每一个被该“亵渎”造成伤害的怪会产生 $x^k$ 的分数，其中 $x$ 是造成伤害前怪的血量，$k$ 是杀死所有怪物所需的“亵渎”的张数。\n>\n> 请求出杀死所有怪物后小豆的分数，对 $10^9+7$ 取模。\n>\n> $1\\le m\\le 50,1\\le n\\le 10^{13}$。\n\n不难发现，血量为 $\\{1,2,3,\\dots,n\\}$ 这样连续的怪只需要一张“亵渎”即可杀光，所以 $k=m+1$，并且杀光一段的得分为 $\\sum\\limits_{i=1}^n i^k=\\sum\\limits_{i=1}^n i^{m+1}$。\n\n也就是说，若令 $a_0=0$，$a_1<a_2<a_3<\\dots<a_m$ 即给它排个序，那么答案即为 $\\sum\\limits_{i=0}^m\\sum\\limits_{j=1}^{n-a_i}j^{m+1}-\\sum\\limits_{j=i+1}^{m} (a_j-a_i)^{m+1}$，那么直接拉插即可。\n\n### 更强力的应用：拉格朗日插值优化 dp\n\n[例题](https://www.luogu.com.cn/problem/P4463)：\n\n> 对于给定的 $n$ 和 $k$，一个正整数序列 $a$ 是合法的当且仅当：\n>\n> - $|a|=n$\n> - $1\\le a_i\\le k$\n> - $a_i$ 两两不同\n>\n> $a$ 的权值定义为 $\\prod\\limits_{i=1}^n a_i$，请你求出所有不同的合法的 $a$ 的权值和，其中两个序列 $a,b$ 不同当且仅当有至少一个 $i$ 满足 $1\\le i\\le n$ 且 $a_i\\not=b_i$。\n>\n> $1\\le n\\le 500,1\\le k\\le 10^9$。\n\n首先不难发现只要钦定序列是递增的，最后乘上 $n!$ 就行了。那么就有个朴素的  dp 做法，设 $dp_{i,j}$ 为填完 $a_{[1,i]}$，$1\\le a_i\\le j$ 的不同的 $a$ 的权值和，那么显然有转移 $dp_{i,j}=j\\times dp_{i-1,j-1}+dp_{i,j-1}$。\n\n但是这样做是 $O(nk)$ 的，所以考虑优化。\n\n- **第一种方法：猜测法（无脑，感性）**\n\n不妨猜测 $dp_{i,j}$ 是一个关于 $j$ 的多项式，严谨证明见第二种方法。\n\n那么直接拉插即可，插 $x$ 坐标连续的 $n$ 个点可以做到线性时间复杂度，所以尽可能多算几个 $dp_{n,\\dots}$，插值即可。\n\n毕竟拉插不难写，考场上遇到某一维特别大的 dp 都可以试试。\n\n- **第二种方法：证明法（理性）**\n\n有一个结论：若 $f(x)$ 是 $n$ 次多项式，那么 $f(x)-f(x-1)$ 是 $n-1$ 次多项式。\n\n****\n\n证明如下：\n\n设 $f(x)$ 的 $n$ 次项系数为 $a$，即 $f(x)=\\dots+ax^n$。那么 $f(x)-f(x-1)$ 的 $n$ 次项为：\n$$\n\\begin{aligned}\n&ax^n-a(x-1)^n\\\\\n&=a(x^n-(x-1)^n)\\\\\n&=a\\left(x^n-\\sum\\limits_{i=0}^n\\binom{n}{i}x^i(-1)^{n-i}\\right)\\\\\n&=a\\left(x^n-x^n-\\sum\\limits_{i=0}^{n-1}\\binom{n}{i}x^i(-1)^{n-i}\\right)\\\\\n&=a\\sum\\limits_{i=0}^{n-1}\\binom{n}{i}x^i(-1)^{n-i}\n\\end{aligned}\n$$\n\n***\n\n这个东西是 $n-1$ 次的，得证。\n\n设 $pd_{i,j}$ 为填完 $a_{[1,i]}$，$a_i=j$ 的所有合法序列的权值和，显然有转移 $pd_{i,j}=j\\sum\\limits_{k=1}^{j-1}pd_{i-1,k}$，那么因为 $pd_{1,j}$ 是关于 $j$ 的 $0$ 次多项式，并且以 $j$ 为上界的求和会使次数加一，乘上 $j$ 也会使次数加一，所以 $pd_{i,j}$ 是关于 $j$ 的 $2i$ 次多项式。\n\n因为 $pd_{i,j}=dp_{i,j}-dp_{i,j-1}$，作差会使次数减 $1$，所以 $dp_{i,j}$ 是关于 $j$ 的 $2i+1$ 次多项式。\n\n那么问题就变得简单起来了，$O(n^2)$ 求出 $dp_{n,[0,2n+1]}$ 后直接拉插即可。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=1005;\n\nint k,n,p;\nint dp[S][S];\n\ninline int qpow(int x,int y)\n{\n\tint res=1;\n\tfor(;y>0;y>>=1,x=1ll*x*x%p) res=(y&1)?1ll*res*x%p:res;\n\treturn res;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\",&k,&n,&p);\n\tfor(int i=0;i<=n*2+1;i++) dp[1][i]=(i+dp[1][i-1])%p;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tdp[i][0]=0;\n\t\tfor(int j=1;j<=n*2+1;j++) dp[i][j]=(1ll*j*dp[i-1][j-1]%p+dp[i][j-1])%p;\n\t}\n\tint ans=0;\n\tfor(int i=0;i<=n*2+1;i++)\n\t{\n\t\tint s1=1,s2=1;\n\t\tfor(int j=0;j<=n*2+1;j++) if(j!=i) s1=1ll*s1*((k-j)%p+p)%p,s2=1ll*s2*((i-j)%p+p)%p;\n\t\tans=(ans+1ll*dp[n][i]*s1%p*qpow(s2,p-2)%p)%p;\n\t}\n\tint fra=1;\n\tfor(int i=1;i<=n;i++) fra=1ll*fra*i%p;\n\tprintf(\"%d\\n\",1ll*ans*fra%p);\n\treturn 0;\n}\n```\n\n### 后记\n\n场上遇到一些某维很大的式子，可以猜测它是关于这维的多项式，线性拉插尽可能多个点来尝试求解。\n",
			"tags": [{"name":"学习笔记"},{"name":"数学"},{"name":"数论"}],
			"title": "拉格朗日插值学习笔记",
			"link": "https://exber.qzz.io/post/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-04-08 07:57:19"
		},
	
		{
			"abstract": "> 要求构造一个 $n$ 个节点的二叉树，节点 $1$ 为根，要使所有节点到根的距离之和为 $d$。要求先判断可不可以构造，如果可以输出 `YES`，下一行输出 $2$ 到 $n$ 号节点的父亲节点，否则输出 `NO`。\n",
			"content": "> 要求构造一个 $n$ 个节点的二叉树，节点 $1$ 为根，要使所有节点到根的距离之和为 $d$。要求先判断可不可以构造，如果可以输出 `YES`，下一行输出 $2$ 到 $n$ 号节点的父亲节点，否则输出 `NO`。\n\n首先显然可以增量构造，每次把某个叶子接到同层的节点下，令深度总和增加 $1$。\n\n那么设深度总和下界（构造一棵完全二叉树）为 $L$，深度总和上界（构造一条链）为 $R$，显然 $d<L$ 或者 $d>R$ 的情况下都是无解的。不妨猜测反之一定有解，尝试证明之，那么由于可以增量构造，所以只需要证明从完全二叉树开始，每次一定能把某个叶子接到同层的节点下。\n\n显然每次操作深度尽量深的叶子是最优的，因为深度深的叶子被移走之后深度较浅的节点更容易暴露出来，成为新的可操作的叶子，并且接深度尽量深的叶子不会减少深度浅的叶子的数量。\n\n那么由于每次都操作深度尽量深的叶子，所以一旦 $u$ 被操作了，并且下一次还能操作它，那么下一次操作一定还是操作它，所以 $u$ 的轨迹一定是这样的：\n\n![](../post-images/1680432193319.png)\n\n那么最后肯定能形成一条链，证毕。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <queue>\n\nusing namespace std;\n\nconst int S=5005;\n\nint n,k;\nbool vis[S];\nint fat[S],du[S];\nint dep[S];\nint idx[S];\n\ninline void slove()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tint R=n*(n-1)/2;\n\tfor(int i=1;i<=n;i++) vis[i]=false,du[i]=0;\n\tqueue<int> q;\n\tq.push(1);\n\tvis[1]=true;\n\tdep[1]=0;\n\twhile(!q.empty())\n\t{\n\t\tint u=q.front();\n\t\tq.pop();\n\t\tfor(int i=1,cnt=0;i<=n&&cnt<2;i++)\n\t\t{\n\t\t\tif(!vis[i])\n\t\t\t{\n\t\t\t\tvis[i]=true;\n\t\t\t\tfat[i]=u;\n\t\t\t\tdu[u]++;\n\t\t\t\tdep[i]=dep[u]+1;\n\t\t\t\tcnt++;\n\t\t\t\tq.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tint L=0;\n\tfor(int i=1;i<=n;i++) L+=dep[i];\n\tif(k<L||k>R) return void(puts(\"NO\"));\n\tputs(\"YES\");\n\tfor(int tme=1;tme<=k-L;tme++)\n\t{\n\t\tfor(int i=1;i<=n;i++) idx[i]=0;\n\t\tfor(int i=1;i<=n;i++) if(du[i]<2&&(idx[dep[i]]==0||du[i]>0)) idx[dep[i]]=i;\n\t\tint u=0;\n\t\tfor(int i=1;i<=n;i++) if(du[i]==0&&idx[dep[i]]!=0&&i!=idx[dep[i]]&&(u==0||dep[i]>dep[u])) u=i;\n\t\tdu[fat[u]]--;\n\t\tdu[fat[u]=idx[dep[u]]]++;\n\t\tdep[u]++;\n\t}\n\tfor(int i=2;i<=n;i++) printf(\"%d \",fat[i]);\n\tprintf(\"\\n\");\n}\n\nint main()\n{\n\tint T;\n\tscanf(\"%d\",&T);\n\twhile(T--) slove();\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"构造"}],
			"title": "CF1311E Construct the Binary Tree 做题记录",
			"link": "https://exber.qzz.io/post/CF1311E%20Construct%20the%20Binary%20Tree%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-04-02 18:41:59"
		},
	
		{
			"abstract": "",
			"content": "前置知识：树的重心\n\n点分治是一种用来处理树上路径问题的思想，而非一种具体分治算法。\n\n先看一到[例题](https://www.luogu.com.cn/problem/P3806)：\n\n>给出一棵 $n$ 个点的无根树，求树上长度为 $k$ 的路径条数。\n\n朴素的做法是枚举路径开头的点，跑 $O(n)$ 树形 dp。但是这样的时间复杂度是 $O(n^2)$ 的，不够优秀。\n\n考虑以点 $u$ 为根的子树的情况，显然所有路径分成两类：\n\n1. 经过 $u$ 的；\n2. 不经过 $u$，在 $u$ 儿子的子树中的；\n\n第二类路径可以递归到 $u$ 的儿子子树中处理，而第一类路径可以 $O(n)$ 遍历整棵子树来处理。\n\n若递归的时候直接让根为 $u$ 的某个儿子，显然来个链的情况就能把这个算法卡到 $O(n^2)$，所以每次选择的根很重要。\n\n回忆一下重心：\n\n> 定义：以重心为根，最大的子树大小是以所有节点为根的有根树中最小的。\n>\n> 性质：以重心为根，所有**子树的大小都不超过整棵树的大小的一半**。\n\n所以只要每次选择子树的重心为根就行了，因为重心的优美性质，所以这样递归的层数是 $O(\\log n)$ 的，时间复杂度为 $O(n\\log n)$。\n\n回到例题，由于点分治的常数巨大，所以建议把所有询问离线下来做：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=50005,BS=10000005;\n\nint n,m,mxk,ks[S];\nint esum,to[S],c[S],nxt[S],h[S];\nint rot,siz[S],mx[S];\nbool hasdis[BS],ans[S];\nbool vis[S];\n\ninline void add(int x,int y,int w)\n{\n\tto[++esum]=y;\n\tc[esum]=w;\n\tnxt[esum]=h[x];\n\th[x]=esum;\n}\n\nvoid gethev(int u,int fa,int sizz)\n{\n\tsiz[u]=1;\n\tmx[u]=0;\n\tfor(int i=h[u];i;i=nxt[i])\n\t{\n\t\tint v=to[i];\n\t\tif(v==fa||vis[v]) continue;\n\t\tgethev(v,u,sizz);\n\t\tsiz[u]+=siz[v];\n\t\tmx[u]=max(mx[u],siz[v]);\n\t}\n\tmx[u]=max(mx[u],sizz-siz[u]);\n\tif(rot==-1||mx[u]<mx[rot]) rot=u;\n}\n\nvoid getdis(int u,int fa,int dis)\n{\n\tfor(int i=1;i<=m;i++) if(ks[i]>=dis) ans[i]|=hasdis[ks[i]-dis];\n\tfor(int i=h[u];i;i=nxt[i])\n\t{\n\t\tint v=to[i],w=c[i];\n\t\tif(v==fa||vis[v]) continue;\n\t\tgetdis(v,u,dis+w);\n\t}\n}\n\nvoid adddis(int u,int fa,int dis,bool f)\n{\n\tif(dis<=mxk) hasdis[dis]=f;\n\tfor(int i=h[u];i;i=nxt[i])\n\t{\n\t\tint v=to[i],w=c[i];\n\t\tif(v==fa||vis[v]) continue;\n\t\tadddis(v,u,dis+w,f);\n\t}\n}\n\nvoid slove(int u)\n{\n\thasdis[0]=true;\n\tfor(int i=h[u];i;i=nxt[i])\n\t{\n\t\tint v=to[i],w=c[i];\n\t\tif(vis[v]) continue;\n\t\tgetdis(v,u,w);\n\t\tadddis(v,u,w,true);\n\t}\n\tfor(int i=h[u];i;i=nxt[i])\n\t{\n\t\tint v=to[i],w=c[i];\n\t\tif(vis[v]) continue;\n\t\tadddis(v,u,w,false);\n\t}\n\tvis[u]=true;\n\tfor(int i=h[u];i;i=nxt[i])\n\t{\n\t\tint v=to[i];\n\t\tif(vis[v]) continue;\n\t\trot=-1;\n\t\tgethev(v,u,siz[v]);\n\t\tslove(rot);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tint x,y,w;\n\t\tscanf(\"%d%d%d\",&x,&y,&w);\n\t\tadd(x,y,w);\n\t\tadd(y,x,w);\n\t}\n\tfor(int i=1;i<=m;i++) scanf(\"%d\",&ks[i]),mxk=max(mxk,ks[i]);\n\trot=-1;\n\tgethev(1,0,n);\n\tslove(rot);\n\tfor(int i=1;i<=m;i++) puts(ans[i]?\"AYE\":\"NAY\");\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"学习笔记"}],
			"title": "点分治学习笔记",
			"link": "https://exber.qzz.io/post/%E7%82%B9%E5%88%86%E6%B2%BB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-04-02 18:37:00"
		},
	
		{
			"abstract": "> 构造一个长度为 $n$ 的 $01$ 串 $s$，使得：\n> \n> - 任意长度小于 $k$ 的 $01$ 串，或者不是 $s$ 的子串，或者在 $s$ 中出现了至少 $2$ 次\n> \n> - 至少存在一个长度为 $k$ 的 $01$ 串，在 $s$ 中出现了恰好一次\n> \n> 保证 $n\\equiv k (mod 2)$。\n> \n> $1\\le k\\le n\\le 10^5$。\n",
			"content": "> 构造一个长度为 $n$ 的 $01$ 串 $s$，使得：\n> \n> - 任意长度小于 $k$ 的 $01$ 串，或者不是 $s$ 的子串，或者在 $s$ 中出现了至少 $2$ 次\n> \n> - 至少存在一个长度为 $k$ 的 $01$ 串，在 $s$ 中出现了恰好一次\n> \n> 保证 $n\\equiv k (mod 2)$。\n> \n> $1\\le k\\le n\\le 10^5$。\n\n构造方法：设 $l=\\frac{n-k}{2}$，那么 $s_i=[i\\operatorname{mod} (l+1)\\ge 1]$。\n\n证明：\n\n这样构造出来的 $s$ 一定是形如 $[1111\\dots10][1111\\dots10][1111\\dots10][11111]$ 这样一段一段的，除了最后一段之外的每一段都是由 $l$ 个 $1$ 和 $1$ 个 $0$ 组成的。\n\n先证明一定至少有一个长度为 $k$ 的子串只出现了一次，可以证明 $s_{[l+1,n-l]}$ 这个的长度为 $n-\\frac{n-k}{2}-\\frac{n-k}{2}-1+1=k$ 的子串一定是只出现一次的，因为它的开头是 $s_{l+1}=0$，而下一个最靠左的 $0$ 却在 $s_{2l+2}$，但是 $n-2l-2+1=n-n+k-2+1=k-1<k$，容不下一个长度为 $k$ 的字符串。\n\n再来证明一定每个长度 $<k$ 的子串都出现了至少两次，设长度为 $t$，开头位置为 $p$。若 $p$ 不在第一段，显然往左移动一段即可找到相同的子串；若 $p$ 在第一段，那么往右移动一段即可。往左移动显然不会超出边界，下面来证明往右移动也不会超出边界：\n\n显然最坏情况是 $p=l+1$，$t=k-1$，那么由于 $2l+2+k-1-1=2\\frac{n-k}{2}+k=n$ 所以右端点不会超出 $n$。\n\n综上，得证。\n",
			"tags": [{"name":"做题记录"},{"name":"构造"},{"name":"结论"}],
			"title": "CF1158B The minimal unique substring 做题记录",
			"link": "https://exber.qzz.io/post/CF1158B%20The%20minimal%20unique%20substring%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-04-02 18:35:18"
		},
	
		{
			"abstract": "> 给定一个字符串 $a$，你可以任意打乱 $a$ 中字符的顺序，记打乱后的字符串为 $b$。记 $b$ 的价值为将 $b$ 转换为 $a$ 所需的最小交换次数（交换指交换两个相邻元素）。输出价值最大的 $b$。\n> \n> 若有多种答案，任意输出一种。\n> \n> $1\\le |a|\\le 10^5$。\n",
			"content": "> 给定一个字符串 $a$，你可以任意打乱 $a$ 中字符的顺序，记打乱后的字符串为 $b$。记 $b$ 的价值为将 $b$ 转换为 $a$ 所需的最小交换次数（交换指交换两个相邻元素）。输出价值最大的 $b$。\n> \n> 若有多种答案，任意输出一种。\n> \n> $1\\le |a|\\le 10^5$。\n\n这种题都有两个方向：直接构造 $T$ 和研究 $T$ 还原到 $S$ 的性质。\n\n发现直接构造不好做，那么考虑研究 $T$ 还原到 $S$ 的性质。\n\n显然**若知道了 $p_i$ 表示 $T_i$ 最终要去的位置，那么把 $T$ 还原到 $S$ 所需的操作就是 $p$ 的逆序对个数**。\n\n不难发现，对于两个满足 $x<y,T_x=T_y$ 的位置 $x,y$，$p_x<p_y$ 显然是最优的，因为 $p_x>p_y$ 会增加至少一对逆序对，并且由于一个更大的数被放到前面了，所以逆序对个数并不会减少。\n\n继续研究两个满足 $x<y,T_x=T_y,T_{[x+1,y-1]}\\not=T_x$ 的两个位置 $x,y$，考虑 $x<k<y$，令 $Sx=\\{k|x<k<y,p_x>p_k\\},Sy=\\{k|x<k<y,p_y<p_k\\}$，显然有 $Sx\\cap Sy=\\varnothing$，那么令 $Sz=\\{k|x<k<y\\}-Sx-Sy$。\n\n显然所有 $k\\in Sx$ 和 $k\\in Sy$ 的 $k$ 对逆序对个数都有 $1$ 的贡献，所有 $k\\in Sz$ 的 $k$ 对逆序对个数都没有贡献。那么考虑把 $T_x$ 换到 $T_{y-1}$ 和把 $T_{y}$ 换到 $T_{x+1}$ 这两种操作：\n\n- 把 $T_x$ 换到 $T_{y-1}$，此时逆序对个数会减少 $|Sx|$，但是又会加上 $|Sy|$；\n- 把 $T_y$ 换到 $T_{x+1}$，此时逆序对个数会减少 $|Sy|$，但是又会加上 $|Sx|$；\n\n并且两种操作都会造成一些额外的非负的来自 $k\\in Sz$ 的逆序对个数贡献，这两种操作中对逆序对贡献更多的操作的贡献肯定至少为 $0$，那么让 $T_x$ 和 $T_y$ 相邻显然更优。\n\n所以**所有相同的字符相邻肯定是最优的**。\n\n那么枚举所有 $4!=24$ 种字符串，$O(n\\log n)$ 计算逆序对个数即可。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n\nusing namespace std;\n\nconst int S=200005;\n\nint n;\nchar a[S];\nvector<int> pos[4];\nint b[S],c[S];\nchar res[S];\n\ninline int id(char x)\n{\n\treturn x=='A'?0:(x=='N'?1:(x=='T'?2:3));\n}\n\ninline char di(int x)\n{\n\treturn x==0?'A':(x==1?'N':(x==2?'T':'O'));\n}\n\ninline void add(int pos,int val)\n{\n\tfor(int i=pos;i<=n;i+=i&-i) c[i]+=val;\n}\n\ninline int que(int pos)\n{\n\tint res=0;\n\tfor(int i=pos;i>=1;i-=i&-i) res+=c[i];\n\treturn res;\n}\n\ninline void slove()\n{\n\tscanf(\"%s\",a+1);\n\tn=strlen(a+1);\n\tfor(int i=0;i<4;i++) pos[i].clear();\n\tfor(int i=1;i<=n;i++) pos[id(a[i])].push_back(i);\n\tlong long mx=-1;\n\tfor(int i=0;i<4;i++)\n\t{\n\t\tfor(int j=0;j<4;j++)\n\t\t{\n\t\t\tif(i==j) continue;\n\t\t\tfor(int k=0;k<4;k++)\n\t\t\t{\n\t\t\t\tif(i==k||j==k) continue;\n\t\t\t\tfor(int l=0;l<4;l++)\n\t\t\t\t{\n\t\t\t\t\tif(i==l||j==l||k==l) continue;\n\t\t\t\t\tint p=0;\n\t\t\t\t\tfor(int &u:pos[i]) b[++p]=u;\n\t\t\t\t\tfor(int &u:pos[j]) b[++p]=u;\n\t\t\t\t\tfor(int &u:pos[k]) b[++p]=u;\n\t\t\t\t\tfor(int &u:pos[l]) b[++p]=u;\n\t\t\t\t\tfor(int o=1;o<=n;o++) c[o]=0;\n\t\t\t\t\tlong long pre=0;\n\t\t\t\t\tfor(int o=n;o>=1;o--)\n\t\t\t\t\t{\n\t\t\t\t\t\tpre+=que(b[o]-1);\n\t\t\t\t\t\tadd(b[o],1);\n\t\t\t\t\t}\n\t\t\t\t\tif(pre>mx)\n\t\t\t\t\t{\n\t\t\t\t\t\tmx=pre;\n\t\t\t\t\t\tp=0;\n\t\t\t\t\t\tfor(int &u:pos[i]) res[++p]=di(i);\n\t\t\t\t\t\tfor(int &u:pos[j]) res[++p]=di(j);\n\t\t\t\t\t\tfor(int &u:pos[k]) res[++p]=di(k);\n\t\t\t\t\t\tfor(int &u:pos[l]) res[++p]=di(l);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tres[n+1]=0;\n\tprintf(\"%s\\n\",res+1);\n}\n\nint main()\n{\n\tint T;\n\tscanf(\"%d\",&T);\n\twhile(T-->0) slove();\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"结论"}],
			"title": "CF1526D Kill Anton 做题记录",
			"link": "https://exber.qzz.io/post/CF1526D%20Kill%20Anton%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-04-02 18:29:12"
		},
	
		{
			"abstract": "> 给定一个 $n$ 个元素的整数序列 $a$, 任意时刻对于任一对**相邻元素** $(a_{i-1},a_i)$，若 $a_{i-1} > a_{i}$ 则要依次执行如下操作：\n> \n> `a[i-1]--,a[i]++`，然后交换 $a_{i-1}$ 和 $a_i$ 的位置。\n> \n> 经过若干次操作后，若能使整个序列变成**非降的**，则输出最终的序列；否则输出 `:(` 。\n> \n> $1 \\leq n \\leq 2\\times 10^5, 0 \\leq a[i] \\leq 10^9$。\n",
			"content": "> 给定一个 $n$ 个元素的整数序列 $a$, 任意时刻对于任一对**相邻元素** $(a_{i-1},a_i)$，若 $a_{i-1} > a_{i}$ 则要依次执行如下操作：\n> \n> `a[i-1]--,a[i]++`，然后交换 $a_{i-1}$ 和 $a_i$ 的位置。\n> \n> 经过若干次操作后，若能使整个序列变成**非降的**，则输出最终的序列；否则输出 `:(` 。\n> \n> $1 \\leq n \\leq 2\\times 10^5, 0 \\leq a[i] \\leq 10^9$。\n\n以后看到这种操作中带加一减一的都要考虑减掉下标。\n\n设 $b_i=a_i-i$，不难发现一次操作 $(i,i+1)$ 相当于交换了 $b_i$ 和 $b_{i+1}$。\n\n那么对 $b_i$ 排序，判断是否两两不同即可。\n",
			"tags": [{"name":"做题记录"},{"name":"结论"}],
			"title": "CF549G Happy Line 做题记录",
			"link": "https://exber.qzz.io/post/CF549G%20Happy%20Line%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-04-02 18:21:25"
		},
	
		{
			"abstract": "",
			"content": "> [原题链接](https://www.codechef.com/SEPT17/problems/WEASELTX)\n>\n> 给一棵 $n$ 个点的有根树，节点 $1$ 是根。节点 $i$ 的初始权值为 $w_i$。 定义一次操作是对于每个 $i$，将 $w_i$ 修改成操作前 $i$ 的子树的所有权值的异或和。 有 $q$ 次独立的询问，每次询问是求 $t_i$ 次操作后 $w_1$ 的值。\n>\n> $1\\le n,q\\le 2\\times 10^5$，$1\\le w_i,t_i\\le 10^9$。\n\n首先不难发现由于每一次操作相当于做前缀和，所以同一层上的点要么都有贡献，要么都没贡献。那么设 $f_{i,j}$ 表示第 $i+1$ 次操作之后深度为 $j$ 的点是否有贡献，显然 $f_{0,j}=1$。\n\n稍加思考可以发现递推式 $f_{i,j}=f_{i-1,j}\\operatorname{xor} f_{i,j-1}$，因为第 $j$ 层的点对第 $j-1$ 层的点有贡献。\n\n画出转移图：\n\n![](../post-images/1680430772335.png)\n\n旋转 $45\\degree$：\n\n![](../post-images/1680430785964.png)\n\n所以说 $f_{i,j}\\equiv C_{i+j}^j\\pmod 2$。\n\n或者说其实这个递推式相当于求从左上角只能向下向右走走到 $(i,j)$ 的方案数，一共有 $i+j$ 次操作，其中有 $j$ 次向下。\n\n然后根据 Lucas 定理，$C_{n}^m\\equiv C_{n\\operatorname{mod} 2}^{m\\operatorname{mod} 2}\\times C_{\\lfloor\\frac{n}{2}\\rfloor}^{\\lfloor\\frac{m}{2}\\rfloor}\\pmod 2$，那么对于 $n,m$ 二进制第 $i$ 位 $x,y$，当 $x=0,y=1$ 时这一位就会让乘积变成 $0$，所以 $f_{i,j}=1$ 当且仅当 $i+j\\operatorname{and}j=j$，即 $i\\operatorname{and} j=0$。\n\n那么求出 $a_i$ 表示所有深度为 $i$ 的点的点权的异或和，$sum_i=\\operatorname{xor}_{j\\operatorname{and} i=j} a_j$，那么 $t$ 次操作之后的答案就相当于是 $sum_{(t-1)二进制按位取反的结果}$。\n\n注意 $t=0$ 的情况要特判。\n",
			"tags": [{"name":"做题记录"},{"name":"数学"},{"name":"组合计数"}],
			"title": "Codechef WEASELTX 做题记录",
			"link": "https://exber.qzz.io/post/Codechef%20WEASELTX%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-04-02 18:18:17"
		},
	
		{
			"abstract": "> 构造一个序列 $a$ 满足以下条件：\n> \n> 1. 长度为 $n$ 。\n> 2. $\\forall i, 1\\leq a_i\\leq 10^9$ 。\n> 3. $\\forall i>1,a_i>a_{i-1}$。\n> 4. 满足 $i<j<k$ 且 $a_i+a_j=a_k$ 的三元组 $(i,j,k)$ 数量恰好为 $m$。\n> \n> $1\\le n\\leq 5000$，$0\\le m\\leq 10^9$。\n",
			"content": "> 构造一个序列 $a$ 满足以下条件：\n> \n> 1. 长度为 $n$ 。\n> 2. $\\forall i, 1\\leq a_i\\leq 10^9$ 。\n> 3. $\\forall i>1,a_i>a_{i-1}$。\n> 4. 满足 $i<j<k$ 且 $a_i+a_j=a_k$ 的三元组 $(i,j,k)$ 数量恰好为 $m$。\n> \n> $1\\le n\\leq 5000$，$0\\le m\\leq 10^9$。\n\n考虑填入正整数序列。\n\n$1,2,3,4,5,6,7,8,9$，贡献为 $0,0,1,1,2,2,3,3,4,4$，不难发现这样构造的三元组是最多的，因为 $i$ 前面的 $i-1$ 个数除了中间那个都会参与贡献。\n\n那么如果这样构造都不够就不合法，否则一直填直到总是 $\\ge m$，假设多了 $w$ 个，不难发现最后填到的这个位置每 $+2$ 三元组个数就会 $-1$，所以当前位置直接加上 $2w$ 即可。\n\n如果最后没有填满 $n$ 个数，假设最大数为 $v$，那么依次填入 $3v,5v,7v,9v,\\dots$ 即可。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=5005;\n\nint n,m;\nint a[S];\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tint tot=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\t a[i]=i;\n\t\t tot+=(i-1)/2;\n\t\t if(tot>=m)\n\t\t {\n\t\t \tint w=tot-m;\n\t\t \ta[i]+=w*2;\n\t\t \tfor(int j=i+1;j<=n;j++) a[j]=a[i]*((j-i)*2+1);\n\t\t \tfor(int j=1;j<=n;j++) printf(\"%d \",a[j]);\n\t\t \tprintf(\"\\n\");\n\t\t \treturn 0;\n\t\t }\n\t}\n\tputs(\"-1\");\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"构造"}],
			"title": "CF1305E Kuroni and the Score Distribution 做题记录",
			"link": "https://exber.qzz.io/post/CF1305E%20Kuroni%20and%20the%20Score%20Distribution%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-04-02 18:16:00"
		},
	
		{
			"abstract": "> 一共有 $n$ 个僵尸，每个僵尸头上有一个值域 $[1,n]$ 的数字 $a_i$，每个僵尸只能看到其他 $n - 1$ 个僵尸头顶的数字，当然，他们也知道自己的编号。 要求提供一种策略，使所有僵尸只利用自己知道的信息**同时**猜自己头顶的数字，保证至少有一个僵尸猜对。\n> \n> 对于每组数据，第一行包含两个正整数 $n$ 和 $r$，表示僵尸总数与当前僵尸的编号，下一行包括 $n−1$ 个正整数，表示当前僵尸看到的所有其他僵尸头顶的编号是多少（按僵尸编号升序排列）。你要输出当前僵尸应该猜测的数字。\n> \n> 时间复杂度要求线性。\n",
			"content": "> 一共有 $n$ 个僵尸，每个僵尸头上有一个值域 $[1,n]$ 的数字 $a_i$，每个僵尸只能看到其他 $n - 1$ 个僵尸头顶的数字，当然，他们也知道自己的编号。 要求提供一种策略，使所有僵尸只利用自己知道的信息**同时**猜自己头顶的数字，保证至少有一个僵尸猜对。\n> \n> 对于每组数据，第一行包含两个正整数 $n$ 和 $r$，表示僵尸总数与当前僵尸的编号，下一行包括 $n−1$ 个正整数，表示当前僵尸看到的所有其他僵尸头顶的编号是多少（按僵尸编号升序排列）。你要输出当前僵尸应该猜测的数字。\n> \n> 时间复杂度要求线性。\n\n神仙题。\n\n首先如果 $x$ 知道每个人头上的数字和对 $n$ 取模的结果 $r$，那么他显然可以求出自己头上的数字。那么考虑让第 $1$ 个人猜 $r=0$，第 $2$ 个人猜 $r=1$，依次类推，第 $i$ 个人猜 $r=i-1$，就可以保证至少有一个人猜对。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nint n,m;\n\ninline void slove()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tint res=m-1;\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tres=(res+x)%n;\n\t}\n\tres=n-res;\n\tprintf(\"%d\\n\",res);\n}\n\nint main()\n{\n\tint T;\n\tscanf(\"%d\",&T);\n\twhile(T-->0) slove();\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"构造"},{"name":"数学"}],
			"title": "CF690A3 Collective Mindsets (hard) 做题记录",
			"link": "https://exber.qzz.io/post/CF690A3%20Collective%20Mindsets%20%28hard%29%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-04-02 18:14:53"
		},
	
		{
			"abstract": "> 给定一个序列 $a_1,a_2,\\ldots ,a_n$，长度为 $n$ 的序列 $b,c$ 符合以下条件\n> \n> 1. $a_i=b_i+c_i$\n> 2. $b$ 为不下降序列，$c$ 为不上升序列，即 $b_i\\geq b_{i-1}, c_i\\leq c_{i-1}$\n> \n> 有 $q$ 个操作，每次操作把 $[l,r]$ 的数增加 $x$。求每次操作后最小的 $\\max(b_i,c_i)$\n",
			"content": "> 给定一个序列 $a_1,a_2,\\ldots ,a_n$，长度为 $n$ 的序列 $b,c$ 符合以下条件\n> \n> 1. $a_i=b_i+c_i$\n> 2. $b$ 为不下降序列，$c$ 为不上升序列，即 $b_i\\geq b_{i-1}, c_i\\leq c_{i-1}$\n> \n> 有 $q$ 个操作，每次操作把 $[l,r]$ 的数增加 $x$。求每次操作后最小的 $\\max(b_i,c_i)$\n\n看到单调不降和单调不升，就不难想到作差分。\n\n设 $ad_i=a_i-a_{i-1},bd_i=b_i-b_{i-1},cd_i=c_i-c_{i-1}$（$a_0=0,b_0=0,c_0=0$），显然对于所有 $2\\le i\\le n$，有 $bd_i\\ge 0,cd_i\\le 0$。那么问题就转化为：\n\n> 给定一个长度为 $n$ 的序列 $ad$，构造两个长度为 $n$，对于所有 $2\\le i\\le n$ 都满足 $bd_i\\ge 0,cd_i\\le 0$ 且对于所有 $1\\le i\\le n$ 都满足 $bd_i+cd_i=ad_i$ 的序列 $bd,cd$，使得 $\\max(\\sum bd_i,-\\sum cd_i)$ 最小。\n\n不难发现，因为 $bd_i\\ge 0,cd_i\\le 0$，所以对于所有 $ad_i\\ge 0$ 的 $i$ 一定有 $bd_i=ad_i,cd_i=0$，对于所有 $ad_i<0$ 的 $i$ 一定有 $bd_i=0,cd_i=ad_i$。那么不妨钦定 $\\max(\\sum bd_i,cd_1)$ 一定为 $cd_1$，那么设 $sm=\\sum\\limits_{i=2}^n \\max(ad_i,0)$，显然有 $ad_1-cd_1+sm\\le cd_1$，那么有 $cd_1\\ge \\lceil\\frac{ad_1+sm}{2}\\rceil$，所以答案就是 $\\lceil\\frac{ad_1+sm}{2}\\rceil$。\n\n每次操作只会改动两个位置，那么动态维护差分即可。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=100005;\n\nint n;\nlong long a[S];\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%lld\",&a[i]);\n\tfor(int i=n;i>=1;i--) a[i]-=a[i-1];\n\tlong long sm=0;\n\tfor(int i=2;i<=n;i++) if(a[i]>0) sm+=a[i];\n\tprintf(\"%lld\\n\",(sm+a[1])/2+(sm+a[1]>0)*((sm+a[1])%2));\n\tint q;\n\tscanf(\"%d\",&q);\n\twhile(q--)\n\t{\n\t\tint l,r;\n\t\tlong long x;\n\t\tscanf(\"%d%d%lld\",&l,&r,&x);\n\t\tr++;\n\t\tif(l>1)\n\t\t{\n\t\t\tif(a[l]>0) sm-=a[l];\n\t\t\ta[l]+=x;\n\t\t\tif(a[l]>0) sm+=a[l];\n\t\t}\n\t\telse a[l]+=x;\n\t\tif(r<=n)\n\t\t{\n\t\t\tif(a[r]>0) sm-=a[r];\n\t\t\ta[r]-=x;\n\t\t\tif(a[r]>0) sm+=a[r];\n\t\t}\n\t\tprintf(\"%lld\\n\",(sm+a[1])/2+(sm+a[1]>0)*((sm+a[1])%2));\n\t} \n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"结论"},{"name":"构造"}],
			"title": "CF1406D Three Sequences 做题记录",
			"link": "https://exber.qzz.io/post/CF1406D%20Three%20Sequences%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-04-02 18:10:39"
		},
	
		{
			"abstract": "> 一次操作选择$1<i<n$，使$c_i$变为$c_i'$，$c_i'=c_{i+1}+c_{i-1}-c_i$\n> \n> 是否能做若干次操作，使每个$c_i$和$t_i$相等？\n> \n> $2\\le n\\le 10^5, 0\\le c_i\\le 2*10^9, 0\\le t_i\\le 2*10^9$。\n",
			"content": "> 一次操作选择$1<i<n$，使$c_i$变为$c_i'$，$c_i'=c_{i+1}+c_{i-1}-c_i$\n> \n> 是否能做若干次操作，使每个$c_i$和$t_i$相等？\n> \n> $2\\le n\\le 10^5, 0\\le c_i\\le 2*10^9, 0\\le t_i\\le 2*10^9$。\n\n首先遇到这种序列操作的题，肯定要考虑原序列、差分序列和前缀后缀和序列。\n\n那么原序列似乎规律，那么观察差分序列。设 $a_i=c_{i+1}-c_i$，那么一次 $c_i=c_{i-1}+c_{i+1}-c_i$ 的操作相当于让 $a_{i-1}=c_{i-1}+c_{i+1}-c_i-c_{i-1}=c_{i+1}-c_i=a_i$，$a_{i}=c_{i+1}-(c_{i-1}+c_{i+1}-c_i)=c_i-c_{i-1}=a_{i-1}$，也就是交换 $a_{i}$ 和 $a_{i-1}$。\n\n那么本题就变得就很简单了，特判掉 $c_1\\not=t_1,c_n\\not=t_n$ 的情况，排序即可。\n",
			"tags": [{"name":"做题记录"},{"name":"结论"}],
			"title": "CF1110E Magic Stones 做题记录",
			"link": "https://exber.qzz.io/post/CF1110E%20Magic%20Stones%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-04-02 18:08:16"
		},
	
		{
			"abstract": "> 有一个 $n\\times m$ 的矩阵 $a$ ,请你构造一个矩阵 $b$ ，使得：\n> - $0<b_{i,j}\\le 10^6$\n> - $b_{i,j}$ 是 $a_{i,j}$ 的倍数\n> - $b$ 中相邻的两个数的差的绝对值可以写成 $k^4(k\\in\\mathbb{N}^+)$\n> \n> $1\\le n,m\\le 500$，$1\\le a_{i,j}\\le 16$。\n",
			"content": "> 有一个 $n\\times m$ 的矩阵 $a$ ,请你构造一个矩阵 $b$ ，使得：\n> - $0<b_{i,j}\\le 10^6$\n> - $b_{i,j}$ 是 $a_{i,j}$ 的倍数\n> - $b$ 中相邻的两个数的差的绝对值可以写成 $k^4(k\\in\\mathbb{N}^+)$\n> \n> $1\\le n,m\\le 500$，$1\\le a_{i,j}\\le 16$。\n\n以后看到这种范围很小的奇奇怪怪的倍数题都要往 $\\operatorname{lcm}$ 上想……\n\n观察到 $\\operatorname{lcm}(1,2,3,\\dots,16)=720720$，并且 $720720>16^4$，所以可以给方格黑白染色，黑色格子填 $720720$，白色格子填 $720720-a_{i,j}^4$。\n",
			"tags": [{"name":"做题记录"},{"name":"数学"},{"name":"构造"}],
			"title": "CF1485D Multiples and Power Differences 做题记录",
			"link": "https://exber.qzz.io/post/CF1485D%20Multiples%20and%20Power%20Differences%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-04-02 18:04:56"
		},
	
		{
			"abstract": "> 构造 $N$ 个集合，$S_1$ 到 $S_N$ 。\n> \n> 每个集合满足以下条件：\n> \n> + 每个元素是不大于 $M$ 的正整数；\n> + 对于两个相邻的集合 $S_i$ 和 $S_{i+1}$，有且仅有一个数恰好在这两个集合中的一个里出现。\n> \n> 定义这 $N$ 个集合的分数为 $\\prod\\limits_{i=1}^m cnt(i)$ ，其中 $cnt(i)$ 为 $i$ 在所有 $N$ 个集合中出现的次数。\n> \n> 求所有满足条件的集合簇的分数之和，答案对 $998244353$ 取模。\n> \n> $1\\le N,M\\le 2\\times 10^5$ 。\n",
			"content": "> 构造 $N$ 个集合，$S_1$ 到 $S_N$ 。\n> \n> 每个集合满足以下条件：\n> \n> + 每个元素是不大于 $M$ 的正整数；\n> + 对于两个相邻的集合 $S_i$ 和 $S_{i+1}$，有且仅有一个数恰好在这两个集合中的一个里出现。\n> \n> 定义这 $N$ 个集合的分数为 $\\prod\\limits_{i=1}^m cnt(i)$ ，其中 $cnt(i)$ 为 $i$ 在所有 $N$ 个集合中出现的次数。\n> \n> 求所有满足条件的集合簇的分数之和，答案对 $998244353$ 取模。\n> \n> $1\\le N,M\\le 2\\times 10^5$ 。\n\n不难发现，元素是互相独立的，所以考虑某个元素 $x$ 的情况，设 $f(x)_i=[x\\in S_i]$，那么 $f(x)$ 一定是一个形如 $[0,0,1,1,0,1]$ 这样的 $01$ 数组。\n\n容易发现，由于有且仅有一个元素只被相邻的 $S_i,S_{i+1}$ 中的一个包含，设这个元素为 $val_i$。由于 $val_i=x$ 的 $val_i$ 已经确定了下来，不能再给别的元素用，所以当 $pos_x=\\{i|val_i=x\\}$ 相同时，这两种方案对于其它元素来说是本质相同的。\n\n观察到 $val_i=x$ 当且仅当 $f(x)_i\\not=f(x)_{i+1}$，所以若给 $f(x)$ 取反，即 $1$ 变成 $0$，$0$ 变成 $1$，$pos_x$ 是不变的，所以其它元素出现次数的乘积也不变，设这个值为 $V$。假设取反之前 $f(x)$ 中有 $a$ 个 $1$，取反之后显然有 $n-a$ 个，取反之前的答案是 $V\\cdot a$，取反之后的答案是 $V\\cdot (n-a)$，总的答案是这两部分的加和，观察到加和就是 $nV$，所以元素 $x$ 对乘积的贡献就是 $n$。那么每种本质不同的方案的答案加起来就是 $n^m$。\n\n考虑计算本质不同的方案数，显然所有方案数是 $2^mm^{n-1}$，因为 $S_1$ 可以任意选，之后的 $S_i$ 和 $S_{i-1}$ 只能有一个元素的差异。那么由于每种元素本质相同的方案都会算两次，所以本质不同的方案数就是 $\\frac{2^mm^{n-1}}{2^m}=m^{n-1}$，答案即为 $n^mm^{n-1}$。\n",
			"tags": [{"name":"做题记录"},{"name":"数学"},{"name":"组合计数"}],
			"title": "ARC147D Sets Scores 做题记录",
			"link": "https://exber.qzz.io/post/ARC147D%20Sets%20Scores%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-04-02 17:59:45"
		},
	
		{
			"abstract": "> 有一无穷长的流水线 $a$，初始时 $\\forall i\\le0\\text{ 和 } i>2n ,a_i=0$。**否则**，若 $i$ 为奇数，则 $a_i=2$；若 $i$ 为偶数，则 $a_i=1$。**也就是说，$a_i=2$ 和 $a_i=1$ 是交替出现的。**  \n> \n> 现需要进行若干次 **如下** 操作，使得 $a$ 中的所有 **非零元素** 为 **连续** 的一段且所有的 $1$ 均在 $2$ **前面**。  \n> \n> 选择两个位置 $p$ 和 $q$，满足 $a_p\\ne0,a_{p+1}\\ne0$ 且 $a_q=a_{q+1}=0$，将 $a_q$ 设为 $a_p$，$a_{q+1}$ 设为 $a_{p+1}$，并且将 $a_p$ 和 $a_{p+1}$ 均设为 $0$。**输出时将此操作表示为 ```p to q```（$p$  和 $q$ 是具体的值）**。  \n> \n> 最小化操作步数，并输出操作序列，出题人将用 $\\text{Special Judge}$ 来评判您的答案的正确性。  \n> \n> $3\\le n\\le 100$。\n",
			"content": "> 有一无穷长的流水线 $a$，初始时 $\\forall i\\le0\\text{ 和 } i>2n ,a_i=0$。**否则**，若 $i$ 为奇数，则 $a_i=2$；若 $i$ 为偶数，则 $a_i=1$。**也就是说，$a_i=2$ 和 $a_i=1$ 是交替出现的。**  \n> \n> 现需要进行若干次 **如下** 操作，使得 $a$ 中的所有 **非零元素** 为 **连续** 的一段且所有的 $1$ 均在 $2$ **前面**。  \n> \n> 选择两个位置 $p$ 和 $q$，满足 $a_p\\ne0,a_{p+1}\\ne0$ 且 $a_q=a_{q+1}=0$，将 $a_q$ 设为 $a_p$，$a_{q+1}$ 设为 $a_{p+1}$，并且将 $a_p$ 和 $a_{p+1}$ 均设为 $0$。**输出时将此操作表示为 ```p to q```（$p$  和 $q$ 是具体的值）**。  \n> \n> 最小化操作步数，并输出操作序列，出题人将用 $\\text{Special Judge}$ 来评判您的答案的正确性。  \n> \n> $3\\le n\\le 100$。\n\n容易证明操作次数下界是 $n$，因为设相邻两个类型相同的包裹有 $t$ 组，初始 $t=0$，最终要令 $t=2n-2$。每次操作取出包裹时 $t$ 不会增加，而放回则最多增加 $2$，并且第一次操作只能令 $t$ 增加 $1$，所以操作次数下界为 $1+\\lceil \\frac{2n-3}{2}\\rceil=n$。\n\n手模一下 $3\\le n\\le 7$ 的情况：\n\n```\nOOOOOOBABABA\nOOOOABBOOABA\nOOOOABBBAAOO\nOOAAABBBOOOO\n```\n\n```\nOOOOOOOOBABABABA\nOOOOOOABBABABOOA\nOOOOOOABBAOOBBAA\nOOOOOOAOOABBBBOO\nOOOOOOAAAABBBBOO\n```\n\n```\nOOOOOOOOOOBABABABABA\nOOOOOOOOABBABABABOOA\nOOOOOOOOABBAOOBABBAA\nOOOOOOOOABBAABBOOBAA\nOOOOOOOOAAAAABBBBBOO\n```\n\n```\nOOOOOOOOOOOOBABABABABABA\nOOOOOOOOOOABBABABABABOOA\nOOOOOOOOOOABBABABAOOBBAA\nOOOOOOOOOOABBOOABAABBBAA\nOOOOOOOOOOABBAAABOOBBBAA\nOOOOOOOOOOAOOAAABBBBBBAA\nOOOOOOOOOOAAAAAABBBBBBOO\n```\n\n```\nOOOOOOOOOOOOOOBABABABABABABA\nOOOOOOOOOOOOABBABABABOOABABA\nOOOOOOOOOOOOABBABAOOBBAABABA\nOOOOOOOOOOOOABBABAABBBAABOOA\nOOOOOOOOOOOOABBAOOABBBAABBAA\nOOOOOOOOOOOOABBAAAABBBOOBBAA\nOOOOOOOOOOOOAOOAAAABBBBBBBAA\nOOOOOOOOOOOOAAAAAAABBBBBBBOO\n```\n\n不难发现，$n>3$ 时，第一步总是 `2n-2 to -1`，并且最后包裹总是停留在 $[-1,2n-2]$。那么考虑构造 $n\\ge 8$ 的操作序列：\n\n```\nOOO...OOOBA[BABABA...BABA]BABA\nOOO...OABBA[BABABA...BABA]BOOA\nOOO...OABBA[OOBABA...BABA]BBAA\n```\n\n此时若我们递归构造，将中括号内变成 `AAA...AB...BBBOO`，那么可以这样构造接下来的操作序列：\n\n```\nOOO...OABBA[AAA...AB...BBBOO]BBAA\nOOO...OAOOA[AAA...AB...BBBBB]BBAA\nOOO...OAAAA[AAA...AB...BBBBB]BBOO\n```\n\n不难发现，这样在递归下去之前用了两次操作，递归完之后又用了两次操作，递归到到子问题 $n$ 减少了 $4$，所以总共恰好使用了 $n$ 次操作。\n\n边界条件显然是 $3\\le n\\le 7$，因为此时递归到到子问题 $n$ 就会 $\\le 3$，不满足最后包裹停留在 $[-1,2n-2]$。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\ninline void mov(int x,int y)\n{\n\tprintf(\"%d to %d\\n\",x,y);\n}\n\nvoid inline run3(int l)\n{\n\tmov(l+1,l-2);\n\tmov(l+4,l+1);\n\tmov(l+2,l-4);\n}\n\nvoid inline run4(int l)\n{\n\tmov(l+5,l-2);\n\tmov(l+2,l+5);\n\tmov(l-1,l+2);\n\tmov(l+6,l-1);\n}\n\nvoid inline run5(int l)\n{\n\tmov(l+7,l-2);\n\tmov(l+2,l+7);\n\tmov(l+5,l+2);\n\tmov(l-1,l+5);\n\tmov(l+8,l-1);\n}\n\nvoid inline run6(int l)\n{\n\tmov(l+9,l-2);\n\tmov(l+6,l+9);\n\tmov(l+1,l+6);\n\tmov(l+5,l+1);\n\tmov(l-1,l+5);\n\tmov(l+10,l-1);\n}\n\nvoid inline run7(int l)\n{\n\tmov(l+7,l-2);\n\tmov(l+4,l+7);\n\tmov(l+11,l+4);\n\tmov(l+2,l+11);\n\tmov(l+8,l+2);\n\tmov(l-1,l+8);\n\tmov(l+12,l-1);\n}\n\ninline void slove(int l,int r)\n{\n\tif((r-l+1)/2==3)\n\t{\n\t\trun3(l);\n\t\treturn;\n\t}\n\tif((r-l+1)/2==4)\n\t{\n\t\trun4(l);\n\t\treturn;\n\t}\n\tif((r-l+1)/2==5)\n\t{\n\t\trun5(l);\n\t\treturn;\n\t}\n\tif((r-l+1)/2==6)\n\t{\n\t\trun6(l);\n\t\treturn;\n\t}\n\tif((r-l+1)/2==7)\n\t{\n\t\trun7(l);\n\t\treturn;\n\t}\n\tmov(r-2,l-2);\n\tmov(l+2,r-2);\n\tslove(l+4,r-4);\n\tmov(l-1,r-5);\n\tmov(r-1,l-1);\n}\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tslove(1,n*2);\n\treturn 0;\n}\n```\n\n",
			"tags": [{"name":"做题记录"},{"name":"构造"}],
			"title": "P6892 [ICPC2014 WF]Baggage 做题记录",
			"link": "https://exber.qzz.io/post/P6892%20%5BICPC2014%20WF%5DBaggage%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-04-02 17:57:03"
		},
	
		{
			"abstract": "> 扫雷地图是一张 $n$ 行 $m$ 列的网格，其中每个格子是地雷或空地。每个空地会显示一个数字代表与它相邻的雷的数量（两个格子相邻当且仅当它们共用一个顶点或一条边，不在边界上的格子与恰好 $8$ 个格子相邻）。 在一次操作中，你可以将一个地雷改成空地，或将空地改成地雷。 给定两张扫雷地图 $A$ 和 $B$，你需要对 $A$ 进行不超过 $\\lfloor\\frac{nm}{2}\\rfloor$ 次操作，使得 $A$ 所有空地上的数字之和等于 $B$ 所有空地上的数字之和。\n",
			"content": "> 扫雷地图是一张 $n$ 行 $m$ 列的网格，其中每个格子是地雷或空地。每个空地会显示一个数字代表与它相邻的雷的数量（两个格子相邻当且仅当它们共用一个顶点或一条边，不在边界上的格子与恰好 $8$ 个格子相邻）。 在一次操作中，你可以将一个地雷改成空地，或将空地改成地雷。 给定两张扫雷地图 $A$ 和 $B$，你需要对 $A$ 进行不超过 $\\lfloor\\frac{nm}{2}\\rfloor$ 次操作，使得 $A$ 所有空地上的数字之和等于 $B$ 所有空地上的数字之和。\n\n\n不难发现，对于一张给定的地图，数字的和有两种计算方式：\n\n- 与每个空地格子相邻的地雷格子个数的和；\n- 与每个地雷格子相邻的空地格子个数的和；\n\n所以若把整个地图取反，即空地都变成地雷，地雷都变成空地，那么数字和不变。\n\n设 $B$ 取反之后的地图是 $B'$，把 $A$ 变成 $B$ 的最小操作次数是 $x$，把 $A$ 变成 $B'$ 的最小操作次数是 $y$，那么由于 $x+y\\le nm$，所以根据抽屉原理，有 $\\min(x,y)\\le \\lfloor\\frac{nm}{2}\\rfloor$。所以把 $A$ 变成 $B$ 和 $B'$ 中需要更少次操作的即可。\n",
			"tags": [{"name":"做题记录"},{"name":"数学"},{"name":"构造"}],
			"title": "Mine Sweeper II 做题记录",
			"link": "https://exber.qzz.io/post/Mine%20Sweeper%20II%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-04-02 17:56:03"
		},
	
		{
			"abstract": "> 给定一张 $n$ 行 $n$ 列的棋盘，每个格子可能是空的或包含一个标志，标志有 $\\text{X}$ 和 $\\text{O}$ 两种。\n> \n> 如果有三个相同的标志排列在一行或一列上的三个连续的位置，则称这个棋盘是一个 **胜局**，\n否则称其为 **平局**。\n> \n> ![](../post-images/1680429260021.png)\n> \n> 例如，上图第一行的局面都是胜局，而第二行的局面都是平局。\n> \n> 在一次操作中，你可以将一个 $\\text X$ 改成 $\\text O$，或将一个 $\\text O$ 改成 $\\text X$。\n> \n> 设棋盘中标志的总数为 $k$，你需要用不超过 $\\lfloor \\frac{k}{3}\\rfloor$\n次操作把给定的局面变成平局。\n> \n> $1\\leq n\\leq 300$。\n",
			"content": "> 给定一张 $n$ 行 $n$ 列的棋盘，每个格子可能是空的或包含一个标志，标志有 $\\text{X}$ 和 $\\text{O}$ 两种。\n> \n> 如果有三个相同的标志排列在一行或一列上的三个连续的位置，则称这个棋盘是一个 **胜局**，\n否则称其为 **平局**。\n> \n> ![](../post-images/1680429260021.png)\n> \n> 例如，上图第一行的局面都是胜局，而第二行的局面都是平局。\n> \n> 在一次操作中，你可以将一个 $\\text X$ 改成 $\\text O$，或将一个 $\\text O$ 改成 $\\text X$。\n> \n> 设棋盘中标志的总数为 $k$，你需要用不超过 $\\lfloor \\frac{k}{3}\\rfloor$\n次操作把给定的局面变成平局。\n> \n> $1\\leq n\\leq 300$。\n\n看到 $\\lfloor\\frac{k}{3}\\rfloor$ 和 $3$ 子棋就很容易想到抽屉原理，那么考虑把所有格子 $(i,j)$ 按照 $(i+j)\\mod 3$ 分成三类。\n\n不难发现，若 $0\\le x<3,0\\le y<3,x\\not=y$，那么只要所有格子满足以下条件：\n\n- 满足 $(i+j)\\mod 3=x$ 的有棋子的格子都为 $\\texttt{X}$；\n- 满足 $(i+j)\\mod 3=y$ 的有棋子的格子都为 $\\texttt{O}$；\n\n就可以使局面为平局，因为同一行上或同一列上相邻三个棋子的分类一定不同。\n\n那么枚举 $x,y$ 即可，不难发现有 $6$ 种情况，所有情况的操作总次数为 $2k$。那么由于抽屉原理 $\\lfloor\\frac{2k}{6}\\rfloor=\\lfloor\\frac{k}{3}\\rfloor$，所以一定有一种情况合法。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=305;\n\nint n;\nchar a[S][S],b[S][S];\n\ninline int work(int tp1,int tp2)\n{\n\tint tot=0;\n\tfor(int i=1;i<=n;i++) for(int j=1;j<=n+1;j++) b[i][j]=a[i][j];\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tint id=(i+j)%3;\n\t\t\tif(a[i][j]=='X'&&id==tp1) tot++,b[i][j]='O';\n\t\t\tif(a[i][j]=='O'&&id==tp2) tot++,b[i][j]='X';\n\t\t}\n\t}\n\treturn tot;\n}\n\ninline void print()\n{\n\tfor(int i=1;i<=n;i++) printf(\"%s\\n\",b[i]+1);\n}\n\ninline void slove()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%s\",a[i]+1);\n\tint k=0;\n\tfor(int i=1;i<=n;i++) for(int j=1;j<=n;j++) k+=a[i][j]!='.';\n\tfor(int i=0;i<3;i++)\n\t{\n\t\tfor(int j=0;j<3;j++)\n\t\t{\n\t\t\tif(i==j) continue;\n\t\t\tif(work(i,j)<=k/3)\n\t\t\t{\n\t\t\t\tprint();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint T;\n\tscanf(\"%d\",&T);\n\twhile(T-->0) slove();\n\treturn 0;\n}\n```\n\n",
			"tags": [{"name":"做题记录"},{"name":"构造"},{"name":"数学"}],
			"title": "CF1450C2 Errich-Tac-Toe (Hard Version) 做题记录",
			"link": "https://exber.qzz.io/post/CF1450C2%20Errich-Tac-Toe%20%28Hard%20Version%29%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-04-02 17:53:21"
		},
	
		{
			"abstract": "> 风见幽香的太阳花田是一个 $n\\times m$ 的矩阵。\n> \n> `X` 的位置是空地，`.` 的位置是向日葵，Imakf **保证给出的矩阵满足所有 `X` 两两之间的切比雪夫距离大于 $1$（没有公共点）**。\n> \n> 请把一些 `.` 换成 `X`，使得所有的 `X` 四连通且不存在简单环（形成一棵树）。\n> \n> $1\\le n,m\\le 500$。\n",
			"content": "> 风见幽香的太阳花田是一个 $n\\times m$ 的矩阵。\n> \n> `X` 的位置是空地，`.` 的位置是向日葵，Imakf **保证给出的矩阵满足所有 `X` 两两之间的切比雪夫距离大于 $1$（没有公共点）**。\n> \n> 请把一些 `.` 换成 `X`，使得所有的 `X` 四连通且不存在简单环（形成一棵树）。\n> \n> $1\\le n,m\\le 500$。\n\n不难想到由于题目对 $\\texttt{X}$ 的个数没有限制，所以可以让某些行全都是 $\\texttt{X}$ 来使得整张图联通。\n\n首先相邻两行都全是 $\\texttt{X}$ 肯定是不行的，空一行也不行，因为有如下情况：\n\n```\nXXXXXX\nX  X X\nXXXXXX\n```\n\n而由于原图满足任意两个 $\\texttt{X}$ 没有公共边和公共顶点，所以如果我们空两行，肯定不会形成环。此时所有全是 $\\texttt{X}$ 的行都和它上面和下面两行联通，而和其它行不连通：\n\n```\nXXXXXX\nX   X\n  X\nXXXXXX\n```\n\n考虑合并这些联通块，显然只需要合并相邻的全为 $\\texttt{X}$ 的行即可。由于原图满足任意两个 $\\texttt{X}$ 没有公共顶点，所以只需要找到这两行之间有 $\\texttt{X}$ 的一列，让这一列不为 $\\texttt{X}$ 的位置也为 $\\texttt{X}$ 即可。若找不到这样的列那么直接让第一列的两个位置都为 $\\texttt{X}$。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=505;\n\nint n,m;\nchar a[S][S];\n\ninline void slove()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++) scanf(\"%s\",a[i]+1);\n\tfor(int i=1+(n%3==0);i<=n;i+=3)\n\t{\n\t\tfor(int j=1;j<=m;j++) a[i][j]='X';\n\t\tif(i+2<=n)\n\t\t{\n\t\t\tint pos=1;\n\t\t\tfor(int j=2;j<=m;j++)\n\t\t\t{\n\t\t\t\tif(a[i+1][j]=='X'||a[i+2][j]=='X')\n\t\t\t\t{\n\t\t\t\t\tpos=j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\ta[i+1][pos]=a[i+2][pos]='X';\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++) printf(\"%s\\n\",a[i]+1);\n}\n\nint main()\n{\n\tint T;\n\tscanf(\"%d\",&T);\n\twhile(T-->0) slove();\n\treturn 0;\n}\n```\n\n",
			"tags": [{"name":"做题记录"},{"name":"构造"}],
			"title": "CF1495C Garden of the Sun 做题记录",
			"link": "https://exber.qzz.io/post/CF1495C%20Garden%20of%20the%20Sun%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-04-02 17:51:27"
		},
	
		{
			"abstract": "> $n \\times k$ 个格子，编号从 $1$ 到 $n \\times k$，染成 $n$ 种颜色，每种颜色恰好 $k$ 个。  \n> 构造 $n$ 个区间，第 $i$ 个区间 $[a_i, b_i]$ 满足\n> \n> - $1 \\le a_i < b_i \\le n \\times k$\n> - 第 $a_i$ 个和第 $b_i$ 个格子的颜色都是 $i$。\n> - 每个格子被包含不超过 $\\lceil \\frac{n}{k-1} \\rceil$ 次。\n> \n> $1\\le n\\le 100$，$2\\le k\\le 100$。\n",
			"content": "> $n \\times k$ 个格子，编号从 $1$ 到 $n \\times k$，染成 $n$ 种颜色，每种颜色恰好 $k$ 个。  \n> 构造 $n$ 个区间，第 $i$ 个区间 $[a_i, b_i]$ 满足\n> \n> - $1 \\le a_i < b_i \\le n \\times k$\n> - 第 $a_i$ 个和第 $b_i$ 个格子的颜色都是 $i$。\n> - 每个格子被包含不超过 $\\lceil \\frac{n}{k-1} \\rceil$ 次。\n> \n> $1\\le n\\le 100$，$2\\le k\\le 100$。\n\n先求出 $pos_{i,j}$ 表示颜色 $i$ 第 $j$ 次出现的位置。\n\n不难发现，只要把 $n$ 个颜色分为 $k-1$ 组，每组大小 $\\le \\lceil\\frac{n}{k-1}\\rceil$，不同组的区间互不相交即可。并且每个颜色选择区间 $[pos_{i,j},pos_{i,j+1}]$ 肯定是最优的。\n\n考虑较为简单的情况的构造，$k=2$ 未免太简单了，考虑 $k=3$ 的情况。这时要分 $2$ 组，每组大小 $\\lceil\\frac{n}{2}\\rceil$，稍加思考可以发现，只要按照 $pos_{i,2}$ 排序，前 $\\lceil\\frac{n}{2}\\rceil$ 个颜色选择区间 $[pos_{i,1},pos_{i,2}]$，其它颜色选择区间 $[pos_{i,2},pos_{i,3}]$ 即可。\n\n考虑推广这个构造方法，容易发现，只要重复 $k-1$ 次，第 $T$ 次按照 $pos_{i,T+1}$ 排序，排序后前 $\\lceil\\frac{n}{k-1}\\rceil$ 个颜色选择区间 $[pos_{i,T},pos_{i,T+1}]$ 即可。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=105;\n\nint n,k;\nint pos[S][S],tot[S];\nint ansl[S],ansr[S];\nint id[S];\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i=1;i<=n*k;i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tpos[x][++tot[x]]=i;\n\t}\n\tint val=n/(k-1)+!!(n%(k-1));\n\tfor(int i=1;i<=k-1;i++)\n\t{\n\t\tint cnt=0;\n\t\tfor(int j=1;j<=n;j++) if(ansl[j]==ansr[j]) id[++cnt]=j;\n\t\tsort(id+1,id+cnt+1,[&](int x,int y){return pos[x][i+1]<pos[y][i+1];});\n\t\tfor(int j=1;j<=cnt&&j<=val;j++) ansl[id[j]]=pos[id[j]][i],ansr[id[j]]=pos[id[j]][i+1];\n\t}\n\tfor(int i=1;i<=n;i++) printf(\"%d %d\\n\",ansl[i],ansr[i]);\n\treturn 0;\n}\n```\n\n",
			"tags": [{"name":"做题记录"},{"name":"构造"}],
			"title": "CF1552E Colors and Intervals 做题记录",
			"link": "https://exber.qzz.io/post/CF1552E%20Colors%20and%20Intervals%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-04-02 17:48:22"
		},
	
		{
			"abstract": "> 给定 $n \\times n$ 的矩阵 $a$，求满足 $a$ 中任意一个元素等于 $b$ 中与其相邻元素的异或和的矩阵 $b$ 的异或和。\n> \n> $2 \\le n \\le 1000$，$n$ 是偶数。\n",
			"content": "> 给定 $n \\times n$ 的矩阵 $a$，求满足 $a$ 中任意一个元素等于 $b$ 中与其相邻元素的异或和的矩阵 $b$ 的异或和。\n> \n> $2 \\le n \\le 1000$，$n$ 是偶数。\n\n![](../post-images/1680001732886.png)\n\n直接在斜线上面构造即可。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=1005;\n\nint n,a[S][S];\n\ninline void slove()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) for(int j=1;j<=n;j++) scanf(\"%d\",&a[i][j]);\n\tint ans=0;\n\tfor(int i=1;i<=n+n-1;i+=4)\n\t{\n\t\tint sx=1+max(i-n,0),sy=min(i,n);\n\t\tfor(int i=1;i<=n;i+=2)\n\t\t{\n\t\t\tint px=sx+i-1,py=sy-i+1;\n\t\t\tif(px<1||px>n||py<1||py>n) break;\n\t\t\tans^=a[px][py];\n\t\t}\n\t\tsx=1+max(i-n,0),sy=max(1,n-i+1);\n\t\tfor(int i=1;i<=n;i+=2)\n\t\t{\n\t\t\tint px=sx+i-1,py=sy+i-1;\n\t\t\tif(px<1||px>n||py<1||py>n) break;\n\t\t\tans^=a[px][py];\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n\nint main()\n{\n\tint T;\n\tscanf(\"%d\",&T);\n\twhile(T--) slove();\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"构造"}],
			"title": "CF1628C Grid Xor 做题记录",
			"link": "https://exber.qzz.io/post/CF1628C%20Grid%20Xor%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-28 19:08:20"
		},
	
		{
			"abstract": "> 给定一棵无根树，有 $n$ 个顶点。在这棵树上有一个顶点 $x$，你希望找到它。\n> \n> 要找到 $x$，你可以进行  $k$ 次查询 $v_1 , v_2 ，\\ldots , v_k$ (其中 $v_i$ 是树中的各个顶点)。当你进行完所有查询后，你会得到 $k$ 个数字 $d_1 , d_2 ，\\ldots , d_k$ ，($d_i$ 是 $v_i$ 和 $x$ 之间的最短路径上的边数)。注意，您知道哪个距离对应于哪个查询。\n> \n> 请你求出最小的  $k$ ，使存在这样的一些查询 $v_1 , v_2 ，\\ldots , v_k$ ，让你总能找到唯一的一个节点 $x$ (无论 $x$ 是什么)。\n> \n> 注意，你不需要输出这些查询。\n> \n> $1 \\le n \\le 2\\times 10^5$。\n",
			"content": "> 给定一棵无根树，有 $n$ 个顶点。在这棵树上有一个顶点 $x$，你希望找到它。\n> \n> 要找到 $x$，你可以进行  $k$ 次查询 $v_1 , v_2 ，\\ldots , v_k$ (其中 $v_i$ 是树中的各个顶点)。当你进行完所有查询后，你会得到 $k$ 个数字 $d_1 , d_2 ，\\ldots , d_k$ ，($d_i$ 是 $v_i$ 和 $x$ 之间的最短路径上的边数)。注意，您知道哪个距离对应于哪个查询。\n> \n> 请你求出最小的  $k$ ，使存在这样的一些查询 $v_1 , v_2 ，\\ldots , v_k$ ，让你总能找到唯一的一个节点 $x$ (无论 $x$ 是什么)。\n> \n> 注意，你不需要输出这些查询。\n> \n> $1 \\le n \\le 2\\times 10^5$。\n\n首先特掉 $n=1$ 和链的情况。\n\n不难发现查询所有度为 $1$ 的叶子节点一定是可以的。\n\n****\n\n具体证明：\n\n可以考虑从这些节点开始染色，遇到度数 $\\ge 3$ 的点停下（度数 $\\ge 3$ 的点不染色）。\n\n那么若神秘点染了色那么一定能找到，否则删掉所有染了色的点后还是相当于询问了所有叶子节点，重复上述过程即可得证。\n\n****\n\n考虑从每个叶子节点 $u$ 开始染色停下的节点 $to_u$，设 $S_x=\\{u|to_u=x\\}$，那么答案即为 $\\sum \\max(|S_x|-1,0)$。\n\n****\n\n证明如下：\n\n柿子的本质就是每个 $S_x$ 里可以少选一个，假设最后选的集合为 $A$，那么考虑所有满足 $u\\in A,v\\in A,u\\not=v$ 的 $u,v$，那么 $u,v$ 之间的路径上的点都可以找到，把这些点染色。\n\n考虑最后没被染色的点，显然它们构成了若干条链，每条链都一端“挂在”某两个被选择的点的路径上，所以也可以确定。\n\n****\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=500005;\n\nint n;\nint esum,to[S],nxt[S],h[S];\nint d[S];\nint tot,siz[S];\n\ninline void add(int x,int y)\n{\n\tto[++esum]=y;\n\tnxt[esum]=h[x];\n\th[x]=esum;\n}\n\nint dfs(int u,int fa)\n{\n\tint res=0;\n\tfor(int i=h[u];i;i=nxt[i])\n\t{\n\t\tint v=to[i];\n\t\tif(v==fa) continue;\n\t\tres+=dfs(v,u);\n\t}\n\tif(d[u]>=3)\n\t{\n\t\ttot+=res>0;\n\t\treturn 0;\n\t}\n\tif(d[u]==1) return 1;\n\treturn res;\n}\n\ninline void slove()\n{\n\tscanf(\"%d\",&n);\n\tesum=0;\n\tfor(int i=1;i<=n;i++) h[i]=d[i]=0;\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);\n\t\tadd(y,x);\n\t\td[x]++,d[y]++;\n\t}\n\tif(n==1)\n\t{\n\t\tputs(\"0\");\n\t\treturn;\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;i++) ans+=d[i]==1;\n\tbool f=false;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(d[i]>=3)\n\t\t{\n\t\t\tf=true;\n\t\t\ttot=0;\n\t\t\tdfs(i,0);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(!f)\n\t{\n\t\tputs(\"1\");\n\t\treturn;\n\t}\n\tans-=tot;\n\tprintf(\"%d\\n\",ans);\n}\n\nint main()\n{\n\tint T;\n\tscanf(\"%d\",&T);\n\twhile(T--) slove();\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"构造"}],
			"title": "CF1695D2 Tree Queries (Hard Version) 做题记录",
			"link": "https://exber.qzz.io/post/CF1695D2%20Tree%20Queries%20%28Hard%20Version%29%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-28 19:04:35"
		},
	
		{
			"abstract": "> 有排列 $p$，令 $nxt_i$ 为 $p_i$ 右侧第一个大于 $p_i$ 的数的位置，若不存在则 $nxt_i=n+1$。\n> \n> 现在整个 $p$ 和 $nxt$ 的一部分丢失了，请根据剩余的 $nxt$，构造出一个符合情况的 $p$，输出任意一解。\n> \n> $1\\le n\\le 5\\times 10^5$。\n",
			"content": "> 有排列 $p$，令 $nxt_i$ 为 $p_i$ 右侧第一个大于 $p_i$ 的数的位置，若不存在则 $nxt_i=n+1$。\n> \n> 现在整个 $p$ 和 $nxt$ 的一部分丢失了，请根据剩余的 $nxt$，构造出一个符合情况的 $p$，输出任意一解。\n> \n> $1\\le n\\le 5\\times 10^5$。\n\n\n$O(n)$ 单调栈+递归构造即可，完全不需要线段树优化建图跑拓扑。\n\n首先发现由于 $nxt_i=\\min\\{j|j>i,p_j>p_j\\}$，所以 $a_{[i,nxt_i-1]}$ 都要比 $a_{nxt_i}$ 小，$nxt_{[i,nxt_i-1]}$ 也都要小于等于 $nxt_i$。设 $fir_i=\\min\\{j|nxt_j=i\\}$，那么不难发现 $fir_i,i$ 构成了类似括号匹配的关系：\n\n![](../post-images/1680001287529.png)\n\n那么扫一遍序列，用单调栈找到最内层的“右括号”的位置 $pos$，刚开始单调栈中只有一个元素 $n+1$。扫到位置 $i$ 时：\n\n- 先将单调栈顶小于等于 $i$ 的元素弹出；\n- 若 $nxt_i=-1$，那么让 $nxt_i\\to pos$；\n- 否则：\n  - 若 $nxt_i>pos$，那么无解；\n  - 否则若 $nxt_i\\not= pos$ 那么把 $nxt_i$ 加入单调栈；\n\n可以通过下面的构造 $p$ 序列的方法证明这样构造 $nxt$ 是正确的：\n\n不难发现，由于括号的嵌套关系，所以内层小段的构造方法和外层大段的基本相同，只需要加上一个偏移量即可，所以考虑递归构造。\n\n设 $dfs(l,r,mov)$ 表示构造在括号 $lft_{nxt_r},nxt_r$ 中的 $p_{[l,r]}$ 这一段，并且整一段的偏移量为 $mov$。\n\n显然边界条件是 $nxt_{[l,r]}=nxt_r$，这时只要构造 $\\{r-l+1+mov,r-l+mov,r-l-1+mov,\\dots,2+mov,1+mov\\}$ 这样倒着的序列即可。\n\n由于某个 “右括号” 也有可能是左括号，这时这两段要看作一段处理。所以先预处理出 $lb_i$ 表示以 $i$ 为右端点的“连通块”的左端点：\n\n![](../post-images/1680001297220.png)\n\n注意若 $i$ 不为“左括号”或者“右括号”，那么 $lb_i=i$。\n\n在 $dfs(l,r,mov)$ 中：\n\n1. 初始化一个空队列 $vec$，令 $pmov=mov$；\n2. 从右往左扫过区间，扫到 $i$ 时：\n   - 若 $nxt_i=nxt_r$，说明 $p_i$ 属于最外层的括号，那么把 $i$ 放入队列 $vec$ 的末尾，最后再处理；\n   - 若 $nxt_i\\not=nxt_r$，说明 $p_i$ 属于内层的某个括号中，那么递归处理 $dfs(lb_i,i,pmov)$，令 $i\\to lb_i-1$，$pmov\\to pmov+i-lb_i+1$；\n3. 队列 $vec$ 中的元素 $i$ 都满足 $nxt_i=nxt_r$，并且队列中元素是从大到小排列的。那么参照 $nxt_{[l,r]}=nxt_r$ 情况的构造方法，不断从队头取出元素 $i$，令 $p_i\\to pmov$，$pmov\\to pmov+1$ 即可。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nconst int S=500005;\n\nint n,nxt[S];\nint sta[S];\nint lb[S],a[S];\n\nvoid dfs(int l,int r,int mov)\n{\n\tint len=r-l+1,nxmov=mov;\n\tvector<int> vec;\n\tfor(int i=r;i>=l;i--)\n\t{\n\t\tif(nxt[i]!=nxt[r]) dfs(lb[i],i,nxmov),nxmov+=i-lb[i]+1,i=lb[i];\n\t\telse vec.push_back(i);\n\t}\n\tfor(int u:vec) a[u]=++nxmov;\n}\n\ninline void slove()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&nxt[i]);\n\tint top=1;\n\tsta[1]=n+1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\twhile(sta[top]<=i) top--;\n\t\tif(nxt[i]==-1) nxt[i]=sta[top];\n\t\telse\n\t\t{\n\t\t\tif(nxt[i]>sta[top])\n\t\t\t{\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse if(nxt[i]<sta[top]) sta[++top]=nxt[i];\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++) lb[i]=i;\n\tfor(int i=1;i<=n;i++) lb[nxt[i]]=min(lb[nxt[i]],lb[i]);\n\tdfs(1,n,0);\n\tfor(int i=1;i<=n;i++) printf(\"%d \",a[i]);\n\tprintf(\"\\n\");\n}\n\nint main()\n{\n\tint T;\n\tscanf(\"%d\",&T);\n\twhile(T-->0) slove();\n\treturn 0;\n}\n```\n\n",
			"tags": [{"name":"做题记录"},{"name":"构造"}],
			"title": "CF1158C Permutation recovery 做题记录",
			"link": "https://exber.qzz.io/post/CF1158C%20Permutation%20recovery%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-28 19:01:12"
		},
	
		{
			"abstract": "> 有一个长度为 $n$（$n<=10^4$）的**内容未知**的序列，再给 $m$（$m<=50$）个限制，每个限制会给一个位置集合 $S$，需要让 $S$ 中所有位置上的数的 $\\operatorname{lcm}$ 严格大于序列里剩下的数的 $\\operatorname{lcm}$，求是否存在一个这样的序列满足所有限制。存在一个序列输出 `possible`，否则输出 `impossible`。\n",
			"content": "> 有一个长度为 $n$（$n<=10^4$）的**内容未知**的序列，再给 $m$（$m<=50$）个限制，每个限制会给一个位置集合 $S$，需要让 $S$ 中所有位置上的数的 $\\operatorname{lcm}$ 严格大于序列里剩下的数的 $\\operatorname{lcm}$，求是否存在一个这样的序列满足所有限制。存在一个序列输出 `possible`，否则输出 `impossible`。\n\n\n有个结论，这 $m$ 个集合只要两两有交就有解，否则无解。\n\n首先证明不是两两有交就无解，考虑反证。若存在两个集合 $A$ 和 $B$ 无交，则设 $\\operatorname{lcm}_{u\\in A} a_u=x,\\operatorname{lcm}_{u\\in B}a_u=y$。那么由于 $A$ 的补集包含 $B$，所以 $A$ 的补集的 $\\operatorname{lcm}$ 一定大于等于 $y$，设它为 $z$；同理，$B$ 的补集的 $\\operatorname{lcm}$ 一定大于等于 $x$，设它为 $w$。由于 $x>z,z\\ge y$，所以 $x>y$；又由于 $y>w,w\\ge x$，所以 $y>x$，与 $x>y$ 矛盾，得证。\n\n然后考虑在集合两两有交的情况下构造解，可以考虑如下构造：\n\n1. 把所有 $a_i$ 赋值为 $1$；\n2. 给每个集合 $S_i$ 赋一个和别的集合不同的质数 $p_i$，每个满足 $u\\in S_i$ 的 $a_u$ 都乘上 $p_i$；\n\n由于集合两两有交，所以一个集合内的 $\\operatorname{lcm}$ 都是 $\\prod\\limits_{i=1}^mp_i$，而集合外面的 $\\operatorname{lcm}$ 一定会少一个 $p_i$，比集合里的小。\n\n所以直接 $O(m^2n)$ 就行了。\n",
			"tags": [{"name":"做题记录"},{"name":"结论"}],
			"title": "CF1166E The LCMs Must be Large 做题记录",
			"link": "https://exber.qzz.io/post/CF1166E%20The%20LCMs%20Must%20be%20Large%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-28 18:57:56"
		},
	
		{
			"abstract": "> 平面上有 $n$ 个与坐标轴平行的矩形。矩形的所有边的长度都是奇数。矩形不能相交，但它们可以互相接触。\n> \n> 你要让每两个接触的矩形有不同的颜色。如果可以则输出 `YES`，并给出每个矩形图上的颜色（$\\in[1,4]$；如果不行输出`NO`。\n",
			"content": "> 平面上有 $n$ 个与坐标轴平行的矩形。矩形的所有边的长度都是奇数。矩形不能相交，但它们可以互相接触。\n> \n> 你要让每两个接触的矩形有不同的颜色。如果可以则输出 `YES`，并给出每个矩形图上的颜色（$\\in[1,4]$；如果不行输出`NO`。\n\n根据四色定理，所以一定可以染色。\n\n由于长方形的边长都是奇数，所以可以按照长方形左下角两个坐标的奇偶性分类，分别叫做奇奇、奇偶、偶奇、偶偶。与某种类型的长方形相邻的长方形一定是另外三种类型之一，所以可以给奇奇涂 $1$、奇偶涂 $2$、偶奇涂 $3$、偶偶涂 $4$。\n",
			"tags": [{"name":"做题记录"},{"name":"结论"}],
			"title": "CF763B Timofey and rectangles 做题记录",
			"link": "https://exber.qzz.io/post/CF763B%20Timofey%20and%20rectangles%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-28 18:53:02"
		},
	
		{
			"abstract": "> 最近，Alice 迷上了一款名为 Sirtet 的游戏。\n> \n> 在 Sirtet 中，玩家会得到一个 $n \\times m$ 的网格。初始时，格 $(i, j)$ 上码放有 $a_{i, j}$ 个方块。若两个格子有一条公共边，我们称这两个格子时相邻的。玩家可以进行以下两种操作：\n> \n> - 在两个相邻的格子上各码上一个方块。\n> - 在一个格子上码上两个方块。\n> \n> 上述中所提到的所有方块都具有相同的高度。\n> \n> 玩家的目标是通过这些操作，使得所有的格子拥有同样的高度（也就是说，每个格子上堆放的方块数相同）。\n> \n> 然而，Alice 发现存在有某些初始局面，使得无论她采用什么策略，都无法达到目标。因此，她希望知道有多少初始局面，满足，\n> \n> - 对于所有的 $1 \\le i \\le n$，$1 \\le j \\le m$，$L \\le a_{i, j} \\le R$。\n> - 玩家可以通过执行这些操作，达到目标。\n> \n> 请帮助 Alice 解决这个问题。注意答案可能很大，请输出所求答案对 $998244353$ 取模的值。\n",
			"content": "> 最近，Alice 迷上了一款名为 Sirtet 的游戏。\n> \n> 在 Sirtet 中，玩家会得到一个 $n \\times m$ 的网格。初始时，格 $(i, j)$ 上码放有 $a_{i, j}$ 个方块。若两个格子有一条公共边，我们称这两个格子时相邻的。玩家可以进行以下两种操作：\n> \n> - 在两个相邻的格子上各码上一个方块。\n> - 在一个格子上码上两个方块。\n> \n> 上述中所提到的所有方块都具有相同的高度。\n> \n> 玩家的目标是通过这些操作，使得所有的格子拥有同样的高度（也就是说，每个格子上堆放的方块数相同）。\n> \n> 然而，Alice 发现存在有某些初始局面，使得无论她采用什么策略，都无法达到目标。因此，她希望知道有多少初始局面，满足，\n> \n> - 对于所有的 $1 \\le i \\le n$，$1 \\le j \\le m$，$L \\le a_{i, j} \\le R$。\n> - 玩家可以通过执行这些操作，达到目标。\n> \n> 请帮助 Alice 解决这个问题。注意答案可能很大，请输出所求答案对 $998244353$ 取模的值。\n\n观察到奇偶性相同的情况下只要不断应用操作 $2$ 就可以达到目标，所以问题就转化为求能让所有 $a_{i,j}$ 奇偶性相同的方案数。\n\n改变奇偶性的操作只有操作 $1$，它一次可以改变相邻两个位置的奇偶性。不难发现，对于两个位置 $(x1,y1)$ 和 $(x2,y2)$，只要在它们之间的最短路上相邻的每两个位置都操作一次，就可以只改变 $a_{x1,y1}$ 和 $a_{x2,y2}$ 的奇偶性而不对其它的位置造成影响。所以问题就转化为：\n\n> 有多少个 $n\\times m$，元素值域 $[L,R]$ 的网格满足可以通过任意多次改变**恰好两个位置**奇偶性来让所有元素的奇偶性相同？\n\n不难发现，这个操作并不能改变奇元素个数的奇偶性和偶元素个数的奇偶性，所以一个网格满足条件当且仅当**奇元素个数和偶元素个数中有至少一个是偶数**。\n\n那么显然 $nm$ 为奇数时网格的所有元素都可以任意取，方案数为 $(R-L+1)^{nm}$。\n\n当 $nm$ 为偶数时，设 $[L,R]$ 内偶数有 $E$ 个，奇数有 $O$ 个，那么方案数为：\n$$\n\\sum\\limits_{i=0}^{\\frac{nm}{2}}\\binom{nm}{2i}E^{2i}O^{nm-2i}\n$$\n发现这个很像二项式定理，那么考虑：\n$$\n(E+O)^{nm}=\\sum\\limits_{i=0}^{nm}\\binom{nm}{i}E^iO^{nm-i}\n$$\n把奇数项和偶数项拆开看：\n$$\n\\sum\\limits_{i=0}^{\\frac{nm}{2}}\\binom{nm}{2i}E^{2i}O^{nm-2i}+\\sum\\limits_{i=1}^{\\frac{nm}{2}}\\binom{nm}{2i-1}E^{2i-1}O^{nm-2i+1}\n$$\n前面部分正好是我们想要的，考虑消去后面的部分，观察到：\n$$\n(E-O)^{nm}=\\sum\\limits_{i=0}^{\\frac{nm}{2}}\\binom{nm}{2i}E^{2i}O^{nm-2i}-\\sum\\limits_{i=1}^{\\frac{nm}{2}}\\binom{nm}{2i-1}E^{2i-1}O^{nm-2i+1}\n$$\n中间是减号是因为后面 $O$ 的指数是奇数，系数是 $-1$。\n\n所以\n$$\n\\begin{aligned}\n\\sum\\limits_{i=0}^{\\frac{nm}{2}}\\binom{nm}{2i}E^{2i}O^{nm-2i}&=\\frac{\\left(\\sum\\limits_{i=0}^{\\frac{nm}{2}}\\binom{nm}{2i}E^{2i}O^{nm-2i}+\\sum\\limits_{i=1}^{\\frac{nm}{2}}\\binom{nm}{2i-1}E^{2i-1}O^{nm-2i+1}\\right)+\\left(\\sum\\limits_{i=0}^{\\frac{nm}{2}}\\binom{nm}{2i}E^{2i}O^{nm-2i}-\\sum\\limits_{i=1}^{\\frac{nm}{2}}\\binom{nm}{2i-1}E^{2i-1}O^{nm-2i+1}\\right)}{2}\\\\\n&=\\frac{(E+O)^{nm}+(E-O)^{nm}}{2}\n\\end{aligned}\n$$\n有个细节就是快速幂要特判底数为 $0$ 的情况。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int p=998244353,inv2=499122177;\n\nint n,m,L,R;\n\ninline int qpow(int x,int y)\n{\n\tif(x==0) return 0;\n\tint res=1;\n\tfor(;y>0;y>>=1,x=1ll*x*x%p) res=(y&1)?1ll*res*x%p:res;\n\treturn res;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d%d\",&n,&m,&L,&R);\n\tif(1ll*n*m&1)\n\t{\n\t\tprintf(\"%d\\n\",qpow((R-L+1)%p,1ll*n*m%(p-1)));\n\t}\n\telse\n\t{\n\t\tint E=(R-L+1)/2+((L&1)==(R&1)),O=R-L+1-E;\n\t\tE%=p,O%=p;\n\t\tint val=1ll*n*m%(p-1);\n\t\tprintf(\"%d\\n\",1ll*(qpow((E+O)%p,val)+qpow((E-O+p)%p,val))%p*inv2%p);\n\t}\n\treturn 0;\n}\n```\n\n",
			"tags": [{"name":"做题记录"},{"name":"数学"},{"name":"组合计数"}],
			"title": "CF1332E Height All the Same 做题记录",
			"link": "https://exber.qzz.io/post/CF1332E%20Height%20All%20the%20Same%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-28 18:12:03"
		},
	
		{
			"abstract": "> $n$ 个整数排成一个环，每次可以选择一个 $x$ 并把环上相邻的某两个整数其中一个加上 $x$，另一个减去 $x$。求把所有整数都变成 $0$ 的最小操作次数。\n>\n> $1\\le n\\le 10^5$，$0\\le |a_i|\\le 10^9$。\n",
			"content": "> $n$ 个整数排成一个环，每次可以选择一个 $x$ 并把环上相邻的某两个整数其中一个加上 $x$，另一个减去 $x$。求把所有整数都变成 $0$ 的最小操作次数。\n>\n> $1\\le n\\le 10^5$，$0\\le |a_i|\\le 10^9$。\n\n考虑设序列 $s_i=a_1+a_2+a_3,\\dots,+a_i$，那么一次操作相当于：\n\n1. 选定一个 $1\\sim n-1$ 的整数 $i$，让 $s_i$ 减去任意一个整数 $x$（可正可负）；\n\n2. 让 $s_{1\\sim n-1}$ 减去任意一个整数 $x$（可正可负）；\n\n目标是让所有 $s_i$ 都变成 $0$。\n\n那么若 $s_n\\not=0$ 就一定无解，否则注意到第一种操作相当于任意更改 $s_{1\\sim n-1}$ 中的某个数，那么可以把 $s_{1\\sim n-1}$ 都变成同一个数 $y$，最后若 $x\\not=0$ 再进行一次第二种操作。\n\n那么解法就呼之欲出了，只要排序找到 $s_{1\\sim n}$ 中出现次数最多的数并统计出它的出现次数 $cnt$，答案即为 $n-cnt$。时间复杂度 $O(n\\log n)$。\n\n注意开 `long long`。\n",
			"tags": [{"name":"做题记录"},{"name":"杂题"}],
			"title": "CF675C Money Transfers 做题记录",
			"link": "https://exber.qzz.io/post/CF675C%20Money%20Transfers%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-28 18:07:12"
		},
	
		{
			"abstract": "> 给出两个长度为 $n$ 的数列 $a,b$，你需要判断能否在数次操作后使得 $a$ 与 $b$ 相同。\n> \n> 操作是指你可以选择一个 $k(1\\le k\\le\\lfloor\\frac n2\\rfloor)$，之后交换 $a$ 的长度为 $k$ 的前缀和长度为 $k$ 的后缀。\n> \n> 例如对于 $a=\\{1,2,3,4,5,6\\}$，选择 $k=2$，那么交换后会得到 $\\{5,6,3,4,1,2\\}$。\n> \n> $1\\le n\\le500$，$1\\le a_i,b_i\\le10^9$。\n",
			"content": "> 给出两个长度为 $n$ 的数列 $a,b$，你需要判断能否在数次操作后使得 $a$ 与 $b$ 相同。\n> \n> 操作是指你可以选择一个 $k(1\\le k\\le\\lfloor\\frac n2\\rfloor)$，之后交换 $a$ 的长度为 $k$ 的前缀和长度为 $k$ 的后缀。\n> \n> 例如对于 $a=\\{1,2,3,4,5,6\\}$，选择 $k=2$，那么交换后会得到 $\\{5,6,3,4,1,2\\}$。\n> \n> $1\\le n\\le500$，$1\\le a_i,b_i\\le10^9$。\n\n\n结论题，别的题解都没给证明，我来证一下吧。\n\n观察到每次操作中对于所有满足 $i\\le \\lfloor\\frac{n}{2}\\rfloor$ 的 $i$ 都进行了  $\\operatorname{swap}(a_i,a_{n-k+i})$，而和 $a_i$ 以序列中点对称的元素是 $a_{n-i+1}$，操作中同时进行了 $\\operatorname{swap}(a_{k-i+1},a_{n-i+1})$，所以 $(a_i,a_{n-i+1})$ 和 $(a_{k-i+1},a_{n-k+i})$ 在交换之后仍然以序列中点对称。\n\n那么把 $a$ “对折”，把 $(a_i,a_{n-i+1})$ 这一对记作 $b_i$，那么每次操作相当于是交换了所有满足 $i\\le \\lfloor\\frac{k}{2}\\rfloor$  的 $b_i$ 和 $b_{k-i+1}$，并且所有满足 $i\\le k$ 的 $b_i$ 组内顺序都被交换了。\n\n不难发现，组内顺序是可以随便交换的，只要做一次 $k=i$，一次 $k=1$，一次 $k=i$ 即可。\n\n现在问题转化为：\n\n> 有一个 $n$ 的排列 $p$，请问能否通过任意次交换满足 $1\\le i\\le \\lfloor\\frac{k}{2}\\rfloor$ 的 $p_i$ 和 $p_{k-i+1}$，得到 $n$ 的另外的一个排列 $b$？\n\n这个问题对于任意 $p,b$ 的答案都是可以，证明如下：\n\n****\n\n- 引理：可以使用 $2$ 次操作将 $p_1,p_2,p_3,\\dots,p_i$ 变为 $p_i,p_1,p_2,\\dots p_{i-1}$，即让某个前缀往后循环移位一位。\n\n  证明：一次 $k=i-1$，一次 $k=i$ 的操作即可。\n\n不难发现，想要证明从任意 $p$ 出发可以到达任意 $b$，只要证明能交换 $p$ 中任意相邻两项即可。\n\n考虑相邻的两项 $i,i+1$，我们只需要做一次 $k=i-1$ 的操作，把 $p_{[1,i+1]}$ 往后循环移位两位，再做一次 $k=i+1$ 的操作即可交换 $p_i,p_{i+1}$，得证。\n\n****\n\n所以直接开桶做就行了。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <map>\n\nusing namespace std;\n\nconst int S=505;\n\nint n,a[S],b[S];\nmap<int,map<int,int> > mp;\n\ninline void slove()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&b[i]);\n\tif((n&1)&&a[n/2+1]!=b[n/2+1])\n\t{\n\t\tputs(\"No\");\n\t\treturn;\n\t}\n\tif(n==1)\n\t{\n\t\tputs(\"Yes\");\n\t\treturn;\n\t}\n\tmp.clear();\n\tfor(int i=1;i<=n/2;i++) mp[a[i]][a[n-i+1]]++,mp[a[n-i+1]][a[i]]++;\n\tfor(int i=1;i<=n/2;i++)\n\t{\n\t\tif(mp[b[i]][b[n-i+1]]==0)\n\t\t{\n\t\t\tputs(\"No\");\n\t\t\treturn;\n\t\t}\n\t\tmp[b[i]][b[n-i+1]]--;\n\t\tmp[b[n-i+1]][b[i]]--;\n\t}\n\tputs(\"Yes\");\n}\n\nint main()\n{\n\tint T;\n\tscanf(\"%d\",&T);\n\twhile(T--) slove();\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"结论"}],
			"title": "CF1365F Swaps Again 做题记录",
			"link": "https://exber.qzz.io/post/CF1365F%20Swaps%20Again%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-28 18:05:14"
		},
	
		{
			"abstract": "> 给定两个长度为 $n$ 的 $01$ 串 $a$ 和 $b$，要求串 $a$ 的任意子序列经过若干次“旋转”操作变为串 $b$。\n> \n> 对于一次“旋转操作”我们这样定义：\n> \n> 如果我们要旋转的序列为\n> \n> $c_1,c_2,c_3,c_4,c_5...c_n$\n> \n> 那么旋转之后的序列为 $c_n,c_1,c_2,c_3,c_4...c_{n-1}$\n> \n> 例如对于 $s=1110100$\n> \n> 如果我们旋转的子序列的下标为 ${2,6,7}$（从1开始）\n> \n> 那么旋转之后的串为 $1010110$\n> \n> 求至少进行多少次“旋转”操作，能够把串 $a$ 变成串 $b$\n> \n> $n(1\\le n\\le 10^6)$。\n",
			"content": "> 给定两个长度为 $n$ 的 $01$ 串 $a$ 和 $b$，要求串 $a$ 的任意子序列经过若干次“旋转”操作变为串 $b$。\n> \n> 对于一次“旋转操作”我们这样定义：\n> \n> 如果我们要旋转的序列为\n> \n> $c_1,c_2,c_3,c_4,c_5...c_n$\n> \n> 那么旋转之后的序列为 $c_n,c_1,c_2,c_3,c_4...c_{n-1}$\n> \n> 例如对于 $s=1110100$\n> \n> 如果我们旋转的子序列的下标为 ${2,6,7}$（从1开始）\n> \n> 那么旋转之后的串为 $1010110$\n> \n> 求至少进行多少次“旋转”操作，能够把串 $a$ 变成串 $b$\n> \n> $n(1\\le n\\le 10^6)$。\n\n首先 $0$、$1$ 数量不同显然无解。\n\n发现 $a_i=b_i$ 的位置不动是最优的，只考虑 $a_i\\not=b_i$ 的位置。\n\n设剔除掉所有 $a_i=b_i$ 的位置后的 $a$ 为 $c$，那么显然 $c$ 中 $0$ 的个数和 $1$ 的个数是相等的。\n\n考虑一次操作能干什么，显然可以选择 $c$ 中的一个 $0$ 和一个 $1$，消除这两个位置。更进一步，每一次操作都可以选一个 $0101010101$ 或者 $1010101010$ 这样 $01$ 相间的长度为偶数的子序列，把这些位置都消除。\n\n那么问题就变成了把 $c$ 划分成尽量少的 $01$ 相间的偶长子序列，有一个朴素的贪心算法：\n\n- 设 $cnt_0,cnt_1$ 分别表示当前以 $0$ 和 $1$ 结尾的子序列有多少个，那么扫一遍 $c$，能接就接，否则新建即可。\n\n这样选出来的 $01$ 相间的子序列显然是最少的，但是不一定都是偶长。不难发现，由于 $c$ 中 $0$ 和 $1$ 的个数相等，所以一定不会出现长度为 $1$ 的子序列，以 $0$ 结尾的长度为奇数的子序列个数也一定与以 $1$ 结尾的长度为奇数的子序列个数相等。那么让这些长度为奇数的子序列按照结尾字符两两配对，每对中结尾靠后的字符拼到结尾靠前的子序列后面即可。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=1000005;\n\nint n;\nchar a[S],b[S];\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tscanf(\"%s%s\",a+1,b+1);\n\tint cnta=0,cntb=0;\n\tfor(int i=1;i<=n;i++) cnta+=a[i]=='1',cntb+=b[i]=='1';\n\tif(cnta!=cntb)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tint cnt0=0,cnt1=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(a[i]!=b[i])\n\t\t{\n\t\t\tif(a[i]=='0')\n\t\t\t{\n\t\t\t\tif(cnt1>0) cnt1--;\n\t\t\t\tcnt0++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(cnt0>0) cnt0--;\n\t\t\t\tcnt1++;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",cnt0+cnt1);\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"杂题"}],
			"title": "CF1370E Binary Subsequence Rotation 做题记录",
			"link": "https://exber.qzz.io/post/CF1370E%20Binary%20Subsequence%20Rotation%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-28 18:02:17"
		},
	
		{
			"abstract": "> 给定一个正整数 $n$，将它的所有大于一的因数按照任意顺序排列在一个环上，你每次可以选择圈上相邻的两个数，在它们中间插入他们的最小公倍数，使得最后的环上不存在两个相邻且互质的数。你需要找到一个需要进行操作次数最少的排列。\n> \n> $4 \\le n \\le 10^9$。\n",
			"content": "> 给定一个正整数 $n$，将它的所有大于一的因数按照任意顺序排列在一个环上，你每次可以选择圈上相邻的两个数，在它们中间插入他们的最小公倍数，使得最后的环上不存在两个相邻且互质的数。你需要找到一个需要进行操作次数最少的排列。\n> \n> $4 \\le n \\le 10^9$。\n\n容易发现，若 $n=pq$，其中 $p$ 和 $q$ 都是质数，也就是说 $n$ 除了 $1$ 之外只有 $3$ 个因子时，一定需要 $1$ 次操作，否则需要 $0$ 次操作。若 $n=p^k$ 显然直接输出除了 $1$ 外的所有因子即可，否则不难想到一种构造方法：把除了 $1$ 外的因子按照最小质因子分类，每一类放连续一段，两段之间用两个质因子的乘积连接起来。\n\n注意特判只有两类的情况，代码如下：\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nconst int S=5005;\n\nint n,a[S];\nint tot;\nmap<int,int> idx;\nvector<int> vec[S];\nint ans[S];\n\ninline void slove()\n{\n\tint x;\n\tscanf(\"%d\",&x);\n\tn=0;\n\tfor(int i=2;i*i<=x;i++)\n\t{\n\t\tif(x%i==0)\n\t\t{\n\t\t\ta[++n]=i;\n\t\t\tif(i*i!=x) a[++n]=x/i;\n\t\t}\n\t}\n\ta[++n]=x;\n\tsort(a+1,a+n+1);\n\tidx.clear();\n\ttot=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint mxj=1;\n\t\tbool f=false;\n\t\tfor(int j=2;j*j<=a[i];j++)\n\t\t{\n\t\t\tmxj=j;\n\t\t\tif(a[i]%j==0)\n\t\t\t{\n\t\t\t\tif(idx.find(j)==idx.end()) idx[j]=++tot;\n\t\t\t\tvec[idx[j]].push_back(a[i]);\n\t\t\t\tf=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int j=mxj;j>=1&&!f;j--)\n\t\t{\n\t\t\tif(a[i]%j==0)\n\t\t\t{\n\t\t\t\tj=a[i]/j;\n\t\t\t\tif(idx.find(j)==idx.end()) idx[j]=++tot;\n\t\t\t\tvec[idx[j]].push_back(a[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif(tot==1)\n\t{\n\t\tfor(int u:vec[1]) printf(\"%d \",u);\n\t\tprintf(\"\\n0\\n\");\n\t}\n\telse if(n==3)\n\t{\n\t\tfor(int i=1;i<=n;i++) printf(\"%d \",a[i]);\n\t\tprintf(\"\\n1\\n\");\n\t}\n\telse if(tot==2)\n\t{\n\t\tint cnt=0;\n\t\tans[n]=a[n];\n\t\tfor(int u:vec[1]) if(u!=ans[n]&&u!=vec[1][0]*vec[2][0]) ans[++cnt]=u;\n\t\tans[++cnt]=vec[1][0]*vec[2][0];\n\t\tfor(int u:vec[2]) ans[++cnt]=u;\n\t\tfor(int i=1;i<=n;i++) printf(\"%d \",ans[i]);\n\t\tprintf(\"\\n0\\n\");\n\t}\n\telse\n\t{\n\t\tint cnt=0;\n\t\tans[n]=vec[1][0]*vec[tot][0];\n\t\tfor(int u:vec[1]) if(u!=ans[n]&&u!=vec[1][0]*vec[2][0]) ans[++cnt]=u;\n\t\tans[++cnt]=vec[1][0]*vec[2][0];\n\t\tfor(int i=2;i<tot;i++)\n\t\t{\n\t\t\tfor(int u:vec[i]) if(u!=vec[i][0]*vec[i+1][0]) ans[++cnt]=u;\n\t\t\tans[++cnt]=vec[i][0]*vec[i+1][0];\n\t\t}\n\t\tfor(int u:vec[tot]) ans[++cnt]=u;\n\t\tfor(int i=1;i<=n;i++) printf(\"%d \",ans[i]);\n\t\tprintf(\"\\n0\\n\");\n\t}\n\tfor(int i=1;i<=tot;i++) vec[i].clear();\n}\n\nint main()\n{\n\tint T;\n\tscanf(\"%d\",&T);\n\twhile(T-->0) slove();\n\treturn 0;\n}\n```\n\n",
			"tags": [{"name":"做题记录"},{"name":"构造"}],
			"title": "CF1419E Decryption 做题记录",
			"link": "https://exber.qzz.io/post/CF1419E%20Decryption%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-28 17:51:52"
		},
	
		{
			"abstract": "> 给定一个数组 $a$, 你将将 $a_i$ 染为 $b_i$ 色, 其中 $b$ 是由你指定的一个 **01 数组**. 将 $a$ 数组中被染成 0 色的数字取出来并依在 $a$ 中出现的顺序排列, 组成数组 $a^{(0)}$. 同理, 将 $a$ 数组中被染成 1 色的数字取出来并依在 $a$ 中出现的顺序排列, 组成数组 $a^{(1)}$. 我们定义 $seg(c)$ 是一个正整数, 其中 $c$ 是一个数组, $seg(c)$ 的值为在我们将 $c$ 中相邻的所有相同元素合并后, $c$ 数组的大小. 例如, $seg([1, 1, 4, 5, 1, 4]) = |[1, 4, 5, 1, 4]|=5$. 最小化 $seg(a^{(0)})+seg(a^{(1)})$。\n> $1\\leq n\\leq 10^5$，$1\\le a_i\\le n$。\n",
			"content": "> 给定一个数组 $a$, 你将将 $a_i$ 染为 $b_i$ 色, 其中 $b$ 是由你指定的一个 **01 数组**. 将 $a$ 数组中被染成 0 色的数字取出来并依在 $a$ 中出现的顺序排列, 组成数组 $a^{(0)}$. 同理, 将 $a$ 数组中被染成 1 色的数字取出来并依在 $a$ 中出现的顺序排列, 组成数组 $a^{(1)}$. 我们定义 $seg(c)$ 是一个正整数, 其中 $c$ 是一个数组, $seg(c)$ 的值为在我们将 $c$ 中相邻的所有相同元素合并后, $c$ 数组的大小. 例如, $seg([1, 1, 4, 5, 1, 4]) = |[1, 4, 5, 1, 4]|=5$. 最小化 $seg(a^{(0)})+seg(a^{(1)})$。\n> $1\\leq n\\leq 10^5$，$1\\le a_i\\le n$。\n\n\n## DP\n\n先合并序列中相邻的相同元素，即让 $a$ 中相邻两项不同，显然这样并不会改变答案。\n\n设 $dp_{i}$ 表示前 $i$ 个分完组的答案，不难发现 $i$ 和 $i-1$ 分到同一组一定是不优的，所以 $dp_i$ 实际上的定义是前 $i$ 个分完组，$i$ 和 $i-1$ 不在同一组的答案，那么可以通过枚举 $i$ 分到的组中它前面的那个元素的位置 $j-1$ 来转移：\n$$\ndp_{i}=\\min\\limits_{j=1}^{i-1} dp_j+(i-j-1)+[a_{j-1}\\not=a_i]\n$$\n初始状态 $dp_1=1$。\n\n转移中加上 $i-j-1$ 是因为 $[j,i-1]$ 都要分配到一组里，但是 $j$ 的贡献已经包含在了 $dp_j$ 里面。\n\n不难发现，由于 $[j,i-1]$ 都要分配到一组里，所以 $j$ 肯定越大越好，那么 $j$ 就只能取 $a_i$ 在 $i$ 之前最后的出现位置的后一个位置 $lst_{a_i}+1$ 或者 $i-1$。\n\n所以有转移：\n$$\ndp_{i}=\\min(dp_{lst_{a_i}+1}+(i-lst_{a_i}-2),dp_{i-1}+[a_{i-2}\\not=a_{i}])\n$$\n\n## 贪心\n\n其实这就是 `Bélády's algorithm`，贪心策略如下：\n\n1. 建立两个数组 $c_0$ 和 $c_1$ 用来存储两组具体的数值，初始两个数组均为空，记 $d_0,d_1$ 分别表示两个数组的末尾元素；\n2. 预处理出 $nxt_{i,j}$ 表示 $i$ 后面第一个出现的 $j$ 的位置；\n3. 从前往后扫描 $a$，扫描到 $a_i$ 的时候：\n   1. 若 $c_0$ 非空且 $a_i=d_0$，那么把 $a_i$ 放到 $c_0$ 末尾；\n   2. 否则若 $c_1$ 非空且 $a_i=d_1$，那么把 $a_i$ 放到 $c_1$ 末尾；\n   3. 否则若 $c_0$ 和 $c_1$ 有一个为空，那么把 $a_i$ 放入空的那个数组；\n   4. 否则若 $nxt_{i,d_0}>nxt_{i,d_1}$，那么把 $a_i$ 放到 $c_0$ 末尾；\n   5. 否则把 $a_i$ 放到 $c_1$ 末尾；\n4. 最后扫一遍 $c_0,c_1$ 即可求出答案；\n\n理性证明在[官方题解](https://codeforces.com/blog/entry/87598?locale=en)中有提及，这里给出感性证明：\n\n首先步骤 $1$、$2$ 和 $4$ 都很显然，重点证明步骤 $3$，第 $1$、$2$、$3$ 条都很显然，重点证明第 $4$ 条和第 $5$ 条。\n\n$nxt_{i,d_0}>nxt_{i,d_1}$ 表明 $d_0$ 和与它相等的元素相遇需要把更多元素放进 $c_1$，让 $d_0$ 等它后面相同的元素就不是很优，所以要把 $a_i$ 放入 $c_0$，第 $5$ 条同理。\n\n感性证明完毕。\n\n参考代码：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nconst int S=100005;\n\nint n,a[S];\n\nnamespace dp\n{\n\tint m,b[S];\n\tint lst[S],dp[S];\n\tinline void slove()\n\t{\n\t\tfor(int i=1;i<=n;i++) if(a[i]!=a[i-1]) b[++m]=a[i];\n\t\tdp[1]=1;\n\t\tlst[b[1]]=1;\n\t\tfor(int i=2;i<=m;i++)\n\t\t{\n\t\t\tdp[i]=dp[i-1]+(b[i]!=b[i-2]);\n\t\t\tif(lst[b[i]]!=0)\n\t\t\t{\n\t\t\t\tint j=lst[b[i]]+1;\n\t\t\t\tdp[i]=min(dp[i],dp[j]+(i-j-1));\n\t\t\t}\n\t\t\tlst[b[i]]=i;\n\t\t}\n\t\tprintf(\"%d\\n\",dp[m]);\n\t}\n}\n\nnamespace greedy\n{\n\tvector<int> pos[S];\n\tint tb,b[S];\n\tint tc,c[S];\n\tinline void slove()\n\t{\n\t\tfor(int i=1;i<=n;i++) pos[a[i]].push_back(i);\n\t\tfor(int i=1;i<=n;i++) pos[i].push_back(n+1);\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(a[i]==b[tb]||tb==0) b[++tb]=a[i];\n\t\t\telse if(a[i]==c[tc]||tc==0) c[++tc]=a[i];\n\t\t\telse if(pos[b[tb]]>pos[c[tc]]) b[++tb]=a[i];\n\t\t\telse c[++tc]=a[i];\n\t\t\tpos[a[i]].erase(pos[a[i]].begin());\n\t\t}\n\t\tint ans=0;\n\t\tfor(int i=1;i<=tb;i++) ans+=b[i]!=b[i-1];\n\t\tfor(int i=1;i<=tc;i++) ans+=c[i]!=c[i-1];\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n//\tdp::slove();\n//\tgreedy::slove();\n\treturn 0;\n}\n```\n\n",
			"tags": [{"name":"做题记录"},{"name":"杂题"}],
			"title": "CF1479B2 Painting the Array II 做题记录",
			"link": "https://exber.qzz.io/post/CF1479B2%20Painting%20the%20Array%20II%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-28 17:47:07"
		},
	
		{
			"abstract": "> 一个长度为 $n$ 的初始排列为 $[1,2,3,4,\\ldots,n]$ 。\n>\n> 对其进行下列操作：\n> \n> - 首先，我们将其循环移动 $k$ 位， $k$ 为一个未知数 $(0 \\leq k \\leq n-1)$ 。\n> \n> 将一个长度为 $n$ 的数组循环移动k位就是将原数组最后 $k$ 位移动到第 $1 \\sim k$ 位，并将其余 $n-k$ 位移动到第 $k+1 \\sim n$ 位。比如说，我们将 $[1,2,3,4,5,6]$ 循环移动两位，就是 $[5,6,1,2,3,4]$ 。\n> \n> - 然后，我们将数组中任意两个数交换，最多进行 $m$ 次。\n> \n> 给定 $n,m$ 和最后的结果，你需要找出所有可能的 $k$ 值。\n> \n> $3 \\leq n \\leq 3 \\times 10^5$，$0 \\leq m \\leq \\dfrac{n}{3}$，$1 \\leq p_i \\leq n$ ，每个 $1 \\sim n$ 的整数均只出现一次。\n",
			"content": "> 一个长度为 $n$ 的初始排列为 $[1,2,3,4,\\ldots,n]$ 。\n>\n> 对其进行下列操作：\n> \n> - 首先，我们将其循环移动 $k$ 位， $k$ 为一个未知数 $(0 \\leq k \\leq n-1)$ 。\n> \n> 将一个长度为 $n$ 的数组循环移动k位就是将原数组最后 $k$ 位移动到第 $1 \\sim k$ 位，并将其余 $n-k$ 位移动到第 $k+1 \\sim n$ 位。比如说，我们将 $[1,2,3,4,5,6]$ 循环移动两位，就是 $[5,6,1,2,3,4]$ 。\n> \n> - 然后，我们将数组中任意两个数交换，最多进行 $m$ 次。\n> \n> 给定 $n,m$ 和最后的结果，你需要找出所有可能的 $k$ 值。\n> \n> $3 \\leq n \\leq 3 \\times 10^5$，$0 \\leq m \\leq \\dfrac{n}{3}$，$1 \\leq p_i \\leq n$ ，每个 $1 \\sim n$ 的整数均只出现一次。\n\n\n首先不难想到枚举每一个 $k$，求出循环移位之后的排列 $a$，快速判断能否在 $m$ 次交换内让 $p=a$。\n\n若我们交换 $m$ 次，最多能让 $p$ 中 $2m$ 个数归位。也就是说，$p$ 中至少要有 $n-2m$ 个数不用交换就已经归位。\n\n因为对于每个 $i$，不交换就让 $p_i=a_i$ 的 $a$ 只会有一个，所以每个 $i$ 都只会有一个 $k$ 能让 $p_i$ 不交换就已经归位，设这个 $k$ 为 $k_i$。\n\n由于 $m\\le \\frac{n}{3}$，所以 $n-2m\\ge \\frac{n}{3}$。也就是说，我们枚举的 $k=k'$ 要满足至少有 $\\frac n 3$ 个 $k_i=k$，所以满足条件的 $k'$ 最多只有 $3$ 个。\n\n但是这个条件只是必要条件，不是充分条件，所以我们还要作进一步的判断。设循环移位 $k'$ 位之后的排列是 $a$，那么问题就转化为求让 $p=a$ 的最少交换次数。\n\n这是一个经典问题，建立 $n$ 个点，对于每一个 $p_i$，都从 $i$ 向满足 $p_j=a_i$ 的 $j$ 连一条有向边，最少交换次数即为 $n-\\text{环个数}$。\n\n其实也可以从 $i$ 向满足 $p_j=a_i$ 的 $j$ 连一条无向边，最少交换次数即为 $n-\\text{连通块个数}$。\n\n****\n\n解释：\n\n考虑这样构造出来的图，显然每个点都有且仅有一个入度和一个出度，那么最后的图一定是由若干个环组成的。\n\n考虑一次交换操作，显然只有交换同一个环内的点是有用的，交换 $p_i,p_j$ 就相当于把 $i$ 的出边和 $j$ 的出边交换，相当于把大环断成两个小环，那么总共需要断 $\\text{环的大小}-1$ 次，所以做法成立。\n\n****\n",
			"tags": [{"name":"做题记录"},{"name":"构造"}],
			"title": "CF1553E Permutation Shift 做题记录",
			"link": "https://exber.qzz.io/post/CF1553E%20Permutation%20Shift%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-28 14:31:15"
		},
	
		{
			"abstract": "> 交互题。\n> \n> 在 $1$ 到 $n$ 里有一个运动的点，要求找到这个点，每次可以查询一个区间内有没有这个点，每次这个点往左或者往右移动 $1$ 到 $k$ 个位置，要求要在 $4500$ 次查询内找到这个点的位置。\n",
			"content": "> 交互题。\n> \n> 在 $1$ 到 $n$ 里有一个运动的点，要求找到这个点，每次可以查询一个区间内有没有这个点，每次这个点往左或者往右移动 $1$ 到 $k$ 个位置，要求要在 $4500$ 次查询内找到这个点的位置。\n\n\n首先可以用二分缩小范围，但是不难发现长度最多只能缩小到 $4k$ 左右。\n\n观察到 $k$ 很小，所以考虑随机化，每次随机问一个位置，若不是就扩大区间，若区间长度超过 $4k$ 就重新二分。\n\n由于 $4k\\le 40$，询问次数却有 $4500$ 次，所以找不到答案的概率几乎为 $0$。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <ctime>\n#include <cstdlib>\n\nusing namespace std;\n\nlong long n;\nint k;\nchar str[15];\n\ninline bool que(long long l,long long r)\n{\n\tprintf(\"%lld %lld\\n\",l,r);\n\tfflush(stdout);\n\tscanf(\"%s\",str);\n\treturn str[0]=='Y';\n}\n\nint main()\n{\n\tsrand(time(NULL));\n\tscanf(\"%lld%d\",&n,&k);\n\tlong long l=1,r=n;\n\twhile(l<r)\n\t{\n\t\tif(r-l+1<=k*4)\n\t\t{\n\t\t\tlong long pos=l+1ll*rand()*rand()%(r-l+1);\n\t\t\tif(que(pos,pos)) break;\n\t\t\tl=max(l-k,1ll),r=min(r+k,n);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlong long mid=l+r>>1;\n\t\t\tif(que(l,mid)) r=min(mid+k,n),l=max(l-k,1ll);\n\t\t\telse r=min(r+k,n),l=max(mid+1-k,1ll);\n\t\t}\n\t}\n\tque(l,l);\n\treturn 0;\n}\n```\n\n",
			"tags": [{"name":"做题记录"},{"name":"交互、通信"}],
			"title": "CF1039B Subway Pursuit 做题记录",
			"link": "https://exber.qzz.io/post/CF1039B%20Subway%20Pursuit%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-28 14:28:54"
		},
	
		{
			"abstract": "> 本题是交互题。\n>\n> 给定长为 $n$ 的数组 $a=[a_1,a_2,...,a_n]$ 和 $k$ 个互不相交的子集 $S_1,S_2,...,S_k$，这些子集中的元素都是 $[1,n]$ 之间的正整数。这些子集两两的**交集**为**空**。\n>\n> 你可以进行最多 $12$ 次询问。每次询问你可以给出 $c$ 个互不相同且在 $[1,n]$ 之间的正整数 $v_1,v_2,...,v_c$，然后你会得到 $\\max\\{v_i\\}$。\n>\n> 对于每个子集 $S_i$，你需要求出 $P_i=\\max\\limits_{j \\notin S_i} a_j$。\n>\n> $1 \\leq t \\le 10,2 \\leq n \\leq 1000$，$1 \\leq a_i,k \\leq n$，$1 \\leq c < n$。\n",
			"content": "> 本题是交互题。\n>\n> 给定长为 $n$ 的数组 $a=[a_1,a_2,...,a_n]$ 和 $k$ 个互不相交的子集 $S_1,S_2,...,S_k$，这些子集中的元素都是 $[1,n]$ 之间的正整数。这些子集两两的**交集**为**空**。\n>\n> 你可以进行最多 $12$ 次询问。每次询问你可以给出 $c$ 个互不相同且在 $[1,n]$ 之间的正整数 $v_1,v_2,...,v_c$，然后你会得到 $\\max\\{v_i\\}$。\n>\n> 对于每个子集 $S_i$，你需要求出 $P_i=\\max\\limits_{j \\notin S_i} a_j$。\n>\n> $1 \\leq t \\le 10,2 \\leq n \\leq 1000$，$1 \\leq a_i,k \\leq n$，$1 \\leq c < n$。\n\n\n诈骗题。\n\n首先二分找到序列中最大值的位置，共需要 $1+\\lceil\\log n\\rceil=11$ 次操作。\n\n观察到子集两两不交，所以最多只有一个子集的最大值不是整个序列的最大值，再询问一次即可。\n\n最多会用 $11+1=12$ 次操作。\n",
			"tags": [{"name":"做题记录"},{"name":"交互、通信"}],
			"title": "CF1363D Guess The Maximums 做题记录",
			"link": "https://exber.qzz.io/post/CF1363D%20Guess%20The%20Maximums%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-28 14:23:57"
		},
	
		{
			"abstract": "> 这是一道交互题。\n>\n> 一共有 $n$ 个人做成一圈，他们的编号从 $1$ 到 $n$。\n>\n> 现在每个人的手里面都有一个数字 $a_i$ ，并且保证每个人与他周围两个人的数字差为 $1$ ，即 $\\mid a_i-a_{i\\pm 1}\\mid =1$ ，特别地，编号为 $1$ 与 $n$ 的人也满足这个规则。\n>\n> 在这个圈里面，编号为 $i$ 的人的对面坐着的是编号为 $i+\\frac{n}{2}$ 的人（其中 $i\\le \\frac{n}{2}$），现在要你找到哪个人与他对面坐着的那个人手中的数字一样。\n>\n> $2\\mid n, n\\le 10^5$。\n",
			"content": "> 这是一道交互题。\n>\n> 一共有 $n$ 个人做成一圈，他们的编号从 $1$ 到 $n$。\n>\n> 现在每个人的手里面都有一个数字 $a_i$ ，并且保证每个人与他周围两个人的数字差为 $1$ ，即 $\\mid a_i-a_{i\\pm 1}\\mid =1$ ，特别地，编号为 $1$ 与 $n$ 的人也满足这个规则。\n>\n> 在这个圈里面，编号为 $i$ 的人的对面坐着的是编号为 $i+\\frac{n}{2}$ 的人（其中 $i\\le \\frac{n}{2}$），现在要你找到哪个人与他对面坐着的那个人手中的数字一样。\n>\n> $2\\mid n, n\\le 10^5$。\n\n首先若 $\\frac{n}{2}$ 是奇数那么无解，因为 $i$ 和 $i+\\frac{n}{2}$ 之间隔了 $\\frac{n}{2}$ 个 $\\pm 1$，若 $\\frac{n}{2}$ 是奇数那么 $a_i$ 和 $a_{i+\\frac{n}{2}}$ 奇偶性一定不同。\n\n考虑 $\\frac{n}{2}$ 为偶数的情况，令 $i'=\\begin{cases}i+\\frac{n}{2}&i\\le\\frac{n}{2}\\\\i-\\frac{n}{2}&i>\\frac{n}{2}\\\\\\end{cases}$，$d_i=a_i-a_{i'}$。显然问题转化成找到一个 $1\\le i\\le \\frac{n}{2}$ 的 $i$，满足 $d_i=0$。那么观察到 $d_i$ 都是偶数，所以 $d_i-d_{i+1}\\in[2,-2,0]$。也就是说，若 $d_l,d_r$ 异号，则 $d_{[l,r]}$ 中一定有至少一个 $0$，即 $[l,r]$ 中一定有满足条件的位置。\n\n由于 $d_i=-d_{i+\\frac{n}{2}}$，所以若 $d_1\\not=0$ 那么 $[1,1+\\frac{n}{2}]$ 中一定有至少一个满足条件的位置。那么在这个区间中二分即可，若 $d_{mid}$ 与 $d_1$ 异号，那么往 $[1,mid-1]$ 二分，否则往 $[mid+1,r]$ 二分。\n\n代码如下：\n\n```cpp\n// Problem: CF1019B The hat\n// Contest: Luogu\n// URL: https://www.luogu.com.cn/problem/CF1019B\n// Memory Limit: 250 MB\n// Time Limit: 1000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nint n;\n\ninline int que(int x)\n{\n\tprintf(\"? %d\\n\",x);\n\tfflush(stdout);\n\tint res;\n\tscanf(\"%d\",&res);\n\treturn res;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tif(n%4!=0)\n\t{\n\t\tputs(\"! -1\");\n\t\tfflush(stdout);\n\t\treturn 0;\n\t}\n\tint l=1,r=n/2+1,ans=-1;\n\tint d1=que(1)-que(1+n/2);\n\tif(d1==0)\n\t{\n\t\tputs(\"! 1\");\n\t\tfflush(stdout);\n\t\treturn 0;\n\t}\n\twhile(l<=r)\n\t{\n\t\tint mid=l+r>>1;\n\t\tint di=que(mid)-que(mid+n/2);\n\t\tif(di==0)\n\t\t{\n\t\t\tans=mid;\n\t\t\tbreak;\n\t\t}\n\t\telse if(di<0^d1<0) r=mid-1;\n\t\telse l=mid+1;\n\t}\n\tprintf(\"! %d\\n\",ans);\n\tfflush(stdout);\n\treturn 0;\n} \n```\n",
			"tags": [{"name":"做题记录"},{"name":"交互、通信"}],
			"title": "CF1019B The hat 做题记录",
			"link": "https://exber.qzz.io/post/CF1019B%20The%20hat%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-28 14:21:41"
		},
	
		{
			"abstract": "> 这是一道交互题。\n> \n> 你和 Alice 正在玩一个奇怪的游戏。给出一棵 $N$ 个点的树，双方分别给顶点编号为 $1$ 到 $N$，双方都不知道对方给树编号的方式。\n> \n> 接着双方在自己对应的树上选择一个联通子图，在**你的编号方式对应的树上**你选择了$x_1,x_2,\\dots,x_{k_1}$，**在 Alice 的编号方式对应的树上** Alice 选择了 $y_1,y_2,\\dots,y_{k_2}$，双方都知道 $x_1,\\dots,x_{k_1}$ 与 $y_1,\\dots,y_{k_2}$ 的值\n> \n> 现在你想知道两个子图是否存在至少一个公共点。你可以进行询问，问题有以下两种：\n> \n> $A,x$：得到在你的编号方式下的 $x$ 号点在Alice的编号方式下的值\n> $B,x$：得到在Alice的编号方式下的 $x$ 号点在你的编号方式下的值\n> \n> 现在请你使用**不多于 $5$ 次**询问得出是否存在公共点，或者确定两棵子树没有公共点。\n> \n> $1\\le n\\le 1000$。\n",
			"content": "> 这是一道交互题。\n> \n> 你和 Alice 正在玩一个奇怪的游戏。给出一棵 $N$ 个点的树，双方分别给顶点编号为 $1$ 到 $N$，双方都不知道对方给树编号的方式。\n> \n> 接着双方在自己对应的树上选择一个联通子图，在**你的编号方式对应的树上**你选择了$x_1,x_2,\\dots,x_{k_1}$，**在 Alice 的编号方式对应的树上** Alice 选择了 $y_1,y_2,\\dots,y_{k_2}$，双方都知道 $x_1,\\dots,x_{k_1}$ 与 $y_1,\\dots,y_{k_2}$ 的值\n> \n> 现在你想知道两个子图是否存在至少一个公共点。你可以进行询问，问题有以下两种：\n> \n> $A,x$：得到在你的编号方式下的 $x$ 号点在Alice的编号方式下的值\n> $B,x$：得到在Alice的编号方式下的 $x$ 号点在你的编号方式下的值\n> \n> 现在请你使用**不多于 $5$ 次**询问得出是否存在公共点，或者确定两棵子树没有公共点。\n> \n> $1\\le n\\le 1000$。\n\n\n首先挑一个对方选了的点 $u$，询问我们对这个点的编号，设询问的结果为 $v$。\n\n那么若 $v$ 被我们选了显然直接输出答案，否则考虑以 $v$ 为根的有根树：\n\n![](../post-images/1679984226670.png)\n\n显然对方选的点集若包含某个点 $q$ 那么也一定包含 $q$ 的所有祖先，那么设我们选的点集中深度最小的点为 $p$，公共点只会有两种情况：\n\n- 没有公共点；\n- $p$ 是其中一个公共点。\n\n所以再问一下 $p$ 在对方编号方式里的编号即可。\n\n一共用了两次询问，足以通过此题。\n",
			"tags": [{"name":"做题记录"},{"name":"交互、通信"}],
			"title": "CF1044B Intersecting Subtrees 做题记录",
			"link": "https://exber.qzz.io/post/CF1044B%20Intersecting%20Subtrees%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-28 14:16:48"
		},
	
		{
			"abstract": "> 构造一个 $n\\times n$ 的矩阵，满足元素 $\\le 10^{16}$。\n>\n> $q$ 次询问，每次给出一条 $(1,1)\\to (n,n)$ **只能向下向右走的路径**上的元素的和，你需要保证矩阵对于这 $q$ 次询问路径都能唯一确定。\n>\n> $1\\le n\\le 25$，$1\\le q\\le 10^3$。\n",
			"content": "> 构造一个 $n\\times n$ 的矩阵，满足元素 $\\le 10^{16}$。\n>\n> $q$ 次询问，每次给出一条 $(1,1)\\to (n,n)$ **只能向下向右走的路径**上的元素的和，你需要保证矩阵对于这 $q$ 次询问路径都能唯一确定。\n>\n> $1\\le n\\le 25$，$1\\le q\\le 10^3$。\n\n\n观察到我们只要知道偶数行在哪里，就可以得知整条路径，所以不妨考虑构造一个奇数行均为 $0$，偶数行均不为 $0$ 的矩阵。\n\n考虑偶数行的取值，显然可以考虑二进制拆位，给每一个处于偶数行的位置都分配一个 $2^p$ 的权值。\n\n考虑 $p$ 的取值，由于不能向左走，所以不同行的 $p$ 可以有重复的。第一行显然必须是 $\\{1,2,3,4,5,\\dots\\}$，第二行则可以是 $\\{3,4,5,6,7,\\dots\\}$ 因为不能向左走。所以第 $2i$ 行开头的 $p$ 最小可以取第 $2_{i-1}$ 行从左往右数第 $3$ 个 $p$。\n\n这样我们一共用了 $n+2(\\lfloor\\frac{n}{2}\\rfloor-1)$ 个 $p$，$n=25$ 时用了 $25+2\\times 11=47$ 个 $p$，$2^{47}\\le 10^{16}$，构造满足限制。\n\n不难发现这样构造之后若路径的权值和为 $sum$，则 $sum$ 的二进制序列（低位在前高位在后）$S$ 中连续的 $1$ 对应在同一偶数行中走，特判 $n$ 的奇偶性输出方案即可。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=30,BS=500;\n\nint n,q;\nlong long a[S][S];\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tint cnt=0;\n\tfor(int i=2;i<=n;i+=2)\n\t{\n\t\tlong long mul=1<<i-2;\n\t\tfor(int j=1;j<=n;j++) a[i][j]=mul,mul<<=1;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++) printf(\"%lld \",a[i][j]);\n\t\tprintf(\"\\n\");\n\t\tfflush(stdout);\n\t}\n\tscanf(\"%d\",&q);\n\twhile(q--)\n\t{\n\t\tlong long sm;\n\t\tscanf(\"%lld\",&sm);\n\t\tint lim=n+(n/2-1)*2-!(n&1);\n\t\tint x=1,y=1;\n\t\tfor(int i=-1;i<=lim;i++)\n\t\t{\n\t\t\tprintf(\"%d %d\\n\",x,y);\n\t\t\tfflush(stdout);\n\t\t\tif((i>=0&&(sm>>i&1))&&!(sm>>i+1&1)) x++;\n\t\t\telse if((1<0||!(sm>>i&1))&&(sm>>i+1&1)) x++;\n\t\t\telse y++;\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n",
			"tags": [{"name":"做题记录"},{"name":"构造"},{"name":"交互、通信"}],
			"title": "CF1392E Omkar and Duck 做题记录",
			"link": "https://exber.qzz.io/post/CF1392E%20Omkar%20and%20Duck%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-28 14:12:32"
		},
	
		{
			"abstract": "> 询问 $a_1,a_2,\\cdots a_n$ 能否通过若干次将任意区间全部赋值为其中位数这个操作，来使得整个序列全部变为$k$。（中位数指第 $\\lfloor \\frac {∣s∣+1} 2 \\rfloor$ 小的数） \n> \n> 多次询问，每次第一行两个整数 $n$ 和 $k$，第二行 $n$ 个整数 $a_1,a_2,\\cdots a_n$。\n> \n> $1 \\le n \\le 10^5,1 \\le k \\le 10^9,1 \\le a_i \\le 10^9$，并保证所有询问中$n$的和不超过 $10^5$。\n",
			"content": "> 询问 $a_1,a_2,\\cdots a_n$ 能否通过若干次将任意区间全部赋值为其中位数这个操作，来使得整个序列全部变为$k$。（中位数指第 $\\lfloor \\frac {∣s∣+1} 2 \\rfloor$ 小的数） \n> \n> 多次询问，每次第一行两个整数 $n$ 和 $k$，第二行 $n$ 个整数 $a_1,a_2,\\cdots a_n$。\n> \n> $1 \\le n \\le 10^5,1 \\le k \\le 10^9,1 \\le a_i \\le 10^9$，并保证所有询问中$n$的和不超过 $10^5$。\n\n首先如果 $a$ 中没有 $k$ 那么无解。\n\n容易发现，若有连续两个 $k$，那么就可以不断向外拓展，一定有解。\n\n否则考虑一次操作之后的结果：\n\n1. 长度为 $2$ 的连续段：都变成较小的数\n2. 长度为 $3$ 且有两个数相同的连续段：都变成相同的数\n\n所以当某个 $k$ 旁边有一个 $\\ge k$ 的数就一定有解。\n\n那么考虑找到两个相邻且 $\\ge k$ 的数，把它们变成相同的数，然后不断向外拓展，直到遇到 $a_i=k$ 的位置。这样就可以造出两个相邻的 $k$，有解。\n\n还有一种情况，若 $a_i$ 和 $a_{i+2}$ 都 $\\ge k$ 也可以变出相邻两个 $\\ge k$ 的数，否则就无解，因为 $<k$ 的数不会比 $\\ge k$ 的数少。\n",
			"tags": [{"name":"做题记录"},{"name":"构造"}],
			"title": "CF1349B Orac and Medians 做题记录",
			"link": "https://exber.qzz.io/post/CF1349B%20Orac%20and%20Medians%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-28 14:09:38"
		},
	
		{
			"abstract": "> 给定 $n$ 个数 $a_1,a_2,\\dots ,a_n$。\n> \n> 对于每一个 $a_i$ 求出它的两个不为 $1$ 的约数 $d_1,d_2$ ，满足 $\\gcd(d_1 + d_2, a_i) = 1$，或指出不存在这样的 $d_1,d_2$。\n> \n> $n\\leq 5\\times 10^5$，$2\\le a_i\\le 10^7$\n",
			"content": "> 给定 $n$ 个数 $a_1,a_2,\\dots ,a_n$。\n> \n> 对于每一个 $a_i$ 求出它的两个不为 $1$ 的约数 $d_1,d_2$ ，满足 $\\gcd(d_1 + d_2, a_i) = 1$，或指出不存在这样的 $d_1,d_2$。\n> \n> $n\\leq 5\\times 10^5$，$2\\le a_i\\le 10^7$\n\n大力推一波式子：\n\n设 $\\gcd(d_1,d_2)=d$，$d_1'=d_1/d,d_2'=d_2/d$。\n\n那么 $d_1+d_2=d(d_1'+d_2')$，$\\gcd(d_1+d_2,a_i)=\\gcd(d(d_1'+d_2'),a_i)=1$。\n\n由于 $d$ 一定是 $a_i$ 的因子，所以 $\\gcd(d(d_1',d_2'),a_i)\\ge d$，所以 $d$ 只能为 $1$。\n\n也就是说，找到两个互质的 $d_1$ 和 $d_2$ 即可。\n\n那么考虑线性筛预处理出每个数的最小质因子，把 $a_i$ 的最小质因子 $p$ 除光，剩下的数 $x$ 显然和 $p$ 互质，特判掉 $x=1$ 的情况即可。\n",
			"tags": [{"name":"做题记录"},{"name":"构造"},{"name":"数学"},{"name":"数论"}],
			"title": "CF1366D Two Divisors 做题记录",
			"link": "https://exber.qzz.io/post/CF1366D%20Two%20Divisors%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-28 14:06:38"
		},
	
		{
			"abstract": "> 给定长度为 $n$ 的排列 $p$，要对于 $k=1,2,3,\\cdots,n$ 求出，有多少个长度为 $n$ 的排列 $p'$ 满足 $p'$ 字典序比 $p$ 小，且 $f(p')=k$，其中 $f(a)$ 表示 $a$ 最少可以划分成多少个区间，使得每个区间中的元素都是公差为 $1$ 的等差数列。\n>\n> 答案对输入的 $m$ 取模，$m$ 不一定是质数。\n>\n> $n\\le 2000$，$10\\le m\\le 10^9$。\n",
			"content": "> 给定长度为 $n$ 的排列 $p$，要对于 $k=1,2,3,\\cdots,n$ 求出，有多少个长度为 $n$ 的排列 $p'$ 满足 $p'$ 字典序比 $p$ 小，且 $f(p')=k$，其中 $f(a)$ 表示 $a$ 最少可以划分成多少个区间，使得每个区间中的元素都是公差为 $1$ 的等差数列。\n>\n> 答案对输入的 $m$ 取模，$m$ 不一定是质数。\n>\n> $n\\le 2000$，$10\\le m\\le 10^9$。\n\n\n首先考虑没有字典序限制，求所有 $n$ 的排列的答案。设 $f_{i}$ 表示恰好分成 $i$ 段的方案数，$g_i$ 表示钦定分成 $i$ 段的方案数，那么有：\n$$\ng_i=\\sum\\limits_{j=1}^{i}\\binom{n-j}{i-j}f_j\\\\\nf_i=g_i-\\sum\\limits_{j=1}^{i-1}\\binom{n-j}{i-j}f_{j}\n$$\n那么问题变成了求 $g_i$，没有字典序限制显然是简单的，字典序限制可以枚举 $p$ 和 $p'$ 的 $\\operatorname{lcp}=i-1$ 来解决。那么设 $(ct1,tt1+ct1)$ 分别表示未填入的数中 $<p_{i}$ 小的连续段个数，以及这样的数的个数；$(ct2,tt2+ct2)$ 类似，只是把 $<p_i$ 换成 $\\ge p_i$。注意跨越 $p_i$ 的连续段被归为 $(ct1,tt1+ct1)$ 里。\n\n那么 $p'_{[i,n]}$ 钦定分成 $k$ 段的方案数就是：\n$$\n\\sum\\limits_{j=0}^{k-ct1-ct2}(ct1+j)(k-1)!\\binom{tt1}{j}\\binom{tt2}{k-ct1-ct2-j}\n$$\n这个式子的意思是枚举 $<p_i$ 中断开了 $j$ 个位置，$\\ge p_i$ 中断开了 $k-ct1-ct2-j$ 个位置，然后这些连续段中只有 $ct1+j$ 个能当第一个，剩下 $k-1$ 个乱选。\n\n接下来考虑化简：\n$$\n\\begin{aligned}\n&\\sum\\limits_{j=0}^{k-ct1-ct2}(ct1+j)(k-1)!\\binom{tt1}{j}\\binom{tt2}{k-ct1-ct2-j}\\\\\n&=(k-1)!\\sum\\limits_{j=0}^{k-ct1-ct2}\\left(ct1\\binom{tt1}{j}+tt1\\binom{tt1-1}{j-1}\\right)\\binom{tt2}{k-ct1-ct2-j}\\\\\n&=(k-1)!\\left(ct1\\binom{tt1+tt2}{k-ct1-ct2}+tt1\\binom{tt1+tt2-1}{k-ct1-ct2-1}\\right)\n\\end{aligned}\n$$\n还有一种情况，$p'_i$ 有可能能填入 $p_{i-1}+1$ 然后和 $p'_{i-1}$ 组成一个连续段。这种情况钦定后面（包括 $p'_{i-1}$ 和 $p'_i$ 组成的那一段）有 $k$ 段的方案数为：\n$$\n(k-1)!\\binom{tt1+tt2}{k-ct1-ct2}\n$$\n每次都容斥显然不行，那么弄个 dp 把 $p'_{[1,i-1]}$ 钦定的情况也统计一下，最后一起累加进 $g$ 容斥即可。 \n\n时间复杂度 $O(n^2)$。\n\n代码如下：\n\n```cpp\n// Problem: Doping\n// Contest: Luogu\n// URL: https://www.luogu.com.cn/problem/CF1750G\n// Memory Limit: 500 MB\n// Time Limit: 3000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=2005;\n\nint n,p;\nint a[S],C[S][S],fra[S];\nbool vis[S],flg[S];\nint dp[S][S];\nint g[S],f[S];\n\ninline void add(int &x,int y)\n{\n\tx+=y;\n\tif(x>=p) x-=p;\n}\n\ninline int qc(int n,int m)\n{\n\tif(n<m||n<0||m<0) return 0;\n\treturn C[n][m];\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&p);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor(int i=0;i<=S-3;i++)\n\t{\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<=i;j++) C[i][j]=(C[i-1][j]+C[i-1][j-1])%p;\n\t}\n\tfra[0]=1;\n\tfor(int i=1;i<=S-3;i++) fra[i]=1ll*fra[i-1]*i%p;\n\ta[0]=-1;\n\tint cnt=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++) flg[j]=false;\n\t\tint ct1=0,tt1=0,ct2=0,tt2=0;\n\t\tfor(int j=1;j<a[i];j++)\n\t\t{\n\t\t\tif(vis[j]) continue;\n\t\t\tif(flg[j-1]) tt1++;\n\t\t\telse ct1++;\n\t\t\tflg[j]=true;\n\t\t}\n\t\tfor(int j=a[i];j<=n;j++)\n\t\t{\n\t\t\tif(vis[j]) continue;\n\t\t\tif(flg[j-1]) tt2++;\n\t\t\telse ct2++;\n\t\t\tflg[j]=true;\n\t\t}\n\t\tfor(int k=ct1+ct2;k<=n-cnt;k++)\n\t\t{\n\t\t\tadd(dp[i][cnt+k],1ll*fra[k-1]*(1ll*ct1*qc(tt1+tt2,k-ct1-ct2)%p+1ll*tt1*qc(tt1+tt2-1,k-ct1-ct2-1)%p)%p);\n\t\t}\n\t\tif(a[i-1]+1>=1&&a[i-1]+1<=n&&!vis[a[i-1]+1]&&a[i-1]+1<a[i])\n\t\t{\n\t\t\tfor(int k=ct1+ct2;k<=n-cnt+1;k++)\n\t\t\t{\n\t\t\t\tadd(dp[i][cnt+k-1],1ll*fra[k-1]*qc(tt1+tt2,k-ct1-ct2)%p);\n\t\t\t}\n\t\t}\n\t\tvis[a[i]]=true;\n\t\tcnt+=a[i]!=a[i-1]+1;\n\t}\n\tfor(int i=n;i>=2;i--)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tadd(dp[i-1][j],dp[i][j]);\n\t\t\tif(a[i-1]==a[i-2]+1&&j<n) add(dp[i-1][j+1],dp[i][j]);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++) g[i]=dp[1][i];\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tf[i]=g[i];\n\t\tfor(int j=1;j<=i-1;j++)\n\t\t{\n\t\t\tadd(f[i],p-1ll*qc(n-j,i-j)*f[j]%p);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++) printf(\"%d \",f[i]);\n\tprintf(\"\\n\");\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"数学"},{"name":"组合计数"}],
			"title": "CF1750G Doping 做题记录",
			"link": "https://exber.qzz.io/post/CF1750G%20Doping%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-28 09:57:44"
		},
	
		{
			"abstract": "> 给你一个边权为 $1$ 的无向图，动态加边，每次加边询问无向图的直径（所有点对的最短路中的最大值）。要求你的答案在真实答案的 $\\frac{1}{2}\\sim 2$ 倍之间（向上取整）。\n> \n> $1\\le n,m,q\\le 10^5$。\n",
			"content": "> 给你一个边权为 $1$ 的无向图，动态加边，每次加边询问无向图的直径（所有点对的最短路中的最大值）。要求你的答案在真实答案的 $\\frac{1}{2}\\sim 2$ 倍之间（向上取整）。\n> \n> $1\\le n,m,q\\le 10^5$。\n\n有一个结论：$1$ 到其它点的最短路的最大值 $dis$ 和直径 $d$ 一定满足 $\\lceil\\frac{d}{2}\\rceil\\le dis\\le d$。\n\n<details><summary>证明</summary><p>\n\n> $dis\\le d$ 显然，$\\lceil\\frac{d}{2}\\rceil\\le dis$ 则是因为要先走到直径上，再走到直径的两个端点。\n</p></details>\n\n所以初始答案 $ans0$ 可以一直用到 $dis<\\left\\lceil\\frac{ans0}{2}\\right\\rceil$，那么二分出第一次减半的位置即可。\n\n时间复杂度 $O(n\\log^2 n)$。\n\n代码如下：\n\n```cpp\n// Problem: Approximate Diameter\n// Contest: Luogu\n// URL: https://www.luogu.com.cn/problem/CF1804F\n// Memory Limit: 500 MB\n// Time Limit: 2000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nconst int S=100005;\n\nstruct node\n{\n\tint x,y;\n}ed1[S],ed2[S];\n\nint n,m,q;\nvector<int> g[S];\nint dis[S],ans[S];\n\ninline int calc(int id)\n{\n\tfor(int i=1;i<=id;i++) g[ed2[i].x].push_back(ed2[i].y),g[ed2[i].y].push_back(ed2[i].x);\n\tfor(int i=1;i<=n;i++) dis[i]=1e8;\n\tqueue<int> q;\n\tq.push(1);\n\tdis[1]=0;\n\twhile(!q.empty())\n\t{\n\t\tint u=q.front();\n\t\tq.pop();\n\t\tfor(int v:g[u])\n\t\t{\n\t\t\tif(dis[u]+1<dis[v])\n\t\t\t{\n\t\t\t\tdis[v]=dis[u]+1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\tint mx=0;\n\tfor(int i=1;i<=n;i++) mx=max(mx,dis[i]);\n\tfor(int i=1;i<=id;i++) g[ed2[i].x].pop_back(),g[ed2[i].y].pop_back();\n\treturn mx;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\ted1[i]=(node){x,y};\n\t}\n\tfor(int i=1;i<=q;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\ted2[i]=(node){x,y};\n\t}\n\tfor(int i=1;i<=m;i++) g[ed1[i].x].push_back(ed1[i].y),g[ed1[i].y].push_back(ed1[i].x);\n\tfor(int i=0;i<=q;i++) ans[i]=-1;\n\tfor(int i=0;i<=q;i++)\n\t{\n\t\tans[i]=calc(i);\n\t\tint lb=i,rb=q,res=q;\n\t\twhile(lb<=rb)\n\t\t{\n\t\t\tint mid=lb+rb>>1;\n\t\t\tif(calc(mid)*2>=ans[i]) res=mid,lb=mid+1;\n\t\t\telse rb=mid-1;\n\t\t}\n\t\ti=res;\n\t}\n\tfor(int i=1;i<=q;i++) if(ans[i]==-1) ans[i]=ans[i-1];\n\tfor(int i=0;i<=q;i++) printf(\"%d \",ans[i]);\n\tprintf(\"\\n\");\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"图论"},{"name":"结论"}],
			"title": "CF1804F Approximate Diameter 做题记录",
			"link": "https://exber.qzz.io/post/CF1804F%20Approximate%20Diameter%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-27 20:08:01"
		},
	
		{
			"abstract": "> 这是一道交互题，给定两个正整数 $n,k$，你需要通过 $\\leq 2n$ 次询问猜出长度为 $n$ 的序列 $\\{a_i\\}$ 中的第 $k$ 小值。\n> \n> 询问分为两种类型：\n> \n> 1. `or i j`，交互器会返回 $a_i \\operatorname{or}a_j$ 的值。\n> 2. `and i j`，交互器会返回 $a_i\\operatorname{and}a_j$ 的值。\n> \n> 其中需要满足 $1\\leq i,j\\leq n$ 且 $i\\not = j$。\n> \n> 最后你需要输出 `finish res`，其中 $res$ 表示你的答案。\n> \n> $3\\leq n \\leq 10^4,1\\leq k\\leq n,0\\leq a_i\\leq 10^9$。\n",
			"content": "> 这是一道交互题，给定两个正整数 $n,k$，你需要通过 $\\leq 2n$ 次询问猜出长度为 $n$ 的序列 $\\{a_i\\}$ 中的第 $k$ 小值。\n> \n> 询问分为两种类型：\n> \n> 1. `or i j`，交互器会返回 $a_i \\operatorname{or}a_j$ 的值。\n> 2. `and i j`，交互器会返回 $a_i\\operatorname{and}a_j$ 的值。\n> \n> 其中需要满足 $1\\leq i,j\\leq n$ 且 $i\\not = j$。\n> \n> 最后你需要输出 `finish res`，其中 $res$ 表示你的答案。\n> \n> $3\\leq n \\leq 10^4,1\\leq k\\leq n,0\\leq a_i\\leq 10^9$。\n\n首先有个结论：$x+y=(x\\operatorname{or} y)+(x\\operatorname{and}y)$。\n\n证明可以考虑每一位的贡献。\n\n那么用 $2n-2$ 次询问求出 $a_1+a_i$，用两次询问求出 $a_i+a_j$ 即可解方程得到 $a_1$，进而得出序列 $a$。\n",
			"tags": [{"name":"做题记录"},{"name":"交互、通信"}],
			"title": "CF1556D Take a Guess 做题记录",
			"link": "https://exber.qzz.io/post/CF1556D%20Take%20a%20Guess%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-27 18:08:35"
		},
	
		{
			"abstract": "> 这是一道交互题。\n> \n> 原来生命的意义是一个 $n$ ($2 \\leq n \\leq 100$) 的排列。 创造了世上所有生命的 Omkar 知道这个排列，他允许你在有限的询问次数内查询出这个排列是什么。\n> \n> 每一次询问你可以给出一个序列 $a_1, a_2, \\ldots, a_n$ ($1\\le a_1,a_2,\\ldots,a_n \\le n$) 来对 Omkar 进行询问。 $ a $ 序列**不一定**要是一个排列。之后 Omkar 会逐个将 $a_i$ 与 $p_i$ 相加得到一个新的序列 $s$ ，即对于每个 $j$ ($1\\le j \\le n$) ，$s_j = p_j + a_j$ 。最后 $s$ 序列中可能会出现一些相同的数，你将读入 Omkar 告诉你的**第一个出现相同数的位置**。如果没有相同的数出现，你将读入数字 $0$ 。\n> \n> 你最多只能进行 $2n$ 次询问。\n",
			"content": "> 这是一道交互题。\n> \n> 原来生命的意义是一个 $n$ ($2 \\leq n \\leq 100$) 的排列。 创造了世上所有生命的 Omkar 知道这个排列，他允许你在有限的询问次数内查询出这个排列是什么。\n> \n> 每一次询问你可以给出一个序列 $a_1, a_2, \\ldots, a_n$ ($1\\le a_1,a_2,\\ldots,a_n \\le n$) 来对 Omkar 进行询问。 $ a $ 序列**不一定**要是一个排列。之后 Omkar 会逐个将 $a_i$ 与 $p_i$ 相加得到一个新的序列 $s$ ，即对于每个 $j$ ($1\\le j \\le n$) ，$s_j = p_j + a_j$ 。最后 $s$ 序列中可能会出现一些相同的数，你将读入 Omkar 告诉你的**第一个出现相同数的位置**。如果没有相同的数出现，你将读入数字 $0$ 。\n> \n> 你最多只能进行 $2n$ 次询问。\n\n显然对于 $a_i=a_j$ 的两个位置 $i,j$，它们一定对答案没有贡献，那么考虑询问形如 $\\{2,2,\\dots,2,1,2,2\\dots,2\\}$ 的第 $i$ 位为 $1$，其它位为 $2$ 的序列 $a$。\n\n记询问只有第 $i$ 位为 $1$ 的 $a$ 的答案为 $res1_i$，那么 $res1_i$ 显然有三种情况：\n\n- $res1_i<i$，那么 $p_i$ 的前驱是 $p_{res1_i}$；\n- $res1_i=i$，那么 $p_i$ 的前驱在 $[i+1,n]$ 中；\n- $res1_i=0$，那么 $p_i=1$；\n\n接下来考虑获取每个位置的后继以解决 $p_i$ 的前驱不确定的情况。类似的，考虑询问形如 $\\{1,1,\\dots,1,2,1,1\\dots,1\\}$ 的第 $i$ 位为 $2$，其它位为 $1$ 的序列 $a$。\n\n记询问只有第 $i$ 位为 $1$ 的 $a$ 的答案为 $res2_i$，那么 $res2_i$ 显然也有三种情况：\n\n- $res2_i<i$，那么 $p_i$ 的后继是 $p_{res2_i}$；\n- $res2_i=i$，那么 $p_i$ 的后继在 $[i+1,n]$ 中；\n- $res2_i=0$，那么 $p_i=1$；\n\n这样我们就用 $2n$ 次操作确定了每个 $p_i$ 的前驱后继，自然也确定了 $p$。\n",
			"tags": [{"name":"做题记录"},{"name":"交互、通信"}],
			"title": "CF1583D Omkar and the Meaning of Life 做题记录",
			"link": "https://exber.qzz.io/post/CF1583D%20Omkar%20and%20the%20Meaning%20of%20Life%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-27 18:05:51"
		},
	
		{
			"abstract": "> 桌子上面摆着 $n$ 张白纸，交互库会依次给你 $m$ 个 $[1,c]$ 中的数，你每次可以把所获得的数写在一张纸上或者替换掉某一张纸上写的数，**在你行动结束后交互库才会给你下一个数**。任何时候，如果所有纸上都写了数字并且成非降序排列，你就赢了，直接结束程序。你要想办法赢交互库。\n> \n> $2\\le n,m$，$1\\le c\\le 1000$，$1\\le n\\cdot \\lceil\\frac{c}{2}\\rceil\\le m\\le 1000$。\n",
			"content": "> 桌子上面摆着 $n$ 张白纸，交互库会依次给你 $m$ 个 $[1,c]$ 中的数，你每次可以把所获得的数写在一张纸上或者替换掉某一张纸上写的数，**在你行动结束后交互库才会给你下一个数**。任何时候，如果所有纸上都写了数字并且成非降序排列，你就赢了，直接结束程序。你要想办法赢交互库。\n> \n> $2\\le n,m$，$1\\le c\\le 1000$，$1\\le n\\cdot \\lceil\\frac{c}{2}\\rceil\\le m\\le 1000$。\n\n首先给出构造方法：\n\n- 若 $x\\le \\lfloor\\frac{c}{2}\\rfloor$，那么从左到右找到第一个满足 $a_i=0$ 或 $a_i>x$ 的 $i$ 放入 $x$；\n- 若 $x>\\lfloor\\frac{c}{2}\\rfloor$，那么从右到左找到第一个满足 $a_i=0$ 或 $a_i<x$ 的 $i$ 放入 $x$；\n\n接下来证明这个构造方法，首先考虑这样一条引理：\n\n- 若每次都从左到右找到第一个满足 $a_i=0$ 或 $a_i>x$ 的 $i$ 放入 $x$，那么最终的单调不降序列长度至少是 $\\lceil\\frac{m}{c}\\rceil$；\n\n****\n\n证明：\n\n考虑这 $m$ 个数中出现次数最多的数 $v$，由于值域大小为 $c$，所以根据抽屉原理，$v$ 至少会出现 $\\lceil\\frac{m}{c}\\rceil$ 次。\n\n把这 $m$ 个数分成三部分考虑：\n\n- 满足 $u=v$ 的 $u$，这些 $u$ 构成的单调不降序列长度至少是 $\\lceil\\frac{m}{c}\\rceil$；\n- 满足 $u<v$ 的 $u$，显然这些 $u$ 都出现在所有 $v$ 之后是最坏情况，这时这些 $u$ 均会被 $v$ 代替；\n- 满足 $u>v$ 的 $u$，显然这些 $u$ 都出现在 $v$ 之前是最坏情况，这时这些 $u$ 均会被 $v$ 代替；\n\n所以最坏情况下最终的单调不降序列长度也是 $\\lceil\\frac{m}{c}\\rceil$，得证。\n\n****\n\n回到我们的构造方法，设满足 $x\\le \\lfloor\\frac{c}{2}\\rfloor$ 的 $x$ 有 $t$ 个，那么满足 $x>\\lfloor\\frac{c}{2}\\rfloor$ 的 $x$ 则有 $m-t$ 个。根据引理，易得出满足 $x\\le \\lfloor\\frac{c}{2}\\rfloor$ 的那 $t$ 个 $x$ 构成的单调不降序列长度至少是 $\\lceil\\frac{2t}{c}\\rceil$，其它的 $x$ 构成的单调不降序列长度至少是 $\\lceil\\frac{2(m-t)}{c}\\rceil$，由于 $\\lceil\\frac{2t}{c}\\rceil+\\lceil\\frac{2(m-t)}{c}\\rceil\\ge \\lceil\\frac{2m}{c}\\rceil\\ge n$，所以得证。\n",
			"tags": [{"name":"做题记录"},{"name":"交互、通信"},{"name":"构造"}],
			"title": "CF896B Ithea Plays With Chtholly 做题记录",
			"link": "https://exber.qzz.io/post/CF896B%20Ithea%20Plays%20With%20Chtholly%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-27 18:03:17"
		},
	
		{
			"abstract": "> 这是一道交互题。\n> \n> 有一场由 $2^n$ 位选手组成的锦标赛。\n> \n> 这个锦标赛的规则如下：第 $1$ 位选手与第 $2$ 位选手竞争，第 $3$ 位选手与第 $4$ 位选手竞争……以此类推，比赛结束时会只剩下一位参赛选手，这位参赛选手就是胜利者。\n> \n> 你不知道比赛的结果，但你想通过询问评审团来得知最后谁赢了。\n> \n> 每次询问评审团，你需要给定两个正整数 $a$ 和 $b$，$a$ 和 $b$ 分别代指两位选手的编号。\n> \n> 若 $a$ 选手 比 $b$ 选手 赢的回合更多，评委团将报出数字 $1$；如果 $b$ 选手 比 $a$ 选手 赢的回合更多，评审团将报出数字 $2$；如果这两位选手赢的回合一样多，评审团会报出数字 $0$。\n> \n> 你要做的是在不超过 $\\lceil \\frac{1}{3} \\cdot 2^{n+1} \\rceil$ 的次数内找到最后胜利的选手。此处 $\\lceil x \\rceil$ 表示四舍五入 $x$ 到最近的整数。\n> \n> 这场锦标赛已经过去很久了。所以保证有唯一解。\n> \n> $1\\leq n\\leq 17$。\n",
			"content": "> 这是一道交互题。\n> \n> 有一场由 $2^n$ 位选手组成的锦标赛。\n> \n> 这个锦标赛的规则如下：第 $1$ 位选手与第 $2$ 位选手竞争，第 $3$ 位选手与第 $4$ 位选手竞争……以此类推，比赛结束时会只剩下一位参赛选手，这位参赛选手就是胜利者。\n> \n> 你不知道比赛的结果，但你想通过询问评审团来得知最后谁赢了。\n> \n> 每次询问评审团，你需要给定两个正整数 $a$ 和 $b$，$a$ 和 $b$ 分别代指两位选手的编号。\n> \n> 若 $a$ 选手 比 $b$ 选手 赢的回合更多，评委团将报出数字 $1$；如果 $b$ 选手 比 $a$ 选手 赢的回合更多，评审团将报出数字 $2$；如果这两位选手赢的回合一样多，评审团会报出数字 $0$。\n> \n> 你要做的是在不超过 $\\lceil \\frac{1}{3} \\cdot 2^{n+1} \\rceil$ 的次数内找到最后胜利的选手。此处 $\\lceil x \\rceil$ 表示四舍五入 $x$ 到最近的整数。\n> \n> 这场锦标赛已经过去很久了。所以保证有唯一解。\n> \n> $1\\leq n\\leq 17$。\n\n首先显然可以耗费 $2^n-1$ 次询问按照淘汰赛树一层一层询问。\n\n发现 $\\left\\lfloor\\dfrac{2^{n+1}}{3}\\right\\rfloor=\\left\\lfloor\\dfrac{2}{3}\\times 2^n\\right\\rfloor$，那么考虑用两次询问确定**同层相邻四个节点**中哪个赢得场数最多。也就是考虑用两次询问从 $[1,2,3,4]$ 中找到下图中被红框框住的节点 $3$：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/k4y0ek97.png)\n\n考虑询问 $1,3$：\n\n- 若返回 $1$ 即 $1$ 赢得比 $3$ 多，那么显然 $3$ 和 $2$ 都不可能是赢得最多的，接下来只用询问 $1,4$ 即可找到赢得最多的；\n- 若返回 $2$ 即 $3$ 赢得比 $1$ 多，那么类比返回 $1$ 的情况询问 $3,2$ 即可；\n- 若返回 $0$ 即赢得一样多，那么显然他们两个都不可能是赢得最多的，接下来询问 $2,4$ 即可。\n\n所以我们每次这样处理一层的节点即可。\n",
			"tags": [{"name":"做题记录"},{"name":"交互、通信"}],
			"title": "CF1713D Tournament Countdown 做题记录",
			"link": "https://exber.qzz.io/post/CF1713D%20Tournament%20Countdown%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-27 17:59:56"
		},
	
		{
			"abstract": "> 给定一个 $n\\times n$ 的矩阵。一次操作可以给定一个 $k$ 然后交换所有的 $A_{i,k}$ 和 $A_{k,i}$ 。\n> \n> 如图表示 $n=4,k=3$ 的情况。 \n> \n> ![](../post-images/1679910985745.webp)\n> \n> 求若干次操作后字典序最小的矩阵。\n> \n> $1 \\leq n \\leq 1000$。\n",
			"content": "> 给定一个 $n\\times n$ 的矩阵。一次操作可以给定一个 $k$ 然后交换所有的 $A_{i,k}$ 和 $A_{k,i}$ 。\n> \n> 如图表示 $n=4,k=3$ 的情况。 \n> \n> ![](../post-images/1679910985745.webp)\n> \n> 求若干次操作后字典序最小的矩阵。\n> \n> $1 \\leq n \\leq 1000$。\n\n显然一个位置 $(x,y)$ 上的数只能被交换到 $(y,x)$，并且**当且仅当 $k=x$ 和 $k=y$ 操作的执行状态不同才会被交换**。\n\n发现字典序最小肯定是尽量让前面的位置上的数更小，那么按照 $x,y$ 升序的顺序遍历所有满足 $x<y$ 的位置 $(x,y)$，若 $a_{x,y}<a_{y,x}$ 显然是让 $k=x$ 和 $k=y$ 操作的执行状态相同更优，否则不同更优。\n\n考虑维护“两个操作的执行状态相同/不同”这个东西，显然可以考虑把 $k=x$ 操作拆成两个点 $x$ 和 $x+n$，用并查集维护。遍历到 $(x,y)$ 时，若 $k=x$ 和 $k=y$ 操作的执行状态相同，那么合并 $x,y$ 和 $x+n,y+n$ 所处的集合，否则合并 $x,y+n$ 和 $x+n,y$ 所处的集合。注意若 $x$ 和 $y+n$ 处于一个集合即 $k=x$ 和 $k=y$ 操作的执行状态不同前面的更优那么就不能合并 $x,y$ 和 $x+n,y+n$ 所处的集合；$x$ 和 $y$ 处于一个集合同理。\n\n最后再按照 $x,y$ 升序的顺序遍历所有满足 $x<y$ 的位置 $(x,y)$，若 $x$ 和 $y+n$ 在同一个集合即 $k=x$ 和 $k=y$ 操作的执行状态不同那么交换 $a_{x,y}$ 和 $a_{y,x}$，即可找到答案。\n",
			"tags": [{"name":"做题记录"},{"name":"数据结构"}],
			"title": "CF1713E Cross Swapping 做题记录",
			"link": "https://exber.qzz.io/post/CF1713E%20Cross%20Swapping%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-27 17:54:23"
		},
	
		{
			"abstract": "> 未知一个数 $a$，让你每次猜两个数 $x$ 和 $y$，若 $(x\\bmod a)\\ge (y\\bmod a)$ 返回 `x`，否则返回 `y`。让你猜测次数少于 $60$ 次的时候猜出数 $a$。\n> \n> $1\\le a\\le 10^9$。\n",
			"content": "> 未知一个数 $a$，让你每次猜两个数 $x$ 和 $y$，若 $(x\\bmod a)\\ge (y\\bmod a)$ 返回 `x`，否则返回 `y`。让你猜测次数少于 $60$ 次的时候猜出数 $a$。\n> \n> $1\\le a\\le 10^9$。\n\n首先若 $x\\le a$ 且 $x\\operatorname{mod} a\\ge 2x\\operatorname{mod} a$，那么显然 $x\\le a\\le2x$。\n\n那么若找到了一个这样的 $x$，就可以在 $[x,2x]$ 中二分 $a$，若 $mid\\operatorname{mod} a\\ge 2mid\\operatorname{mod} a$ 则记下答案向上二分，否则向下二分。\n\n考虑怎么找出这样的 $x$，考虑倍增，从 $x=1$ 开始，若 $x\\operatorname{mod} a< 2x\\operatorname{mod} a$，那么让 $x\\to 2x$，直到找到满足条件的 $x$ 为止。\n\n倍增最多 $30$ 次，二分最多 $29$ 次。\n",
			"tags": [{"name":"做题记录"},{"name":"交互、通信"}],
			"title": "CF1103B Game with modulo 做题记录",
			"link": "https://exber.qzz.io/post/CF1103B%20Game%20with%20modulo%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-27 17:51:44"
		},
	
		{
			"abstract": "> 交互题，系统有两个整数 $(a,b)$，你每次可以询问一组整数 $(c,d)$，系统会回答：\n> - $1$ 如果 $a\\oplus c>b\\oplus d$\n> - $0$ 如果 $a\\oplus c=b\\oplus d$\n> - $-1$ 如果 $a\\oplus c<b\\oplus d$\n> \n> 其中操作 $a\\oplus b$ 表示 $a$ 和 $b$ 按位异或。\n> \n> 你需要在询问不超过 $62$ 次之后输出 $(a,b)$ 的值，保证 $0\\le a, b < 2^{30}$。\n",
			"content": "> 交互题，系统有两个整数 $(a,b)$，你每次可以询问一组整数 $(c,d)$，系统会回答：\n> - $1$ 如果 $a\\oplus c>b\\oplus d$\n> - $0$ 如果 $a\\oplus c=b\\oplus d$\n> - $-1$ 如果 $a\\oplus c<b\\oplus d$\n> \n> 其中操作 $a\\oplus b$ 表示 $a$ 和 $b$ 按位异或。\n> \n> 你需要在询问不超过 $62$ 次之后输出 $(a,b)$ 的值，保证 $0\\le a, b < 2^{30}$。\n\n首先显然可以询问一次得到 $a,b$ 的大小关系 $f$，接下来分类讨论：\n\n- 若 $f=0$，那么 $a$ 和 $b$ 相等，从高位向低位依次枚举，显然第 $i$ 位为 $1$ 当且仅当 $a>(b\\oplus 2^i)$。这样就可以用 $30$ 次询问确定 $a$ 和 $b$；\n\n- 若 $f\\not=0$，那么从高位向低位依次枚举。枚举到第 $i$ 位时设当前（确定了前面的位的）答案为 $A$ 和 $B$，$a\\oplus A$ 和 $b\\oplus B$ 的大小关系为 $F$。\n\n  显然刚开始 $A=0,B=0,F=f$。\n\n  枚举到第 $i$ 位时，询问 $(a\\oplus A\\oplus 2^i)$ 和 $(b\\oplus B\\oplus 2^i)$ 的大小关系，即询问两个数第 $i$ 位和更低位都异或上 $2^i$ 的大小关系。设询问的结果为 $E$，分类讨论：\n\n  - 若 $E=F$，那么 $a$ 和 $b$ 的第 $i$ 位相等，这时若 $(a\\oplus A)>(b\\oplus B\\oplus 2^i)$ 那么 $a$ 和 $b$ 的第 $i$ 位为 $1$，因为 $(a\\oplus A)$ 和 $(b\\oplus B)$ 的最高位都是第 $i$ 位，这一位均为 $1$ 那么异或 $2^i$ 相当于消去最高位，显然会变得比另一个小；\n  - 若 $E\\not=F$，那么 $a$ 和 $b$ 的第 $i$ 位不相等，这时若 $F=1$ 那么 $a$ 的第 $i$ 位为 $1$，否则 $b$ 的第 $i$ 位为 $1$。更新完 $A$ 和 $B$ 之后再问一次 $(a\\oplus A)$ 和 $(b\\oplus B)$ 的大小关系来更新 $F$，注意若此时 $F$ 更新成 $0$ 那么剩下的位就要按照 $f=0$ 情况的方法处理。\n\n  代码如下：\n\n  ```cpp\n  // Problem: CF1088D Ehab and another another xor problem\n  // Contest: Luogu\n  // URL: https://www.luogu.com.cn/problem/CF1088D\n  // Memory Limit: 250 MB\n  // Time Limit: 1000 ms\n  // \n  // Powered by CP Editor (https://cpeditor.org)\n  \n  #include <iostream>\n  #include <cstdio>\n  \n  using namespace std;\n  \n  const int N=29;\n  \n  int a,b;\n  \n  inline int que(int c,int d)\n  {\n  \tprintf(\"? %d %d\\n\",c,d);\n  \tfflush(stdout);\n  \tint x;\n  \tscanf(\"%d\",&x);\n  \treturn x;\n  }\n  \n  int main()\n  {\n  \tint f=que(0,0);\n  \tint srt=N;\n  \tif(f!=0)\n  \t{\n  \t\tfor(int i=N;i>=0;i--)\n  \t\t{\n  \t\t\tint val=1<<i;\n  \t\t\tint pre=que(a^val,b^val);\n  \t\t\tif(pre!=f)\n  \t\t\t{\n  \t\t\t\tif(f==1) a|=val;\n  \t\t\t\telse b|=val;\n  \t\t\t\tf=que(a,b);\n  \t\t\t\tif(f==0)\n  \t\t\t\t{\n  \t\t\t\t\tsrt=i-1;\n  \t\t\t\t\tbreak;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\telse if((f==1&&que(a^val,b)==-1)||(f==-1&&que(a,b^val)==1)) a|=val,b|=val;\n  \t\t}\n  \t}\n  \tfor(int i=srt;i>=0;i--)\n  \t{\n  \t\tint val=1<<i;\n  \t\tif(que(a,b^val)==1) a|=val,b|=val;\n  \t}\n  \tprintf(\"! %d %d\\n\",a,b);\n  \tfflush(stdout);\n  \treturn 0;\n  }\n  ```\n\n  \n\n  \n",
			"tags": [{"name":"做题记录"},{"name":"交互、通信"}],
			"title": "CF1088D Ehab and another another xor problem 做题记录",
			"link": "https://exber.qzz.io/post/CF1088D%20Ehab%20and%20another%20another%20xor%20problem%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-27 17:49:19"
		},
	
		{
			"abstract": "",
			"content": "楼房重建线段树是一种用于快速维护前/后缀最小/最大值以及其相关状态的特殊线段树。\n\n楼房重建线段树的特殊之处主要体现在节点 $u$ 的两个儿子合并更新节点 $u$ 的数据上。\n\n先看一道例题：\n\n[CF1690G Count the Trains](https://www.luogu.com.cn/problem/CF1690G)\n\n> 单点修改，改完查询不同的前缀最小值个数。\n>\n> $1\\le n,m\\le 10^5$。\n\n对原序列建出线段树，对应区间为 $[l,r]$ 的节点 $u$ 维护两个值：\n\n- 区间中的最小值 $mn_u$\n- **仅考虑这个区间**时的答案 $ans_u$，即不考虑 $[1,l-1]$ 对 $[l,r]$ 中的前缀最小值的影响时 $[l,r]$ 中不同的前缀最小值的个数。\n\n由于只有单点修改，所以考虑递归到底层再不断回溯更新答案即可。\n\n考虑合并 $u$ 的两个儿子的信息：\n\n- $mn_u$ 在两个儿子的最小值中取 $\\min$ 即可。\n- $ans_u$ 却不能直接取两个儿子的 $ans$ 相加，因为左儿子的区间的最小值会对右儿子的区间的前缀最小值有影响。\n\n考虑 $ans_u$ 的求值，显然左儿子的答案可以直接加进 $ans_u$，那么考虑左儿子的区间的最小值 $val=mn_{ls}$ 对右儿子的答案的影响。\n\n考虑引入一个函数 $calc(u,val)$，它返回 $u$ 考虑了前缀最小值 $val$ 的影响后的答案，代码如下：\n\n```cpp\nint calc(int u,int l,int r,int val)\n{\n\tif(l==r) return mx[u]<val;\n\tint mid=l+r>>1;\n\tif(val>mx[u<<1]) return calc(u<<1,l,mid,val)+ans[u]-ans[u<<1];\n\telse return calc(u<<1|1,mid+1,r,val);\n}\n```\n\n其中 `u<<1` 和 `u<<1|1` 即为 $u$ 的左右儿子。\n\n考虑这样做的正确性：\n\n- 当区间长度为 $1$ 时，贡献直接暴力计算。\n- 当区间长度大于 $1$ 时：\n  1. 若 $val>mn_{ls}$，那么 $val$ 肯定不会对右子树的答案有影响，直接用 $ans_u-ans_{ls}$ 算出右子树考虑了左子树影响后的答案，然后递归左子树即可；\n  2. 否则左子树肯定不会产生任何贡献，直接递归右子树。\n\n这样做的时间复杂度显然是 $O(\\log n)$ 的，因为每次会且仅会进入一个儿子的子树进行递归。\n\n每次通过 $u$ 的两个儿子的信息更新 $u$ 的信息时直接 $ans_u\\to ans_{ls}+calc(rs,mn_{ls})$ 即可。\n\n这样做还有一个小小的问题，若 $ans$ 维护的东西**不具有可减性**，那么不能直接通过 $ans_u-ans_{ls}$ 算出右子树考虑了左子树影响后的答案， 也不能在 $calc$ 中同时递归两个子树。这时可以考虑**每次合并两个儿子更新父亲的信息时记录右儿子的贡献**。\n\n完整代码如下：\n\n```cpp\n// Problem: CF1690G Count the Trains\n// Contest: Luogu\n// URL: https://www.luogu.com.cn/problem/CF1690G\n// Memory Limit: 250 MB\n// Time Limit: 2000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=100005;\n\nint n,m;\nint a[S];\nint mx[S<<2],ans[S<<2];\n\nint calc(int u,int l,int r,int val)\n{\n\tif(l==r) return mx[u]<val;\n\tint mid=l+r>>1;\n\tif(val>mx[u<<1]) return calc(u<<1,l,mid,val)+ans[u]-ans[u<<1];\n\telse return calc(u<<1|1,mid+1,r,val);\n}\n\nvoid upda(int u,int l,int r)\n{\n\tmx[u]=min(mx[u<<1],mx[u<<1|1]);\n\tint mid=l+r>>1;\n\tans[u]=ans[u<<1]+calc(u<<1|1,mid+1,r,mx[u<<1]);\n}\n\nvoid upd(int u,int l,int r,int pos,int val)\n{\n\tif(l==r)\n\t{\n\t\tmx[u]=val;\n\t\tans[u]=1;\n\t\treturn;\n\t}\n\tint mid=l+r>>1;\n\tif(pos<=mid) upd(u<<1,l,mid,pos,val);\n\telse upd(u<<1|1,mid+1,r,pos,val);\n\tupda(u,l,r);\n}\n\ninline void slove()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]),upd(1,1,n,i,a[i]);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint pos,val;\n\t\tscanf(\"%d%d\",&pos,&val);\n\t\tupd(1,1,n,pos,a[pos]-=val);\n\t\tprintf(\"%d \",ans[1]);\n\t}\n\tprintf(\"\\n\");\n}\n\nint main()\n{\n\tint T;\n\tscanf(\"%d\",&T);\n\twhile(T-->0) slove();\n\treturn 0;\n}\n```\n\n## 练习题目\n\n- [P4198 楼房重建](https://www.luogu.com.cn/problem/P4198)（维护不同的前缀最大值的个数）\n- 区间：\n\n> ## 问题描述\n>\n> 小 A 最近在研究数组，他认为如果数组的一个区间内不包含重复的元素，那么这个区间是一个优美的区间。\n>\n> 现在小 A 弄到了一个有趣的数组，他想知道这个数组有多少个优美的区间。当然，他有时候也会觉得这个数组不够优美，此时他会修改数组中的一个元素。\n>\n> 小 A 发现在修改之后他不会算有多少个优美的区间了，于是他来向你求助。\n>\n> ## 输入格式\n>\n> 第一行输入一个数 $n$，表示数组长度。\n>\n> 接下来一行输入 $n$ 个整数，第 $i$ 个整数 $a_i$ 是数组中的第 $i$ 个元素。\n>\n> 接下来一行输入一个数 $q$，表示操作数量。\n>\n> 接下来 $q$ 行每行表示一次操作。如果某行第一个数为 $0$，则表示一次询问。否则后面输入两个数 $x$ 和 $y$，表示将 $a_x$ 修改为 $y$。\n>\n> ## 输出格式\n>\n> 对于每次询问，输出一行一个整数表示答案。\n>\n> ## 输入数据 1\n>\n> ```input1\n> 3\n> 1 2 3\n> 3\n> 0\n> 1 1 2\n> 0\n> ```\n>\n> ## 输出数据 1\n>\n> ```output1\n> 6\n> 4\n> ```\n>\n> ## 数据范围及约定\n>\n> 对于 $40\\%$ 的数据，保证 $n\\le 10^3$。\n>\n> 对于 $100\\%$ 的数据，保证 $1\\le n\\le 10^5$，$1\\le q\\le 2n$，$1\\le a_i\\le n$。\n\n",
			"tags": [{"name":"学习笔记"},{"name":"数据结构"}],
			"title": "楼房重建线段树学习笔记",
			"link": "https://exber.qzz.io/post/%E6%A5%BC%E6%88%BF%E9%87%8D%E5%BB%BA%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-03-27 17:07:35"
		},
	
		{
			"abstract": "> Ridbit 有一个隐藏的长度为 $n$ 的数组 $a$，Ashish 要去猜，$n$ 是 $2$ 的**整数次幂**。Ridbit 允许 Ashish 提出三种不同类型的查询。它们分别是：  \n> \n> - AND $i,j$：求元素 $a_i$ 和 $a_j$ 每一位的 $and$（$1≤i$,$j≤n$,$i≠j$）\n> \n> - OR $i,j$：求元素 $a_i$ 和 $a_j$ 每一位的 $or$（$1≤i$,$j≤n$,$i≠j$）\n> \n> - XOR $i,j$：求元素 $a_i$ 和 $a_j$ 每一位的 $xor$（$1≤i$,$j≤n$,$i≠j$）\n> \n> 限制：\n> \n> - Ashish 最多可以询问 $n + 1$ 次（Hard Version）$n+2$ 次（Easy Version）。\n> - $0 \\le a_i \\le n - 2$。\n> \n> $1\\le n\\le 2^{16}$。\n",
			"content": "> Ridbit 有一个隐藏的长度为 $n$ 的数组 $a$，Ashish 要去猜，$n$ 是 $2$ 的**整数次幂**。Ridbit 允许 Ashish 提出三种不同类型的查询。它们分别是：  \n> \n> - AND $i,j$：求元素 $a_i$ 和 $a_j$ 每一位的 $and$（$1≤i$,$j≤n$,$i≠j$）\n> \n> - OR $i,j$：求元素 $a_i$ 和 $a_j$ 每一位的 $or$（$1≤i$,$j≤n$,$i≠j$）\n> \n> - XOR $i,j$：求元素 $a_i$ 和 $a_j$ 每一位的 $xor$（$1≤i$,$j≤n$,$i≠j$）\n> \n> 限制：\n> \n> - Ashish 最多可以询问 $n + 1$ 次（Hard Version）$n+2$ 次（Easy Version）。\n> - $0 \\le a_i \\le n - 2$。\n> \n> $1\\le n\\le 2^{16}$。\n\n\n## Easy Version\n\n发现求出 $a_1$ 就能通过异或求出剩下的数，那么考虑求 $a_1$。\n\n先用两次操作求出 $a_1\\oplus a_2=xor12$ 和 $a_1\\&a_2=and12$。显然对于某一个二进制位 $i$，若 $and12$ 的第 $i$ 位为 $1$，$a_1$ 和 $a_2$ 的第 $i$ 位也肯定为 $1$；若 $xor12$ 的第 $i$ 位为 $1$，$a_1$ 和 $a_2$ 之间肯定**有且仅有** 一个数第 $i$ 位为 $1$。\n\n考虑确定 $xor12$ 二进制中的 $1$ 哪些属于 $a_1$，哪些属于 $a_2$。显然可以再用两次操作求出 $a_2|a_3=or23$ 和 $a_1\\&a_3=and13$。 对于某一个满足 $xor12$ 的第 $i$ 位为 $1$ 的二进制位 $i$，若 $or23$ 的第 $i$ 位为 $0$，那么这个 $1$ 显然属于 $a_1$；否则若 $and13$ 的第 $i$ 位为 $1$ 那么这一个 $1$ 属于 $a_1$，否则这个 $1$ 属于 $a_2$。\n\n这样我们就用 $4$ 次操作求出了 $a_1$ 和 $a_2$，接下来用 $n-2$ 次操作即可求出整个序列 $a$，总共花费了 $n+2$ 次操作。\n\n## Hard Version\n\n先对 $2\\le i\\le n$ 的 $i$ 求出 $b_i=a_1\\oplus a_i$，耗费 $n-1$ 次操作。\n\n然后考虑用 $2$ 次操作求出 $a_1$：\n\n- 显然若 $b$ 中有相同的元素或者存在 $b_i=0$ 那么可以直接花费 $1$ 次操作求出重复的元素，然后直接异或上 $b_i$ 求出 $a_1$。\n- 否则此时 $a$ 中元素两两不同，那么显然一定有且仅有一个 $b_i=1$，也有且仅有一个 $b_j=2$，那么找出 $i,j$，询问 $a_1\\& a_i$ 即可确定 $a_1$ 二进制中除了最后一位的其它位，询问 $a_1\\&a_j$ 即可确定 $a_1$ 二进制中的最后一位。\n\n",
			"tags": [{"name":"做题记录"},{"name":"交互、通信"}],
			"title": "CF1451E1&2 Bitwise Queries (Easy&Hard Version) 做题记录",
			"link": "https://exber.qzz.io/post/CF1451E1%262%20Bitwise%20Queries%20%28Easy%26Hard%20Version%29%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-27 17:01:04"
		},
	
		{
			"abstract": "> 给定一个长为 $n$ 的不降序列，每次操作可以任选相邻的两个数，并将这两个数替换为两个数按位异或的结果，现在需要破坏序列的不降，求最少操作次数，无解输出 $-1$。\n> \n> $2 \\le n \\le 10^5$，$1 \\le a_i \\le 10^9$。\n",
			"content": "> 给定一个长为 $n$ 的不降序列，每次操作可以任选相邻的两个数，并将这两个数替换为两个数按位异或的结果，现在需要破坏序列的不降，求最少操作次数，无解输出 $-1$。\n> \n> $2 \\le n \\le 10^5$，$1 \\le a_i \\le 10^9$。\n\n首先，若序列中有三项的最高位相同（它们必定相邻），那么前两个异或起来就可以消去最高位，显然答案为 $1$。\n\n否则序列中最高位为 $2^i$ 的项最多只有两个，那么序列中最多有 $60$ 个数，直接暴力枚举 $[l,k]$ 和 $[k+1,r]$，用前缀异或和判断能否破坏不降即可。\n",
			"tags": [{"name":"做题记录"},{"name":"结论"}],
			"title": "CF1415D XOR-gun 做题记录",
			"link": "https://exber.qzz.io/post/CF1415D%20XOR-gun%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-27 16:58:10"
		},
	
		{
			"abstract": "> 这是一道交互题\n> \n> 有一个长为 $n$ 的排列 $p$，你需要在 $\\lfloor\\frac{3n}{2}\\rfloor + 30$ 次询问内找出排列 $p$ 每一位所对应的数。\n> \n> 有两种操作\n> \n>  - $t = 1 : max(min(x, p_i), min(x + 1, p_j))$ \n>  - $t = 2 : min(max(x, p_i), max(x +1, p_j))$\n> \n> $1 \\le t \\le 2,1 \\le i,j \\le n(i \\ne j),1 \\le x \\le n - 1$\n> \n> $1 \\le T \\le 10^4,3 \\le n \\le 10^{4}, \\sum n \\le 2\\times 10^4$\n",
			"content": "> 这是一道交互题\n> \n> 有一个长为 $n$ 的排列 $p$，你需要在 $\\lfloor\\frac{3n}{2}\\rfloor + 30$ 次询问内找出排列 $p$ 每一位所对应的数。\n> \n> 有两种操作\n> \n>  - $t = 1 : max(min(x, p_i), min(x + 1, p_j))$ \n>  - $t = 2 : min(max(x, p_i), max(x +1, p_j))$\n> \n> $1 \\le t \\le 2,1 \\le i,j \\le n(i \\ne j),1 \\le x \\le n - 1$\n> \n> $1 \\le T \\le 10^4,3 \\le n \\le 10^{4}, \\sum n \\le 2\\times 10^4$\n\n\n$T$ 组询问 每次询问开始时会给出 $p$ 的长度 $n$。\n若知道了 $p_i=1$ 的 $i$，那么可以通过 $n$ 次询问来确定 $p$，每次询问 $\\max(\\min(n-1,p_i),\\min(n,p_j))$ 即可确定 $p_j$。\n\n现在问题转化成了用 $\\left\\lfloor\\frac{n}{2}\\right\\rfloor+30$ 次询问找到 $p_i=1$ 的 $i$。\n\n若每次询问相邻两个位置 $p_i$ 和 $p_{i+1}$，取得 $res=\\min(\\max(1,p_i),\\max(2,p_{i+1}))$，若 $res=1$ 那么 $p_i=1$，若 $res=2$ 那么反过来问一次 $\\min(\\max(1,p_{i+1}),\\max(2,p_{i}))$ 即可。\n\n询问次数最多 $\\left\\lfloor\\frac{n}{2}\\right\\rfloor+2$。\n",
			"tags": [{"name":"做题记录"},{"name":"交互、通信"}],
			"title": "CF1521C Nastia and a Hidden Permutation 做题记录",
			"link": "https://exber.qzz.io/post/CF1521C%20Nastia%20and%20a%20Hidden%20Permutation%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-27 16:53:20"
		},
	
		{
			"abstract": "> $n$ 点 $m$ 边的无向图里面选 $k$ 个点，满足与其它 $n-k$ 个点之间的连边条数为偶数，求方案数。\n",
			"content": "> $n$ 点 $m$ 边的无向图里面选 $k$ 个点，满足与其它 $n-k$ 个点之间的连边条数为偶数，求方案数。\n\n\n提示：考虑节点的度。\n&nbsp;\n\n&nbsp;\n\n&nbsp;\n\n&nbsp;\n\n&nbsp;\n\n&nbsp;\n\n&nbsp;\n\n&nbsp;\n\n&nbsp;\n\n&nbsp;\n\n&nbsp;\n\n&nbsp;\n\n&nbsp;\n\n&nbsp;\n\n&nbsp;\n\n&nbsp;\n\n&nbsp;\n\n&nbsp;\n\n&nbsp;\n\n&nbsp;\n\n&nbsp;\n\n&nbsp;\n\n&nbsp;\n\n&nbsp;\n\n&nbsp;\n\n&nbsp;\n\n&nbsp;\n\n&nbsp;\n\n结论：度为偶数的点可以随便选，度为奇数的点选偶数个。\n\n证明：\n\n- 度为偶数的点\n\n  1. 若这些点之间没有边相连，结论显然成立。\n\n  2. 否则若 $u,v$ 之间有边相连，显然若都选它们则度数都变为奇数，加起来还是偶数；若只选一个或者不选，则与情况 1 同理。\n  3. 若更多的点之间有边相连，那么和情况 2 同理。\n\n- 度为奇数的点\n\n  1. 若这些点之间没有边相连，结论显然成立。\n  2. 否则若 $u,v$ 之间有边相连，显然若都选它们则度数都变为偶数，加起来还是偶数；若只选一个或者不选，则与情况 1 同理。\n  3. 若更多的点之间有边相连，那么和情况 2 同理。\n\n证毕。\n\n赛时想了 1h。\n",
			"tags": [{"name":"做题记录"},{"name":"结论"}],
			"title": "ABC262E Red and Blue Graph 做题记录",
			"link": "https://exber.qzz.io/post/ABC262E%20Red%20and%20Blue%20Graph%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-27 16:50:41"
		},
	
		{
			"abstract": "> 通信题，Alice 和 Bob 会收到同一个 $n$ 个点 $m$ 条边的无向图，Alice 会额外收到这个图的一个合法 $8$ 染色。Alice 要向 Bob 发一个长度小于等于 $2.5\\times 10^5$ 的 $01$ 串，Bob 需要根据这个 $01$ 串还原出任意一个合法的 $8$ 染色方案。\n> \n> $1\\le n\\le 2\\times 10^5$，$1\\le m\\le 5\\times 10^5$。\n",
			"content": "> 通信题，Alice 和 Bob 会收到同一个 $n$ 个点 $m$ 条边的无向图，Alice 会额外收到这个图的一个合法 $8$ 染色。Alice 要向 Bob 发一个长度小于等于 $2.5\\times 10^5$ 的 $01$ 串，Bob 需要根据这个 $01$ 串还原出任意一个合法的 $8$ 染色方案。\n> \n> $1\\le n\\le 2\\times 10^5$，$1\\le m\\le 5\\times 10^5$。\n\n考虑让 Alice 发送每个点颜色 $\\operatorname{mod} 4$ 的结果，然后 Bob 就可以通过对同色子图进行二分图染色来还原方案。\n\n这样需要发送长 $4\\times 10^5$ 的 $01$ 串，考虑剪枝，不难发现度数 $<8$ 的点不用发，那么需要发的长度降到了 $\\frac{m}{8}\\times 2\\times 2=\\frac{m}{2}=2.5\\times 10^5$，可以通过本题。\n\n代码如下：\n\nAlice.cpp：\n\n```cpp\n#include \"Alice.h\"\n\nconst int S=200005;\n\nstd::vector<int> Alice(int N,int M,std::vector<int> U,std::vector<int> V,std::vector<int> C)\n{\n\tstd::vector<int> res;\n\tstd::vector<std::vector<int>> g;\n\tfor(int i=0;i<N;i++) g.push_back(std::vector<int>());\n\tfor(int i=0;i<M;i++) g[U[i]].push_back(V[i]),g[V[i]].push_back(U[i]);\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tif(g[i].size()>=8)\n\t\t{\n\t\t\tint idx=C[i]&3;\n\t\t\tres.push_back(idx>>1&1);\n\t\t\tres.push_back(idx&1);\n\t\t}\n\t}\n\treturn res;\n}\n```\n\nBob.cpp：\n\n```cpp\n#include \"Bob.h\"\n#include <cstdio>\n#include <queue>\n\nstd::vector<int> Bob(int N,int M,std::vector<int> U,std::vector<int> V,std::vector<int> X)\n{\n\tstd::vector<int> res,flg;\n\tstd::vector<std::vector<int>> g;\n\tfor(int i=0;i<N;i++) g.push_back(std::vector<int>()),flg.push_back(-1);\n\tfor(int i=0;i<N;i++) res.push_back(-1);\n\tfor(int i=0;i<M;i++) g[U[i]].push_back(V[i]),g[V[i]].push_back(U[i]);\n\tstd::vector<std::pair<int,int>> val;\n\tfor(int i=0,j=0;i<N;i++)\n\t{\n\t\tif(g[i].size()>=8)\n\t\t{\n\t\t\tint idx=0;\n\t\t\tidx=idx<<1|X[j++];\n\t\t\tidx=idx<<1|X[j++];\n\t\t\tflg[i]=idx;\n\t\t\tval.push_back(std::make_pair(i,idx));\n\t\t}\n\t}\n\tfor(int id=0;id<=3;id++)\n\t{\n\t\tfor(std::pair<int,int> u:val)\n\t\t{\n\t\t\tif(u.second==id&&res[u.first]==-1)\n\t\t\t{\n\t\t\t\tstd::queue<int> q;\n\t\t\t\tq.push(u.first);\n\t\t\t\tres[u.first]=id;\n\t\t\t\twhile(!q.empty())\n\t\t\t\t{\n\t\t\t\t\tint u=q.front();\n\t\t\t\t\tq.pop();\n\t\t\t\t\tfor(int v:g[u])\n\t\t\t\t\t{\n\t\t\t\t\t\tif(flg[v]==id&&res[v]==-1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tres[v]=res[u]==id?4+id:id;\n\t\t\t\t\t\t\tq.push(v);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tif(g[i].size()<8)\n\t\t{\n\t\t\tbool vis[8];\n\t\t\tfor(int j=0;j<8;j++) vis[j]=false;\n\t\t\tfor(int v:g[i]) if(res[v]!=-1) vis[res[v]]=true;\n\t\t\tfor(int j=0;j<8;j++) if(!vis[j]) res[i]=j;\n\t\t}\n\t}\n\treturn res;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"构造"},{"name":"交互、通信"}],
			"title": "QOJ141 染色 做题记录",
			"link": "https://exber.qzz.io/post/QOJ141%20%E6%9F%93%E8%89%B2%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-27 15:50:29"
		},
	
		{
			"abstract": "> 有一个无限大的平面，每个点上都有一盏灯。\n> \n> 刚开始只有位于 $(X,0)$ 的灯是亮起的，之后 Alice 会进行若干次操作，每次操作她会选择一个位置 $(x,y)$，并同时改变 $(x,y)$、$(x,y-1)$、$(x-1,y-1)$ 这些灯的状态。\n> \n> 最终一共有 $n$ 盏灯亮起了，给定这些灯的位置 $(x_i,y_i)$，请你求出 $X$。\n> \n> $1\\le n\\le 10^5$，$0\\le |x_i|,|y_i|\\le 10^{17}$。\n> \n> 保证有解且 $0\\le |X| \\le 10^{17}$\n",
			"content": "> 有一个无限大的平面，每个点上都有一盏灯。\n> \n> 刚开始只有位于 $(X,0)$ 的灯是亮起的，之后 Alice 会进行若干次操作，每次操作她会选择一个位置 $(x,y)$，并同时改变 $(x,y)$、$(x,y-1)$、$(x-1,y-1)$ 这些灯的状态。\n> \n> 最终一共有 $n$ 盏灯亮起了，给定这些灯的位置 $(x_i,y_i)$，请你求出 $X$。\n> \n> $1\\le n\\le 10^5$，$0\\le |x_i|,|y_i|\\le 10^{17}$。\n> \n> 保证有解且 $0\\le |X| \\le 10^{17}$\n\n由于操作可逆，所以考虑不断把亮着的灯往下移，对于一盏亮着的灯 $(x,y)$，可以操作一次 $(x,y)$ 来让它灭掉，同时改变 $(x,y-1)$ 和 $(x-1,y-1)$ 的状态。\n\n设 $f_{x,y}$ 表示 $(x,y)$ 这盏灯在通过以上操作灭掉 $x'>x$ 的灯时的状态，那么有 $f_{x,y}=f_{x,y+1}\\oplus f_{x+1,y+1}$。不难发现 $f_{x,y}=\\binom{X-x}{0-y}\\operatorname{mod} 2$。那么根据 Lucas 定理，有 $f_{x,y}=[X-x\\in -y]$，其中 $\\in$ 为二进制意义下的包含，即 $X-x$ 按位与 $-y$ 还是 $X-x$。\n\n由于操作可逆，所以 Alice 的操作可以看作先把亮的灯往下移下的地方再把亮的灯往上移，所以对于一个足够小的 $y$，有 $f_{x,y}=\\oplus_{i=1}^n [x_i-x\\in y_i-y]$。\n\n那么假如已经找到了一组 $(p,y)$ 满足 $f_{p,y}=1$，则可以得知 $p-X\\in -y$。那么可以从大往小枚举 $k$，若 $f_{p-2^k,y}=1$ 则让 $p\\to p-2^k$。这样最终会把 $p-X$ 变成 $0$，得到 $X$。\n\n而由于刚开始亮着的灯是 $(X,0)$，所以 $f_{10^{17},-(2^{60}-1)}$ 一定为 $1$，那么令 $p=10^{17}$，$y=-(2^{60}-1)$ 即可。\n\n代码如下：\n\n```cpp\n// Problem: Triangular Lamps Easy\n// Contest: Luogu\n// URL: https://www.luogu.com.cn/problem/AT_wtf19_c1\n// Memory Limit: 1 MB\n// Time Limit: 2000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=100005;\n\nstruct node\n{\n\tlong long x,y;\n}a[S];\n\nint n;\n\ninline bool chk(long long x,long long y)\n{\n\tbool res=false;\n\tfor(int i=1;i<=n;i++) res^=((a[i].y-y)&(x-a[i].x))==x-a[i].x;\n\treturn res;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%lld%lld\",&a[i].x,&a[i].y);\n\tlong long p=100000000000000000ll,y=-((1ll<<60)-1);\n\tprintf(\"%d\\n\",chk(p,y));\n\tfor(int i=59;i>=0;i--)\n\t{\n\t\tif(chk(p-(1ll<<i),y)) p-=1ll<<i;\n\t}\n\tprintf(\"%lld\\n\",p);\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"构造"}],
			"title": "【World tour final 2019 C1】Triangular Lamps Easy 做题记录",
			"link": "https://exber.qzz.io/post/%E3%80%90World%20tour%20final%202019%20C1%E3%80%91Triangular%20Lamps%20Easy%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-27 14:56:51"
		},
	
		{
			"abstract": "",
			"content": "> 给定一棵树，求任意两点的 $\\operatorname{lca}$，不需要支持带修。\n\n这是一个十分常见的问题，这里总结一下目前常用的几种做法。\n\n## 倍增（$O(n\\log n+q\\log n)$）\n\n最常用的方法，**用 $up_{u,i}$ 记录 $u$ 的第 $2^i$ 级祖先，用 $dep_u$ 记录 $u$ 的深度**，显然这两个东西可以一遍 $dfs$ 在 $O(n\\log n)$ 的时间复杂度内求出来。\n\n每次询问 $\\operatorname{lca}(x,y)$ 的时候**先倍增让深度大的那个点跳到深度和另外一个点的深度相同的祖先，然后两个点一起倍增往上跳**即可。\n\n时间复杂度 $O(n\\log n+q\\log n)$。\n\n代码如下：\n\n```cpp\nvoid dfs(int u,int fa)\n{\n\tdep[u]=dep[fa]+1;\n\tup[u][0]=fa;\n\tfor(int i=1;i<=25;i++) up[u][i]=up[up[u][i-1]][i-1];\n\tfor(int i=h[u];i;i=nxt[i])\n\t{\n\t\tint v=to[i];\n\t\tif(v==fa) continue;\n\t\tdfs(v,u);\n\t}\n}\n\ninline int quelca(int x,int y)\n{\n\tif(dep[x]<dep[y]) swap(x,y);\n\tfor(int i=25;i>=0;i--) if(dep[up[x][i]]>=dep[y]) x=up[x][i];\n\tif(x==y) return x;\n\tfor(int i=25;i>=0;i--) if(up[x][i]!=up[y][i]) x=up[x][i],y=up[y][i];\n\treturn up[x][0];\n}\n```\n\n\n\n## dfs 序 （$O(n\\log n+q)$）\n\n目前主流的还是欧拉序求 $\\operatorname{lca}$，但是其实 dfs 序也可以，而且时间空间常数码量等等都吊打欧拉序。\n\n思考欧拉序为什么能 $\\operatorname{rmq}$ 求 $\\operatorname{lca}$，显然是因为 $x,y$ 和 $\\operatorname{lca}(x,y)$ 映射到欧拉序之后 $\\operatorname{lca}(x,y)$ 一定在两点之间，而映射到 dfs 序之后却没有这个性质。\n\n但是 dfs 序也有一个看似无用的性质：**祖先一定出现在后代之前**。\n\n为了表述方便，**设 $pos_u$ 表示节点 $u$ 在 dfs 序中的位置，设 $dep_u$ 表示节点 $u$ 的深度**，并且下文**假定 $pos_x<pos_y$**。\n\n接下来分情况讨论：\n\n1. $x$ **不是 $y$ 的祖先**\n\n   设 $\\operatorname{lca}(x,y)=r$，那么显然有 $pos_r<pos_x$。显然此时 dfs 的顺序是从 $r$ 下降到 $x$，再回到 $r$，下降到 $y$。\n\n   考虑 $r$ 的 $y$ 方向的儿子，即 $r$ 的满足 $y$ 在 $u$ 子树内的儿子 $u$，那么由于需要先回到 $r$ 才能在下降到 $y$ 的过程中经过 $u$，所以一定有 $pos_x<pos_u\\le pos_y$，也就是说**在 dfs 序中 $u$ 会出现在 $x$ 和 $y$ 中间**。\n\n   那么找到 dfs 序 $[pos_x,pos_y]$ 区间内深度最小的点的父亲即可。 \n\n2. $x$ **是 $y$ 的祖先**\n\n   虽然这种情况可以很方便地特判掉，但是这样不够优美。\n\n   依旧考虑 $x$ 的 $y$ 方向的儿子 $u$，那么一定有 $pos_x<pos_u\\le pos_y$，那么找到 dfs 序 $[pos_x+1,pos_y]$ 区间内深度最小的点的父亲即可。\n\n   观察到就算 $x$ 不是 $y$ 的祖先，查询 $[pos_x+1,pos_y]$ 区间内深度最小的点的父亲也可以得到 $\\operatorname{lca}(x,y)$，所以**直接对于所有情况都查询 $[pos_x+1,pos_y]$ 区间内深度最小的点的父亲，唯一需要特判的情况只有 $x=y$**。\n\n那么解法就很显然了，用倍增 $O(n\\log n)$ 预处理 dfs 序某个区间中 $dep_u$ 最小的点 $u$ 即可做到 $O(n\\log n+q)$。\n\n代码如下：\n\n```cpp\nint tot,dep[S],fat[S],a[S],pos[S];\nint mylog[S],mn[S][30];\nvoid dfs(int u,int fa)\n{\n    dep[u]=dep[fa]+1;\n    fat[u]=fa;\n    a[++tot]=u;\n    pos[u]=tot;\n    for(int i=h[u];i;i=nxt[i])\n    {\n        int v=to[i];\n        if(v==fa) continue;\n        dfs(v,u);\n    }\n}\ninline void init(int rt)\n{\n    dfs(rt,0);\n    mylog[0]=-1;\n    for(int i=1;i<=n;i++) mylog[i]=mylog[i>>1]+1;\n    for(int i=1;i<=n;i++) mn[i][0]=a[i];\n    for(int j=1;j<=mylog[n];j++)\n    {\n        for(int i=1;i<=n-(1<<j)+1;i++)\n        {\n            mn[i][j]=dep[mn[i][j-1]]<dep[mn[i+(1<<j-1)][j-1]]?mn[i][j-1]:mn[i+(1<<j-1)][j-1];\n        }\n    }\n}\ninline int quelca(int x,int y)\n{\n    if(x==y) return x;\n    if(pos[x]>pos[y]) swap(x,y);\n    int l=pos[x]+1,r=pos[y];\n    int k=mylog[r-l+1];\n    int u=dep[mn[l][k]]<dep[mn[r-(1<<k)+1][k]]?mn[l][k]:mn[r-(1<<k)+1][k];\n    return fat[u];\n}\n```\n\n## 树链剖分（$O(n+q\\log n)$，支持换根操作）\n\n前置知识：[树链剖分学习笔记](https://www.luogu.com.cn/blog/251130/shu-lian-pou-fen-xue-xi-bi-ji)\n\n完成剖分之后每次暴力跳重链即可。\n\n树链剖分还可以**支持换根操作**，具体详见：[换根树剖学习笔记](https://www.luogu.com.cn/blog/251130/huan-gen-shu-pou-xue-xi-bi-ji)\n\n时间复杂度 $O(n+q\\log n)$。\n\n## Tarjan（$O(n+q)$，离线）\n\n有些恶心的题目数据范围太大，带 $\\log$ 的时间复杂度都过不去，那么此时就需要用 tarjan 来离线求 $\\operatorname{lca}$。\n\n考虑 $x$ 和 $y$ 和它们的 $\\operatorname{lca}(x,y)=d$ 在对整棵树进行 dfs 遍历时的访问顺序，显然是先从 $d$ 下降到 $x,y$ 中的某一个点，再回到 $d$，然后下降到另外一个点。\n\n设一个点 $u$ “完成了”当且仅当 $u$ 的整棵子树都遍历完成了，若我们**每次“完成”一个点之后就把它子树内的点集并入它的父亲的点集，那么显然 $d$ 即为 $x$ 和 $y$ 都“完成”时“完成”得较早的那个点所处的集合内深度最小的那个点**。\n\n那么把询问离线下来，然后用并查集维护即可。\n\n代码如下：\n\n```cpp\nint tot;\nint xs[S],ys[S],ans[S];\nvector<int> ques[S];\nint fa[S];\nbool vis[S];\ninline void quelca(int x,int y)\n{\n\txs[++tot]=x;\n\tys[tot]=y;\n\tques[x].push_back(tot),ques[y].push_back(tot);\n}\ninline int fnd(int x)\n{\n\treturn fa[x]==x?x:fa[x]=fnd(fa[x]);\n}\ninline void meg(int x,int y)\n{\n\tint rx=fnd(x),ry=fnd(y);\n\tfa[rx]=ry;\n}\nvoid dfs(int u,int fa)\n{\n\tfor(int i=h[u];i;i=nxt[i])\n\t{\n\t\tint v=to[i];\n\t\tif(v==fa) continue;\n\t\tdfs(v,u);\n\t\tmeg(v,u);\n\t}\n\tvis[u]=true;\n\tfor(int qid:ques[u])\n\t{\n\t\tint v=u==xs[qid]?ys[qid]:xs[qid];\n\t\tif(vis[v]) ans[qid]=fnd(v);\n\t}\n}\nvoid flush(int rt)\n{\n\tfor(int i=1;i<=n;i++) fa[i]=i;\n\tdfs(rt,0);\n}\n```\n\n\n\n## 总结 & 完整模板\n\n一般情况下，倍增求 $\\operatorname{lca}$ 和 dfs 序求 $\\operatorname{lca}$ 已经足够。\n\n在需要换根的情况下，只能用树剖求 $\\operatorname{lca}$。\n\n在需要卡常的情况下，若询问数较少，常数优秀的树剖求 $\\operatorname{lca}$ 比 Tarjan 求 $\\operatorname{lca}$ 还要快，但是若询问数非常多，那么 Tarjan 求 $\\operatorname{lca}$ 还是有必要的。\n\n在强制在线并且要卡常的情况下，常数优秀的树剖求 $\\operatorname{lca}$ 是唯一的选择。\n\n完整模板：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nconst int S=1000005;\n\nint n,q,rot;\nint esum,to[S],nxt[S],h[S];\n\ninline void add(int x,int y)\n{\n\tto[++esum]=y;\n\tnxt[esum]=h[x];\n\th[x]=esum;\n}\n\nnamespace BZ\n{\n\tint dep[S],up[S][30];\n\tvoid dfs(int u,int fa)\n\t{\n\t\tdep[u]=dep[fa]+1;\n\t\tup[u][0]=fa;\n\t\tfor(int i=1;i<=25;i++) up[u][i]=up[up[u][i-1]][i-1];\n\t\tfor(int i=h[u];i;i=nxt[i])\n\t\t{\n\t\t\tint v=to[i];\n\t\t\tif(v==fa) continue;\n\t\t\tdfs(v,u);\n\t\t}\n\t}\n\tinline int quelca(int x,int y)\n\t{\n\t\tif(dep[x]<dep[y]) swap(x,y);\n\t\tfor(int i=25;i>=0;i--) if(dep[up[x][i]]>=dep[y]) x=up[x][i];\n\t\tif(x==y) return x;\n\t\tfor(int i=25;i>=0;i--) if(up[x][i]!=up[y][i]) x=up[x][i],y=up[y][i];\n\t\treturn up[x][0];\n\t}\n}\n\nnamespace DFS\n{\n\tint tot,dep[S],fat[S],a[S],pos[S];\n\tint mylog[S],mn[S][30];\n\tvoid dfs(int u,int fa)\n\t{\n\t\tdep[u]=dep[fa]+1;\n\t\tfat[u]=fa;\n\t\ta[++tot]=u;\n\t\tpos[u]=tot;\n\t\tfor(int i=h[u];i;i=nxt[i])\n\t\t{\n\t\t\tint v=to[i];\n\t\t\tif(v==fa) continue;\n\t\t\tdfs(v,u);\n\t\t}\n\t}\n\tinline void init(int rt)\n\t{\n\t\tdfs(rt,0);\n\t\tmylog[0]=-1;\n\t\tfor(int i=1;i<=n;i++) mylog[i]=mylog[i>>1]+1;\n\t\tfor(int i=1;i<=n;i++) mn[i][0]=a[i];\n\t\tfor(int j=1;j<=mylog[n];j++)\n\t\t{\n\t\t\tfor(int i=1;i<=n-(1<<j)+1;i++)\n\t\t\t{\n\t\t\t\tmn[i][j]=dep[mn[i][j-1]]<dep[mn[i+(1<<j-1)][j-1]]?mn[i][j-1]:mn[i+(1<<j-1)][j-1];\n\t\t\t}\n\t\t}\n\t}\n\tinline int quelca(int x,int y)\n\t{\n\t\tif(x==y) return x;\n\t\tif(pos[x]>pos[y]) swap(x,y);\n\t\tint l=pos[x]+1,r=pos[y];\n\t\tint k=mylog[r-l+1];\n\t\tint u=dep[mn[l][k]]<dep[mn[r-(1<<k)+1][k]]?mn[l][k]:mn[r-(1<<k)+1][k];\n\t\treturn fat[u];\n\t}\n}\n\nnamespace TARJAN\n{\n\tint tot;\n\tint xs[S],ys[S],ans[S];\n\tvector<int> ques[S];\n\tint fa[S];\n\tbool vis[S];\n\tinline void quelca(int x,int y)\n\t{\n\t\txs[++tot]=x;\n\t\tys[tot]=y;\n\t\tques[x].push_back(tot),ques[y].push_back(tot);\n\t}\n\tinline int fnd(int x)\n\t{\n\t\treturn fa[x]==x?x:fa[x]=fnd(fa[x]);\n\t}\n\tinline void meg(int x,int y)\n\t{\n\t\tint rx=fnd(x),ry=fnd(y);\n\t\tfa[rx]=ry;\n\t}\n\tvoid dfs(int u,int fa)\n\t{\n\t\tfor(int i=h[u];i;i=nxt[i])\n\t\t{\n\t\t\tint v=to[i];\n\t\t\tif(v==fa) continue;\n\t\t\tdfs(v,u);\n\t\t\tmeg(v,u);\n\t\t}\n\t\tvis[u]=true;\n\t\tfor(int qid:ques[u])\n\t\t{\n\t\t\tint v=u==xs[qid]?ys[qid]:xs[qid];\n\t\t\tif(vis[v]) ans[qid]=fnd(v);\n\t\t}\n\t}\n\tvoid flush(int rt)\n\t{\n\t\tfor(int i=1;i<=n;i++) fa[i]=i;\n\t\tdfs(rt,0);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&q,&rot);\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y),add(y,x);\n\t}\n//\tBZ::dfs(rot,0);\n//\tDFS::init(rot);\n\twhile(q--)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t//\tprintf(\"%d\\n\",BZ::quelca(x,y));\n\t//\tprintf(\"%d\\n\",DFS::quelca(x,y));\t\t\n\t\tTARJAN::quelca(x,y);\n\t}\n\tTARJAN::flush(rot);\n\tfor(int i=1;i<=TARJAN::tot;i++) printf(\"%d\\n\",TARJAN::ans[i]);\n\treturn 0;\n}\n```\n\n",
			"tags": [{"name":"学习笔记"},{"name":"图论"}],
			"title": "最近公共祖先（LCA）学习笔记",
			"link": "https://exber.qzz.io/post/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%EF%BC%88LCA%EF%BC%89%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-03-27 11:21:24"
		},
	
		{
			"abstract": "",
			"content": "Kruskal 重构树是一种常用于维护连通性的数据结构，用它可以快速维护一些点要联通的瓶颈边权之类的问题。\n\n先看一道例题：[CF1706E Qpwoeirut and Vertices](https://www.luogu.com.cn/problem/CF1706E)。\n\n> 给一张 $n$ 个点 $m$ 条边的无向连通图，$q$ 次询问，每次询问给一个区间 $[l,r]$，求按照输入顺序加边，至少加到第几条边可以令编号在 $[l,r]$ 内的点连通。\n>\n> $2\\le n\\le 10^5$，$1\\le m,q\\le 2\\times 10^5$。\n\n首先让所有点都单独自己一个连通块，并且让**每个连通块的根节点都为连通块内的那个点本身**。\n\n然后按照**边输入的顺序**合并边两头的节点所在的连通块，处理到第 $i$ 条边时：\n\n1. 若这条边两头的节点已经连通，那么跳过这次操作；\n2. 设两个连通块的根节点分别是 $rx$ 和 $ry$，那么就新建一个连向两个连通块的新点 $r'$，连接 $r'\\to rx$ 和 $r'\\to ry$；\n3. 令 $tme_{r'}=i$，即记录下 $r'$ 新建的时间点；\n4. 最后合并两个连通块，新的连通块的根节点即为 $r'$；\n\n其实就是相当于把 Kruskal 求最小生成树时的合并操作表达成树。\n\n![](../post-images/1679887146663.png)\n\n容易发现，这样建出来的是一棵二叉树，并且有一些美妙的性质：\n\n- 叶子节点就是原图中的每个点，新建出来的点代表原图的**建边顺序最小生成树**中的边；\n- 对于所有满足 $v$ 是 $u$ 子树内的节点的 $v$，都有 $tme_v<tme_u$ \n- 原图中的一个点集 $S$ 连通**至少要加前 $tme_{\\operatorname{lca}(S)}$ 条边**；\n\n我们就把这样的二叉树叫做 Kruskal 重构树。那么本题直接用线段树维护 Kruskal 重构树上的区间 $\\operatorname{lca}$ 即可。\n\n建树代码：\n\n```cpp\nfor(int i=1;i<=n*2-1;i++) fa[i]=i;\nfor(int i=1;i<=n*2-1;i++) ls[i]=rs[i]=tme[i]=0;\nint cnt=n;\nfor(int i=1;i<=m;i++)\n{\n    int x,y;\n    scanf(\"%d%d\",&x,&y);\n    int rx=fnd(x),ry=fnd(y);\n    if(rx!=ry)\n    {\n        int u=++cnt;\n        tme[u]=i;\n        ls[u]=rx;\n        rs[u]=ry;\n        fa[rx]=fa[ry]=u;\n    }\n}\n```\n\n### 练习题目\n\n- [P4197 Peaks](https://www.luogu.com.cn/problem/P4197)\n\n- [P7834 [ONTAK2010] Peaks 加强版](https://www.luogu.com.cn/problem/P7834)\n",
			"tags": [{"name":"学习笔记"},{"name":"数据结构"}],
			"title": "Kruskal 重构树学习笔记",
			"link": "https://exber.qzz.io/post/Kruskal%20%E9%87%8D%E6%9E%84%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-03-27 11:18:35"
		},
	
		{
			"abstract": "> [P6545 [CEOI2014] The Wall](https://www.luogu.com.cn/problem/P6545)\n",
			"content": "> [P6545 [CEOI2014] The Wall](https://www.luogu.com.cn/problem/P6545)\n\n\n首先有个结论，**筑的墙一定会把 $(1,1)$ 到所有别的关键点的左上角的最短路都围进去**。例如：\n\n![](../post-images/1679880958305.png)\n\n若当前墙包含的是深蓝色区域，而 $(1,1)$ 到关键点 $u$ 的左上角的最短路是绿色的线，那么显然把浅蓝色区域也包含进墙里是更优的，因为红色段肯定是比代替它的五小段绿色段的长度和要长的，因为绿色的线是最短路。\n\n**为什么是左上角？**其实**四个角都没关系**，这个之后再证明。\n\n求出了 $(1,1)$ 到别的关键点的左上角的最短路之后，问题就转化为最小化筑墙的花费，使得筑出的墙可以圈住所有的最短路和关键点。\n\n那么考虑**把一个网格线的交点都拆成四个点，点之间顺时针连边权为 $0$ 的有向边，属于不同交点的点之间连边权为原权值的有向边**，但是要注意**经过关键点和最短路的边都不能连**：\n\n![](../post-images/1679880965789.png)\n\n容易发现，这样建好图之后，从网格左上角的交点拆出来的 $1$ 号点出发，走到它的 $3$ 号点，就能筑出合法的墙。那么花费最小的方案显然就是这两点之间的最短路。\n\n最后说一下之前留下来的悬念：\n\n>为什么要走到左上角？？？为什么走到哪个角都没关系？？？\n\n不妨先钦定一定从左上角那个关键点的左上角出发，显然**走到右上角的最短路一定“围着”走到左上角的最短路**，即绿色的线不可能越过红色的线再回来，因为那样不优。\n\n那么分两种情况讨论：\n\n- 走到左上角的最短路**是**先走到右上角再往左走：\n\n    ![](../post-images/1679880974512.png)\n\n  这时由于最后筑的墙要包含所有关键点，所以左上角和右上角之间的那条边不会被筑墙，也就是说，红线和绿线有用的部分是完全相等的，那么自然对答案没有任何影响；\n\n- 走到左上角的最短路**不是**先走到右上角再往左走：\n\n    ![](../post-images/1679880983201.png)\n\n  这时考虑最后跑的最短路，即筑的墙，用紫色的线标识。显然，由于走到左上角的最短路不是先走到右上角再往左走，所以走左上角和右上角的那条边一定是不优的；并且走红线和绿线中间也是不优的，因为红线和绿线是最短路。那么最终的墙只有可能是这样：\n\n    ![](../post-images/1679880993924.png)\n\n  所以对最终的答案没有影响；\n\n参考这样的证明方法，容易得出从哪个角出发，走到哪个角都是没有任何关系的。所以为了好写，干脆直接钦定从左上角开始和结束。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nconst int S=5000005,MS=405;\n\nint n,m;\nint a[MS][MS];\nlong long dnval[MS][MS],rgval[MS][MS];\nint esum,to[S],nxt[S],h[S];\nlong long c[S],dis[S];\nbool vis[S];\nbool dntag[MS][MS],rgtag[MS][MS];\n\ninline int getid(int x,int y)\n{\n\treturn (x-1)*(m+1)+y;\n}\n\ninline int getx(int id)\n{\n\treturn (id-1)/(m+1)+1;\n}\n\ninline int gety(int id)\n{\n\treturn (id-1)%(m+1)+1;\n}\n\ninline void add(int x,int y,long long w)\n{\n\tto[++esum]=y;\n\tc[esum]=w;\n\tnxt[esum]=h[x];\n\th[x]=esum;\n}\n\ninline void dijkstra(int s)\n{\n\tmemset(dis,127,sizeof(dis));\n\tmemset(vis,0,sizeof(vis));\n\tdis[s]=0;\n\tpriority_queue<pair<long long,int> > q;\n\tq.push(make_pair(-dis[s],s));\n\twhile(!q.empty())\n\t{\n\t\tint u=q.top().second;\n\t\tq.pop();\n\t\tif(vis[u]) continue;\n\t\tvis[u]=true;\n\t\tfor(int i=h[u];i;i=nxt[i])\n\t\t{\n\t\t\tint v=to[i];\n\t\t\tlong long w=c[i];\n\t\t\tif(dis[u]+w<dis[v])\n\t\t\t{\n\t\t\t\tdis[v]=dis[u]+w;\n\t\t\t\tq.push(make_pair(-dis[v],v));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dfs(int u)\n{\n\tvis[u]=true;\n\tfor(int i=h[u];i;i=nxt[i])\n\t{\n\t\tint v=to[i];\n\t\tlong long w=c[i];\n\t\tif(dis[u]==dis[v]+w)\n\t\t{\n\t\t\tint ux=getx(u),uy=gety(u),vx=getx(v),vy=gety(v);\n\t\t\tif(vx!=ux) dntag[min(ux,vx)][uy]=true;\n\t\t\telse rgtag[ux][min(uy,vy)]=true;\n\t\t\tif(!vis[v]) dfs(v);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++) for(int j=1;j<=m;j++) scanf(\"%d\",&a[i][j]);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=m+1;j++)\n\t\t{\n\t\t\tscanf(\"%lld\",&dnval[i][j]);\n\t\t\tint idu=getid(i,j),idv=getid(i+1,j);\n\t\t\tadd(idu,idv,dnval[i][j]);\n\t\t\tadd(idv,idu,dnval[i][j]);\n\t\t}\n\t}\n\tfor(int i=1;i<=n+1;i++)\n\t{\n\t\tfor(int j=1;j<=m;j++)\n\t\t{\n\t\t\tscanf(\"%lld\",&rgval[i][j]);\n\t\t\tint idu=getid(i,j),idv=getid(i,j+1);\n\t\t\tadd(idu,idv,rgval[i][j]);\n\t\t\tadd(idv,idu,rgval[i][j]);\n\t\t}\n\t}\n\tdijkstra(getid(1,1));\n\tmemset(vis,0,sizeof(vis));\n\tfor(int i=1;i<=n;i++) for(int j=1;j<=m;j++) if(a[i][j]==1&&!vis[getid(i,j)]) dfs(getid(i,j));\n\tesum=0;\n\tmemset(h,0,sizeof(h));\n\tfor(int i=1;i<=n+1;i++)\n\t{\n\t\tfor(int j=1;j<=m+1;j++)\n\t\t{\n\t\t\tint bg=(getid(i,j)-1)*4;\n\t\t\tint _0=bg+1,_1=bg+2,_2=bg+3,_3=bg+4;\n\t\t\tif(!dntag[i-1][j]&&a[i-1][j-1]==0&&a[i-1][j]==0) add(_0,_1,0);\n\t\t\tif(!rgtag[i][j]&&a[i-1][j]==0&&a[i][j]==0) add(_1,_2,0);\n\t\t\tif(!dntag[i][j]&&a[i][j]==0&&a[i][j-1]==0) add(_2,_3,0);\n\t\t\tif(!rgtag[i][j-1]&&a[i][j-1]==0&&a[i-1][j-1]==0) add(_3,_0,0);\n\t\t\tif(i>1)\n\t\t\t{\n\t\t\t\tint ubg=(getid(i-1,j)-1)*4;\n\t\t\t\tint u2=ubg+3,u3=ubg+4;\n\t\t\t\tadd(u2,_1,dnval[i-1][j]);\n\t\t\t\tadd(_0,u3,dnval[i-1][j]);\n\t\t\t}\n\t\t\tif(j>1)\n\t\t\t{\n\t\t\t\tint lbg=(getid(i,j-1)-1)*4;\n\t\t\t\tint l1=lbg+2,l2=lbg+3;\n\t\t\t\tadd(l1,_0,rgval[i][j-1]);\n\t\t\t\tadd(_3,l2,rgval[i][j-1]);\n\t\t\t}\n\t\t}\n\t}\n\tdijkstra(2);\n\tprintf(\"%lld\\n\",dis[4]);\n\treturn 0;\n}\n```\n\n",
			"tags": [{"name":"做题记录"},{"name":"图论"},{"name":"最短路"}],
			"title": "P6545 [CEOI2014] The Wall 做题记录",
			"link": "https://exber.qzz.io/post/P6545%20%5BCEOI2014%5D%20The%20Wall%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-27 09:27:37"
		},
	
		{
			"abstract": "",
			"content": "线性基是一种经常用于解决集合异或问题的数据结构。其实与其说它是数据结构，说它是一种巧妙的构造算法更恰当。\n\n## 定义\n\n非负整数集合 $S$ 的线性基 $A$ 满足一些美妙的性质：\n\n1. $A$ 是一个集合；\n2. $S$ 能异或出来的所有非负整数，$A$ **都能**异或出来，但 **$A$ 的所有真子集都不能完全异或出来**，也就是说 $A$ 是**极小的**；\n3. 记 $S$ 能异或出来的所有非负整数集合为 $T$，那么 $T$ 中的每一个元素都**仅可以被 $A$ 中的某个特定子集 $B$ 异或出来**；\n\n简单来说，线性基就是一个关于非负整数集合 $S$ 的特殊的集合，它很小但又可以异或出 $S$ 能异或出来的所有值。\n\n## 构造\n\n考虑线性基的构造，可以构造一种特殊的线性基使得：\n\n1. $A$ 是一个有序序列；\n\n2. 对于每个 $i$：\n\n   1. 要么 $A$ 中**有且仅有 $A_i$ 的二进制第 $i$ 位为 $1$**，且 $A_i$ 的**二进制最高的为 $1$ 的位是第 $i$ 位**；\n\n   2. 要么 $A_i=0$ 且**只有所有满足 $j>i$ 的 $A_j$ 二进制的第 $i$ 位为可能为 $1$**；\n\n3. $|A|$ 最大为 $\\log V$，其中 $V$ 是值域；\n\n具体方法是，先让 $A=\\{0,0,\\dots,0\\}$，然后不断的把 $S$ 中的元素插入 $A$。一次插入的流程如下：（设插入的非负整数为 $x$）\n\n**从高位到低位**枚举，假设枚举到第 $i$ 位，显然**若 $x$ 的二进制中第 $i$ 位为 $0$ 则 $x$ 不可能插入此处，直接跳过**即可。否则：\n\n- 若 $A_i\\not=0$，那么此时 $x$ 肯定无法插入此处。由于**要保证性质 2.1 中关于最高位的性质**，所以需要删掉 $x$ 的第 $i$ 位。又由于要满足线性基的**性质 2**，所以我们不能直接让 $x$ 减去 $2^i$，而是应该**让 $x\\to x\\operatorname{xor} A_i$，因为这样可以保证最终插入 $A$ 的 $x$ 异或上 $A_i$ 还可以表示原来插入的 $x$，这样也不会让 $A$ 中的元素能异或出其它的值或让 $A$ 不再是极小的**；\n\n- 若 $A_i=0$，那么：\n\n  1. 让 **$x$ 异或上所有满足 $j<i$ 且 $x$ 的二进制中第 $j$ 位为 $1$ 的 $A_j$**，这样做是为了**保证性质 2.1 中有且仅有 $A_j$ 的二进制第 $j$ 位可能为 $1$ 的性质**，所以要通过异或操作把 $x$（未来的 $A_i$） 的这些位删掉，不直接减去 $2^j$ 的原因同上。\n  2.  让 $A_i\\to x$；\n  3. 让**所有满足 $j>i$ 的 $A_j$ 都异或上 $A_i$**，这样做同样是为了**保证性质 2.1 中有且仅有 $A_j$ 的二进制第 $j$ 位可能为 $1$ 的性质**；\n  4. 结束插入；\n  \n\n执行完插入流程后，若 $x\\not=0$ 那么插入就成功了，否则就表明当前的线性基中的元素已经能异或出 $x$，无需插入。但是若 $x=0$ 就表明插入失败，即线性基已经能异或出 $x$ 了。\n\n插入代码如下：\n\n```cpp\nlong long a[65];\nbool has0;\n\ninline void ins(long long x)\n{\n\tfor(int i=60;i>=0&&x>0;i--) // 注意一定要倒序枚举！因为要消掉 x 的二进制高位的 1，并且需要对 x 的二进制的低位造成影响\n\t{\n\t\tif((x>>i)&1) // x 的二进制这一位为 1\n\t\t{\n\t\t\tif(a[i]==0) // 可以插入\n\t\t\t{\n\t\t\t\tfor(int j=i-1;j>=0;j--) if((x>>j)&1) x^=a[j]; // 这个循环的顺序不重要\n\t\t\t\t// 因为所有满足 j<i 的不为 0 的 A[j] 都不会影响到其它不为 0 的 A[j]\n\t\t\t\ta[i]=x; // 插入\n\t\t\t\tfor(int j=i+1;j<=60;j++) if((a[j]>>i)&1) a[j]^=a[i]; // 把所有满足 j>i 且 A[j] 的二进制第 i 位为一的 A[j] 的二进制第 i 位消去\n\t\t\t\tbreak;  // 记得结束插入过程\n\t\t\t}\n\t\t\telse x^=a[i]; // 不能插入，消去这一位\n\t\t}\n\t}\n\tif(x==0) has0=true;\n}\n```\n\n## 查询\n\n把非负整数集合 $S$ 的元素都插入线性基后，线性基能支持几种关于异或的查询。\n\n### 求 $S$ 有多少个不同的子集异或和为 $x$\n\n首先检查是否能异或出 $x$，若可以，那么 $x$ 异或上线性基外的任意几个数得到的 $x'$ 都可以被线性基异或出来，所以答案为 $2^{n-siz}$，其中 $siz=\\sum [A_i\\not=0]$。\n\n### 求 $S$ 的子集的最大异或和\n\n由于构造出来的线性基满足有且仅有 $A_i$ 的二进制中第 $i$ 位为 $1$，所以 **$A_i$ 中参与异或运算的元素越多结果就越大**，让所有 $A_i$ 异或起来的结果 $xsum$ 肯定是 $A_i$ 的所有子序列的异或和中最大的。又由于线性基可以异或出 $S$ 能异或出的所有值，所以 $xsum$ 就是 $S$ 的子集的最大异或和。\n\n代码如下：\n\n```cpp\ninline long long quemx()\n{\n\tlong long res=0;\n\tfor(int i=0;i<=60;i++) res^=a[i];\n\treturn res;\n}\n```\n\n### 求 $S$ 的子集的最小异或和\n\n由于 $A_i$ 中参与异或运算的元素越多结果就越大，所以最优的情况显然是只让 $A$ 中的一个元素参与异或运算，所以**返回 $A$ 中的最小值**即可。不过要特判 $0$ 的情况。\n\n代码如下：\n\n```cpp\ninline long long quemn()\n{\n\tif(has0) return 0;\n\tlong long mn=2e18;\n\tfor(int i=0;i<=60;i++) mn=min(mn,a[i]);\n\treturn mn;\n}\n```\n\n### 求 $S$ 的子集的第 $k$ 小异或和\n\n首先线性基中的元素是异或不出 $0$ 的，所以**若 $S$ 可以异或出 $0$，即 $has0=true$，那么就需要让 $k\\to k-1$**。\n\n由于 $A$ 中只有不为 $0$ 的元素才对异或和有贡献，所以不妨**用一个数组 $B$ 依次记录下 $A$ 中不为 $0$ 的值**。\n\n显然，由于线性基可以异或出 $S$ 能异或出的所有值，所以 **$2^{|B|}-1$ 种 $B$ 的非空子序列都可以异或出互不相同的值**，所以**若 $k>2^{|B|}-1$ 就无解**。\n\n由于构造出来的线性基满足有且仅有 $A_i$ 的二进制中第 $i$ 位为 $1$，所以对于任意一个 $0\\le i\\le |B|$ 的非负整数 $i$，**任意一个非负整数异或上 $B_i$ 得到的结果都它比依次异或上 $B_1,B_2,B_3,\\dots B_{i-1}$ 小**，这和二进制很像。\n\n那么解法就很明显了，**把所有满足 $k$ 的二进制中第 $i$ 位为 $1$ 的 $B_i$ 异或起来**，我们就能得到 $S$ 的子集的第 $k$ 小异或和。\n\n代码如下：\n\n```cpp\nlong long b[65];\n\ninline long long kth(long long k)\n{\n\tif(has0) k--;\n\tint len=-1;\n\tfor(int i=0;i<=60;i++) if(a[i]!=0) b[++len]=a[i];\n\tlong long ans=0;\n\tfor(int i=0;i<=len;i++) if((k>>i)&1) ans^=b[i],k^=1ll<<i;\n\treturn k>0?-1:ans;\n}\n```\n\n## 额外的操作\n\n线性基还支持一些其它的操作。\n\n### 合并\n\n两个线性基合并，只需要暴力把一个线性基中的所有元素插入到另一个线性基中即可。容易证明插入完成的线性基还是满足所有性质的。\n\n### 可持久化\n\n由于线性基数组 $A$ 很短，所以可以用二维数组来实现可持久化，时间和空间复杂度都是 $O(q\\log V)$ 的。其中 $q$ 为操作次数，$V$ 则表示值域大小。\n\n****\n\nupd：2025.06.21\n\n### 带删除\n\n离线可以直接抠背包（线段树分治），做到 $O(n\\log n\\log w)$，或者说 $O(n\\log n\\frac{m}{\\omega})$，其中 $m$ 是维数。\n\n或者可以给每个基打时间戳，插入的时候维护一下每个基的最晚出现时间（适用于双指针）。\n\n而用一堆分讨可以做到在线，单次 $O(\\log w)$ 或者 $O(\\frac{m^2}{\\omega})$（和插入同阶）。\n\n具体的，每个元素插入的时候额外维护一个 $id_i$ 表示它最后由那些元素组成（即最后变成某个基或者变成 $0$ 时具体异或上了原来插入的哪些元素）。\n\n那么分讨一下，假设删除的是 $x$：\n\n- 如果删除的元素不在线性基中，直接删除即可；\n- 否则要消去 $x$ 带来的影响：\n  - 若存在一个不在线性基中的元素（插入时被消成了 $0$），满足其 $id$ 包含 $x$，那么 $x$ 将会在这个地方复活，处理一下；\n  - 否则秩将会减一，此时：\n    - 找到线性基中最小的，$id$ 包含 $x$ 的基 $z$；\n    - 将所有 $id$ 包含 $x$ 的基全部异或上 $z$（$z$ 也要异或自己，相当于变成了 $0$）；\n\n这样做显然是对的。\n",
			"tags": [{"name":"学习笔记"},{"name":"数据结构"}],
			"title": "线性基学习笔记",
			"link": "https://exber.qzz.io/post/%E7%BA%BF%E6%80%A7%E5%9F%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-03-27 09:22:35"
		},
	
		{
			"abstract": "> 给定 $n$ 个数 $a_{[1,n]}$，现在要将其重排。\n> \n> 如果 $a_i$ 于重排前在第 $i$ 个位置，现在移动到了第 $j$ 个位置，那么对答案的贡献就是 $|j-i|\\times a_i$。\n> \n> 输出所有重排方案中最大的答案。\n> \n> - $2 \\leq N \\leq 2000$\n> - $1 \\leq A_i \\leq 10^9$\n",
			"content": "> 给定 $n$ 个数 $a_{[1,n]}$，现在要将其重排。\n> \n> 如果 $a_i$ 于重排前在第 $i$ 个位置，现在移动到了第 $j$ 个位置，那么对答案的贡献就是 $|j-i|\\times a_i$。\n> \n> 输出所有重排方案中最大的答案。\n> \n> - $2 \\leq N \\leq 2000$\n> - $1 \\leq A_i \\leq 10^9$\n\n首先不难发现最大值一定是放在 $1$ 或者 $n$，但是会出现放在 $1$ 和 $n$ 时价值相同的情况，所以不能直接贪心。\n\n那么考虑设 $dp_{l,r}$ 表示重新排列 $a_{[l,r]}$ 后这段区间对答案的最大贡献，但是似乎不太好转移。\n\n继续挖掘性质，不难发现原来的顺序并不重要，考虑从小到大填数。设 $dp_{l,r}$ 表示前 $r-l+1$ 小的数填入 $[l,r]$ 后对答案的最大贡献，转移：\n\n$$\ndp_{[l,r]}=\\max(dp_{[l,r-1]}+|pos_{r-l+1}-r|\\times val_{r-l+1},dp_{[l+1,r]}+|pos_{r-l+1}-l|\\times val_{r-l+1})\n$$\n\n其中 $pos_i$ 和 $val_i$ 分别表示 $a$ 中第 $i$ 小的数的位置和数值。\n\n边界为 $dp_{i,i-1}=0$，答案为 $dp_{1,n}$。\n\n代码如下：\n\n```cpp\n// Problem: [ABC163E] Active Infants\n// Contest: Luogu\n// URL: https://www.luogu.com.cn/problem/AT_abc163_e\n// Memory Limit: 1 MB\n// Time Limit: 2000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=2005;\n\nint n,a[S];\nint id[S];\nlong long dp[S][S];\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]),id[i]=i;\n\tsort(id+1,id+n+1,[&](int x,int y){return a[x]<a[y];});\n\tfor(int len=1;len<=n;len++)\n\t{\n\t\tfor(int l=1;l<=n-len+1;l++)\n\t\t{\n\t\t\tint r=l+len-1;\n\t\t\tdp[l][r]=max(\n\t\t\t\tdp[l][r-1]+1ll*abs(id[r-l+1]-r)*a[id[r-l+1]],\n\t\t\t\tdp[l+1][r]+1ll*abs(id[r-l+1]-l)*a[id[r-l+1]]\n\t\t\t);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[1][n]);\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"DP"},{"name":"贪心"}],
			"title": "ABC163E Active Infants 做题记录",
			"link": "https://exber.qzz.io/post/ABC163E%20Active%20Infants%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-26 17:28:36"
		},
	
		{
			"abstract": "> 给定一个长度为奇数的排列 $a_1, a_2, \\dots, a_n$，你需要构造一组长度不超过的 $\\frac 52 n$ 的操作序列 $s_1, s_2, \\dots, s_k$，使得：\n> \n> * $1 \\le s_i \\le n$，$s_i$ 为奇数；\n> * 按从前往后的顺序，对于每个 $s_i$，反转排列的前 $s_i$ 项，最后得到的排列中 $a_i = i$。\n> \n> $1\\le n\\le 2021$，$1\\le a_i\\le n$。\n",
			"content": "> 给定一个长度为奇数的排列 $a_1, a_2, \\dots, a_n$，你需要构造一组长度不超过的 $\\frac 52 n$ 的操作序列 $s_1, s_2, \\dots, s_k$，使得：\n> \n> * $1 \\le s_i \\le n$，$s_i$ 为奇数；\n> * 按从前往后的顺序，对于每个 $s_i$，反转排列的前 $s_i$ 项，最后得到的排列中 $a_i = i$。\n> \n> $1\\le n\\le 2021$，$1\\le a_i\\le n$。\n\n首先由于每次翻转的长度都是奇数，所以并不会改变奇偶性，那么若 $a_i$ 和 $i$ 奇偶性不相同就是无解。\n\n否则假设有解，考虑让 $i$ 和 $i+1$ 在一起（$i$ 是奇数），然后丢到后面来不对别的数造成影响，最后再整体翻转一次。由于操作次数是 $\\frac{5}{2}n$，所以不难想到给每一对数 $5$ 次操作来还原。\n\n这里给出一种构造方案：\n\n1. 用一次操作把 $i$ 换到第一位；\n2. 用一次操作把 $i$ 换到和 $i+1$ 相邻的位置；\n3. 把 $i+1$ 换到第二个位置，这时 $i$ 在第三个位置；\n4. 交换前三个位置，这样就可以让序列的前两个位置分别为 $i$ 和 $i+1$；\n5. 把它们两个放到最后即可。\n\n这样做每次只需要 $5$ 次操作即可把 $i$ 和 $i+1$ 换好。\n\n最后整体倒过来就行，总操作次数刚好是 $\\dfrac{5}{2}n$。\n\n",
			"tags": [{"name":"做题记录"},{"name":"构造"}],
			"title": "CF1558C Bottom-Tier Reversals 做题记录",
			"link": "https://exber.qzz.io/post/CF1558C%20Bottom-Tier%20Reversals%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-26 11:28:03"
		},
	
		{
			"abstract": "> 这是一道交互题。\n> \n> 在文本编辑器里有 $n$ 个单词，其中第 $i$ 个单词的长度为 $l_i$ ($1 \\le l_i \\le 2000$)。$l$ 仅对测评机可见。\n> \n> 文本编辑器一行一行展示文本，以空格分开相邻的两个单词，但是行末不一定有空格，即单词可以直接作为某一行的末尾。定义文本的高度 $h$ 为文本展示需要的行数。对于给定的屏幕宽度，编辑器会以高度最小的方式显示。\n> \n> 更正式地，设文本编辑器的宽度为 $w$ 。设 $a$ 是一个长度为 $k + 1$ 的序列，其中 $1 = a_1 < a_2 < ... < a_{k+1} = n + 1$. $\\{a_n\\}$ 是一个合法的序列当且仅当，$\\forall 1 \\le i \\le k, l_{a_i} + 1 + l_{a_{i + 1}} + 1 + \\dots + 1 + l_{a_{i+1} - 1} \\le w$。 那么，$h$ 就是所有合法的 $\\{a_n\\}$ 中最小的 $k$.。\n> \n> 注意，如果 $w \\le \\max(l_i)$，那么文本编辑器将不能显示所有的文字并且崩溃，此时 $h = 0$。\n> \n> 你可以做 $n + 30$ 次询问。每次询问中，输出宽度 $w$ . 测评机将返回 $h_w$ ，即当宽度为 $w$ 的最小高度。\n> \n> 请找到文本编辑器的最小面积，即求 $min(w\\times h_w | 1 \\le w \\le n)$。\n",
			"content": "> 这是一道交互题。\n> \n> 在文本编辑器里有 $n$ 个单词，其中第 $i$ 个单词的长度为 $l_i$ ($1 \\le l_i \\le 2000$)。$l$ 仅对测评机可见。\n> \n> 文本编辑器一行一行展示文本，以空格分开相邻的两个单词，但是行末不一定有空格，即单词可以直接作为某一行的末尾。定义文本的高度 $h$ 为文本展示需要的行数。对于给定的屏幕宽度，编辑器会以高度最小的方式显示。\n> \n> 更正式地，设文本编辑器的宽度为 $w$ 。设 $a$ 是一个长度为 $k + 1$ 的序列，其中 $1 = a_1 < a_2 < ... < a_{k+1} = n + 1$. $\\{a_n\\}$ 是一个合法的序列当且仅当，$\\forall 1 \\le i \\le k, l_{a_i} + 1 + l_{a_{i + 1}} + 1 + \\dots + 1 + l_{a_{i+1} - 1} \\le w$。 那么，$h$ 就是所有合法的 $\\{a_n\\}$ 中最小的 $k$.。\n> \n> 注意，如果 $w \\le \\max(l_i)$，那么文本编辑器将不能显示所有的文字并且崩溃，此时 $h = 0$。\n> \n> 你可以做 $n + 30$ 次询问。每次询问中，输出宽度 $w$ . 测评机将返回 $h_w$ ，即当宽度为 $w$ 的最小高度。\n> \n> 请找到文本编辑器的最小面积，即求 $min(w\\times h_w | 1 \\le w \\le n)$。\n\n看到 $n+30$ 次询问，容易猜到应该是用 $30$ 次操作求一个关于值域的东西，剩下 $n$ 次操作求出答案。\n\n考虑 $30$ 次操作能求出什么，显然可以二分求出：\n\n1.  最长的单词长度 $mxlen$；\n2. $h=1$ 时最小的 $w$，即所有单词的长度和加上 $n-1$，设它为 $L$。\n\n$mxlen$ 好像没什么用，那么考虑 $L$ 的用途。\n\n若 $h=i$ 且此时更优秀，那么 $w$ 的最大的情况只能是 $\\lfloor\\frac{L}{i}\\rfloor$，并且由于 $h=i$ 时最多只能比 $h=1$ 节省 $i-1$ 个空格，所以 $w=\\lfloor\\frac{L}{i}\\rfloor-1$ 是不可能成立的。\n\n所以 $h=i$ 且更优秀时的 $w$ 一定为 $\\lfloor\\frac{L}{i}\\rfloor$。\n\n那么求出 $L$ 之后枚举 $h$ 即可。\n",
			"tags": [{"name":"做题记录"},{"name":"构造"},{"name":"交互、通信"}],
			"title": "CF1672E notepad.exe 做题记录",
			"link": "https://exber.qzz.io/post/CF1672E%20notepad.exe%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-26 11:23:02"
		},
	
		{
			"abstract": "> 给定一个长度为 $n(1\\le n\\le 1000)$ ，仅由前 $17$ 个英文小写字母和问号组成的字符串 $s$。\n> \n> 多次询问，每次给出一个由前 $17$ 个英文小写字母组成的字符集 $A$ ，你可以将 $s$ 中的问号任意替换成 $A$ 中的字母，求你能得到多少个不同的回文子串\n> \n> 答案对 $998144353$ 取模。\n",
			"content": "> 给定一个长度为 $n(1\\le n\\le 1000)$ ，仅由前 $17$ 个英文小写字母和问号组成的字符串 $s$。\n> \n> 多次询问，每次给出一个由前 $17$ 个英文小写字母组成的字符集 $A$ ，你可以将 $s$ 中的问号任意替换成 $A$ 中的字母，求你能得到多少个不同的回文子串\n> \n> 答案对 $998144353$ 取模。\n\n观察到字符集很小，所以考虑预处理出每个字符集的答案，询问的时候快速回答。\n\n设 $dp_{i,j}$ 表示字符集为 $i$（$i$ 的二进制位表示对应字符有/没有），字符集大小为 $j$ 的答案，$all$ 为整个字符串中 `?` 的个数。\n\n这里新增一维存储字符集大小是因为转移的时候 $dp_i$ 会统计上 $j\\in i$ 的 $dp_j$，而在统计答案的时候会用到字符集大小的乘方，无法化简。\n\n不难发现，可以枚举回文中心，然后不停往两边拓展，扩展途中记录下当前子串内部的 `?` 个数 $cnt$：\n\n- 若遇到两个不为 `?` 且不同的字符或者超出字符串边界，那么停止拓展；\n- 若遇到一边为 `?` 另一边不为 `?`，那么字符集 $sta$ 加上不为 `?` 的那个字符且让 $cnt\\to cnt+1$；\n- 若遇到两边都为 `?`，那么让 $cnt\\to cnt+1$；\n- 初始子串为空串，每拓展一次，就把 $dp_{sta,j}$ 加上 $j^{all-cnt}$。\n\n处理完所有子串之后，需要让 $dp_i$ 统计上所有 $j\\in i$ 的 $dp_j$，那么仿照 [CF449D Jzzhu and Numbers](../CF449D Jzzhu and Numbers 做题记录) 的思路，转移的时候先按位枚举，再枚举那一位为 $1$ 的 $i$ 来转移 $dp_i$，这样就可以避免算重。\n\n```cpp\nint n,q;\nchar s[S],str[S];\nint dp[1<<17][25];\n\ninline int qpow(int x,int y)\n{\n\tint res=1;\n\tfor(;y>0;y>>=1,x=1ll*x*x%p) res=(y&1)?1ll*res*x%p:res;\n\treturn res;\n}\n\ninline void slove()\n{\n\tcin>>n;\n\tcin>>(s+1);\n\tint all=0;\n\tfor(int i=1;i<=n;i++) all+=s[i]=='?';\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint l=i+1,r=i-1;\n\t\tint sta=0,cnt=0;\n\t\twhile(l>1&&r<n&&(s[l-1]==s[r+1]||s[l-1]=='?'||s[r+1]=='?'))\n\t\t{\n\t\t\tl--,r++;\n\t\t\tif(s[l]=='?'&&s[r]!='?') sta|=1<<s[r]-'a';\n\t\t\tif(s[l]!='?'&&s[r]=='?') sta|=1<<s[l]-'a';\n\t\t\tif(l!=r&&(s[l]=='?'||s[r]=='?')) cnt++;\n\t\t\tfor(int j=1;j<=17;j++) dp[sta][j]=(dp[sta][j]+qpow(j,all-cnt))%p;\n\t\t}\n\t\tl=i+1,r=i;\n\t\tsta=0,cnt=0;\n\t\twhile(l>1&&r<n&&(s[l-1]==s[r+1]||s[l-1]=='?'||s[r+1]=='?'))\n\t\t{\n\t\t\tl--,r++;\n\t\t\tif(s[l]=='?'&&s[r]!='?') sta|=1<<s[r]-'a';\n\t\t\tif(s[l]!='?'&&s[r]=='?') sta|=1<<s[l]-'a';\n\t\t\tif(s[l]=='?'||s[r]=='?') cnt++;\n\t\t\tfor(int j=1;j<=17;j++) dp[sta][j]=(dp[sta][j]+qpow(j,all-cnt))%p;\n\t\t}\n\t}\n\tfor(int j=0;j<=16;j++)\n\t\tfor(int i=0;i<=(1<<17)-1;i++)\n\t\t\tif((i>>j)&1)\n\t\t\t\tfor(int k=1;k<=17;k++) dp[i][k]=(dp[i][k]+dp[i^(1<<j)][k])%p;\n\tcin>>q;\n\twhile(q-->0)\n\t{\n\t\tcin>>(str+1);\n\t\tint len=strlen(str+1),sta=0;\n\t\tfor(int i=1;i<=len;i++) sta|=1<<str[i]-'a';\n\t\tcin<<dp[sta][len]<<endl;\n\t}\n}\n```\n\n",
			"tags": [{"name":"做题记录"},{"name":"数学"},{"name":"组合计数"},{"name":"DP"},{"name":"字符串"}],
			"title": "CF1679E Typical Party in Dorm 做题记录",
			"link": "https://exber.qzz.io/post/CF1679E%20Typical%20Party%20in%20Dorm%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-26 11:19:09"
		},
	
		{
			"abstract": "> 本题是多组数据。\n> \n> 对于每组数据，给出 $n$ 个数字，求有多少种排列方式，使得排列后的 $n$ 个数字首尾相接形成的数字能被 $11$ 整除。答案对 $998244353$ 取模\n> \n> $1\\le n\\le 2000$，$1\\le a_i\\le 10^9$。\n",
			"content": "> 本题是多组数据。\n> \n> 对于每组数据，给出 $n$ 个数字，求有多少种排列方式，使得排列后的 $n$ 个数字首尾相接形成的数字能被 $11$ 整除。答案对 $998244353$ 取模\n> \n> $1\\le n\\le 2000$，$1\\le a_i\\le 10^9$。\n\n发现一个数能被 $11$ 整除当且仅当它奇数位的和和偶数位的和相等，也就是奇数位的和减去偶数位的和等于 $0$。\n\n那么预处理出每一个数字的奇数位减偶数位的结果 $a_i$，与每一个数字的位数 $len_i$。不难发现，若 $len_i$ 为奇数，那么它插入序列之后它后面的差会取反，$len_i$ 为偶数则可以随便插入而对后面没有影响。所以不妨先让所有 $len_i$ 为奇数的 $a_i$ 确定好位置，再让 $len_i$ 为偶数 $a_i$ 的插入进去。\n\n所以设 $dp_{i,j,k}$ 为前 $i$ 个 $len_i$ 为奇数的 $a_i$，有 $j$ 个 $a_i$ 贡献为负，总和 $\\operatorname{mod} 11=k$ 的方案数（不考虑顺序）。那么有转移：\n$$\ndp_{i,j,k}=dp_{i-1,j,k-a_i}+dp_{i-1,j-1,k+a_i}\n$$\n也就是相当于挑出一些 $len_i$ 为奇数的 $a_i$，让它们贡献为负数，另外一些贡献为正数。由于并没有考虑顺序，所以最后 $len_i$ 为奇数的 $a_i$ 构成总和为 $k$ 的序列个数为 $\\lfloor\\frac{cnt_1}{2}\\rfloor!(cnt_1-\\lfloor\\frac{cnt_1}{2}\\rfloor)!dp_{cnt_1,\\lfloor\\frac{cnt_1}{2}\\rfloor,k}$，其中 $cnt_1$ 为 $len_i$ 为奇数的 $a_i$ 个数。\n\n考虑 $len_i$ 为偶数的 $a_i$ 插入的方案，仿照 $len_i$ 为奇数的 $a_i$ 的思路，设 $pd_{i,j,k}$ 表示前 $i$ 个 $len_i$ 为偶数的 $a_i$，有 $j$ 个 $a_i$ 贡献为负，总和 $\\operatorname{mod} 11=k$ 的方案数（不考虑顺序）。那么有转移：\n$$\npd_{i,j,k}=pd_{i-1,j,k-a_i}+pd_{i-1,j-1,k+a_i}\n$$\n那么枚举 $len_i$ 为偶数的 $a_i$ 和 $len_i$ 为奇数的 $a_i$ 对总和的贡献即可，答案为：（其中 $cnt_0$ 表示 $len_i$ 为偶数的 $a_i$ 个数，$cnt_1$ 表示 $len_i$ 为奇数的 $a_i$ 个数）\n$$\n\\sum\\limits_{i=0}^{10}\\lfloor\\frac{cnt_1}{2}\\rfloor!\\lceil\\frac{cnt_1}{2}\\rceil!dp_{cnt_1,\\lfloor\\frac{cnt_1}{2}\\rfloor,i}\\sum\\limits_{j=0}^{cnt_0}j!\\binom{j+\\lfloor\\frac{cnt_1+1}{2}\\rfloor-1}{\\lfloor\\frac{cnt_1+1}{2}\\rfloor-1}(cnt_0-j)!\\binom{cnt_0-j+\\lceil\\frac{cnt_1+1}{2}\\rceil-1}{\\lceil\\frac{cnt_1+1}{2}\\rceil-1}pd_{cnt_0,j,11-i}\n$$\n细节较多，代码如下：\n\n```cpp\nint fra[S*2],C[S*2][S*2];\nint n,a[S],b[S];\nint cnt0,cnt1,id0[S],id1[S];\nint dp[2][S][11],pd[2][S][11];\n\ninline int calc(int n,int m)\n{\n\tif(m==0) return n==0;\n\treturn 1ll*fra[n]*C[n+m-1][m-1]%p;\n}\n\ninline void slove()\n{\n\tcin>>n;\n\tcnt0=cnt1=0;\n\tfor(int i=1;i<=n;i++) a[i]=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tlong long x;\n\t\tcin>>x;\n\t\tlong long tmp=x;\n\t\tint tot=0;\n\t\tdo b[++tot]=tmp%10,tmp/=10;\n\t\twhile(tmp>0);\n\t\tif(tot&1) id1[++cnt1]=i;\n\t\telse id0[++cnt0]=i;\n\t\tbool odd=true;\n\t\twhile(tot>0) a[i]=(a[i]+(odd?1:-1)*b[tot--]+11)%11,odd=!odd;\n\t}\n\tfor(int i=0;i<=1;i++) for(int j=0;j<=n;j++) for(int k=0;k<11;k++) dp[i][j][k]=pd[i][j][k]=0;\n\tdp[0][0][0]=1;\n\tfor(int i=1;i<=cnt1;i++)\n\t{\n\t\tint u=i&1,v=i-1&1;\n\t\tfor(int j=0;j<=i;j++) for(int k=0;k<11;k++) dp[u][j][k]=(dp[v][j][(k-a[id1[i]]+11)%11]+(j>0?dp[v][j-1][(k+a[id1[i]])%11]:0))%p;\n\t}\n\tpd[0][0][0]=1;\n\tfor(int i=1;i<=cnt0;i++)\n\t{\n\t\tint u=i&1,v=i-1&1;\n\t\tfor(int j=0;j<=i;j++) for(int k=0;k<11;k++) pd[u][j][k]=(pd[v][j][(k-a[id0[i]]+11)%11]+(j>0?pd[v][j-1][(k+a[id0[i]])%11]:0))%p;\n\t}\n\tint ans=0;\n\tfor(int i=0;i<11;i++)\n\t{\n\t\tint ndel=cnt1/2+1,nadd=cnt1-cnt1/2;\n\t\tint mul=1ll*fra[cnt1/2]*fra[cnt1-cnt1/2]%p*dp[cnt1&1][cnt1/2][i]%p,sum=0;\n\t\tfor(int j=0;j<=cnt0;j++) sum=(sum+1ll*calc(j,ndel)*calc(cnt0-j,nadd)%p*pd[cnt0&1][j][(11-i)%11]%p)%p;\n\t\tans=(ans+1ll*mul*sum%p)%p;\n\t}\n\tcout<<ans<<endl;\n}\n\nint main()\n{\n\tfra[0]=1;\n\tfor(int i=1;i<=S*2-2;i++) fra[i]=1ll*fra[i-1]*i%p;\n\tC[0][0]=1;\n\tfor(int i=1;i<=S*2-2;i++)\n\t{\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<=i;j++) C[i][j]=(C[i-1][j]+C[i-1][j-1])%p;\n\t}\n\tint T=1;\n\tcin>>T;\n\twhile(T-->0)\n\t{\n\t\tslove();\n\t}\n\treturn 0;\n}\n```\n\n",
			"tags": [{"name":"做题记录"},{"name":"数学"},{"name":"组合计数"},{"name":"DP"}],
			"title": "CF856C Eleventh Birthday 做题记录",
			"link": "https://exber.qzz.io/post/CF856C%20Eleventh%20Birthday%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-26 11:16:04"
		},
	
		{
			"abstract": "> 棋盘大小为 $h \\times w$，有一个王在 $(1,1)$。每一步可以走到八连通的格子之一。构造一种方案，使得王经过所有格子，并停在 $(a,b)$。\n> \n> $1 \\le h,w \\le100$。\n",
			"content": "> 棋盘大小为 $h \\times w$，有一个王在 $(1,1)$。每一步可以走到八连通的格子之一。构造一种方案，使得王经过所有格子，并停在 $(a,b)$。\n> \n> $1 \\le h,w \\le100$。\n\n(1) 若 $H=2$，那么可以这样走：\n\n![](../post-images/1679800471227.png)\n\n(2) 若 $H>2$ 且 $W=2$，那么可以交换行列，变成情况 (1)。\n\n(3) 若 $H>2$ 且 $W>2$，那么可以这样走：\n\n![](../post-images/1679800481335.png)\n\n这样可以消掉第一列，递归处理 $H,W-1,H-A+1,B-1$。\n\n但是有一些特殊情况，若 $B=1$ 或者 $B=2$ 且 $A=H$ 即终点在浅绿色的格子里，那么就不能这样消去一行，需要转换行列之后消去第一列。\n\n部分代码：\n\n```cpp\ntypedef pair<int,int> P;\n\nint n,m,a,b;\n\nvector<P> dfs(int n,int m,int a,int b)\n{\n\tvector<P> res;\n\tif(m==2)\n\t{\n\t\tvector<P> tmp=dfs(m,n,b,a);\n\t\tfor(P u:tmp) res.push_back(P(u.second,u.first));\n\t\treturn res;\n\t}\n\tif(n==2)\n\t{\n\t\tfo(i,1,b-1) res.push_back(P(1,i)),res.push_back(P(2,i));\n\t\tfo(i,b,m) res.push_back(P(a==1?2:1,i));\n\t\tdf(i,m,b) res.push_back(P(a,i));\n\t\treturn res;\n\t}\n\tif(a==1||(b==m&&a==2))\n\t{\n\t\tvector<P> tmp=dfs(m,n,b,a);\n\t\tfor(P u:tmp) res.push_back(P(u.second,u.first));\n\t}\n\telse\n\t{\n\t\tfo(i,1,m) res.push_back(P(1,i));\n\t\tvector<P> tmp=dfs(n-1,m,a-1,m-b+1);\n\t\tfor(P u:tmp) res.push_back(P(u.first+1,m-u.second+1));\n\t}\n\treturn res;\n}\n\ninline void slove()\n{\n\trd(n),rd(m),rd(a),rd(b);\n\tvector<P> ans=dfs(n,m,a,b);\n\tfor(P u:ans) wrt(u.first),spe(),wrt(u.second),edl();\n}\n```\n\n",
			"tags": [{"name":"做题记录"},{"name":"构造"}],
			"title": "ABC232H King''s Tour 做题记录",
			"link": "https://exber.qzz.io/post/ABC232H%20King%27%27s%20Tour%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-26 11:12:54"
		},
	
		{
			"abstract": "> 给定平面上的 $n$ 个点的坐标 $(x_i,y_i)$ ， **其中没有两点有相同的坐标** 。定义点 $i,j$ 间的距离为 $d(i,j)=|x_i-x_j|+|y_i-y_j|$ 。\n> \n> 现用 $n$ 种颜色对这些点进行染色，求满足以下条件的方案数：\n> \n> - 每种相同颜色的点两两间距离相等\n> \n> - 每个点到具有不同颜色的点的距离总 **大于** 与其颜色相同的其他点（若存在）的距离。\n> \n> 答案取模 $998244353$ 。\n> \n> $2\\le n\\le 100,0\\le x_i,y_i\\le 10^8$\n",
			"content": "> 给定平面上的 $n$ 个点的坐标 $(x_i,y_i)$ ， **其中没有两点有相同的坐标** 。定义点 $i,j$ 间的距离为 $d(i,j)=|x_i-x_j|+|y_i-y_j|$ 。\n> \n> 现用 $n$ 种颜色对这些点进行染色，求满足以下条件的方案数：\n> \n> - 每种相同颜色的点两两间距离相等\n> \n> - 每个点到具有不同颜色的点的距离总 **大于** 与其颜色相同的其他点（若存在）的距离。\n> \n> 答案取模 $998244353$ 。\n> \n> $2\\le n\\le 100,0\\le x_i,y_i\\le 10^8$\n\n一个重要的结论：\n\n> 如果 $u$ 不是单独一个颜色，那么它一定与且仅与所有离它最近的点颜色相同。\n\n证明很显然，因为**每个点到具有不同颜色的点的距离需要大于与它颜色相同的点**，所以与它颜色相同的点一定是离它最近的。\n\n那么预处理出所有**颜色可以相同且至少有两个点**的点的集合，再设 $dp_{i,j}$ 表示前 $i$ 个集合，用了 $j$ 种颜色，转移考虑每个集合的点颜色相同或者不相同即可。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nconst int S=105;\nconst int p=998244353;\n\nstruct node\n{\n\tint x,y;\n}a[S];\n\nint n;\nint C[S][S],fra[S];\nint fdis[S];\nvector<int> fri[S];\nbool vis[S],tmp[S];\nint cnt[S];\nint tot,siz[S];\nint dp[S][S];\n\ninline int getdis(node x,node y)\n{\n\treturn abs(x.x-y.x)+abs(x.y-y.y);\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tC[0][0]=1;\n\tfra[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfra[i]=1ll*fra[i-1]*i%p;\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<=i;j++)\n\t\t{\n\t\t\tC[i][j]=(C[i-1][j]+C[i-1][j-1])%p;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d%d\",&a[i].x,&a[i].y);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint mn=1e9;\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tif(j==i)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmn=min(mn,getdis(a[i],a[j]));\n\t\t}\n\t\tfdis[i]=mn;\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tif(getdis(a[i],a[j])==mn)\n\t\t\t{\n\t\t\t\tfri[i].push_back(j);\n\t\t\t}\n\t\t}\n\t}\n\tint sm=n;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(!vis[i])\n\t\t{\n\t\t\tbool fl=false;\n\t\t\tfor(int u:fri[i])\n\t\t\t{\n\t\t\t\tif(vis[u])\n\t\t\t\t{\n\t\t\t\t\tfl=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(fl)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint pre=fri[i].size();\n\t\t\ttmp[i]=true;\n\t\t\tcnt[i]=0;\n\t\t\tfor(int u:fri[i])\n\t\t\t{\n\t\t\t\ttmp[u]=true;\n\t\t\t\tcnt[u]=1;\n\t\t\t}\n\t\t\tbool f=true;\n\t\t\tfor(int u:fri[i])\n\t\t\t{\n\t\t\t\tif(fdis[u]!=fdis[i])\n\t\t\t\t{\n\t\t\t\t\tf=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor(int v:fri[u])\n\t\t\t\t{\n\t\t\t\t\tif(!tmp[v])\n\t\t\t\t\t{\n\t\t\t\t\t\tf=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcnt[v]++;\n\t\t\t\t}\n\t\t\t\tif(!f)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tf&=cnt[i]==pre;\n\t\t\tfor(int u:fri[i])\n\t\t\t{\n\t\t\t\tf&=cnt[u]==pre;\n\t\t\t}\n\t\t\ttmp[i]=false;\n\t\t\tvis[i]=f;\n\t\t\tfor(int u:fri[i])\n\t\t\t{\n\t\t\t\ttmp[u]=false;\n\t\t\t\tvis[u]=f;\n\t\t\t}\n\t\t\tif(f)\n\t\t\t{\n\t\t\t\tsiz[++tot]=pre+1;\n\t\t\t\tsm-=pre+1;\n\t\t\t}\n\t\t}\n\t}\n\tdp[0][0]=1;\n\tfor(int i=1;i<=tot;i++)\n\t{\n\t\tfor(int j=1;j<=n-sm;j++)\n\t\t{\n\t\t\tdp[i][j]=(1ll*dp[i-1][j-1]*j%p+(j>=siz[i]?1ll*dp[i-1][j-siz[i]]*C[j][siz[i]]%p*fra[siz[i]]%p:0))%p;\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=0;i<=n-sm;i++)\n\t{\n\t\tans=(ans+1ll*C[n][i+sm]*C[i+sm][i]%p*dp[tot][i]%p*fra[sm]%p)%p;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n\n",
			"tags": [{"name":"做题记录"},{"name":"结论"}],
			"title": "CF1697E Coloring 做题记录",
			"link": "https://exber.qzz.io/post/CF1697E%20Coloring%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-26 11:09:54"
		},
	
		{
			"abstract": "> 给你一个字符串 $S$，由 `Y` 和 `.` 构成。\n> \n> 现在你可以最多进行 $k$ 次操作，每次可以交换两个相邻的字符。\n> \n> 请你求出最多 $k$ 次操作后，最长连续字符 `Y` 的长度。\n> \n> - $2 \\leq |S| \\leq 2 \\times 10^5$\n> - $0 \\leq K \\leq 10^{12}$\n",
			"content": "> 给你一个字符串 $S$，由 `Y` 和 `.` 构成。\n> \n> 现在你可以最多进行 $k$ 次操作，每次可以交换两个相邻的字符。\n> \n> 请你求出最多 $k$ 次操作后，最长连续字符 `Y` 的长度。\n> \n> - $2 \\leq |S| \\leq 2 \\times 10^5$\n> - $0 \\leq K \\leq 10^{12}$\n\n设 $A$ 为 $S$ 中 `Y` 的位置从小到大构成的序列，令 $B_i=A_i-i$，那么问题就转化为：\n\n> 每次操作可以选择一个 $i$，让 $B_i\\to B_i+1$ 或者 $B_i\\to B_i-1$，最多进行 $k$ 次操作，求操作之后最长的 $B_i$ 相同的连续段。\n\n考虑尺取，假设当前区间为 $[l,r]$，那么最少需要的操作次数显然就相当于这个函数的最小值：\n$$\nf(x)=\\sum\\limits_{i=l}^r|B_i-x|\n$$\n不难发现这是个小学奥数题，显然 $x=B_{i+\\lfloor\\frac{r-l+1}{2}\\rfloor}$ 即最中间时 $f(x)$ 是最小的，那么只要判断 $f(B_{i+\\lfloor\\frac{r-l+1}{2}\\rfloor})$ 小于等于 $k$ 即可。\n\n",
			"tags": [{"name":"做题记录"},{"name":"杂题"}],
			"title": "ABC229G Longest Y 做题记录",
			"link": "https://exber.qzz.io/post/ABC229G%20Longest%20Y%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-26 11:07:19"
		},
	
		{
			"abstract": "> 给定一个 $n$ 个点 $m$ 条边的无向图，第  $i$ 个点的点权初始值为  $p_i$,所有 $p_i$ 互不相同。\n> \n> 接下来进行 $q$ 次操作，分为两类：\n> \n> - $\\tt 1\\ v$ 查询与  $v$ 连通的点中， $p_u$ 最大的点  $u$ 并输出  $p_u$，然后让  $p_u=0$。\n> - $\\tt 2\\ i$ 将第 $i$ 条边删掉。\n> \n> $1 \\le n \\le 2 \\cdot 10^5$，$1 \\le m \\le 3 \\cdot 10^5$，$1 \\le q \\le 5 \\cdot 10^5$。\n",
			"content": "> 给定一个 $n$ 个点 $m$ 条边的无向图，第  $i$ 个点的点权初始值为  $p_i$,所有 $p_i$ 互不相同。\n> \n> 接下来进行 $q$ 次操作，分为两类：\n> \n> - $\\tt 1\\ v$ 查询与  $v$ 连通的点中， $p_u$ 最大的点  $u$ 并输出  $p_u$，然后让  $p_u=0$。\n> - $\\tt 2\\ i$ 将第 $i$ 条边删掉。\n> \n> $1 \\le n \\le 2 \\cdot 10^5$，$1 \\le m \\le 3 \\cdot 10^5$，$1 \\le q \\le 5 \\cdot 10^5$。\n\n这是一道比较有趣的“启发式分裂”题。\n\n首先容易发现，**每次删边之后大小较小的那部分的大小至少减半**，那么参照启发式合并的思路，考虑每次断边之后在大小较小的部分上跑一次 dfs，求出上次断边到这次断边之间的询问的答案。\n\n具体的：\n\n1. 首先对图上的每个连通块都跑一遍 dfs，求出它们内部节点按照权值从大到小排序之后的序列。并且把所有删边操作倒过来，变成加边操作，用并查集找到所有改变图的连通性的删边操作；\n\n2. 对于每一次询问操作，直接取对应连通块内权值最大的节点 $u$（权值序列中第一个节点），把它的权值变为 $0$ 之后放到权值序列的末尾即可；\n\n3. 对于每一次删边操作，若这次操作不改变图的连通性，直接删掉它即可；否则删掉它之后在大小较小的那一部分上跑一次 dfs，求出它内部节点排序后的序列，根据这个序列和连通块分裂之前的序列就可以求出另一部分的序列。\n\n用 set 维护连通块权值序列的时间复杂度是 $O(\\log V)$ 的，其中 $V$ 是值域，又因为“启发式分裂”的时间复杂度是 $(n+m)\\log n$ 的，所以时间复杂度 $O((n+m)\\log^2 n+q)$，卡一卡可以过。\n\n代码如下：（卡常用的火车头省略了）\n\n```cpp\n#include <cstdio>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nchar buf[1<<23],*p1=buf,*p2=buf,obuf[1<<23],*O=obuf;\n#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\ninline int rd()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9') x=x*10+(ch^48),ch=getchar();\n\treturn x*f;\n}\nvoid print(int x)\n{\n    if(x>9) print(x/10);\n    *O++=x%10|48;\n}\n\nconst int MS=200005,S=300005,QS=500005;\n\nstruct edge\n{\n\tint x,y;\n\tbool del; // 是否被删除\n}ed[S];\n\nstruct opt\n{\n\tint tpe,id; // 操作类型，删边的编号/节点编号\n\tbool imp;\n\tint mnx; // 删边之后属于大小较小的连通块的点\n}que[QS];\n\nint n,m,q,qdel;\nint a[MS];\nvector<int> g[MS];\nint fa[MS],siz[MS];\nset<pair<int,int> > st[MS];\nint cnt,uid[MS];\n\ninline int fnd(int x)\n{\n\treturn fa[x]==x?x:fa[x]=fnd(fa[x]);\n}\n\nvoid dfs(int u,int stid)\n{\n\tst[stid].erase(make_pair(-a[u],u));\n\tst[uid[u]].insert(make_pair(-a[u],u));\n\tfor(int i:g[u])\n\t{\n\t\tif(ed[i].del) continue;\n\t\tint v=ed[i].x==u?ed[i].y:ed[i].x;\n\t\tif(uid[v]==uid[u]) continue;\n\t\tuid[v]=uid[u];\n\t\tdfs(v,stid);\n\t}\n}\n\nint main()\n{\n\tn=rd();\n\tm=rd();\n\tq=rd();\n\tfor(register int i=1;i<=n;++i) a[i]=rd();\n\tfor(register int i=1;i<=m;++i)\n\t{\n\t\ted[i].x=rd();\n\t\ted[i].y=rd();\n\t\tg[ed[i].x].push_back(i),g[ed[i].y].push_back(i);\n\t}\n\tfor(register int i=1;i<=q;++i)\n\t{\n\t\tque[i].tpe=rd();\n\t\tque[i].id=rd();\n\t\tif(que[i].tpe==2) ed[que[i].id].del=true;\n\t}\n\tfor(register int i=1;i<=n;++i) siz[i]=(fa[i]=i)==i;\n\tfor(register int i=1;i<=m;++i)\n\t{\n\t\tif(!ed[i].del)\n\t\t{\n\t\t\tint rx=fnd(ed[i].x),ry=fnd(ed[i].y);\n\t\t\tif(rx!=ry) fa[rx]=ry,siz[ry]+=siz[rx];\n\t\t}\n\t}\n\tfor(register int i=q;i>=1;--i)\n\t{\n\t\tif(que[i].tpe==2)\n\t\t{\n\t\t\tint rx=fnd(ed[que[i].id].x),ry=fnd(ed[que[i].id].y);\n\t\t\tif(rx!=ry)\n\t\t\t{\n\t\t\t\tque[i].imp=true;\n\t\t\t\tif(siz[rx]<siz[ry]) que[i].mnx=ed[que[i].id].x;\n\t\t\t\telse que[i].mnx=ed[que[i].id].y;\n\t\t\t\tfa[rx]=ry,siz[ry]+=siz[rx];\n\t\t\t\ted[que[i].id].del=false;\n\t\t\t}\n\t\t}\n\t}\n\tfor(register int i=1;i<=n;++i) if(fa[i]==i) uid[i]=++cnt;\n\tfor(register int i=1;i<=n;++i) st[uid[i]=uid[fnd(i)]].insert(make_pair(-a[i],i));\n\tfor(register int i=1;i<=q;++i)\n\t{\n\t\tif(que[i].tpe==1)\n\t\t{\n\t\t\tint id=uid[que[i].id];\n\t\t\tpair<int,int> fir=*st[id].begin();\n\t\t\tprint(-fir.first);\n\t\t\t*O++='\\n';\n\t\t\tst[id].erase(fir);\n\t\t\ta[fir.second]=0;\n\t\t\tst[id].insert(make_pair(0,fir.second));\n\t\t}\n\t\telse\n\t\t{\n\t\t\ted[que[i].id].del=true;\n\t\t\tif(que[i].imp)\n\t\t\t{\n\t\t\t\tuid[que[i].mnx]=++cnt;\n\t\t\t\tint oth=uid[ed[que[i].id].x==que[i].mnx?ed[que[i].id].y:ed[que[i].id].x];\n\t\t\t\tdfs(que[i].mnx,oth);\n\t\t\t}\n\t\t}\n\t\tif(O-obuf>(1<<22)) fwrite(obuf,O-obuf,1,stdout),O=obuf;\n\t}\n\tfwrite(obuf,O-obuf,1,stdout);\n\treturn 0;\n}\n```\n\n",
			"tags": [{"name":"做题记录"},{"name":"数据结构"}],
			"title": "CF1416D Graph and Queries 做题记录",
			"link": "https://exber.qzz.io/post/CF1416D%20Graph%20and%20Queries%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-26 11:05:37"
		},
	
		{
			"abstract": "> 求满足以下条件的排列个数：\n> \n> - 长度为 $n$。\n> - 恰有 $k$ 个数满足：所有包含这个数的区间中，不同的最大值的个数恰有 $m$ 个。\n> \n> 答案对 $p$ 取模。\n> \n> $1 \\le n \\le 100, 1 \\le m \\le n, 1 \\le k \\le n, 1 \\le p \\le 10^9$。\n",
			"content": "> 求满足以下条件的排列个数：\n> \n> - 长度为 $n$。\n> - 恰有 $k$ 个数满足：所有包含这个数的区间中，不同的最大值的个数恰有 $m$ 个。\n> \n> 答案对 $p$ 取模。\n> \n> $1 \\le n \\le 100, 1 \\le m \\le n, 1 \\le k \\le n, 1 \\le p \\le 10^9$。\n\n首先定义 $i-\\text{好数}$ 为所有包含这个数的区间中，不同的最大值恰好有 $i$ 个的数，问题就变成了求 $m-\\text{好数}$ 恰好有 $k$ 个的 $n$ 的排列的个数。\n\n设 $dp_{i,j,k}$ 为满足恰好有 $k$ 个 $j-\\text{好数}$ 的 $i$ 的排列个数，那么可以通过枚举最大值的位置 $p$ 和 $p$ 左侧序列的 $(j-1)-\\text{好数}$ 个数来转移：\n$$\ndp_{i,j,k}=\\sum\\limits_{p=2}^{i-1}\\dbinom{i-1}{p-1}\\sum\\limits_{lft=0}^{k-[j=1]}dp_{p-1,j-1,lft}\\times dp_{i-p,j-1,k-[j=1]-lft}\n$$\n注意边界 $dp_{1,1,1}=1$ 且 $p=1$ 和 $p=i$ 的情况要单独转移，并且 $j>i$ 或者 $j<1$ 的 $dp_{i,j,0}=i!$。\n\n转移的时候要注意卡常，有 $0$ 就不做乘法。\n",
			"tags": [{"name":"做题记录"},{"name":"数学"},{"name":"组合计数"},{"name":"DP"}],
			"title": "CF1580B Mathematics Curriculum 做题记录",
			"link": "https://exber.qzz.io/post/CF1580B%20Mathematics%20Curriculum%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-26 11:00:07"
		},
	
		{
			"abstract": "> [P5298 [PKUWC2018]Minimax](https://www.luogu.com.cn/problem/P5298)\n",
			"content": "> [P5298 [PKUWC2018]Minimax](https://www.luogu.com.cn/problem/P5298)\n\n首先有暴力转移：\n$$\nD_{u,i}=D_{s1,i}\\left(\\left(P_u\\sum\\limits_{j<i}D_{s2,j}\\right)+\\left((1-P_u)\\sum\\limits_{j>i}D_{s2,j}\\right)\\right)+D_{s2,i}\\left(\\left(P_u\\sum\\limits_{j<i}D_{s1,j}\\right)+\\left((1-P_u)\\sum\\limits_{j>i}D_{s1,j}\\right)\\right)\n$$\n然后可以用线段树合并来转移。节点 $u$ 的线段树的节点维护区间内 $D_{u,i}$ 的和，合并的时候维护当前区间左边的和与当前区间右边的和，打上 lazytag 即可。\n\n```cpp\n// Problem: P5298 [PKUWC2018]Minimax\n// Contest: Luogu\n// URL: https://www.luogu.com.cn/problem/P5298\n// Memory Limit: 500 MB\n// Time Limit: 1000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nconst int MS=300005,S=5000005;\nconst int p=998244353,inv=796898467;\n\nstruct node\n{\n\tint sm,mu;\n\tint ls,rs;\n}tr[S];\n\nint n,a[MS];\nint m,b[MS];\nint ls[MS],rs[MS];\nint cnt,rt[MS];\n\ninline void adtg(int u,int val)\n{\n\ttr[u].sm=1ll*tr[u].sm*val%p,tr[u].mu=1ll*tr[u].mu*val%p;\n}\n\ninline void dntg(int u)\n{\n\tadtg(tr[u].ls,tr[u].mu),adtg(tr[u].rs,tr[u].mu),tr[u].mu=1;\n}\n\ninline void upda(int u)\n{\n\ttr[u].sm=(tr[tr[u].ls].sm+tr[tr[u].rs].sm)%p;\n}\n\nvoid upd(int &u,int l,int r,int pos,int val)\n{\n\tif(u==0) tr[u=++cnt]=(node){0,1,0,0};\n\tif(l==r)\n\t{\n\t\ttr[u].sm=val;\n\t\treturn;\n\t}\n\tdntg(u);\n\tint mid=l+r>>1;\n\tif(pos<=mid) upd(tr[u].ls,l,mid,pos,val);\n\telse upd(tr[u].rs,mid+1,r,pos,val);\n\tupda(u);\n}\n\nint que(int u,int l,int r,int pos)\n{\n\tif(l==r) return tr[u].sm;\n\tdntg(u);\n\tint mid=l+r>>1;\n\tif(pos<=mid) return que(tr[u].ls,l,mid,pos);\n\telse return que(tr[u].rs,mid+1,r,pos);\n}\n\nint meg(int x,int y,int lftx,int rigx,int lfty,int rigy,int u)\n{\n\tif(x==0&&y==0) return 0;\n\tif(y==0)\n\t{\n\t\tint val=(1ll*a[u]*lftx%p+1ll*(1-a[u]+p)*rigx%p)%p;\n\t\treturn adtg(x,val),x;\n\t}\n\tif(x==0)\n\t{\n\t\tint val=(1ll*a[u]*lfty%p+1ll*(1-a[u]+p)*rigy%p)%p;\n\t\treturn adtg(y,val),y;\n\t}\n\tdntg(x),dntg(y);\n\tint xlsm=tr[tr[x].ls].sm,xrsm=tr[tr[x].rs].sm;\n\tint ylsm=tr[tr[y].ls].sm,yrsm=tr[tr[y].rs].sm;\n\ttr[x].ls=meg(tr[x].ls,tr[y].ls,lftx,(rigx+yrsm)%p,lfty,(rigy+xrsm)%p,u);\n\ttr[x].rs=meg(tr[x].rs,tr[y].rs,(lftx+ylsm)%p,rigx,(lfty+xlsm)%p,rigy,u);\n\tupda(x);\n\treturn x;\n}\n\nvoid dfs(int u)\n{\n\tif(ls[u]!=0) dfs(ls[u]);\n\tif(rs[u]!=0) dfs(rs[u]);\n\tif(ls[u]==0&&rs[u]==0) upd(rt[u],1,m,a[u],1);\n\telse if(ls[u]==0||rs[u]==0) rt[u]=rt[ls[u]]+rt[rs[u]];\n\telse rt[u]=meg(rt[ls[u]],rt[rs[u]],0,0,0,0,u);\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint fa;\n\t\tscanf(\"%d\",&fa);\n\t\tif(fa!=0)\n\t\t{\n\t\t\tif(ls[fa]==0) ls[fa]=i;\n\t\t\telse rs[fa]=i;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tif(ls[i]!=0||rs[i]!=0) a[i]=1ll*a[i]*inv%p;\n\t\telse b[++m]=a[i];\n\t}\n\tsort(b+1,b+m+1);\n\tfor(int i=1;i<=n;i++) if(ls[i]==0&&rs[i]==0) a[i]=lower_bound(b+1,b+m+1,a[i])-b;\n\tdfs(1);\n\tint ans=0;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint Di=que(rt[1],1,m,i);\n\t\tans=(ans+1ll*i*b[i]%p*Di%p*Di%p)%p;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n\n",
			"tags": [{"name":"做题记录"},{"name":"DP"},{"name":"数据结构"}],
			"title": "P5298 [PKUWC2018]Minimax 做题记录",
			"link": "https://exber.qzz.io/post/P5298%20%5BPKUWC2018%5DMinimax%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-26 10:57:35"
		},
	
		{
			"abstract": "> 给定长度为 $N$ 的序列 $A$，我们定义一种将 $A$ 划分为若干段的方案的价值为每一段的最大值减去最小值的差的乘积，你需要求出所有划分方案的价值的总和，答案对 $998244353$ 取模。\n> \n> - $1 \\leq N \\leq 3 \\times 10^5$\n> - $1 \\leq A_i \\leq 10^9$\n",
			"content": "> 给定长度为 $N$ 的序列 $A$，我们定义一种将 $A$ 划分为若干段的方案的价值为每一段的最大值减去最小值的差的乘积，你需要求出所有划分方案的价值的总和，答案对 $998244353$ 取模。\n> \n> - $1 \\leq N \\leq 3 \\times 10^5$\n> - $1 \\leq A_i \\leq 10^9$\n\n首先显然可以设 $dp_i$ 表示前 $i$ 个数的和，通过枚举最后一段来转移，但是这样做是 $O(n^2)$ 的。\n\n考虑把最后一段的 $\\max$ 和 $\\min$ 单独考虑，求出 $\\max$ 的贡献和 $\\min$ 的贡献，再作差。可以用单调栈维护 $\\max$ 和 $\\min$ 改变的位置，然后用前缀和来转移。\n\n部分代码：\n\n```cpp\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tsm[0]=1;\n\tint sm0=0,sm1=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\twhile(mxq[0]>0&&a[mxq[mxq[0]]]<=a[i]) sm1=(sm1-1ll*a[mxq[mxq[0]]]%p*(sm[mxq[mxq[0]]-1]-(mxq[0]>1?sm[mxq[mxq[0]-1]-1]:0)+p)%p+p)%p,mxq[0]--;\n\t\twhile(mnq[0]>0&&a[mnq[mnq[0]]]>=a[i]) sm0=(sm0-1ll*a[mnq[mnq[0]]]%p*(sm[mnq[mnq[0]]-1]-(mnq[0]>1?sm[mnq[mnq[0]-1]-1]:0)+p)%p+p)%p,mnq[0]--;\n\t\tsm1=(sm1+1ll*a[i]%p*(sm[i-1]-(mxq[0]>0?sm[mxq[mxq[0]]-1]:0)+p)%p)%p;\n\t\tsm0=(sm0+1ll*a[i]%p*(sm[i-1]-(mnq[0]>0?sm[mnq[mnq[0]]-1]:0)+p)%p)%p;\n\t\tmxq[++mxq[0]]=i;\n\t\tmnq[++mnq[0]]=i;\n\t\tint dpi=(sm1-sm0+p)%p;\n\t\tsm[i]=(sm[i-1]+dpi)%p;\n\t\tif(i==n) printf(\"%d\\n\",dpi%p);\n\t}\n\treturn 0;\n}\n```\n\n",
			"tags": [{"name":"做题记录"},{"name":"数学"},{"name":"组合计数"},{"name":"DP"}],
			"title": "ABC234G Divide a Sequence 做题记录",
			"link": "https://exber.qzz.io/post/ABC234G%20Divide%20a%20Sequence%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-26 10:55:04"
		},
	
		{
			"abstract": "> 有 $T$ 组数据，每组数据有一个长度为 $n$ 的 $\\tt 01$ 字符串，求构造一个 $n$ 个结点的树满足每个结点的度数的奇偶性符合 $\\tt 01$ 串 $s$，且将这些点依次排列到一个环上，任意两条边不在非端点处相交。\n> \n> $1\\le n\\le 2\\times 10^5$。\n",
			"content": "> 有 $T$ 组数据，每组数据有一个长度为 $n$ 的 $\\tt 01$ 字符串，求构造一个 $n$ 个结点的树满足每个结点的度数的奇偶性符合 $\\tt 01$ 串 $s$，且将这些点依次排列到一个环上，任意两条边不在非端点处相交。\n> \n> $1\\le n\\le 2\\times 10^5$。\n\n\nVP 的时候想到了一大堆奇奇怪怪的做法，有些是对的，但是都否定了。\n\n首先发现因为每条边都会贡献两个度数，又有 $n-1$ 条边，所以若度数总和是奇数那么就不行。\n\n由于需要构成一棵树，而树的叶子节点一定只有一个度，所以若度数全都是偶数也不行。\n\n对于其它情况，考虑构造解：\n\n1. 若度数都是奇数，那么此时 $n$ 必定为偶数，把 $1$ 当作根，其它点向 $1$ 连边组成菊花图即可；\n\n2. 否则考虑构造一些链，把整个序列看作一个环，把环断成 $k$ 段 $[0,0,0,\\dots,1]$ 这样的序列，每一段序列都依次串起来，这样我们就获得了一些”趴在边上“的链。考虑如何把这些链连起来，显然由于度数是偶数，$k$ 一定是也偶数，所以拿一条链的开头当作根把这些链接上即可。\n",
			"tags": [{"name":"做题记录"},{"name":"构造"}],
			"title": "CF1682D Circular Spanning Tree 做题记录",
			"link": "https://exber.qzz.io/post/CF1682D%20Circular%20Spanning%20Tree%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-26 10:51:49"
		},
	
		{
			"abstract": "> 给定 $N$、$S$ 和长度为 $N$ 的序列 $A$，找到满足以下条件的序列 $X$ 的个数对 $998244353$ 取模后的结果：\n>\n> - $X$ 的每个元素都是正奇数\n> - $\\sum X_i=S$\n> - 设 $Y_i=\\sum\\limits_{j=1}^iX_j$，那么对于所有 $1\\le i\\le |X|,1\\le j\\le N$ 的 $i,j$，都满足 $Y_i\\not=A_j$\n>\n> $1\\le N\\le 10^5$\n>\n> $1\\le A_1<A_2<\\dots<A_N<S\\le10^{18}$\n",
			"content": "> 给定 $N$、$S$ 和长度为 $N$ 的序列 $A$，找到满足以下条件的序列 $X$ 的个数对 $998244353$ 取模后的结果：\n>\n> - $X$ 的每个元素都是正奇数\n> - $\\sum X_i=S$\n> - 设 $Y_i=\\sum\\limits_{j=1}^iX_j$，那么对于所有 $1\\le i\\le |X|,1\\le j\\le N$ 的 $i,j$，都满足 $Y_i\\not=A_j$\n>\n> $1\\le N\\le 10^5$\n>\n> $1\\le A_1<A_2<\\dots<A_N<S\\le10^{18}$\n\n\n发现 $Y_i$ 的奇偶性和 $i$ 的奇偶性相同，设 $dp_{i}$ 表示总和为 $i$ 的 $X$ 的个数，那么有转移：\n$$\ndp_{i}=\\begin{cases}\\sum\\limits_{0\\le j\\le i-1,j\\not\\equiv i\\pmod 2}dp_j&\\nexists A_j=i\\\\0&\\exists A_j=i\\end{cases}\n$$\n这样做时间复杂度是 $O(S)$ 的，完美爆炸。考虑换一下 $dp$ 的定义，设 $dp_{0/1,i}$ 为总和是奇数/偶数，并且小于等于 $i$ 的方案数，那么有转移：\n$$\n\\begin{cases}\ndp_{0,i}=dp_{0,i-1}+[i\\operatorname{mod}2=0\\land\\nexists A_j=i]dp_{1,i-1}\\\\\ndp_{1,i}=dp_{1,i-1}+[i\\operatorname{mod}2=1\\land\\nexists A_j=i]dp_{0,i-1}\\\\\n\\end{cases}\n$$\n观察到对于所有满足 $A_j< i< A_{j+1}$ 的 $i$，$dp_{0/1,i}$ 的转移是完全不受到 $[\\nexists A_j=i]$ 的影响的，这时有：\n$$\n\\begin{cases}\n\\begin{bmatrix}dp_{0,i-1},dp_{1,i-1}\\end{bmatrix}\\times \\begin{bmatrix}1,1\\\\0,1\\end{bmatrix}=\\begin{bmatrix}dp_{0,i},dp_{1,i}\\end{bmatrix}&i\\operatorname{mod}2=1\\\\\n\\begin{bmatrix}dp_{0,i-1},dp_{1,i-1}\\end{bmatrix}\\times \\begin{bmatrix}1,0\\\\1,1\\end{bmatrix}=\\begin{bmatrix}dp_{0,i},dp_{1,i}\\end{bmatrix}&i\\operatorname{mod}2=0\n\\end{cases}\n$$\n考虑把两次转移合并，有：\n$$\n\\begin{cases}\n\\begin{bmatrix}dp_{0,i-2},dp_{1,i-2}\\end{bmatrix}\\times \\begin{bmatrix}1,1\\\\1,2\\end{bmatrix}=\\begin{bmatrix}dp_{0,i},dp_{1,i}\\end{bmatrix}&(i-2)\\operatorname{mod}2=1\\\\\n\\begin{bmatrix}dp_{0,i-2},dp_{1,i-2}\\end{bmatrix}\\times \\begin{bmatrix}2,1\\\\1,1\\end{bmatrix}=\\begin{bmatrix}dp_{0,i},dp_{1,i}\\end{bmatrix}&(i-2)\\operatorname{mod}2=0\\\\\n\\end{cases}\n$$\n那么可以枚举 $j$，手动做一次转移，用矩阵乘法做 $A_{j+1}-A_j-1$ 次转移，再手动做一次转移即可。\n\n时间复杂度 $O(N\\log S)$。\n\n",
			"tags": [{"name":"做题记录"},{"name":"数学"},{"name":"组合计数"},{"name":"DP"}],
			"title": "ABC258Ex Odd Steps 做题记录",
			"link": "https://exber.qzz.io/post/ABC258Ex%20Odd%20Steps%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-26 10:49:44"
		},
	
		{
			"abstract": "> 给定仅存在小写英文字母的字符串 $S, T$。你需要将 $T$ 分割成 $k$ 个 $S$ 的前缀（或着说用 $ S $ 的若干个前缀组成 $T$），最小化 $k$，输出最小值。若 $k$ 不存在输出 `-1`。\n> \n> $1 \\leq |S|,|T| \\leq 5\\times 10^5$\n",
			"content": "> 给定仅存在小写英文字母的字符串 $S, T$。你需要将 $T$ 分割成 $k$ 个 $S$ 的前缀（或着说用 $ S $ 的若干个前缀组成 $T$），最小化 $k$，输出最小值。若 $k$ 不存在输出 `-1`。\n> \n> $1 \\leq |S|,|T| \\leq 5\\times 10^5$\n\n首先有个结论，每次从 $T$ 末尾删除最长的 $S$ 的前缀是最优的，因为假设 $T$ 是由这些蓝色的 $S$ 的前缀构成的：\n\n![](../post-images/1679798902337.png)\n\n若红色这一段是 $S$ 的前缀，那它完全可以代替最后那三段 $S$ 的前缀和第一段 $S$ 的前缀的后面一段，因为**前缀减去末尾的一段依然是前缀**：\n\n![](../post-images/1679798913216.png)\n\n而若想让组成 $T$ 的前缀数尽可能少，每个前缀就要尽可能长，所以每次贪心地从 $T$ 末尾删掉最长的一段 $S$ 的前缀是最优的。\n\n考虑快速求出 $T$ 中以 $T_i$ 结尾的最长的 $S$ 的前缀，当然可以用后缀数组/后缀自动机来做，但是观察到这个定义和 kmp 数组的定义很像：\n\n> $kmp_i$ 为 $s_{[1,i]}$ 的最长的是后缀的前缀长度。\n\n那么可以令 $R$ 为 $S+T$ 即 $S$ 拼上 $T$ 的字符串，求出 $R$ 的 $kmp_i$，然后贪心即可。\n",
			"tags": [{"name":"做题记录"},{"name":"字符串"},{"name":"贪心"}],
			"title": "ABC257G Prefix Concatenation 做题记录",
			"link": "https://exber.qzz.io/post/ABC257G%20Prefix%20Concatenation%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-26 10:47:51"
		},
	
		{
			"abstract": "> 有三种不同颜色的球，分别有 $A,B,C$ 个。（相同颜色的球之间不区分）\n> \n> 将球放入 $N$ 个不同的盒子中，要求：\n> \n> - 每个盒子至少放了一个球\n> \n> - 每个盒子不能存在两个相同颜色的球\n> \n> - 可以不放完所有的球\n> \n> 求放置方案数对 $998244353$ 取模的结果。\n> \n> $1 \\leq N \\leq 5 \\times 10^6$，$0 \\leq A,B,C \\leq N$\n",
			"content": "> 有三种不同颜色的球，分别有 $A,B,C$ 个。（相同颜色的球之间不区分）\n> \n> 将球放入 $N$ 个不同的盒子中，要求：\n> \n> - 每个盒子至少放了一个球\n> \n> - 每个盒子不能存在两个相同颜色的球\n> \n> - 可以不放完所有的球\n> \n> 求放置方案数对 $998244353$ 取模的结果。\n> \n> $1 \\leq N \\leq 5 \\times 10^6$，$0 \\leq A,B,C \\leq N$\n\n\n考虑枚举有多少个花圃种了花，然后容斥，有：\n$$\nans=\\sum\\limits_{i=1}^{n}(-1)^{n-i}\\dbinom{n}{i}\\sum\\limits_{j=0}^{A,i}\\dbinom{i}{j}\\sum\\limits_{j=0}^{B,i}\\dbinom{i}{j}\\sum\\limits_{j=0}^{C,i}\\dbinom{i}{j}\n$$\n\n发现后面那三个求和形式都是 $\\sum\\limits_{j=0}^{m,n}\\dbinom{n}{j}$，那么不妨设 $dp_{n,m}=\\sum\\limits_{j=0}^{m,n}\\dbinom{n}{j}$，显然若 $n\\le m$ 那么 $dp_{n,m}=2^n$，否则考虑这样一个网格图：\n\n![](../post-images/1679796429250.png)\n\n显然 $dp_{n,m}$ 就相当于从 $(0,0)$ **向上向右**走到 $(n,0),(n-1,1),(n-2,2),\\dots,(n-m,m)$ 的方案数。那么考虑从 $dp_{n-1,m}$ 递推到 $dp_{n,m}$，也就是从所有橙色的点**向上向右**走到蓝色的点的方案数。\n\n观察到除了最后一个点，其它点向上或者向右都能走到蓝色的点，最后一个点却只能向上走走到蓝色的点。那么不妨让所有点都能向上向右走，求出方案数，再减去**走到最后一个点再向右走**的方案数。显然第一部分的方案数是 $2dp_{n-1,m}$，而减掉的方案数是 $\\dbinom{n-1}{m}$。\n\n",
			"tags": [{"name":"做题记录"},{"name":"数学"},{"name":"组合计数"}],
			"title": "ABC235G Gardens 做题记录",
			"link": "https://exber.qzz.io/post/ABC235G%20Gardens%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-26 10:06:55"
		},
	
		{
			"abstract": ">  有一个 $n$ 个节点的有向图 $G$，对于所有的 $1 \\le i, j \\le n$ 且 $i \\not= j$，都有一条权值为 $(a_i + b_j) \\bmod m$ 的边连接 $i$ 和 $j$，请你求出 $G$ 从 $1$ 到 $n$ 的最短路。\n",
			"content": ">  有一个 $n$ 个节点的有向图 $G$，对于所有的 $1 \\le i, j \\le n$ 且 $i \\not= j$，都有一条权值为 $(a_i + b_j) \\bmod m$ 的边连接 $i$ 和 $j$，请你求出 $G$ 从 $1$ 到 $n$ 的最短路。\n\n\n发现取模不好处理，那么考虑构造一个”取模装置“：建立 $m$ 个点 $0',1',2',3',\\dots,(m-1)'$，$i'\\to (i+1)'$ 连一条权值为 $1$ 的边，特别的，$(m-1)'\\to0'$ 连一条权值为 $1$ 的边。\n\n![](../post-images/1679795232666.png)\n\n然后建出原来的 $n$ 个节点，但是这个”取模装置“只能处理减法的取模，考虑用一个式子把加法转换成减法：\n$$\n(x+y)\\operatorname{mod}m=y-(m-x)\\operatorname{mod} m\n$$\n所以可以 $i\\to(m-a_i)'$ 连一条长度为 $0$ 的边，$b_i'\\to i$ 连一条长度为 $0$ 的边，跑 $1$ 到 $n$ 的最短路即可。\n\n但是 $m$ 是 $10^9$ 级别的，把”取模装置“建完肯定空间和时间都会爆炸。观察到”取模装置“上的点有很多都是没有原来的节点与之相连的，这些点就可以直接缩掉，像这样：\n\n![](../post-images/1679795244368.png)\n\n缩点操作可以使用离散化来实现，建好图之后跑一边 dijkstra 即可。\n",
			"tags": [{"name":"做题记录"},{"name":"图论"},{"name":"最短路"}],
			"title": "ABC232G Modulo Shortest Path 做题记录",
			"link": "https://exber.qzz.io/post/ABC232G%20Modulo%20Shortest%20Path%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-26 09:38:50"
		},
	
		{
			"abstract": "",
			"content": "组合恒等式的推导证明一般可以考虑等号两边的组合意义、杨辉三角、二项式定理或者直接硬上组合定义式。\n\n****\n\n$$\n\\binom{n}{m}=\\binom{n-1}{m}+\\binom{n-1}{m-1}\n$$\n\n考虑最后一个元素有没有选。\n\n****\n\n$$\n\\sum\\limits_{i=0}^n\\binom{n}{i}=2^n\n$$\n\n枚举在 $n$ 个元素的集合中选多少个元素，再枚举选出的是那些元素，等于枚举每个元素有没有选。\n\n****\n\n$$\n\\sum\\limits_{i=0}^n(-1)^i\\binom{n}{i}=0\n$$\n\n二项式定理：\n\n$(-1+1)^n=\\sum\\limits_{i=0}^n(-1)^i1^i\\binom{n}{i}=\\sum\\limits_{i=0}^n(-1)^i\\binom{n}{i}=0$\n\n****\n\n$$\n\\sum\\limits_{i=n}^m\\binom{i}{n}=\\binom{m+1}{n+1}\n$$\n\n考虑杨辉三角：\n\n![](../post-images/1679753833734.png)\n\n****\n\n$$\n\\sum\\limits_{i=0}^m\\binom{n+i}{i}=\\binom{m+1}{n+m}\n$$\n\n依旧是考虑杨辉三角：\n\n![](../post-images/1679753843046.png)\n\n****\n\n$$\n\\binom{n}{m}=\\frac{n-m+1}{m}\\binom{n}{m-1}\n$$\n\n$\\binom{n}{m}=k\\binom{n}{m-1}$\n\n$k=\\frac{\\binom{n}{m}}{\\binom{n}{m-1}}=\\frac{\\frac{n!}{m!(n-m)!}}{\\frac{n!}{(m-1)!(n-m+1)!}}=\\frac{(m-1)!(n-m+1)!}{m!(n-m)!}=\\frac{n-m+1}{m}$\n\n****\n\n$$\n\\sum\\limits_{i=0}^k\\binom{n}{i}\\binom{m}{k-i}=\\binom{n+m}{k}\n$$\n\n著名的范德蒙德卷积，组合意义是从两个没有重复元素的集合中选择 $k$ 个元素可以通过枚举每个集合中选了几个来计算。\n\n****\n\n$$\nxy=\\binom{x+y}{2}-\\binom{x}{2}-\\binom{y}{2}\n$$\n\n从 $x$ 个各不相同的小球中选出一个，再从 $y$ 个各不相同的小球中选出一个的方案数，等于从这 $x+y$ 个小球中选出 $2$ 个的方案数减去两个球都是从某一边选出的方案数。\n\n****\n\n$$\n\\sum\\limits_{i=k}^n 2^{n-i}\\binom{m+i}{m+k}=\\sum\\limits_{i=m+k+1}^{m+n+1}\\binom{m+n+1}{i}\n$$\n\n![](../post-images/1697632948748.png)\n",
			"tags": [{"name":"学习笔记"},{"name":"数学"},{"name":"组合计数"}],
			"title": "组合恒等式学习笔记",
			"link": "https://exber.qzz.io/post/%E7%BB%84%E5%90%88%E6%81%92%E7%AD%89%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-03-25 22:16:56"
		},
	
		{
			"abstract": "> [P1758 \\[NOI2009\\] 管道取珠](https://www.luogu.com.cn/problem/P1758)\n",
			"content": "> [P1758 \\[NOI2009\\] 管道取珠](https://www.luogu.com.cn/problem/P1758)\n\n\n方案数的平方可以看做是两个人分别操作，操作到同一种结果的方案数。\n\n直接 dp 一下即可。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=505,p=1024523;\n\nint n,m;\nint a[S],b[S];\nint dp[2][S][S];\n\ninline void add(int &x,int y)\n{\n\tx+=y;\n\tif(x>=p) x-=p;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++) scanf(\" %c\",&a[i]),a[i]-='A';\n\tfor(int i=1;i<=m;i++) scanf(\" %c\",&b[i]),b[i]-='A';\n\tfor(int i=1;i<=n/2;i++) swap(a[i],a[n-i+1]);\n\tfor(int i=1;i<=m/2;i++) swap(b[i],b[m-i+1]);\n\tdp[0][0][0]=1;\n\tfor(int i=0;i<=n+m;i++)\n\t{\n\t\tint u=i&1,v=i&1^1;\n\t\tfor(int j=0;j<=i-1&&j<=n;j++) for(int k=0;k<=i-1&&k<=n;k++) dp[v][j][k]=0;\n\t\tfor(int j=0;j<=i&&j<=n;j++)\n\t\t{\n\t\t\tfor(int k=0;k<=i&&k<=n;k++)\n\t\t\t{\n\t\t\t\tif(dp[u][j][k]==0) continue;\n\t\t\t\tint jb=i-j,kb=i-k;\n\t\t\t\tif(j<n&&k<n&&a[j+1]==a[k+1]) add(dp[v][j+1][k+1],dp[u][j][k]);\n\t\t\t\tif(jb<m&&k<n&&b[jb+1]==a[k+1]) add(dp[v][j][k+1],dp[u][j][k]);\n\t\t\t\tif(j<n&&kb<m&&a[j+1]==b[kb+1]) add(dp[v][j+1][k],dp[u][j][k]);\n\t\t\t\tif(jb<m&&kb<m&&b[jb+1]==b[kb+1]) add(dp[v][j][k],dp[u][j][k]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[n+m&1][n][n]);\n\treturn 0;\n}\n```\n\n",
			"tags": [{"name":"做题记录"},{"name":"数学"},{"name":"组合计数"},{"name":"DP"}],
			"title": "P1758 [NOI2009] 管道取珠 做题记录",
			"link": "https://exber.qzz.io/post/P1758%20%5BNOI2009%5D%20%E7%AE%A1%E9%81%93%E5%8F%96%E7%8F%A0%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-25 22:12:57"
		},
	
		{
			"abstract": "> 考虑一个字符集合$A$（$A$中元素互不相同）和一个长度为$n$的字符串$S$，其中$S$中的字符都属于集合$A$。\n>\n> 给你一个包含 $m$ 个整数的序列 $b$  ($b_1<b_2<\\dots<b_m$)。你可以对字符串 $S$ 作以下的操作：\n>\n> 1.选择一个合法的 $i$ ,并且令 $k=b_i$ ;\n>\n> 2.取出 $S$ 中前 $k$ 个字符 $Pr_k$ ;\n>\n> 3.取出 $S$ 中后 $k$ 个字符$Su_k$ ;\n>\n> 4.将 $S$ 中前 $k$ 个字符替换成翻转后的 $Su_k$ ;\n>\n> 5.将 $S$ 中后 $k$ 个字符替换成翻转后的 $Pr_k$ ;\n>\n> 举个例子，我们令 $S=$ \"abcdefghi\"，$k=2$ 。这时$Pr_2=$ \"ab\"，$Su_2=$ \"hi\"，翻转后有 $Pr_2=$ \"ba\"，$Su_2=$ \"ih\"，那么最终得到的字符串 $S$ 就是 \"ihcdefgba\"。\n>\n> 这个操作可以被执行许多次（可能是零次），任何一个 $i$ 也可以被使用多次。\n>\n> 我们将字符串 $S$ 和 $T$ 称为相等的字符串，当且仅当存在一个操作序列，将字符串 $S$ 变成 $T$。对于上面的例子来说，\"abcdefghi\" 和 \"ihcdefgba\" 是相等的。注意到 $S$ 和它自己也是相等的。\n>\n> 你的任务很简单，数出互不相同的字符串的个数。\n>\n> 最终的答案可能会非常大，因此你只需要输出答案 $mod$ $998244353$ 的结果。\n>\n> $2 \\leq n \\leq 10^9$，$1 \\leq m \\leq min(\\frac{n}{2},2 * 10^5)$，$1\\leq |A|\\leq 10^9$。\n",
			"content": "> 考虑一个字符集合$A$（$A$中元素互不相同）和一个长度为$n$的字符串$S$，其中$S$中的字符都属于集合$A$。\n>\n> 给你一个包含 $m$ 个整数的序列 $b$  ($b_1<b_2<\\dots<b_m$)。你可以对字符串 $S$ 作以下的操作：\n>\n> 1.选择一个合法的 $i$ ,并且令 $k=b_i$ ;\n>\n> 2.取出 $S$ 中前 $k$ 个字符 $Pr_k$ ;\n>\n> 3.取出 $S$ 中后 $k$ 个字符$Su_k$ ;\n>\n> 4.将 $S$ 中前 $k$ 个字符替换成翻转后的 $Su_k$ ;\n>\n> 5.将 $S$ 中后 $k$ 个字符替换成翻转后的 $Pr_k$ ;\n>\n> 举个例子，我们令 $S=$ \"abcdefghi\"，$k=2$ 。这时$Pr_2=$ \"ab\"，$Su_2=$ \"hi\"，翻转后有 $Pr_2=$ \"ba\"，$Su_2=$ \"ih\"，那么最终得到的字符串 $S$ 就是 \"ihcdefgba\"。\n>\n> 这个操作可以被执行许多次（可能是零次），任何一个 $i$ 也可以被使用多次。\n>\n> 我们将字符串 $S$ 和 $T$ 称为相等的字符串，当且仅当存在一个操作序列，将字符串 $S$ 变成 $T$。对于上面的例子来说，\"abcdefghi\" 和 \"ihcdefgba\" 是相等的。注意到 $S$ 和它自己也是相等的。\n>\n> 你的任务很简单，数出互不相同的字符串的个数。\n>\n> 最终的答案可能会非常大，因此你只需要输出答案 $mod$ $998244353$ 的结果。\n>\n> $2 \\leq n \\leq 10^9$，$1 \\leq m \\leq min(\\frac{n}{2},2 * 10^5)$，$1\\leq |A|\\leq 10^9$。\n\n记字符集大小为 $V$。\n\n观察到一次操作相当于是把 $S$ 的前 $k$ 位和 $S$ 的后 $k$ 位按位交换，即\n\n$$\\operatorname{swap}_{i=1}^k(S_i,S_{n-i+1})$$\n\n那么考虑把 $S$ “对折”，问题就变成了有两个长度为 $\\lfloor\\frac{n}{2}\\rfloor$ 的字符串 $A$ 和 $B$，每次操作可以选一个 $k\\in \\{b_i\\}$，交换 $A_{[1,k]}$ 和 $B_{[1,k]}$，问有多少种本质不同的 $AB$（$A$ 和 $B$ 拼起来的字符串）。特别的，如果 $n$ 是奇数，那么中间那个位置永远不会被操作到，可以单独处理。\n\n不难发现，由于操作中的 $k$ 一定是序列 $b$ 中的某个数，并且同一个 $k$ 最多只会操作一次。所以我们关心的只是 $A_{[b_{i-1}+1,b_i]}$ 是否等于 $B_{[b_{i-1}+1,b_i]}$。因为若不等则交换后结果不一样，否则结果一样。为了表述方便，不妨记它们为 $A_{[i]}$ 和 $B_{[i]}$。\n\n下面的部分瞟了一眼题解才会。\n\n************\n\n考虑枚举每一个 $i$：\n\n- $A_{[i]}=B_{[i]}$ 的情况：共有 $V^{|A_{[i]}|}$ 种方案；\n- $A_{[i]}\\not=B_{[i]}$ 的情况：共有 $\\dfrac{V^{|A_{[i]}|}(V^{|B_{[i]}|}-1)}{2}$ 种方案，除以 $2$ 是因为交换后的也枚举过。\n\n这两种情况的方案数加起来，再乘起来，最后永远不会被操作到的单独处理即可。\n\n部分代码：\n\n```cpp\nint ans=1;\nfor(int i=1;i<=m;i++)\n{\n    scanf(\"%d\",&b[i]);\n    int eq=qpow(v,b[i]-b[i-1]);\n    int neq=1ll*qpow(v,b[i]-b[i-1])*(qpow(v,b[i]-b[i-1])-1)%p*qpow(2,p-2)%p;\n    ans=1ll*ans*(eq+neq)%p;\n}\nans=1ll*ans*qpow(v,n-b[m]-b[m])%p;\n```\n\n",
			"tags": [{"name":"做题记录"},{"name":"数学"},{"name":"组合计数"}],
			"title": "CF1065E Side Transmutations 做题记录",
			"link": "https://exber.qzz.io/post/CF1065E%20Side%20Transmutations%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-25 22:06:12"
		},
	
		{
			"abstract": "> 有 $n$ 个箱子和 $m$ 个小球，初始时第 $i$ 个箱子有 $a_i$ 个小球。每次操作可以将**一个**小球移到相邻的箱子里。求要使得最终数组 $a_i\\ge a_{i+1}$ 的最小操作次数。\n> \n> $1\\le n,m\\le 250$。\n",
			"content": "> 有 $n$ 个箱子和 $m$ 个小球，初始时第 $i$ 个箱子有 $a_i$ 个小球。每次操作可以将**一个**小球移到相邻的箱子里。求要使得最终数组 $a_i\\ge a_{i+1}$ 的最小操作次数。\n> \n> $1\\le n,m\\le 250$。\n\n把 $a$ 反过来，问题变成了让 $a_i\\ge a_{i-1}$ 的最小操作次数。\n\n考虑设 $dp_{i,j,k}$ 为前 $i-1$ 个满足条件，$a_i=j$ 且 $a_i-a_{i-1}=k$ 的最小操作次数，并且 $i$ 后面的位置没有改动。这么设置状态是因为 $a_i$ 不会影响到 $a_{i-2}$，而 $a_{i-1}$ 对 $a_{i-2}$ 的影响已经算过了，实现了无后效性。\n\n显然有 $dp_{1,a_1,a_1}=0$。\n\n考虑转移，按 $j$ 和 $a_i$ 的大小关系分类：\n\n- $j>a_i$：多出来的只可能是 $a_{i-1}$ 给的，此时 $a_i$ 肯定没给 $a_{i-1}$，所以 $dp_{i,j,k}=j-a_i+\\min\\limits_{l=j-a_i}^{m}dp_{i-1,j-k+j-a_i,l}$；\n- $j<a_i$：少掉的只可能是给了 $a_{i-1}$，此时 $a_{i-1}$ 肯定没给 $a_i$。并且注意到因为给了 $a_{i-1}$ 一些，所以 $a_{i-1}$ 在没给之前可以比 $a_{i-2}$ 小，也就是说 $dp_{i,j,k}=a_i-j+\\min\\limits_{l=j-a_i}^{m-a_i+j} dp_{i-1,j-k-a_i+j,l}$；\n- $j=a_i$：谁也没给谁，$dp_{i,j,k}=\\min\\limits_{l=0}^{m}dp_{i-1,j-k,l}$。\n\n最后答案即为 $\\min\\limits_{i=0}^m\\min\\limits_{j=0}^idp_{n,i,j}$。\n\n注意到转移中的 $\\min$ 可以用后缀 $\\min$ 来优化到 $O(1)$，那么可以在 $O(nm^2)$ 的时间复杂度内解决此题。\n\n完整代码：\n\n```cpp\n// Problem: CF1675G Sorting Pancakes\n// Contest: Luogu\n// URL: https://www.luogu.com.cn/problem/CF1675G\n// Memory Limit: 250 MB\n// Time Limit: 2000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n \n#include <iostream>\n#include <cstdio>\n#include <cstring>\n \nusing namespace std;\n \nconst long long MS=255;\nconst int mov=252,mov2=502;\n \nint n,m,a[MS];\nint dp[2][MS*3][MS*3],mn[2][MS*3][MS*3];\n \nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tfor(int i=1;i<=n/2;i++)\n\t{\n\t\tswap(a[i],a[n-i+1]);\n\t}\n\tmemset(dp,127,sizeof(dp));\n\tmemset(mn,127,sizeof(mn));\n\tdp[1][a[1]+mov][a[1]+mov2]=0;\n\tfor(int i=m;i>=-m*2;i--)\n\t{\n\t\tint id1=a[1]+mov;\n\t\tint id2=i+mov2;\n\t\tmn[1][id1][id2]=min(mn[1][id1][id2+1],dp[1][id1][id2]);\n\t}\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tint u=i&1;\n\t\tint v=u^1;\n\t\tmemset(dp[u],127,sizeof(dp[u]));\n\t\tmemset(mn[u],127,sizeof(mn[u]));\n\t\tfor(int j=-m;j<=m;j++)\n\t\t{\n\t\t\tint idj=j+mov;\n\t\t\tfor(int k=j-m;k<=j;k++)\n\t\t\t{\n\t\t\t\tint idk=k+mov2;\n\t\t\t\tif(j>a[i])\n\t\t\t\t{\n\t\t\t\t\tdp[u][idj][idk]=j-a[i]+mn[v][j-k+j-a[i]+mov][j-a[i]+mov2];\n\t\t\t\t}\n\t\t\t\telse if(j<a[i])\n\t\t\t\t{\n\t\t\t\t\tdp[u][idj][idk]=a[i]-j+mn[v][j-k+j-a[i]+mov][j-a[i]+mov2];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdp[u][idj][idk]=mn[v][j-k+mov][mov2];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int k=m;k>=-m*2;k--)\n\t\t\t{\n\t\t\t\tint idk=k+mov2;\n\t\t\t\tmn[u][idj][idk]=min(mn[u][idj][idk+1],dp[u][idj][idk]);\n\t\t\t}\n\t\t}\n\t}\n\tint ans=1e8;\n\tfor(int i=0;i<=m;i++)\n\t{\n\t\tans=min(ans,mn[n&1][i+mov][mov2]);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n\n",
			"tags": [{"name":"做题记录"},{"name":"数学"},{"name":"组合计数"},{"name":"DP"}],
			"title": "CF1675G Sorting Pancakes 做题记录",
			"link": "https://exber.qzz.io/post/CF1675G%20Sorting%20Pancakes%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-25 22:04:18"
		},
	
		{
			"abstract": "",
			"content": "需要**求 $n,m\\le lim$ 的一些 $C_n^m$ 模 $p$ 的结果**，但是递推预处理组合数时间复杂度无法接受时，该怎么办呢？\n\n## 0x0 普通方法\n\n最基础的方法是预处理出阶乘和阶乘的逆元，直接套公式计算：\n\n```cpp\ninline void init()\n{\n\tfra[0]=1;\n\tfor(int i=1;i<=lim;i++)\n\t{\n\t\tfra[i]=1ll*fra[i-1]*i%p;\n\t}\n\tinv[lim]=qpow(fra[lim],p-2);\n\tfor(int i=lim;i>=1;i--)\n\t{\n\t\tinv[i-1]=1ll*inv[i]*i%p;\n\t}\n}\n\ninline int C(int n,int m)\n{\n\treturn n<m?0:1ll*fra[n]*fra[n-m]%p*fra[m]%p;\n}\n```\n\n这样做的话单次时间复杂度是 $O(1)$ 的，预处理时间复杂度则是 $O(lim)$。\n\n## 1x0 特殊手段\n\n普通方法已经能满足大多数情况，但是有两种特殊情况除外。\n\n### 1x1 $lim\\ge p$，但 $p$ 是质数的情况（Lucas）\n\n当 $lim\\ge p$ 时，**所有 $i\\ge p$ 的 $i!$ 都不与 $p$ 互质，没有模 $p$ 意义下的逆元**，普通方法就行不通了。\n\n这时可以借助 Lucas 定理：\n\n$$C_n^m\\equiv C_{n\\operatorname{mod}p}^{m\\operatorname{mod} p}\\cdot C_{\\lfloor\\frac{n}{p}\\rfloor}^{\\lfloor\\frac{m}{p}\\rfloor}\\pmod p$$\n\n来实现递归求解：\n\n```cpp\ninline void init()\n{\n\tint lim2=min(lim,p-1);\n\tfra[0]=1;\n\tfor(int i=1;i<=lim2;i++)\n\t{\n\t\tfra[i]=1ll*fra[i-1]*i%p;\n\t}\n\tinv[lim2]=qpow(fra[lim2],p-2);\n\tfor(int i=lim2;i>=1;i--)\n\t{\n\t\tinv[i-1]=1ll*inv[i]*i%p;\n\t}\n}\ninline int C(int n,int m)\n{\n\treturn n<m?0:1ll*fra[n]*inv[m]%p*inv[n-m]%p;\n}\n\nint lucas(int n,int m)\n{\n\treturn m==0?1:1ll*C(n%p,m%p)*lucas(n/p,m/p)%p;\n}\n```\n\n这样做的话单次时间复杂度是 $O(\\log_p m)$ 的，预处理时间复杂度则是 $O(\\min(lim,p))$。\n\n****\n\n定理证明：\n\n**【引理 1】** 对于任意一个满足 $1\\le x<p$ 的正整数 $x$，均有 $C_p^x\\equiv0\\pmod p$，证明如下：\n\n$$\\begin{aligned}C_p^x&\\equiv\\dfrac{p!}{x!(p-x)!}\\pmod p\\\\&\\equiv p\\cdot\\dfrac{(p-1)!}{x!(p-x)!}\\pmod p\\\\&\\equiv 0\\pmod p\\end{aligned}$$\n\n**【引理 2】** $(a+b)^p\\equiv a^p+b^p\\pmod p$，证明如下：\n\n根据二项式定理：\n\n$$\\begin{aligned}(a+b)^p&\\equiv\\sum\\limits_{i=0}^pC_p^i\\cdot a^i\\cdot b^{p-i}\\pmod p\\\\&\\equiv a^p+b^p+\\sum\\limits_{i=1}^{p-1}C_p^i\\cdot a^i\\cdot b^{p-i}\\pmod p\\\\&\\equiv a^p+b^p\\pmod p\\text{（由引理 1 得）}\\end{aligned}$$\n\n**【定理 1（Lucas 定理）】** $C_n^m\\equiv C_{n\\operatorname{mod}p}^{m\\operatorname{mod} p}\\cdot C_{\\lfloor\\frac{n}{p}\\rfloor}^{\\lfloor\\frac{m}{p}\\rfloor}\\pmod p$，证明如下：\n\n设 $x$ 为一个满足 $1\\le x<p$ 的正整数，由二项式定理得：$(1+x)^n\\equiv \\sum\\limits_{i=0}^n C_n^ix^i$。\n\n令 $p_n=\\lfloor\\frac{n}{p}\\rfloor,p_m=\\lfloor\\frac{m}{p}\\rfloor,r_n=n\\operatorname{mod}p,r_m=m\\operatorname{mod} p$，那么有：\n\n$$\\begin{aligned}(1+x)^n&\\equiv (1+x)^{p\\cdot p_n+r_n}\\pmod p\\\\&\\equiv [(1+x)^p]^{p_n}\\cdot(1+x)^{r_n}\\pmod p\\\\&\\equiv (1+x^p)^{p_n}\\cdot (1+x)^{r_n}\\pmod p\\\\&\\equiv \\sum\\limits_{i=0}^{p_n}\\sum\\limits_{j=0}^{r_n}C_{p_n}^i\\cdot C_{r_n}^j\\cdot x^{ip+j}\\pmod p\\text{（根据二项式定理）}\\\\&\\equiv\\sum\\limits_{i=0}^nC_{p_n}^{\\lfloor\\frac{i}{p}\\rfloor}\\cdot C_{r_n}^{i\\operatorname{mod} p}\\cdot x^i\\pmod p\\end{aligned}$$\n\n所以：\n\n$$\\sum\\limits_{i=0}^n C_n^ix^i\\equiv\\sum\\limits_{i=0}^nC_{p_n}^{\\lfloor\\frac{i}{p}\\rfloor}\\cdot C_{r_n}^{i\\operatorname{mod} p}\\cdot x^i\\pmod p$$\n\n$$C_n^m\\equiv C_{p_n}^{p_m}\\cdot C_{r_n}^{r_m}\\pmod p$$\n\n证毕。\n\n****\n\n练习：[P3773 [CTSC2017]吉夫特](https://www.luogu.com.cn/problem/P3773)\n\n### 1x2 $p$ 不是质数的情况（exLucas）\n\n未完待续。\n",
			"tags": [{"name":"学习笔记"},{"name":"数学"},{"name":"组合计数"}],
			"title": "组合数取模（Lucas 定理 & exLucas 定理）学习笔记",
			"link": "https://exber.qzz.io/post/%E7%BB%84%E5%90%88%E6%95%B0%E5%8F%96%E6%A8%A1%EF%BC%88Lucas%20%E5%AE%9A%E7%90%86%20%26%20exLucas%20%E5%AE%9A%E7%90%86%EF%BC%89%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-03-25 21:59:48"
		},
	
		{
			"abstract": "",
			"content": "# 0x0 基本原理\n\n### 0x01 加法原理\n\n若做 $A$ 有 $n$ 种方法，做 $B$ 有 $m$ 种方法，并且它们**互不干涉**，那么做 $A$ 或 $B$ 中的**恰好一个**有 $n+m$ 种方法。\n\n### 0x02 乘法原理\n\n若做 $A$ 有 $n$ 种方法，做 $B$ 有 $m$ 种方法，并且它们**互不干涉**，那么**做 $A$ 并且做 $B$** 有 $n\\times m$ 种方法。\n\n# 0x1 排列组合\n\n### 0x11 排列\n\n从 $n$ 个**各不相同的元素**中**有顺序地**取出 $m$ 个元素的方法数，**记为 $A_n^m$**，即为排列数。\n\n考虑 $A_n^m$ 的具体求法。考虑每一次选出的元素，第一次选择有 $n$ 种方法，第二次选择有 $n-1$ 种方法，$\\dots$，第 $m$ 次选择有 $n-m+1$ 种方法。由于**每次选择事件互不干涉**，所以根据乘法原理：\n\n$$A_n^m=n(n-1)(n-2)\\dots(n-m+1)=\\dfrac{n!}{(n-m)!}$$\n\n### 0x12 组合\n\n从 $n$ 个**各不相同的元素**中**无顺序地**取出 $m$ 个元素的方法数，**记为 $C_n^m$ 或 $\\dbinom{n}{m}$**，即为组合数。\n\n考虑 $C_n^m$ 的具体求法。**无顺序地取出可以看作是有顺序地取出后去掉顺序**，那么由于 $m$ 个各不相同的元素有 $m!$ 种排列方式，所以：\n\n$$C_n^m=\\dfrac{A_n^m}{m!}=\\dfrac{n!}{(n-m)!m!}$$\n\n### 0x13 排列数与组合数的求法\n\n在实际应用中，排列数和组合数都可以通过预处理阶乘的方法来求出。\n\n但是**组合数有 $O(nm)$ 的预处理方法**（$n$ 是元素个数上限，$m$ 是选出的元素数量上限）：\n\n$$C^m_n=C^{m-1}_{n-1}+C^{n-1}_m$$\n\n****\n\n证明：\n\n首先把 $n$ 个物品分成两组，第一组有 $n-1$ 个，第二组有 $1$ 个。\n\n那么我们可以从第一组里选 $m-1$ 个并从第二组里选一个，或者从第一组里选 $m$ 个。\n\n****\n\n预处理组合数的代码：（对 $p$ 取模）\n\n```cpp\nC[0][0]=1;\nfor(int i=1;i<=n;i++)\n{\n\tC[i][0]=1;\n\tfor(int j=1;j<=i;j++)\n\t{\n\t\tC[i][j]=(C[i-1][j-1]+C[i-1][j])%p;\n\t}\n}\n```\n\n另外，关于组合数的取模问题，可以看[组合数取模（Lucas 定理 & exLucas 定理）学习笔记](../组合数取模（Lucas 定理 & exLucas 定理）学习笔记)。\n\n### 0x14 一些技巧\n\n#### 0x141 整体考虑\n\n有时候元素会分成很多个组，组之间有顺序关系，组内也有顺序关系，那么就可以**考虑每一组单独排列组合，再把每一组当成单个元素来排列组合**。\n\n#### 0x142 插板法\n\n> $n$ 个**相同的物品**放到 $m$ 个**不同的盒子**内，**不允许空盒子**，有多少种方法？\n\n可以考虑**在 $n$ 个物品中间放 $m-1$ 个“隔板”**，把所有物品分隔成 $m$ 组，那么方案数就是 $C_{n-1}^{m-1}$。\n\n插板法还有个变形，即**允许空盒子**：\n\n> $n$ 个**相同的物品**放到 $m$ 个**不同的盒子**内，不**允许空盒子**，有多少种方法？\n\n可以考虑**增加 $m$ 个物品**，那么盒子里放一个物品就相当于是没有放，放两个就相当于是放了一个，依此类推。所以方案数即为 $C_{n+m-1}^{m-1}$。\n\n#### 0x143 贡献有次方的处理\n\n权值为 $x$ 的方案贡献为 $x^k$ 的时候，可以考虑运用**二项式定理拆开次方**，也可以考虑组合意义：$n$ 个对象，$k$ 个人各选一个的方案数。\n\n例题：[P1758 [NOI2009] 管道取珠](https://www.luogu.com.cn/problem/P1758) | [题解](../P1758 [NOI2009] 管道取珠 做题记录)\n\n#### 0x144 组合恒等式\n\n详见[组合恒等式学习笔记](../组合恒等式学习笔记)。\n\n#### 0x145 格路计数\n\n详见[格路计数入门](../格路计数入门)。\n\n# 1x0 二项式定理\n\n$$(a+b)^n=\\sum\\limits_{i=0}^n\\dbinom{n}{i}a^ib^{n-i}$$\n\n****\n\n证明：\n\n首先考虑把 $(a+b)^n$ 的幂拆开：\n\n$$(a+b)^n=\\begin{matrix}\\underbrace{(a+b)(a+b)(a+b)\\dots(a+b)}\\\\n\\text{个}(a+b)\\end{matrix}$$\n\n接下来拆括号，考虑选 $i$ 个 $a$ 出来，那么就会有 $n-i$ 个 $b$ 和它配对，即 $a^ib^{n-i}$，选 $a$ 出来的方案数是 $\\dbinom{n}{i}$，所以原式成立。\n\n****\n\n# 1x1 容斥原理\n\n### 1x11 基础容斥\n\n设有一些元素和一些条件 $R=\\{P_1,P_2,P_3,\\dots\\}$，**令 $f(S)$ 表示满足 $S$ 中所有条件**的元素个数。那么**至少满足 $R$ 中一个条件**的元素个数为：\n\n$$\\sum\\limits_{T\\subseteq R,T\\not=\\varnothing}(-1)^{|T|-1}f(T)$$\n\n****\n\n可以靠维恩图来理解：\n\n![](../post-images/1679752695242.png)\n\n至少满足一个条件的元素个数可以看作是维恩图中不是空白的部分的面积，是 \n\n$$|A|+|B|+|A|-|AC|-|AB|-|BC|+|ABC|$$\n\n仔细观察就会发现它与式子一致。\n\n****\n\n**不满足 $R$ 中任意一个条件**的元素个数为：\n\n$$\\sum\\limits_{T\\subseteq R}(-1)^{|T|}f(T)$$\n\n****\n\n依旧是靠之前那一张维恩图来理解，不满足任意一个条件的元素个数可以看作维恩图中空白部分的面积，是\n\n$$\\text{元素个数}-|A|-|B|-|C|+|AC|+|AB|+|BC|-|ABC|$$\n\n而元素个数就是 $f(\\varnothing)$，这也是求和里的 $T$ 可以等于 $\\varnothing$ 的原因。\n\n****\n\n### 1x12 基础容斥扩展\n\n依旧是有一些元素和一些条件 $R=\\{P_1,P_2,P_3,\\dots\\}$，$f(S)$ **依旧表示满足 $S$ 中所有条件的元素个数**。令 $g(S)$ 表示**满足且仅满足 $S$ 中所有条件**的元素个数，那么有：\n\n$$g(S)=\\sum\\limits_{S\\subseteq T}(-1)^{|T|-|S|}f(T)$$\n\n****\n\n还是靠维恩图理解：\n\n![](../post-images/1679752695242.png)\n\n满足且仅满足某个集合中的条件的元素个数可以看成是一块颜色的面积。假设要求 $g(A)$ 也就是维恩图中黄色那块的面积。那么显然它是\n\n$$|A|-|AC|-|AB|+|ABC|$$\n\n仔细观察就会发现它与式子一致。\n\n### 1x13 容斥底层原理\n\n其实所有容斥都可以这样描述：\n\n> 假设现在要计数集合 $S$ 中满足条件（$01$ 函数） $P(x)$ 的元素 $x$ 的个数，即 $|\\{x|x\\in S,P(x)=1\\}|$。\n>\n> 容斥其实使用一系列简单的条件 $Q_i(x)$ 和容斥系数 $f_i$ 去表示 $P(x)$。具体的，我们会计算 $\\sum_i|\\{x|x\\in S,Q_i(x)=1\\}|\\times f_i$ 使得 $x$ 恰好被计算 $P(x)$ 次，即 $\\sum_iQ_i(x)f_i=P(x)$。\n\n举个例子，[Loj #3395. 「2020-2021 集训队作业」Yet Another Permutation Problem](https://loj.ac/p/3395) 这题，需要计算不存在长度为 $k$ 连续上升段的排列个数。那么对于一个排列 $x$，不难发现它一定可以分成若干段极长上升段，不妨设这些上升段长度为 $a_1,a_2,\\dots,a_m$，则显然 $P(x)=\\prod [a_i< k]$，不妨设 $R(x)=[x< k]$，则 $P(x)=\\prod R(a_i)$。\n\n考虑极长不好算，不妨算钦定，即每次钦定往后接一段上升段。不难发现这样是好转移的，有 $ans_i=\\sum\\limits_{j=0}^{i-1}ans_j\\times \\binom{i}{j}\\times f_{i-j}$，其中 $f_l$ 是往后钦定接一段长 $l$ 的上升段的容斥系数。\n\n考虑如何计算 $f_l$，只需满足长 $x$ 的极长段被计算到的次数 $g_x=R(x)=[x<k]$ 次。\n\n设 $f$ 的 OGF 为 $F(x)=\\sum\\limits_{i=1}^{\\infin} f_ix^i$，则有 $g_i=[x^i]\\sum\\limits_{i=1}^\\infin F^{i}(x)=[x^i]\\left(\\frac{1}{1-F(x)}-1\\right)$。\n\n求逆即可，或者可以观察系数规律。\n\n# 2x0 各种常见数列\n\n### 2x01 卡特兰数\n\n> 有 $n$ 个左括号和 $n$ 个右括号的合法括号序列有多少个？\n\n把左括号记为 $1$，右括号记为 $-1$，不难发现一个括号序列合法当且仅当其前缀和均 $\\ge0$。\n\n直接计算不好做，考虑寻找映射关系。对于每个不合法的括号序列，考虑把其前缀和中第一个 $<0$ 的位置和其之前的括号都翻转。由于翻转之前这个位置的前缀和一定为 $-1$，所以翻转后的序列共有 $n+1$ 个 $1$ 和 $n-1$ 个 $-1$。\n\n不难发现，每个有 $n+1$ 个 $1$ 和 $n-1$ 个 $-1$ 的序列都对应一个不合法序列，只要把其前缀和中第一个 $>0$ 的位置和其之前的括号都翻转即可还原出一个不合法序列，并且是一一对应的，所以不合法的括号序列总共有 $\\binom{2n}{n-1}$ 个。\n\n由于总共的括号序列有 $\\binom{2n}{n}$，所以合法括号序列有 $\\binom{2n}{n}-\\binom{2n}{n-1}=\\frac{(2n)!}{n!^2}-\\frac{(2n)!}{(n-1)!(n+1)!}=\\frac{(2n)!(n+1)-n(2n)!}{n!^2(n+1)}=\\frac{\\binom{2n}{n}}{n+1}$。\n\n这就是卡特兰数的通项公式，不妨记 $C_n=\\frac{\\binom{2n}{n}}{n+1}$，那么有 $C_{n+1}=\\sum\\limits_{i=0}^{n}C_iC_{n-i}$。\n\n****\n\n证明：\n\n假设最后一个右括号和第 $i+1$ 个左括号匹配，那么这对括号中间和这对括号外面的部分是互相独立的，所以此时的合法括号序列个数为 $C_iC_{n-i}$。\n\n****\n\n一些运用：\n\n- > 有 $n$ 个点的有根二叉树的个数？\n\n  设 $f_n$ 表示问题的答案，那么有 $f_n=\\sum\\limits_{i=0}^{n-1}f_{i}f_{n-1-i}$ 且 $f_0=f_1=1$，和卡特兰数的递推式一致，所以有 $f_n=C_n$。\n\n- > 有 $n$ 个点的所有有根二叉树的叶子的总数？\n\n  对于每棵 $n$ 个点的二叉树，设它有 $k$ 个叶子，那么把这 $k$ 个叶子分别删去就能得到 $k$ 棵 $n-1$ 个点的二叉树。\n\n  由于每一颗 $n-1$ 个点的二叉树都能悬挂 $n$ 个新的叶子，所以每一棵 $n-1$ 个点的二叉树都会被上面的过程得到 $n$ 次。\n\n  由于 $n$ 个点的有根二叉树有 $C_n$ 种，所以 $n$ 个点的所有二叉树总共有 $nC_{n-1}=\\binom{2n-2}{n-1}$ 个叶子。\n\n### 2x03 第二类斯特林数\n\n### 2x02 第一类斯特林数\n\n### 2x04 分拆数\n",
			"tags": [],
			"title": "组合计数入门",
			"link": "https://exber.qzz.io/post/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0%E5%85%A5%E9%97%A8",
			"date": "2023-03-25 21:57:33"
		},
	
		{
			"abstract": "",
			"content": "这些都是近来我 VP CF 遇到的奇奇妙妙的题。\n\n\n\n# 构造\n\n这一类题通常需要大胆猜结论/经验积累。\n\n### [CF1514B AND 0, Sum Big](https://www.luogu.com.cn/problem/CF1514B)\n\n首先因为与运算和为 $0$，所以**每一位上都至少有一个数这一位为 $0$**。\n\n然后因为元素的和要尽量大，所以**肯定不存在两个数同一位为 $0$**。\n\n那么**每一位都需要让 $a_{1\\sim n}$  中的恰好一个在这一位为 $0$**，所以答案即为 $n^k$。\n\n### [CF1630A And Matching](https://www.luogu.com.cn/problem/CF1630A)\n\n首先来看三个性质：\n\n- $i\\&(n-1-i)=0$，因为 $i$ 和 $n-1-i$ 的二进制是“错开”的；\n- $i\\&(n-1)=i$，因为 $n-1$ 的二进制全是 $1$；\n- $i\\&0=0$，显然。\n\n接下来分类讨论：\n\n- 若 $k\\not=n-1$：\n\n可以**先构造出 $k\\&(n-1)=k$ 和 $(n-1-k)\\&0=0$，然后对于每个 $1\\le i\\le n-1$ 且 $i\\not=k$ 且 $i\\not=n-1-k$ 的 $i$ 构造出 $i\\&(n-1-i)=0$。**\n\n注意**特判 $k=0$，这时不需要构造 $(n-1-k)\\&0=0$**。\n\n- 若 $k=n-1$\n\n这时容易发现让其中一对与为 $k$ 的办法行不通了，所以我们要另辟蹊径，**让两对的与加起来为 $k$**。\n\n显然 $(n-1)\\&(n-2)=n-2$，$1\\&(n-3)=1$，那么先构造这两对即可。\n\n接下来发现 $n-1-(n-1)=0$，$n-1-(n-3)=2$，$n-1-(n-2)=1$ 也就是说 $0$ 和 $2$ 不能组成 $i\\&(n-1-i)=0$ 了，那么让它们单独组，**构造 $0\\&2=0$**。\n\n接下来构造 $i\\&(n-1-i)=0$ 即可。\n\n注意到**若 $n\\le 4$ 则 $n-1$、$n-2$、$n-3$、$0$、$1$、$2$ 会重叠，这时是无解的**。\n\n### [CF1659D Reverse Sort Sum](https://www.luogu.com.cn/problem/CF1659D)\n\n不难发现，由于每个 $1$ 对 $\\sum C$ 都有且仅有 $n$ 的贡献，所以 **$A$ 中 $1$ 的个数即为 $\\dfrac{\\sum C}{n}$**。\n\n接下来，我们很容易发现 **$A_n=1$ 当且仅当 $C_n=n$**，因为 $A_n=1$ 时 $B_{i,n}$ 一定为 $1$。\n\n有了这个性质的启示，不难想到可以**通过减掉 $B_n$ 对 $C$ 的贡献来实现缩小问题的规模，令 $n$ 变为 $n-1$**。实际上实现起来也并不难，因为**我们已经取得了 $A$ 中 $1$ 的个数 $m$，$B_n$ 一定只会对 $[n-m+1,n]$ 有 $1$ 的贡献，那么用差分来实现快速区间减法即可**。\n\n### [CF1658D2 388535 (Hard Version)](https://www.luogu.com.cn/problem/CF1658D2)\n\n首先**肯定有一个 $a_i$ 满足 $a_i\\operatorname{xor} l=x$，即它本来是 $l$**。那么我们枚举每个 $a_i$，判断它原来是不是 $l$ 即可。\n\n接下来思考判断的方法。不难发现，**由于 $a_i$ 原来是不重复的一个排列，所以异或后的 $a_i$ 也是不重复的一个排列，所以只要 $a_i$ 满足 $r=\\max\\operatorname{xor}(a_i\\operatorname{xor} l)$ 就说明 $a_i$ 原来是 $l$**。\n\n这个东西用 trie 维护即可。\n\n### [CF1592C Bakry and Partitioning](https://www.luogu.com.cn/problem/CF1592C)\n\n从每一部分的异或和相同出发，设分割后每一部分的异或和都为 $k$，所有 $a_i$ 的异或和为 $sum$。不难发现**要么 $sum=0$ 即最后是偶数个 $k$ 异或起来，要么 $sum=k$ 即最后是奇数个 $k$ 异或起来**。\n\n- 若 $sum=0$，我们**割断任意一条边都一定合法。因为割出来的两部分只有异或和相同它们异或起来的结果 $sum$ 才为 $0$**。\n\n- 若 $sum=k$，那么**割断两条边，分割出三个异或和为 $k$ 的连通块显然是最优的**。所以**考虑找到两个异或和都为 $k$ 的连通块，剩下那一块异或和就自然为 $k$**。因为**肯定有一个满足条件的连通块是一棵子树，减掉它的贡献后又会有一个满足条件的连通块是一棵子树**，所以跑一次 $dfs$，**求出每个节点子树去掉异或和为的 $k$ 子树后的异或和** $dp_u=\\operatorname{xor}_{v\\text{ 是 }u\\text{ 的儿子}}[dp_v\\not=k]dp_v$ 即可。最后若 $\\sum\\limits_{u} [dp_u=k]\\ge2$ 就说明有解。\n\n部分代码如下：\n\n```cpp\nvoid dfs(int u,int fa,long long val)\n{\n\tdp[u]=a[u];\n\tfor(int i=h[u];i;i=nxt[i])\n\t{\n\t\tint v=to[i];\n\t\tif(v==fa)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(v,u,val);\n\t\tif(dp[v]!=val)\n\t\t{\n\t\t\tdp[u]^=dp[v];\n\t\t}\n\t}\n}\n\ninline void slove()\n{\n\tesum=0;\n\tscanf(\"%d%d\",&n,&k);\n\tlong long sm=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\th[i]=0;\n\t\tdp[i]=0;\n\t\tscanf(\"%lld\",&a[i]);\n\t\tsm^=a[i];\n\t}\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);\n\t\tadd(y,x);\n\t}\n\tif(sm==0)\n\t{\n\t\tputs(\"YES\");\n\t\treturn;\n\t}\n\tif(k==2)\n\t{\n\t\tputs(\"NO\");\n\t\treturn;\n\t}\n\tdfs(1,0,sm);\n\tint cnt=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcnt+=dp[i]==sm;\n\t}\n\tputs(cnt>=2?\"YES\":\"NO\");\n}\n```\n\n\n\n# 交互\n\n这一类题通常需要程序和交互库互动，思维难度较高。\n\n### [CF1503B 3-Coloring](https://www.luogu.com.cn/problem/CF1503B)\n\n用 $1$ 和 $2$ 交替着填，实在不行用 $3$ 即可。\n\n### [CF1592D Hemose in ICPC](https://www.luogu.com.cn/problem/CF1592D)\n\n首先由于 $\\gcd$ 里的数越多，结果就越小，所以**最大的 $Dist$ 一定是一条边的边权**。\n\n那么我们**先询问所有节点求出最大的 $Dist=val$，然后二分所有的边**。\n\n考虑如何二分，显然需要把树“拍扁”，用类似 $dfs$ 序的东西来解决。具体的，考虑节点 $u$ 和它的所有儿子 ${v_i}$，显然 $u\\to v_i$ 都有一条边，那么**先往序列里加入 $u$，再在 $dfs$ 完每个 $v_i$ 后都加入 $u$ 即可**。\n\n### [CF1634D Finding Zero](https://www.luogu.com.cn/problem/CF1634D)\n\n![img](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1634D/74895b22455b2b459cd8609f4caa3df7273f47e6.png)\n\n考虑从 $4$ 个可能的下标 $b_1,b_2,b_3,b_4$ 中去掉一些不可能的下标。\n\n显然一次询问的结果是三个数的极差。记 $q_1,q_2,q_3,q_4$ 为询问四个下标里分别除去 $b_1,b_2,b_3,b_4$ 的结果，即 $q_1$ 为询问 $b_2,b_3,b_4$ 的结果。那么**显然 $m=\\max(q_1,q_2,q_3,q_4)$ 就是 $a_{b_1},a_{b_2},a_{b_3},a_{b_4}$ 的极差**。\n\n不难发现，**若 $q_i=m$，那么 $b_i$ 一定不可能为 $0$**。因为去掉 $0$ 后三个数的极差一定不是这四个数的极差。\n\n这样每排除一次至少可以去掉至少两个不可能的下标，总共需要的次数上限就是 $\\dfrac{4n}{2}=2n$，足以通过此题。\n\n特别的，若剩下三个下标未排除，拿一个排除过的下标和它们组队即可。\n\n\n\n# 杂题\n\n最后给两道匕匕车交女少白勺杂题。\n\n### [CF1632D New Year Concert](https://www.luogu.com.cn/problem/CF1632D)\n\n不难发现，当区间 $[l,r]$ 的右端点 $r$ 固定不动，左端点 $l$ 减小时，$\\gcd(a_l,a_{l+1},a_{l+2},\\dots,a_r)$ 是单调不增的，而 $r-l+1$ 则是单调递增的，这造成了它们最多只会有一个交点。也就是说，**对于一个固定的 $r$，最多有一个 $l$ 满足 $\\gcd(a_l,a_{l+1},a_{l+2},\\dots,a_r)=r-l+1$**。\n\n那么用倍增实现 $O(n\\log n\\log v)$ 预处理 $O(1)$ 查询 $\\gcd$，然后枚举 $r$，每次找满足条件的 $l$，如果有那么答案加一并且把 $a_l$ 改为 $1$ 即可。\n\n部分代码如下：\n\n```cpp\nint ans=0,lb=1;\nfor(int i=1;i<=n;i++)\n{\n\twhile(lb<i&&que(lb,i)<i-lb+1)\n\t{\n\t\tlb++;\n\t}\n\tif(que(lb,i)==i-lb+1)\n\t{\n\t\tans++;\n\t\tlb=i+1;\n\t}\n\tprintf(\"%d \",ans);\n}\nprintf(\"\\n\");\n```\n\n### [CF1594D The Number of Imposters](https://www.luogu.com.cn/problem/CF1594D)\n\n并查集拆点模板题，建议先看一下我的[博客](https://www.luogu.com.cn/blog/251130/awa-bing-zha-ji-xue-xi-bi-ji)。\n\n每个人拆两个点 $i$ 和 $i+n$，分别表示这个人是好人和坏人的情况，**统计答案的时候对每个集合的“帮主”是好人/坏人的情况下的好人的数量取最大值，加起来即可**。\n\n\n\n## [CF1685B Linguistics](https://www.luogu.com.cn/problem/CF1685B)\n\n贪心。\n\n题意显然可以转化为**把 $a$ 个 $\\texttt{A}$、$b$ 个 $\\texttt{B}$、$c$ 个 $\\texttt{A}\\texttt{B}$ 和 $d$ 个 $\\texttt{B}\\texttt{A}$ 不重叠地放进字符串 $s$ 中，使得对应位相等**。\n\n首先若放的 $\\texttt{\\texttt{A}}$、$\\texttt{B}$ 的个数和 $s$ 中 $\\texttt{A}$、$\\texttt{B}$ 的个数不同，那么就是不行的。接下来考虑让所有放单个 $\\texttt{A}$ 和 $\\texttt{B}$ 的操作都挪到最后进行，那么问题就转化为判断能否把 $c$ 个 $\\texttt{A}\\texttt{B}$ 和 $d$ 个 $\\texttt{B}\\texttt{A}$ 都放进 $s$ 里面。\n\n考虑一段形如 $\\texttt{A}\\texttt{B}\\texttt{A}\\texttt{B}\\texttt{A}\\texttt{B}\\texttt{A}\\texttt{B}$ 这样 **$\\texttt{A}\\texttt{B}$ 相间的极长子串**，设它的长度为 $cnt$，那么分类讨论：\n\n- 若 $cnt$ 是奇数，那么这一段可以**放 $\\lfloor\\frac{cnt}{2}\\rfloor$ 个 $\\texttt{A}\\texttt{B}$ 或 $\\texttt{B}\\texttt{A}$**；\n- 若 $cnt$ 是偶数，那么：\n  * 若这一段以 $\\texttt{B}$ 结尾，即形如 $\\texttt{A}\\texttt{B}\\texttt{A}\\texttt{B}$，那么可以**放 $\\lfloor\\frac{cnt}{2}\\rfloor-1$ 个 $\\texttt{A}\\texttt{B}$ 或 $\\texttt{B}\\texttt{A}$，或者可以放 $\\lfloor\\frac{cnt}{2}\\rfloor$ 个 $\\texttt{A}\\texttt{B}$**；\n  * 若这一段以 $\\texttt{A}$ 结尾，即形如 $\\texttt{B}\\texttt{A}\\texttt{B}\\texttt{A}$，那么可以**放 $\\lfloor\\frac{cnt}{2}\\rfloor-1$ 个 $\\texttt{A}\\texttt{B}$ 或 $\\texttt{B}\\texttt{A}$，或者可以放 $\\lfloor\\frac{cnt}{2}\\rfloor$ 个 $\\texttt{B}\\texttt{A}$**；\n\n不难发现，当 $cnt$ 为奇数时这一段**对 $\\texttt{A}\\texttt{B}$ 和 $\\texttt{B}\\texttt{A}$ 都是公平的**，即它们放的上限都是 $\\lfloor\\frac{cnt}{2}\\rfloor$，并且对放多少个 $\\texttt{A}\\texttt{B}$ 和多少个 $\\texttt{B}\\texttt{A}$ 没有限制，只要它们数量加起来不超过 $\\lfloor\\frac{cnt}{2}\\rfloor$ 就可以了。\n\n所以可以令 $bot=\\sum\\limits_{cnt\\operatorname{mod}2=1}\\lfloor\\frac{cnt}{2}\\rfloor$ 即**奇数段最多可以放的 $\\texttt{A}\\texttt{B}$ 和 $\\texttt{B}\\texttt{A}$ 的数量**。\n\n若 $cnt$ 为偶数，那么这一段**对 $\\texttt{A}\\texttt{B}$ 和 $\\texttt{B}\\texttt{A}$ 是不公平的**，即它们放的上限一个多，一个少。为了减少位置的浪费，不妨**先钦定这一段都放上限多的那种字符串，再用两个数组 $vala$ 和 $valb$ 存偏心 $\\texttt{A}\\texttt{B}$ 或者 $\\texttt{B}\\texttt{A}$ 即能放更多 $\\texttt{A}\\texttt{B}$ 或 $\\texttt{B}\\texttt{A}$ 的偶数段中两种字符串放置的上限**。\n\n最后**若每一段偶数段都放上限多的字符串时 $c$ 或 $d$ 还是大于 $0$，那么就让偏心另一种字符串的偶数段分一些位置放这种字符串**即可。不难发现由于没分之前偶数段总共能放 $\\lfloor\\frac{cnt}{2}\\rfloor$ 个字符串，分了之后只能放 $\\lfloor\\frac{cnt}{2}\\rfloor-1$ 个，所以**分的段数肯定是越少越好**。那么按段的长度从大到小分即可。\n\n代码如下：\n\n```cpp\n// Problem: D. Linguistics\n// Contest: Codeforces Round #794 (Div. 2)\n// URL: https://codeforces.com/contest/1686/problem/D\n// Memory Limit: 256 MB\n// Time Limit: 1000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\nconst int S=1919810;\n\nstruct node\n{\n\tint x,y;\n}vala[S],valb[S];\n\nint n,a,b,c,d;\nchar str[S];\n\ninline bool cmp(node x,node y)\n{\n\treturn x.y>y.y;\n}\n\ninline void slove()\n{\n\tcin>>a>>b>>c>>d>>(str+1);\n\tn=strlen(str+1);\n\tint cnta=0,cntb=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcnta+=str[i]=='A';\n\t\tcntb+=str[i]=='B';\n\t}\n\tif(cnta-c-d!=a||cntb-c-d!=b) // A 或 B 的数量不符合的情况\n\t{\n\t\tcout<<\"NO\"<<endl;\n\t\treturn;\n\t}\n\tint m1=0,m2=0,bot=0;\n\tstr[n+1]=str[n];\n\tfor(int i=1,cnt=0;i<=n+1;i++)\n\t{\n\t\tif(str[i]!=str[i-1])\n\t\t{\n\t\t\tcnt++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(cnt>1)\n\t\t\t{\n\t\t\t\tif(cnt&1) // 公平的奇数段\n\t\t\t\t{\n\t\t\t\t\tbot+=cnt/2;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(str[i-1]=='B')\n\t\t\t\t\t{\n\t\t\t\t\t\tvala[++m1]=(node){cnt/2,cnt/2-1}; // 偏心 AB\n\t\t\t\t\t\tc-=cnt/2;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tvalb[++m2]=(node){cnt/2,cnt/2-1}; // 偏心 BA\n\t\t\t\t\t\td-=cnt/2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcnt=1;\n\t\t}\n\t}\n\tif(d>0)\n\t{\n\t\tsort(vala+1,vala+m1+1,cmp);\n\t\tfor(int i=1;i<=m1;i++)\n\t\t{\n\t\t\tif(c+vala[i].x<=0)\n\t\t\t{\n\t\t\t\tc+=vala[i].x;\n\t\t\t\td-=vala[i].y;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint lft=vala[i].x+c;\n\t\t\t\tif(lft>vala[i].y)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\td-=vala[i].y-lft;\n\t\t\t\tc=0;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tsort(valb+1,valb+m2+1,cmp);\n\t\tfor(int i=1;i<=m2;i++)\n\t\t{\n\t\t\tif(d+valb[i].x<=0)\n\t\t\t{\n\t\t\t\td+=valb[i].x;\n\t\t\t\tc-=valb[i].y;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint lft=valb[i].x+d;\n\t\t\t\tif(lft>valb[i].y)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tc-=valb[i].y-lft;\n\t\t\t\td=0;\n\t\t\t}\n\t\t}\n\t}\n\tc=max(c,0);\n\td=max(d,0);\n\tcout<<(c+d<=bot?\"YES\":\"NO\")<<endl;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tint _=1;\n\tcin>>_;\n\twhile(_--)\n\t{\n\t\tslove();\n\t}\n\treturn 0;\n}\n```\n\n",
			"tags": [{"name":"杂题选讲"}],
			"title": "2022 暑假杂题选讲",
			"link": "https://exber.qzz.io/post/2022%20%E6%9A%91%E5%81%87%E6%9D%82%E9%A2%98%E9%80%89%E8%AE%B2",
			"date": "2023-03-25 21:56:01"
		},
	
		{
			"abstract": "",
			"content": "有些时候，我们需要合并两棵**动态开点线段树**维护的信息，而一个个枚举插入又太慢了，这时就需要线段树合并的技巧。\n\n假设现在要合并下图中蓝色的线段树和红色的线段树：\n\n![](../post-images/1679752335197.png)\n\n朴素的做法是一个一个叶节点插入，但是考虑**同时在这两棵树上面 dfs**：\n\n![](../post-images/1679752343709.png)\n\n两棵树的**当前位置都有节点**，所以**继续往下递归**：\n\n![](../post-images/1679752354978.png)\n\n两棵树的当前位置都有节点，继续往下递归：\n\n![](../post-images/1679752366285.png)\n\n发现**蓝色线段树当前位置没有节点了**，所以可以**直接把红色线段树当前位置的节点拿来用，并回溯**：\n\n![](../post-images/1679752375911.png)\n\n发现当前位置还没有递归处理完，往右递归：\n\n![](../post-images/1679752387194.png)\n\n发现红色线段树当前位置没有节点了，所以可以直接把蓝色线段树当前位置的节点拿来用，并回溯：\n\n![](../post-images/1679752398753.png)\n\n当前位置**递归处理完了，新建一个节点来保存子树信息，并回溯**：\n\n![](../post-images/1679752407524.png)\n\n发现当前位置还没有递归处理完，往右递归：\n\n![](../post-images/1679752418576.png)\n\n发现蓝色线段树当前位置没有节点了，所以可以直接把红色线段树当前位置的节点拿来用，并回溯：\n\n![](../post-images/1679752474165.png)\n\n当前位置递归处理完了，新建一个节点来保存子树信息，并回溯：\n\n![](../post-images/1679752483094.png)\n\n这样就完成了合并。\n\n总结一下合并的规则：\n\n- **同时在这两棵线段树上面 dfs**；\n\n- 若**当前位置是叶节点，新建一个节点保存合并的信息，并回溯**；\n\n- 若两棵树的**当前位置都有节点，继续往下递归**；\n\n- 若**有一棵树当前位置没有节点了，直接把另一棵树当前位置的节点拿来用，并回溯**；\n\n- 当前位置**递归处理完后，新建一个节点来保存子树信息，并回溯**。\n\n其中除了第二条，其它在图示里面都见过。第二条也很好理解，因为**叶节点无需也没法继续递归下去**。\n\n**将共有 $n$ 个叶子节点的任意多棵线段树以任意顺序合并的时间复杂度是 $O(n\\log n)$ 的**。证明如下：\n\n****\n\n不难发现，**每次 dfs 合并两个节点可以看成丢掉一个节点**，由于总共只有 $n\\log n$ 个节点，所以时间复杂度就是 $O(n\\log n)$ 的。\n\n****\n\n具体代码实现如下：\n\n```cpp\nstruct node\n{\n\tint lson,rson;\n\tint val;\n}tree[500005];\n\nint cnt; // 节点数量（用于动态开点）\n\nint meg(int x,int y)\n{\n\tif(x==0||y==0) return x+y;\n\tif(tree[x].lson==0&&tree[x].rson==0)\n\t{\n\t\tint res=++cnt;\n\t\ttree[res]=tree[x];\n\t\ttree[res].val+=tree[y].val;\n\t\treturn res;\n\t}\n\telse\n\t{\n\t\tint res=++cnt;\n\t\ttree[res].lson=meg(tree[x].lson,tree[y].lson);\n\t\ttree[res].rson=meg(tree[x].rson,tree[y].rson);\n\t\tupd(res);\n\t\treturn res;\n\t}\n}\n```\n\n有些时候空间卡得紧，我们**在合并的时候可以不新建节点，代价是破坏某棵线段树的结构**：\n\n```cpp\nstruct node\n{\n\tint lson,rson;\n\tint val;\n}tree[500005];\n\nint cnt; // 节点数量（用于动态开点）\n\nint meg(int x,int y)\n{\n\tif(x==0||y==0) return x+y;\n\tif(tree[x].lson==0&&tree[x].rson==0)\n\t{\n\t\ttree[x].val+=tree[y].val;\n\t\treturn x;\n\t}\n\telse\n\t{\n\t\ttree[x].lson=meg(tree[x].lson,tree[y].lson);\n\t\ttree[x].rson=meg(tree[x].rson,tree[y].rson);\n\t\tupd(x);\n\t\treturn x;\n\t}\n}\n```\n\n### 练习题目\n\n- [P4556 [Vani有约会]雨天的尾巴 /【模板】线段树合并](https://www.luogu.com.cn/problem/P4556)\n",
			"tags": [{"name":"学习笔记"},{"name":"数据结构"}],
			"title": "线段树合并学习笔记",
			"link": "https://exber.qzz.io/post/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-03-25 21:51:55"
		},
	
		{
			"abstract": "> 给定一个 $n$ 的排列 $p$，求 $n$ 个节点的**有标号有根树**的个数，满足这棵树的**先序遍历结果是 $p$**。先序遍历定义如下：对于 $u$ 的子树，先输出 $u$，然后**按照编号从小到大**遍历 $u$ 的孩子。答案对 $998244353$ 取模，$1\\le n\\le 500$。\n",
			"content": "> 给定一个 $n$ 的排列 $p$，求 $n$ 个节点的**有标号有根树**的个数，满足这棵树的**先序遍历结果是 $p$**。先序遍历定义如下：对于 $u$ 的子树，先输出 $u$，然后**按照编号从小到大**遍历 $u$ 的孩子。答案对 $998244353$ 取模，$1\\le n\\le 500$。\n\n\n赛时开题开错顺序了，应该先做这道题再做 F 的……\n\n可以设 $dp_{l,r}$ 表示 $[l,r]$ 构成一棵树的方案数，$pd_{l,r}$ 表示 $[l,r]$ 构成森林的方案数，那么森林可以通过森林加一棵树来转移，树可以通过一个点下面连森林来转移。\n\n初始状态是 $dp_{l,l}=1$，$pd_{l,l}=1$，$pd_{l+1,l}=1$。前两个很好理解，最后一个则是因为森林可以为空，方便森林包含树的情况。\n\n转移如下：\n\n$dp_{l,r}=pd_{l+1,r}$\n\n$pd_{l,r}=\\sum\\limits_{k=l}^r [p_l<p_{k+1}\\lor k=r]\\times dp_{l,k}\\times pd_{k+1,r}$\n\n最后答案即为 $dp_{l,r}$。\n\n",
			"tags": [{"name":"做题记录"},{"name":"数学"},{"name":"组合计数"},{"name":"DP"}],
			"title": "ABC252G Pre-Order 做题记录",
			"link": "https://exber.qzz.io/post/ABC252G%20Pre-Order%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-25 21:43:31"
		},
	
		{
			"abstract": "",
			"content": "启发式合并是一种神奇的暴力，它经常**用于合并两个只能一个个元素插入的集合**。\n\n假设我们要合并两个集合 $S$ 和 $T$，那么**显然小的集合里元素一个个插入大的集合是更优的。所以启发式合并就是将小集合中元素插入大集合来合并**。\n\n这样做看起来很暴力，但**因为一个元素 $u$ 所属的集合比另一个集合小的话 $u$ 才会被枚举插入，所以 $u$ 被枚举插入集合一次以后，它所在的集合大小至少翻倍**。\n\n所以**启发式合并的时间复杂度是 $O(tn\\log n)$ 的，其中 $t$ 是插入集合的时间复杂度**。\n\n### 练习题目\n\n- [P3302 [SDOI2013] 森林](https://www.luogu.com.cn/problem/P3302)\n\n- [P3201 [HNOI2009] 梦幻布丁](https://www.luogu.com.cn/problem/P3201)\n",
			"tags": [{"name":"学习笔记"},{"name":"小技巧"}],
			"title": "启发式合并学习笔记",
			"link": "https://exber.qzz.io/post/%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-03-25 21:34:38"
		},
	
		{
			"abstract": "",
			"content": "首先不难发现一条路径可以分成深度递减的一段和深度递增的一段：\n\n![](../post-images/1679749134539.png)\n\n为了方便下文描述，我们**称深度递减的那一段为”上升链“，深度递增的那一段为”下降链“**。\n\n不难发现，对于路径 $a\\to b$，**若 $a$ 和 $b$ 不是子孙关系，那么它的上升链为 $a\\to \\operatorname{lca}(a,b)$，下降链为 $\\operatorname{lca}(a,b) \\to b$，否则就只有上升链或下降链 $a\\to b$**。\n\n那么考虑对上升链和下降链分别计算答案，最后加起来：（定义 $dep_u$ 为节点 $u$ 的深度）\n\n- 对于上升链：\n\n  * 因为**起点为 $v$ 的上升链能被 $u$ 观察到当且仅当 $dep_v-dep_u=w_u$，移项得 $dep_v=w_u+dep_u$**；\n  * 所以可以在 dfs 的同时**用 $cnt_i$ 表示满足 $dep_v=i$ 且这条上升链经过 $u$ 的上升链的起点 $v$ 的个数**；\n  * 那么上升链**对 $u$ 的贡献即为 $cnt_{w_u+dep_u}$**。\n\n- 对于下降链：\n\n  * 令 **$stme_v$ 表示这条下降链的开始时间**，因为一个人要跑完上升链才会去跑下降链；\n\n  * 因为起点为 $v$ 的下降链能被 $u$ 观察到当且仅当 $dep_u-dep_v=w_u-stme_v$，移项得 $stme_v-dep_v=w_u-dep_u$；\n  * 所以可以在 dfs 的同时**用 $cnt2_i$ 表示满足 $stme_v-dep_v=i$ 且这条下降链经过 $u$ 的下降链的起点 $v$ 的个数**；\n  * 那么下降链**对 $u$ 的贡献即为 $cnt2_{w_u-dep_u}$**\n\n但是有个问题就是路径 $a\\to b$ 的 $\\operatorname{lca}(a,b)$ 可能会被计算两次，所以**若 $a\\to b$ 既有上升链又有下降链我们就要规定 $\\operatorname{lca}(a,b)$ 包含且仅包含在上升链中**。\n\n还有一个问题就是 $cnt2$ 的下标可能是负数，那么让下标整体加上一个大整数即可。\n\n计算答案的过程还有一个细节，**为了防止其它子树的贡献影响到 $u$ 的子树**，所以需要这样写：\n\n```cpp\nvoid dfs2(int u,int fa)\n{\n\tint tmp=cnt[w[u]+dep[u]],tmp2=cnt2[w[u]-dep[u]+mov]; // 记录下其它子树的贡献\n\tfor(int i=h[u];i;i=nxt[i])\n\t{\n\t\tint v=to[i];\n\t\tif(v==fa)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tdfs2(v,u);\n\t}\n\tfor(int val:st[0][u])\n\t{\n\t\tcnt[val]++;\n\t}\n\tfor(int val:st[1][u])\n\t{\n\t\tcnt[val]--;\n\t}\n\tfor(int val:st2[0][u])\n\t{\n\t\tcnt2[val+mov]++;\n\t}\n\tfor(int val:st2[1][u])\n\t{\n\t\tcnt2[val+mov]--;\n\t}\n\tans[u]=cnt[w[u]+dep[u]]-tmp+cnt2[w[u]-dep[u]+mov]-tmp2; // 容斥获得 u 子树的贡献\n}\n```\n\n",
			"tags": [{"name":"做题记录"},{"name":"杂题"}],
			"title": "P1600 [NOIP2016 提高组] 天天爱跑步 做题记录",
			"link": "https://exber.qzz.io/post/P1600%20%5BNOIP2016%20%E6%8F%90%E9%AB%98%E7%BB%84%5D%20%E5%A4%A9%E5%A4%A9%E7%88%B1%E8%B7%91%E6%AD%A5%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-25 20:58:32"
		},
	
		{
			"abstract": "> 给定一棵树，多组询问，每次询问给定四个点 $a,b,c,d$，求 $a\\to b$ 和 $c\\to d$ 这两条路径是否有交。\n",
			"content": "> 给定一棵树，多组询问，每次询问给定四个点 $a,b,c,d$，求 $a\\to b$ 和 $c\\to d$ 这两条路径是否有交。\n\n有个结论：**若树上两条路径 $a\\to b$ 和 $c\\to d$ 有交，那么令 $\\operatorname{lca}(a,b)=x,\\operatorname{lca}(c,d)=y$，要么 $x$ 在 $c\\to d$ 上，要么 $y$ 在 $a\\to b$ 上**。\n\n****\n\n证明如下：\n\n把 $a,b,x$ 画出来：（写文章时图论编辑器上不去……）\n\n![](../post-images/1679747242222.png)\n\n容易发现，**$x$ 把它的子树“堵住”了，想要进去就必须经过它。但 $a\\to b$ 肯定在 $x$ 的子树内，所以子树外面的链想和 $a\\to b$ 相交就一定要经过 $x$**。\n\n还有一种可能就是 $c\\to d$ 在 $x$ 的子树内，不难发现**此时的情况相当于把 $a\\to b$ 和 $c\\to d$ 这两条路径交换**。\n\n综上，得证。\n\n****\n\n所以根据结论判断即可。**判断一个节点是否在链上可以用这个节点到链两端的长度是否等于链的长度来做**。\n",
			"tags": [{"name":"做题记录"},{"name":"结论"}],
			"title": "P3398 仓鼠找 sugar 做题记录",
			"link": "https://exber.qzz.io/post/P3398%20%E4%BB%93%E9%BC%A0%E6%89%BE%20sugar%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-25 20:10:44"
		},
	
		{
			"abstract": "",
			"content": "### 树上差分\n\n假设要让 $a\\to b$ 的路径上的点都加上一个权值，那么**可以通过维护每个节点到根的权值和 $s_i$**，每次询问就在 $s_a$ 和 $s_b$ 都加上权值，$s_{\\operatorname{lca}(a,b)}$ 和 $s_{\\operatorname{fa}(\\operatorname{lca}(a,b))}$ 减掉权值，最后 dfs 计算一遍即可。\n\n这个技巧有诸多变形，可以通过练习题深入学习。\n\n#### 练习题目\n\n- [P3128 [USACO15DEC]Max Flow P](https://www.luogu.com.cn/problem/P3128)\n\n- [P3258 [JLOI2014]松鼠的新家](https://www.luogu.com.cn/problem/P3258)\n\n- [P8201 生活在树上（hard version）](https://www.luogu.com.cn/problem/P8201)\n\n- [P1600 [NOIP2016 提高组] 天天爱跑步](https://www.luogu.com.cn/problem/P1600)\n\n### 两条路径的交\n\n有个结论：**若树上两条路径 $a\\to b$ 和 $c\\to d$ 有交，那么令 $\\operatorname{lca}(a,b)=x,\\operatorname{lca}(c,d)=y$，要么 $x$ 在 $c\\to d$ 上，要么 $y$ 在 $a\\to b$ 上**。\n****\n证明如下：\n\n把 $a,b,x$ 画出来：（写文章时图论编辑器上不去……）\n\n![](../post-images/1679745664170.png)\n\n容易发现，**$x$ 把它的子树“堵住”了，想要进去就必须经过它。但 $a\\to b$ 肯定在 $x$ 的子树内，所以子树外面的链想和 $a\\to b$ 相交就一定要经过 $x$**。\n\n还有一种可能就是 $c\\to d$ 在 $x$ 的子树内，不难发现**此时的情况相当于把 $a\\to b$ 和 $c\\to d$ 这两条路径交换**。\n\n综上，得证。\n****\n\n#### 练习题目\n\n- [P3398 仓鼠找 sugar](https://www.luogu.com.cn/problem/P3398)\n\n### 点边容斥\n\n树上连通块满足 $\\text{点数}-\\text{边数}=1$。\n\n例题：\n\n> 给定一个 $n$ 个点的无向图，点 $i$ 和 点 $j$ 之间有 $c_{i,j}$ 条互不相同的边。\n>\n> 计算满足以下所有条件的生成树的数量，模 $998244353$：\n>\n> 1. 共有 $K$ 个要求，每个要求给出一个节点子集 $S$，要求生成树在仅保留 $S$ 中的点和它们之间的边时，$S$ 的导出子图仍然连通；\n>\n> $1\\le n\\le 500$。\n\n<details><summary>题解</summary><p>\n\n> 点边容斥，限制相当于点集 $S$ 内（两端点都在点集里）的树边数量 $cnt$ 恰好为 $|S|-1$。注意到有 $cnt\\le |S|-1$，故给边 $(x,y)$ 一个权值表示有多少个限制点集同时包含了 $x$ 和 $y$，问题就转化为最大生成树计数，使用矩阵树定理即可。\n>\n> 注意要判无解。\n\n</p></details>\n",
			"tags": [{"name":"学习笔记"},{"name":"小技巧"}],
			"title": "一些树上问题的小技巧",
			"link": "https://exber.qzz.io/post/%E4%B8%80%E4%BA%9B%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7",
			"date": "2023-03-25 19:58:42"
		},
	
		{
			"abstract": "> 有 $a_i$ 个 $i$（$1\\le i\\le 7$），每次从所有未选的数中等概率随机选出一个，接在最后面，求连续 $7$ 个互不相同的数的组数的期望。\n> \n> $1\\le a_i\\le 10^9$，$\\sum a_i\\le 10^9$。\n",
			"content": "> 有 $a_i$ 个 $i$（$1\\le i\\le 7$），每次从所有未选的数中等概率随机选出一个，接在最后面，求连续 $7$ 个互不相同的数的组数的期望。\n> \n> $1\\le a_i\\le 10^9$，$\\sum a_i\\le 10^9$。\n\n\n看了一下题解才会……\n\n首先设 $S=\\sum\\limits_{i=1}^7a_i$，那么前 $7$ 次施法**按顺序**触发技能的概率为：\n\n$\\dfrac{a_1}{S}\\times\\dfrac{a_2}{S-1}\\times\\dfrac{a_3}{S-2}\\times\\dfrac{a_4}{S-3}\\times\\dfrac{a_5}{S-4}\\times\\dfrac{a_6}{S-5}\\times\\dfrac{a_7}{S-6}$\n\n不过**顺序是不重要的，因为从 $S$ 个元素中选 $7$ 个不同的元素的概率是一样的**。\n\n所以前 $7$ 次施法触发技能的概率为：\n\n$7!\\times\\dfrac{a_1}{S}\\times\\dfrac{a_2}{S-1}\\times\\dfrac{a_3}{S-2}\\times\\dfrac{a_4}{S-3}\\times\\dfrac{a_5}{S-4}\\times\\dfrac{a_6}{S-5}\\times\\dfrac{a_7}{S-6}$\n\n考虑**前 $7$ 次触发技能后的第 $8$ 次施法**，可以枚举第一次施的魔法类型，那么第 $8$ 次施法也触发技能的概率为：\n\n$7!\\times\\dfrac{a_1}{S}\\times\\dfrac{a_2}{S-1}\\times\\dfrac{a_3}{S-2}\\times\\dfrac{a_4}{S-3}\\times\\dfrac{a_5}{S-4}\\times\\dfrac{a_6}{S-5}\\times\\dfrac{a_7}{S-6}\\times\\sum\\limits_{i=1}^7\\dfrac{a_i-1}{S-7}$\n\n容易发现最后那个求和的值为 $1$，也就是说概率不变。\n\n那么答案即为：\n\n$(S-6)\\times7!\\times\\dfrac{a_1}{S}\\times\\dfrac{a_2}{S-1}\\times\\dfrac{a_3}{S-2}\\times\\dfrac{a_4}{S-3}\\times\\dfrac{a_5}{S-4}\\times\\dfrac{a_6}{S-5}\\times\\dfrac{a_7}{S-6}$\n\n也就是：\n\n$7!\\times\\dfrac{a_1}{S}\\times\\dfrac{a_2}{S-1}\\times\\dfrac{a_3}{S-2}\\times\\dfrac{a_4}{S-3}\\times\\dfrac{a_5}{S-4}\\times\\dfrac{a_6}{S-5}\\times a_7$\n\n",
			"tags": [{"name":"做题记录"},{"name":"数学"},{"name":"概率、期望"}],
			"title": "P3802 小魔女帕琪 做题记录",
			"link": "https://exber.qzz.io/post/P3802%20%E5%B0%8F%E9%AD%94%E5%A5%B3%E5%B8%95%E7%90%AA%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-25 16:45:49"
		},
	
		{
			"abstract": "> 求字典序第 $k$ 小的对任意一个 $2\\le i\\le n-1$ 的 $i$ 满足 $p_{i-1}>p_i<p_{i-1}$ 或 $p_{i-1}<p_i>p_{i+1}$ 的 $n$ 的排列 $p$。$1\\le n\\le 20,1\\le k\\le \\text{满足条件的排列数量}$\n",
			"content": "> 求字典序第 $k$ 小的对任意一个 $2\\le i\\le n-1$ 的 $i$ 满足 $p_{i-1}>p_i<p_{i-1}$ 或 $p_{i-1}<p_i>p_{i+1}$ 的 $n$ 的排列 $p$。$1\\le n\\le 20,1\\le k\\le \\text{满足条件的排列数量}$\n\n\n考虑是先上后下还是先下后上，**设 $dp_{n,i}$ 为先上后下，长度为 $n$，$p_1=i$ 的方案数；$pd_{n,i}$ 为先下后上，长度为 $n$，$p_1=i$ 的方案数**。\n\n那么有转移：\n\n$dp_{n,i}=\\sum\\limits_{j=i}^{n-1}pd_{n-1,j}$\n\n$pd_{n,i}=\\sum\\limits_{j=1}^{i-1}dp_{n-1,j}$\n\n即考虑在前面插入数 $i$。\n\n考虑构造答案，显然若 $p_1$ 相同，那么先下后上是更优的。\n\n那么从前往后考虑构造答案即可，不过**构造时要注意编号的变换**。\n\n记得开 `long long`。\n",
			"tags": [{"name":"做题记录"},{"name":"数学"},{"name":"组合计数"},{"name":"DP"}],
			"title": "P7690 [CEOI2002] A decorative fence 做题记录",
			"link": "https://exber.qzz.io/post/P7690%20%5BCEOI2002%5D%20A%20decorative%20fence%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-25 16:44:51"
		},
	
		{
			"abstract": "> 在无向连通图中，若一条边被删除后，图会分成不连通的两部分，则称该边为割边。\n> \n> 求满足如下条件的无向连通图的数量：\n> \n> 1. 由 $n$ 个结点构成，结点有标号。\n> 2. 割边不超过 $m$ 条。\n> 3. 没有重边和自环。\n> \n> 答案对 $10^{9}+7$ 取模。\n> \n> $2≤n≤50,0≤m≤\\dfrac{n(n-1)}{2}$\n",
			"content": "> 在无向连通图中，若一条边被删除后，图会分成不连通的两部分，则称该边为割边。\n> \n> 求满足如下条件的无向连通图的数量：\n> \n> 1. 由 $n$ 个结点构成，结点有标号。\n> 2. 割边不超过 $m$ 条。\n> 3. 没有重边和自环。\n> \n> 答案对 $10^{9}+7$ 取模。\n> \n> $2≤n≤50,0≤m≤\\dfrac{n(n-1)}{2}$\n\n**设 $dp_{n,m}$ 表示 $n$ 个点，$m$ 条割边的连通有标号无向图的数量**，那么可以考虑**枚举 $n$ 所在的强连通分量来转移**。\n\n发现直接转移不好转，所以加一个**辅助数组 $pd_{n,m,k}$ 表示 $n$ 个点，$m$ 条割边，$k$ 个连通块的有标号无向图的数量**，那么 $dp_{n,m}$ 的转移就可以**枚举 $n$ 所在的强连通分量，然后和其它的连通块都连一条边。显然和其它连通块的每条连边都可以贡献一条割边**。\n\n那么有转移：\n\n$$dp_{n,m}=\\sum\\limits_{i=1}^{n-1}\\dbinom{n-1}{i-1}dp_{i,0}\\sum\\limits_{j=1}^{\\min(n-i,m)}pd_{n-i,m-j,j}\\times i^j$$\n\n最后那个 $i^j$ 表示从 $n$ 所在的强连通分量连向 $j$ 个连通块的方案数，注意**在这里我们把这 $j$ 个连通块的大小当成了 $1$**。\n\n接下来考虑 $pd_{n,m,k}$ 的转移，可以**枚举 $n$ 所在的连通块，然后枚举这个连通块里的割边数量**：\n\n$$pd_{n,m,k}=\\sum\\limits_{i=1}^n\\sum\\limits_{j=0}^m\\dbinom{n-1}{i-1}dp_{i,j}\\times pd_{n-i,m-j,k-1}\\times i$$\n\n**最后的 $\\times i$ 是因为之前在转移 $dp$ 时我们把连通块大小当成了 $1$**。\n\n不过还有个问题，$dp_{n,0}$ 无法转移，所以需要**计算出所有有标号无向连通图的数量再减去有割边的有标号无向连通图的数量，即设 $cnt_u$ 为有标号无向连通图的数量，那么 $dp_{n,0}=cnt_u-\\sum\\limits_{i=1}^{n-1}dp_{u,i}$**。\n",
			"tags": [{"name":"做题记录"},{"name":"数学"},{"name":"组合计数"},{"name":"DP"}],
			"title": "P6596 How Many of Them 做题记录",
			"link": "https://exber.qzz.io/post/P6596%20How%20Many%20of%20Them%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-24 16:35:49"
		},
	
		{
			"abstract": "> 一天，他问了小 H 和小 W 这样一个问题：\n> \n> 如果在一个圆上有 $n$ 个不同的点，依次标号为 $1$ 到 $n$，有多少种方案能把它们连成一棵树？\n> \n> 小 H & 小 W：这不是sb题吗？\n> \n> 小 L：那如果**连边不能相交**呢？\n> \n> 小 H & 小 W：这不是sb题吗？\n> \n> 小 L：那如果把「树」换成「图」呢呢？\n> \n> 小 H & 小 W：这不是sb题吗？\n> \n> 小 L：那如果给每个点一个权值 $a_i$，连接 $(i,j)$ 的边权值为 $a_i\\times a_j$，求**满足上面**的图的**期望所有边权值之和**呢？\n> \n> 小 H & 小 W：这不是sb题吗？\n> \n> 小 L 见自己辛苦做了许久都没写出的题目被 dalao 轻松秒杀后十分郁闷。为了安慰他，你需要帮他做出这个问题。\n> \n> **注意**\n> \n> 1. 两条边在端点处**不视作相交**。\n> 2. **没有边的图（即只有 $n$ 个点，之间没有边相连）也合法**\n> 3. 点**按顺时针从 $1$ 到 $n$** 编号。\n> 4. 图中**不能有自环和重边**\n",
			"content": "> 一天，他问了小 H 和小 W 这样一个问题：\n> \n> 如果在一个圆上有 $n$ 个不同的点，依次标号为 $1$ 到 $n$，有多少种方案能把它们连成一棵树？\n> \n> 小 H & 小 W：这不是sb题吗？\n> \n> 小 L：那如果**连边不能相交**呢？\n> \n> 小 H & 小 W：这不是sb题吗？\n> \n> 小 L：那如果把「树」换成「图」呢呢？\n> \n> 小 H & 小 W：这不是sb题吗？\n> \n> 小 L：那如果给每个点一个权值 $a_i$，连接 $(i,j)$ 的边权值为 $a_i\\times a_j$，求**满足上面**的图的**期望所有边权值之和**呢？\n> \n> 小 H & 小 W：这不是sb题吗？\n> \n> 小 L 见自己辛苦做了许久都没写出的题目被 dalao 轻松秒杀后十分郁闷。为了安慰他，你需要帮他做出这个问题。\n> \n> **注意**\n> \n> 1. 两条边在端点处**不视作相交**。\n> 2. **没有边的图（即只有 $n$ 个点，之间没有边相连）也合法**\n> 3. 点**按顺时针从 $1$ 到 $n$** 编号。\n> 4. 图中**不能有自环和重边**\n\n设 $f_i$ 表示有 $i$ 个点的方案，$g_i$ 表示 $i$ 个点并且 $1$ 和 $i$ 之间有连边的方案。显然 $f_i=2g_i$ 因为在 $f_i$ 里 $1$ 和 $i$ 之间那一条边可以连也可以不连。那么答案就是：\n\n$\\sum\\limits_{i=1}^n\\sum\\limits_{j=i+1}^n a_ia_j\\dfrac{g_{j-i+1}g_{n-j+i+1}}{f_n}$\n\n$=\\sum\\limits_{i=1}^n\\sum\\limits_{j=i+1}^n a_ia_j\\dfrac{f_{j-i+1}f_{n-j+i+1}}{4f_n}$\n\n$=\\dfrac{\\sum\\limits_{i=1}^n\\sum\\limits_{j=i+1}^n a_ia_jf_{j-i+1}f_{n-j+i+1}}{4f_n}$\n\n令 $t_i=f_{i+2}f_{n-i}$，那么：\n\n$=\\dfrac{\\sum\\limits_{j=1}^na_j\\sum\\limits_{i=1}^{j-1} a_it_{j-1-i}}{4f_n}$\n\n注意到 $a_0=0$，那么：\n\n$=\\dfrac{\\sum\\limits_{j=1}^na_j\\sum\\limits_{i=0}^{j-1} a_it_{j-1-i}}{4f_n}$\n\n是个卷积的形式，不难求。重点就变成了怎么求 $f$，显然边界是 $f_1=1$。\n\n假设当前知道了 $f_{1\\dots i-1}$，要求 $f_i$，那么令 $j$ 表示 $i$ 连到的最小编号的点，不难发现 $i$ 到 $j$ 这条边把图分成了两个相对独立的部分，所以：\n\n$f_{i}=f_{i-1}+\\sum\\limits_{j=1}^{i-1}g_{i-j+1}f_j$ （注意这里是 $g_{i-j+1}f_{j}$ 因为另一部分不能包含 $i$）\n\n$=f_{i-1}+\\dfrac{\\sum\\limits_{j=1}^{i-1}f_{i-j+1}f_j}{2}$\n\n$=2f_{i-1}+\\sum\\limits_{j=2}^{i-1}f_{i-j+1}f_j$（把 $\\dfrac{f_if_1}{2}$ 移到左边再同时乘 $2$）\n\n是个卷积的形式！但是朴素是 $O(n^2\\log n)$ 的，TLE。\n\n考虑让这个卷积变得更加标准，设 $h_i=f_{i+1}$，那么有：\n\n$h_{i-1}=2h_{i-2}+\\sum\\limits_{j=2}^{i-1}h_{i-j}h_{j-1}$\n\n$h_i=2h_{i-1}+\\sum\\limits_{j=2}^ih_{i+1-j}h_{j-1}$\n\n$=2h_{i-1}+\\sum\\limits_{j=1}^{i-1}h_{i-j}h_j$\n\n如果能带上 $h_0$ 就完美了！\n\n$2h_i=2h_{i-1}+\\sum\\limits_{j=0}^{i-1}h_{i-j}h_j$\n\n$3h_i=2h_{i-1}+\\sum\\limits_{i=0}^ih_{i-j}h_j$（因为 $h_0=f_1=1$）\n\n$h_i=\\dfrac{2}{3}h_{i-1}+\\dfrac{1}{3}\\sum\\limits_{j=0}^ih_{i-j}h_j$\n\n设 $H(x)=\\sum\\limits_{i=0}^{\\inf}h_ix^i$ 即 $h$ 的生成函数，那么有：\n\n$H=\\dfrac{1}{3}H^2+\\dfrac{2}{3}xH+\\dfrac{2}{3}$（加上 $\\dfrac{2}{3}$ 是因为 $h_0$）\n\n$\\dfrac{1}{3}H^2+\\left(\\dfrac{2}{3}x-1\\right)H+\\dfrac{2}{3}=0$\n\n$H=\\dfrac{1-\\frac{2}{3}x\\pm\\sqrt{\\frac{4}{9}x^2-\\frac{4}{3}x+1-\\frac{8}{9}}}{\\frac{2}{3}}$\n\n$=\\dfrac{3-2x\\pm\\sqrt{4x^2-12x+1}}{2}$\n\n因为 $H(0)=1$，所以显然取减号。\n\n$H=\\dfrac{3-2x-\\sqrt{4x^2-12x+1}}{2}$\n\n考虑拆掉根号，我们可以设 $q(x)=4x^2-12x+1,Q(x)=q(x)^{\\frac{1}{2}}$，那么有：\n\n$Q'(x)=\\dfrac{1}{2}q(x)^{-\\frac{1}{2}}q'(x)$（注意链式法则）\n\n$Q'(x)q(x)=\\dfrac{1}{2}q(x)^{\\frac{1}{2}}q'(x)=\\dfrac{1}{2}Q(x)q'(x)$\n\n那么设 $Q(x)=\\sum\\limits_{i=0}^{\\inf} b_ix^i,Q'(x)=\\sum\\limits_{i=0}^{\\inf}b_{i+1}(i+1)x^i$，然后因为 $q(x)=4x^2-12x+1$，所以 $q'(x)=8x-12$，也即是说：\n\n$Q'(x)q(x)=\\left(\\sum\\limits_{i=0}^{\\inf}b_{i+1}(i+1)x^i\\right)4x^2-12x+1$\n\n$=\\sum\\limits_{i=0}^{\\inf}b_{i+1}(i+1)x^i-12b_{i+1}(i+1)x^{i+1}+4b_{i+1}(i+1)x^{i+2}$\n\n$=\\sum\\limits_{i=0}^{\\inf}(b_{i+1}(i+1)-12b_{i}i+4b_{i-1}(i-1))x^i$（假设 $b_{-1}=0$）\n\n$\\dfrac{1}{2}Q(x)q'(x)=\\dfrac{1}{2}\\left(\\sum\\limits_{i=0}^{\\inf}b_ix^i\\right)8x-12$\n\n$=\\sum\\limits_{i=0}^{\\inf}4b_ix^{i+1}-6b_ix^i$\n\n$=\\sum\\limits_{i=0}^{\\inf}(4b_{i-1}-6b_i)x^i$（假设 $b_{-1}=0$）\n\n$\\because Q'(x)q(x)=\\dfrac{1}{2}Q(x)q'(x)$\n\n$\\therefore \\sum\\limits_{i=0}^{\\inf}(b_{i+1}(i+1)-12b_{i}i+4b_{i-1}(i-1))x^i=\\sum\\limits_{i=0}^{\\inf}(4b_{i-1}-6b_i)x^i$\n\n$\\therefore b_{i+1}(i+1)-12b_{i}i+4b_{i-1}(i-1)=4b_{i-1}-6b_i$\n\n解得 $b_{i+1}=\\dfrac{(8-4i)b_{i-1}+(12i-6)b_i}{i+1}$，显然边界时 $b_0=1,b_1=-6$，那么我们就成功去掉了根号。\n\n看回 $H=\\dfrac{3-2x-\\sqrt{4x^2-12x+1}}{2}$ 这条柿子，现在我们知道它等于 $\\dfrac{3-2x-\\sum\\limits_{i=0}^{\\inf} b_ix^i}{2}$，那么我们只需要将 $b$ 全部负过来，$b_0\\to b_0+3$，$b_1\\to b_1-2$，然后对所有 $b$ 除以 $2$，$b$ 就变成了 $h$，我们就求得了 $f$。\n\n\n",
			"tags": [{"name":"做题记录"},{"name":"数学"},{"name":"组合计数"},{"name":"多项式、生成函数"},{"name":"DP"}],
			"title": "P6694 强迫症 做题记录",
			"link": "https://exber.qzz.io/post/P6694%20%E5%BC%BA%E8%BF%AB%E7%97%87%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-24 16:07:02"
		},
	
		{
			"abstract": "> 这个背包最多可以装 $10^5$ 大小的东西\n> \n> 付公主有 $n$ 种商品，她要准备出摊了\n> \n> 每种商品体积为 $v_i$，都有无限件\n> \n> 给定 $m$，对于 $s\\in [1,m]$，请你回答用这些商品恰好装 $s$ 体积的方案数。\n",
			"content": "> 这个背包最多可以装 $10^5$ 大小的东西\n> \n> 付公主有 $n$ 种商品，她要准备出摊了\n> \n> 每种商品体积为 $v_i$，都有无限件\n> \n> 给定 $m$，对于 $s\\in [1,m]$，请你回答用这些商品恰好装 $s$ 体积的方案数。\n\n朴素的做法是 $n$ 个长度为 $m$ 的多项式相乘，时间复杂度为 $O(nm\\log m)$，显然会 TLE\n\n考虑一个物品的生成函数：\n\n$f(x)=\\sum\\limits_{i=0}^{\\inf}[i\\equiv 0\\pmod v]x^i$\n\n$=\\sum\\limits_{i=0}^{\\inf}x^{iv}$\n\n显然这个式子当且仅当 $-1<x<1$ 时收敛，所以我们考虑令 $0<x<1$：\n\n$\\sum\\limits_{i=0}^{\\inf}x^{iv}=\\lim\\limits_{n\\to\\inf}\\dfrac{x^{nv}-1}{x^v-1}$\n\n由于当 $n$ 无限大时 $x^{nv}$ 无限趋近于 $0$，所以：\n\n$\\lim\\limits_{n\\to\\inf}\\dfrac{x^{nv}-1}{x^v-1}=\\dfrac{-1}{x^v-1}=\\dfrac{1}{1-x^v}$\n\n也就是说 $f(x)=\\dfrac{1}{1-x^v}$\n\n我们要求很多个 $f$ 的乘积，那么考虑化乘为加，给 $f(x)$ 取个 $\\ln$，求：\n\n$\\ln f(x)=\\ln(\\dfrac{1}{1-x^v})$\n\n$=-\\ln(1-x^v)$\n\n这个东西不太好求，考虑求导：\n\n$-\\ln'(1-x^v)=-\\dfrac{(1-x^v)'}{1-x^v}$\n\n$=-\\dfrac{1'-(x^v)'}{1-x^v}$\n\n$=-\\dfrac{-vx^{v-1}}{1-x^v}$\n\n$=vx^{v-1}\\dfrac{1}{1-x^v}$\n\n注意到 $\\dfrac{1}{1-x^v}=\\sum\\limits_{i=0}^{\\inf}x^{iv}$，所以：\n\n$=vx^{v-1}\\sum\\limits_{i=0}^{\\inf}x^{iv}$\n\n$=\\sum\\limits_{i=0}^{\\inf}vx^{(i+1)v-1}$\n\n$=\\sum\\limits_{i=1}^{\\inf}vx^{iv-1}$\n\n积分回来：\n\n$\\ln f(x)=\\sum\\limits_{i=1}^{\\inf}\\int vx^{iv-1}dx$\n\n$=\\sum\\limits_{i=1}^{\\inf}\\int \\dfrac{1}{i}ivx^{iv-1} dx$\n\n$=\\sum\\limits_{i=1}^{\\inf}\\dfrac{1}{i}x^{iv}$\n\n好了，我们终于求得了 $f(x)=\\sum\\limits_{i=1}^{\\inf}\\dfrac{1}{i}x^{iv}$。\n\n接下来把它们相加，求 $\\exp$ 即可。\n\n具体的做法是，开一个桶 $t_i$ 存 $v=i$ 的多项式有多少个，然后调和级数搞即可。\n",
			"tags": [{"name":"做题记录"},{"name":"数学"},{"name":"组合计数"},{"name":"多项式、生成函数"}],
			"title": "P4389 付公主的背包 做题记录",
			"link": "https://exber.qzz.io/post/P4389%20%E4%BB%98%E5%85%AC%E4%B8%BB%E7%9A%84%E8%83%8C%E5%8C%85%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-24 16:05:12"
		},
	
		{
			"abstract": "> 小C有一个集合 $S$，里面的元素都是小于 $m$ 的非负整数。他用程序编写了一个数列生成器，可以生成一个长度为 $n$ 的数列，数列中的每个数都属于集合 $S$。  \n> \n> 小C用这个生成器生成了许多这样的数列。但是小C有一个问题需要你的帮助：给定整数 $x$，求所有可以生成出的，且满足数列中所有数的乘积 $\\bmod \\ m$ 的值等于 $x$ 的不同的数列的有多少个。  \n> \n> 小C认为，两个数列 $A$ 和 $B$ 不同，当且仅当 $\\exists i \\text{ s.t. } A_i \\neq B_i$。另外，小C认为这个问题的答案可能很大，因此他只需要你帮助他求出答案对 $1004535809$ 取模的值就可以了。\n",
			"content": "> 小C有一个集合 $S$，里面的元素都是小于 $m$ 的非负整数。他用程序编写了一个数列生成器，可以生成一个长度为 $n$ 的数列，数列中的每个数都属于集合 $S$。  \n> \n> 小C用这个生成器生成了许多这样的数列。但是小C有一个问题需要你的帮助：给定整数 $x$，求所有可以生成出的，且满足数列中所有数的乘积 $\\bmod \\ m$ 的值等于 $x$ 的不同的数列的有多少个。  \n> \n> 小C认为，两个数列 $A$ 和 $B$ 不同，当且仅当 $\\exists i \\text{ s.t. } A_i \\neq B_i$。另外，小C认为这个问题的答案可能很大，因此他只需要你帮助他求出答案对 $1004535809$ 取模的值就可以了。\n\n我们设 $dp_{i,x}$ 表示长度为 $i$，$\\operatorname{mod} m$ 的值为 $x$ 的不同序列的个数。那么有转移：\n\n$dp_{i,x}=\\sum\\limits_{ab\\mod m=x,b\\in S}dp_{i-1,a}$\n\n$=\\sum\\limits_{b\\in S}dp_{i-1,\\frac{x}{b}}$\n\n设 $S'$ 为 $S$ 中所有元素的乘法逆元组成的集合，那么：\n\n$=\\sum\\limits_{b\\in S'}dp_{i-1,bx}$\n\n发现很难求解，此路不通。\n\n注意到”拦路虎“其实是乘法。我们并不会计算多项式的乘法卷积，只会计算多项式的加法卷积，那么我们不妨化乘法为加法，令 $S'=\\{\\log_g(u)|u\\in S\\}$（其中 $g$ 是 $m$ 的一个原根）即可，那么有:\n\n$dp_{i,x}=\\sum\\limits_{b\\in S'}dp_{i-1,x-b\\mod p}$\n\n设 $F_i=[i\\in S']$，那么：\n\n$=\\sum\\limits_{i=0}^xF_idp_{i-1,x-i\\mod p}$\n\n变成了卷积的形式！写得抽象点就是：\n\n$dp_i=F*dp_{i-1}$\n\n$=F^{i-1}*dp_1$\n\n$=F^i$\n\n那么多项式快速幂即可，不过注意到 $F$ 的长度很小，所以 $O(\\log^2)$ 算法也可以被接受。\n\n最后答案即为 $dp_{n,\\log_g(x)}$，有一个细节就是算完卷积后要把后半部分加到前半部分，因为这是循环卷积。并且多项式的长度是 $m-1$。\n",
			"tags": [{"name":"做题记录"},{"name":"数学"},{"name":"组合计数"},{"name":"多项式、生成函数"},{"name":"DP"}],
			"title": "P3321 [SDOI2015]序列统计 做题记录",
			"link": "https://exber.qzz.io/post/P3321%20%5BSDOI2015%5D%E5%BA%8F%E5%88%97%E7%BB%9F%E8%AE%A1%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-24 16:03:31"
		},
	
		{
			"abstract": "> 黑板上有一个整数 $x$，初始时它的值为 $[0,n]$ 中的某一个整数，其中为 $i$ 的概率是 $p_i$\n> \n> 每一轮你可以将 $x$ 完全随机地替换成 $[0,x]$ 中的一个数。\n> \n> 求 $m$ 轮后，对于每个 $i\\in[0,n]$，$x=i$ 的概率。\n> \n> $n \\le 10^5$，$m \\le 10^{18}$，答案对 $998244353$ 取模。\n",
			"content": "> 黑板上有一个整数 $x$，初始时它的值为 $[0,n]$ 中的某一个整数，其中为 $i$ 的概率是 $p_i$\n> \n> 每一轮你可以将 $x$ 完全随机地替换成 $[0,x]$ 中的一个数。\n> \n> 求 $m$ 轮后，对于每个 $i\\in[0,n]$，$x=i$ 的概率。\n> \n> $n \\le 10^5$，$m \\le 10^{18}$，答案对 $998244353$ 取模。\n\n\n设 $f_m(x)$ 表示 $m$ 轮之后数为 $x$ 的答案，$F_m(x)=\\sum\\limits_{i=0}^n f_m(i)x^i$  也就是 $f$ 的生成函数，那么有：\n\n$\\because f_m(x)=\\sum\\limits_{i=x}^n \\dfrac{f_{m-1}(i)}{i+1}$\n\n$\\therefore F_m(x)=\\sum\\limits_{i=0}^nx^i\\sum\\limits_{j=i}^n\\dfrac{f_{m-1}(j)}{j+1}$\n\n$=\\sum\\limits_{i=0}^n \\dfrac{f_{m-1}(i)}{i+1}\\sum\\limits_{j=0}^i x^j$\n\n$=\\sum\\limits_{i=0}^n \\dfrac{f_{m-1}(i)}{i+1}\\dfrac{x^{i+1}-1}{x-1}$\n\n$=\\dfrac{1}{x-1}\\sum\\limits_{i=0}^nf_{m-1}(i)\\dfrac{x^{i+1}-1}{i+1}$\n\n注意到 $\\int x^i dx=\\dfrac{x^{i+1}}{i+1}$，那么：\n\n$=\\dfrac{1}{x-1}\\sum\\limits_{i=0}^nf_{m-1}(i)\\int_1^xt^idt$\n\n$=\\dfrac{1}{x-1}\\sum\\limits_{i=0}^n\\int_1^xf_{m-1}(i)t^idt$\n\n$=\\dfrac{1}{x-1}\\int_1^xF_{m-1}(t)dt$\n\n发现这个定积分很烦，那么考虑设 $G_m(x)=f_m(x+1)=\\sum\\limits_{i=0}^ng_m(i)x^i$，那么有：\n\n$G_m(x)=\\dfrac{1}{x}\\int_1^{x+1}F_{m-1}(t)dt$\n\n$=\\dfrac{0}{x}\\int_0^xF_{m-1}(t+1)d(t+1)$\n\n$=\\dfrac{1}{x}\\int_0^xG_{m-1}(t)dt$\n\n$=\\dfrac{1}{x}\\int_0^xG_{m-1}(t)dt$\n\n$=\\dfrac{1}{x}\\sum\\limits_{i=0}^n\\dfrac{g_{m-1}(i)}{i+1}x^{i+1}$\n\n$=\\sum\\limits_{i=0}^n\\dfrac{g_{m-1}(i)}{i+1}x^{i}$\n\n即 $g_m(i)=\\dfrac{g_{m-1}(i)}{i+1}=\\dfrac{g_1(i)}{(i+1)^{m-1}}$，接下来问题就转变为快速求出 $g_1(i)$，然后根据 $g_m(i)$ 快速求出 $f_m(i)$。\n\n先考虑快速求出 $g_1(i)$：\n\n$\\because G_{1}(x)=F_1(x+1)$\n\n$\\therefore G_1(x)=\\sum\\limits_{i=0}^nf_1(i)(x+1)^i$\n\n注意到 $f_1(i)=p_i$：\n\n$=\\sum\\limits_{i=0}^n p_i(x+1)^i$\n\n根据二项式定理展开整理：\n\n$=\\sum\\limits_{i=0}^np_i\\sum\\limits_{j=0}^i\\dbinom{i}{j}x^j$\n\n$=\\sum\\limits_{i=0}^nx^j\\sum\\limits_{j=i}^n\\dbinom{j}{i}p_j$\n\n也就是说：\n\n$g_1(i)=\\sum\\limits_{j=i}^n\\dbinom{j}{i}p_j$\n\n$=\\sum\\limits_{j=i}^n\\dfrac{p_jj!}{i!(j-i)!}$\n\n$=\\dfrac{1}{i!}\\sum\\limits_{j=i}^n\\dfrac{p_jj!}{(j-i)!}$\n\n根据老套路，我们把 $p$ 反过来，设 $p'_j=p_{n-j}$，那么有：\n\n$=\\dfrac{1}{i!}\\sum\\limits_{j=0}^{n-i}\\dfrac{p'_j(n-j)!}{(n-i-j)!}$\n\n显然可以用卷积快速做。\n\n接下来考虑根据 $g_m(i)$ 求出 $f_m(i)$，与上面十分类似：\n\n$\\because G_m(x)=F_m(x+1)$\n\n$\\therefore F_m(x)=\\sum\\limits_{i=0}^ng_m(i)(x-1)^i$\n\n$=\\sum\\limits_{i=0}^ng_m(i)\\sum\\limits_{j=0}^i\\dbinom{i}{j}x^j(-1)^{i-j}$\n\n$=\\sum\\limits_{i=0}^nx^i\\sum\\limits_{j=i}^ng_m(j)\\dbinom{j}{i}(-1)^{j-i}$\n\n即：\n\n$f_m(i)=\\sum\\limits_{j=i}^ng_m(j)\\dbinom{j}{i}(-1)^{j-i}$\n\n$=\\sum\\limits_{j=i}^n\\dfrac{g_m(j)(-1)^{j-i}j!}{i!(j-i)!}$\n\n$=\\dfrac{1}{i!}\\sum\\limits_{j=i}^ng_m(j)j!\\dfrac{(-1)^{j-i}}{(j-i)!}$\n\n设 $g'_i=g_{n-i}$：\n\n$=\\dfrac{1}{i!}\\sum\\limits_{j=0}^{n-i}g'_m(j)(n-j)!\\dfrac{(-1)^{n-i-j}}{(n-i-j)!}$\n\n显然可以用卷积快速做。\n\n总结一下，首先通过 $p'$ 求出 $g_1(i)$：\n\n$g_1(i)=\\dfrac{1}{i!}\\sum\\limits_{j=0}^{n-i}\\dfrac{p'_j(n-j)!}{(n-i-j)!}$\n\n然后根据 $g_1(i)$ 求出 $g_m(i)$：\n\n$g_m(i)=\\dfrac{g_1(i)}{(i+1)^{m-1}}$\n\n最后根据 $g’_m(i)$ 求出 $f_m(i)$：\n\n$f_m(i)=\\dfrac{1}{i!}\\sum\\limits_{j=0}^{n-i}g'_m(j)(n-j)!\\dfrac{(-1)^{n-i-j}}{(n-i-j)!}$\n\n",
			"tags": [{"name":"做题记录"},{"name":"数学"},{"name":"组合计数"},{"name":"多项式、生成函数"},{"name":"概率、期望"}],
			"title": "CF923E Perpetual Subtraction 做题记录",
			"link": "https://exber.qzz.io/post/CF923E%20Perpetual%20Subtraction%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-24 16:00:43"
		},
	
		{
			"abstract": "> 生成测试数据并非简单的任务！生成大的随机数据通常不能够完全保证解法的正确性。\n> \n> 举个例子，考虑以前 Codeforces round 的一道题。它的输入格式如下：\n> \n> > 第一行是一个整数 $n(1\\leq n \\leq max_n)$ 表示集合的大小，第二行包含 $n$ 个互不相同的整数 $a_1,a_2,\\dots,a_n(1\\leq a_i\\leq max_a)$ 表示集合中的元素，升序排列。\n> \n> 如果你不注意题目的解法，看起来生成一个好的测试数据是非常容易的。令 $n=max_n$，从 $1\\sim max_a$ 中生成 $n$ 个不相同的数，并排序。但是马上你就会知道这不那么简单。\n> \n> 下面是这道题目的真实解法。令 $g$ 为 $a_1,a_2,\\dots,a_n$ 的最大公约数，令 $x=a_n/g-n$，如果 $x$ 是奇数输出 `Alice`，如果 $x$ 是偶数输出 `Bob`\n> \n> 考虑这道题两个错误的解法，它们与正解只在计算 $x$ 中不同。\n> \n> 第一个解法令 $x = a_n/g$ （不减去 $n$）\n> \n> 第二个解法令 $x=a_n-n$（不除以 $g$）\n> \n> 如果一个测试数据令这两个解法**都**输出错误的答案，称这个数据是有趣的。\n> \n> 给定 $max_n, max_a, q$ 求满足限制且有趣的测试数据的数量对 $q$ 取模的结果。\n> \n> $1\\leq max_n\\leq 30000, max_n\\leq max_a\\leq 10^9, 10^4\\leq q\\leq 10^5+129$\n",
			"content": "> 生成测试数据并非简单的任务！生成大的随机数据通常不能够完全保证解法的正确性。\n> \n> 举个例子，考虑以前 Codeforces round 的一道题。它的输入格式如下：\n> \n> > 第一行是一个整数 $n(1\\leq n \\leq max_n)$ 表示集合的大小，第二行包含 $n$ 个互不相同的整数 $a_1,a_2,\\dots,a_n(1\\leq a_i\\leq max_a)$ 表示集合中的元素，升序排列。\n> \n> 如果你不注意题目的解法，看起来生成一个好的测试数据是非常容易的。令 $n=max_n$，从 $1\\sim max_a$ 中生成 $n$ 个不相同的数，并排序。但是马上你就会知道这不那么简单。\n> \n> 下面是这道题目的真实解法。令 $g$ 为 $a_1,a_2,\\dots,a_n$ 的最大公约数，令 $x=a_n/g-n$，如果 $x$ 是奇数输出 `Alice`，如果 $x$ 是偶数输出 `Bob`\n> \n> 考虑这道题两个错误的解法，它们与正解只在计算 $x$ 中不同。\n> \n> 第一个解法令 $x = a_n/g$ （不减去 $n$）\n> \n> 第二个解法令 $x=a_n-n$（不除以 $g$）\n> \n> 如果一个测试数据令这两个解法**都**输出错误的答案，称这个数据是有趣的。\n> \n> 给定 $max_n, max_a, q$ 求满足限制且有趣的测试数据的数量对 $q$ 取模的结果。\n> \n> $1\\leq max_n\\leq 30000, max_n\\leq max_a\\leq 10^9, 10^4\\leq q\\leq 10^5+129$\n\n多项式和最大公因数又有什么关系呢？\n\n哦，目标显然是让 $n$ 为奇数且 $g$ 包含了 $a_n$ 的所有因子 $2$，并且 $a_n$ 是偶数。\n\n那么可以枚举 $g$ 的因子 $2$ 的个数，假设 $g$ 有 $k$ 个因子 $2$，问题就变为求 $a_i\\le \\left\\lfloor\\dfrac{max_a}{2^k}\\right\\rfloor$，$n$ 为奇数且 $a_n$ 为奇数的方案数。\n\n设 $f_{i,j}$ 表示 $n=j$，$a$ 的取值范围为 $[1,i]$ 且 $a_j$ 为偶数的方案数；$g_{i,j}$ 表示 $n=j$，$a$ 的取值范围为 $[1,i]$ 且 $a_j$ 为奇数的方案数。那么我们只要求出 $f$ 的转移方法就能类似地推出 $g$ 的转移方法了。\n\n显然有转移：\n\n$$f_{i,j}=f_{i-1,j}+[i\\operatorname{mod}2=0](f_{i-1,j-1}+g_{i-1,j-1})$$\n\n意思是，我们可以让 $a_j<i$ 或者让 $a_j=i$。\n\n然后换一种转移方式，考虑从取值范围 $[1,x]$ 和取值范围 $[1,y]$ 转移到取值范围 $[1,x+y]$：\n\n$$f_{x+y,i}=\\sum\\limits_{j=0}^{i-1}(f_{x,j}+g_{x,j})([x\\operatorname{mod}2=0]f_{y,i-j}+[x\\operatorname{mod}2=1]g_{y,i-j})$$\n\n意思是，前 $j$ 个数满足 $1\\le a_i\\le x$，后 $i-j$ 个数满足 $x+1\\le a_i\\le x+y$ 且最后一个数是偶数。\n\n边界条件是 $f_{1,1}=0$。\n\n总结一下：\n\n$$\\begin{cases}f_{1,1}=0\\\\f_{i,j}=f_{i-1,j}+[i\\operatorname{mod}2=0](f_{i-1,j-1}+g_{i-1,j-1}+[j=1])\\\\f_{2i,j}=f_{i,j}+\\sum\\limits_{k=0}^{j-1}(f_{i,k}+g_{i,k})([i\\operatorname{mod}2=0]f_{i,j-k}+[i\\operatorname{mod}2=1]g_{i,j-k})\\end{cases}$$\n\n类似地：\n\n$$\\begin{cases}g_{1,1}=1\\\\g_{i,j}=g_{i-1,j}+[i\\operatorname{mod}2=1](f_{i-1,j-1}+g_{i-1,j-1}+[j=1])\\\\g_{2i,j}=g_{i,j}+\\sum\\limits_{k=0}^{j-1}(f_{i,k}+g_{i,k})([i\\operatorname{mod}2=1]f_{i,j-k}+[i\\operatorname{mod}2=0]g_{i,j-k})\\end{cases}$$\n\n然后就可以倍增地边求 $f$ 边求 $g$，求出答案了。\n",
			"tags": [{"name":"做题记录"},{"name":"数学"},{"name":"组合计数"},{"name":"多项式、生成函数"},{"name":"DP"}],
			"title": "CF773F Test Data Generation 做题记录",
			"link": "https://exber.qzz.io/post/CF773F%20Test%20Data%20Generation%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-24 15:28:37"
		},
	
		{
			"abstract": "> 有一排 $n$ 个球，定义一个组可以只包含一个球或者包含两个相邻的球。现在一个球只能分到一个组中，求从这些球中取出  $k$ 组的方案数。\n> \n> $n\\le 10^9$，$k<2^{15}$。\n",
			"content": "> 有一排 $n$ 个球，定义一个组可以只包含一个球或者包含两个相邻的球。现在一个球只能分到一个组中，求从这些球中取出  $k$ 组的方案数。\n> \n> $n\\le 10^9$，$k<2^{15}$。\n\n$$dp_{n,k}=dp_{n-1,k}+dp_{n-1,k-1}+dp_{n-2,k-1}$$\n\n$$dp_{a+b,k}=\\left(\\sum\\limits_{i=0}^k dp_{a,i}dp_{b,k-i}\\right)+\\left(\\sum\\limits_{i=0}^{k-1}dp_{a-1,i}+dp_{b-1,k-1-i}\\right)$$\n\n设 $F_n(x)\\sum\\limits_{k=0}^{\\inf}x^kdp_{n,k}$，那么：\n\n$$F_n(x)=F_{n-1}(x)+xF_{n-1}(x)+xF_{n-2}(x)$$\n\n$$F_{a+b}(x)=(F_a*F_b)(x)+x(F_{a-1}*F_{b-1})(x)$$\n\n那么：\n\n$$F_n(x)=F_{n-1}(x)+xF_{n-1}(x)+xF_{n-2}(x)$$\n\n$$F_{2n}(x)=F_n^2(x)+xF_{n-1}^2(x)$$\n\n$$F_{2n-1}(x)=(F_n*F_{n-1})(x)+x(F_{n-1}*F_{n-2})(x)$$\n\n$$F_{2n-2}(x)=F_{n-1}^2(x)+xF_{n-2}^2(x)$$\n\n",
			"tags": [{"name":"做题记录"},{"name":"数学"},{"name":"组合计数"},{"name":"多项式、生成函数"},{"name":"DP"}],
			"title": "CF755G PolandBall and Many Other Balls 做题记录",
			"link": "https://exber.qzz.io/post/CF755G%20PolandBall%20and%20Many%20Other%20Balls%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-24 15:22:25"
		},
	
		{
			"abstract": "> 对于一个整数序列 $\\{a_1, a_2, \\ldots, a_n\\}$，我们定义它的变换为 $\\{b_1, b_2, \\ldots, b_n\\}$，其中 $b_i = a_1 | a_2 | \\ldots | a_i$，其中 $|$ 表示二进制按位或运算。\n> \n> 现在求有多少个长为 $n$ 的序列 $a$，满足 $1\\leq a_i \\leq 2^k - 1$，使得它的变换 $b$ 是**严格单调递增**的，对 $10^9+7$ 取模。\n> \n> $1\\leq n \\leq 10^{18}$，$1\\leq k \\leq 3 \\times 10^4$。\n",
			"content": "> 对于一个整数序列 $\\{a_1, a_2, \\ldots, a_n\\}$，我们定义它的变换为 $\\{b_1, b_2, \\ldots, b_n\\}$，其中 $b_i = a_1 | a_2 | \\ldots | a_i$，其中 $|$ 表示二进制按位或运算。\n> \n> 现在求有多少个长为 $n$ 的序列 $a$，满足 $1\\leq a_i \\leq 2^k - 1$，使得它的变换 $b$ 是**严格单调递增**的，对 $10^9+7$ 取模。\n> \n> $1\\leq n \\leq 10^{18}$，$1\\leq k \\leq 3 \\times 10^4$。\n\n我们设 $dp_{i,j,0/1}$ 表示序列有 $i$ 个数，当前或和第 $j$ 位（二进制）是 $0/1$ 的方案数\n\n好难转移啊/ll\n\n如果设 $dp_{i,j}$ 表示序列有 $i$ 个数，当前或和为 $j$ 的方案数呢？\n\n那么我们可以枚举 $j$ 的二进制中 $1$ 的个数来转移！\n\n所以说正确的状态应该是 $dp_{i,j}$ 表示序列有 $i$ 个数，当前或和二进制有 $j$ 个 $1$。\n\n推一下柿子：\n\n$dp_{i,j}=\\sum\\limits_{l=0}^j\\dbinom{j}{l}dp_{i-1,l}2^l$\n\n这个柿子的意思是，枚举前 $i-1$ 项的或和有多少个 $1$ 和这些 $1$ 在哪里，然后第 $i$ 项的剩下 $j-l$ 个 $1$ 的位置必须是 $1$，但是 $l$ 个 $1$ 的位置可以是 $0$ 也可以是 $1$。\n\n拆组合数：\n\n$dp_{i,j}=j!\\sum\\limits_{l=0}^j\\dfrac{dp_{i-1,l}2^l}{l!}\\dfrac{1}{(j-l)!}$\n\n考虑换一种转移方式，有：\n\n$dp_{a+b,j}=\\sum\\limits_{l=0}^j \\dbinom{j}{l}dp_{a,l}dp_{b,j-l}2^{bl}$\n\n这个柿子的意思是，枚举前 $a$ 项的或和有多少个 $1$ 和这些 $1$ 在哪里，然后剩下 $b$ 项补足前 $a$ 项没有的 $1$，并且这 $b$ 项的被前 $a$ 项占用的那些位置可以填 $0/1$。\n\n然后拆一下组合数：\n\n$dp_{a+b,j}=j!\\sum\\limits_{l=0}^j\\dfrac{2^{bl}dp_{a,l}}{l!}\\dfrac{dp_{b,j-l}}{(j-l)!}$\n\n也就是说，我们可以这样倍增转移：\n\n$\\begin{cases}dp_{n,i}=i!\\sum\\limits_{j=0}^i\\dfrac{dp_{n-1,j}2^j}{j!}\\dfrac{1}{(i-j)!}\\\\dp_{2n,i}=i!\\sum\\limits_{j=0}^i\\dfrac{2^{nj}dp_{n,j}}{j!}\\dfrac{dp_{n,i-j}}{(i-j)!}\\end{cases}$\n\n好了，用 MTT 优化就行。\n\n",
			"tags": [{"name":"做题记录"},{"name":"数学"},{"name":"组合计数"},{"name":"多项式、生成函数"},{"name":"DP"}],
			"title": "CF623E Transforming Sequence 做题记录",
			"link": "https://exber.qzz.io/post/CF623E%20Transforming%20Sequence%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-24 14:35:23"
		},
	
		{
			"abstract": "> 给定一张 $n$ 个点 $m$ 条边的无重边无自环的有向图，你要从 $1$ 号点到 $n$ 号点去。\n> \n> 如果你在 $t$ 时刻之后到达 $n$ 号点，你要交 $x$ 元的罚款。\n> \n> 每条边从 $a_i$ 到 $b_i$，走过它需要花费 $c_i$ 元，多次走过同一条边需要多次花费。\n> \n> 走过每条边所需的时间是随机的，对于 $k \\in [1,t]$，$\\frac{p_{i,k}}{10^5}$ 表示走过第 $i$ 条边需要时间 $k$ 的概率。因此如果多次走过同一条边，所需的时间也可能不同。\n> \n> 你希望花费尽可能少的钱（花费与罚款之和）到达 $n$ 号点，因此每到达一个点，你可能会更改原有的计划。\n> \n> 求在最优决策下，你期望花费的钱数。\n> \n> $n \\le 50$，$m \\le 100$，$t \\le 2 \\times 10^4$，$x,c_i \\le 10^6$，$\\sum_{k=1}^t p_{i,k} = 10^5$，答案精度误差 $\\le 10^{-6}$。\n",
			"content": "> 给定一张 $n$ 个点 $m$ 条边的无重边无自环的有向图，你要从 $1$ 号点到 $n$ 号点去。\n> \n> 如果你在 $t$ 时刻之后到达 $n$ 号点，你要交 $x$ 元的罚款。\n> \n> 每条边从 $a_i$ 到 $b_i$，走过它需要花费 $c_i$ 元，多次走过同一条边需要多次花费。\n> \n> 走过每条边所需的时间是随机的，对于 $k \\in [1,t]$，$\\frac{p_{i,k}}{10^5}$ 表示走过第 $i$ 条边需要时间 $k$ 的概率。因此如果多次走过同一条边，所需的时间也可能不同。\n> \n> 你希望花费尽可能少的钱（花费与罚款之和）到达 $n$ 号点，因此每到达一个点，你可能会更改原有的计划。\n> \n> 求在最优决策下，你期望花费的钱数。\n> \n> $n \\le 50$，$m \\le 100$，$t \\le 2 \\times 10^4$，$x,c_i \\le 10^6$，$\\sum_{k=1}^t p_{i,k} = 10^5$，答案精度误差 $\\le 10^{-6}$。\n\n\n首先设 $dp_{i,j}$ 表示在 $j$ 时刻开始，从 $i$ 走到 $n$ 的最小花费，那么有：\n\n$\\begin{cases}dp_{n,i}=0&i\\le t\\\\dp_{n,i}=x&i>t\\\\dp_{u,i}=\\min\\limits_{\\text{u -- j -> v}}c_j+\\sum\\limits_{k=1}^t \\dfrac{p_{j,k}}{10^5}dp_{v,i+k}&u\\not=n,i\\le t\\\\dp_{u,i}=\\operatorname{dist}(u,n)+x&u\\not=n,i>t\\end{cases}$\n\n其中 $\\operatorname{dist}(x,y)$ 表示从 $x$ 到 $y$ 的最小花费（路程上的，不算罚款），我们最后需要 $dp_{1,0}$。\n\n由于这不一定是 DAG 而且 dijkstra 不好写所以需要 spfa，然而暴力跑 spfa 是 $O(nmt^2)$ 的，显然不够优。\n\n容易发现，令人讨厌的转移部分显然是 $\\sum\\limits_{k=1}^t \\dfrac{p_{j,k}}{10^5}dp_{v,i+k}$，考虑优化这一部分。\n\n令 $p’_{j,t-k}=\\dfrac{p_{j,k}}{10^5}$，那么原式可化为：\n\n$\\sum\\limits_{k=1}^t p'_{j,t-k}dp_{v,i+k}$\n\n容易发现这是一个卷积的形式，下标和恒为 $t-k+i+k=i+t$，那么式子就变成了：\n\n$(p_j'*dp_v)_{i+t}$\n\n所以优化后的转移为：\n\n$\\begin{cases}dp_{n,i}=0&i\\le t\\\\dp_{n,i}=x&i>t\\\\dp_{u,i}=\\min\\limits_{\\text{u -- j -> v}}c_j+(p_j'*dp_v)_{i+t}&u\\not=n,i\\le t\\\\dp_{u,i}=\\operatorname{dist}(u,n)+x&u\\not=n,i>t\\end{cases}$\n\n跑 spfa 的话时间复杂度为 $O(nmt\\log t)$，但是跑不满，而且有 8S，所以足够通过此题。\n\nspfa 在反向图上跑即可，相当于倒着转移吧。\n",
			"tags": [{"name":"做题记录"},{"name":"数学"},{"name":"组合计数"},{"name":"多项式、生成函数"},{"name":"DP"},{"name":"概率、期望"}],
			"title": "CF553E Kyoya and Train 做题记录",
			"link": "https://exber.qzz.io/post/CF553E%20Kyoya%20and%20Train%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-24 14:25:13"
		},
	
		{
			"abstract": "> 给出一个门限值 $k$ 和两个只包含 $\\texttt{AGCT}$ 四种字符的基因串 $S$ 和 $T$。现在你要找出在下列规则中 $T$ 在 $S$ 中出现了几次。 \n> \n> $T$ 在 $S$ 的第 $i$ 个位置中出现，当且仅当把 $T$ 的首字符和 $S$ 的第 $i$ 个字符对齐后，$T$ 中的每一个字符能够在 $S$ 中找到一个位置偏差不超过 $k$ 的相同字符。\n> \n> 即对于所有的 $j \\in[1,|T|]$，都存在一个 $p \\in [1,|S|]$ 使得 $|(i+j-1)-p| \\leq k$ 且 $S_p=T_j$ 。 \n> \n> 例如 $k=1$ 时，$\\texttt{ACAT}$ 出现在 $\\texttt{AGCAATTCAT}$ 的 $2$ 号， $3$ 号和 $6$ 号位置。 (编号从 $1$ 开始。)\n",
			"content": "> 给出一个门限值 $k$ 和两个只包含 $\\texttt{AGCT}$ 四种字符的基因串 $S$ 和 $T$。现在你要找出在下列规则中 $T$ 在 $S$ 中出现了几次。 \n> \n> $T$ 在 $S$ 的第 $i$ 个位置中出现，当且仅当把 $T$ 的首字符和 $S$ 的第 $i$ 个字符对齐后，$T$ 中的每一个字符能够在 $S$ 中找到一个位置偏差不超过 $k$ 的相同字符。\n> \n> 即对于所有的 $j \\in[1,|T|]$，都存在一个 $p \\in [1,|S|]$ 使得 $|(i+j-1)-p| \\leq k$ 且 $S_p=T_j$ 。 \n> \n> 例如 $k=1$ 时，$\\texttt{ACAT}$ 出现在 $\\texttt{AGCAATTCAT}$ 的 $2$ 号， $3$ 号和 $6$ 号位置。 (编号从 $1$ 开始。)\n\n\n考虑设 $A,C,G,T$ 是四个 $01$ 序列，表示四种字母是否能在 $S$ 的某一位上匹配；设 $A_*,C_*,G_*,T_*$ 是四个 $01$ 序列表示 $T$ 的某一位上是否某种字母。\n\n例如样例中：\n\n$A=\\{1,1,1,1,1,1,0,1,1,1\\}$\n\n$C=\\{0,1,1,1,0,0,1,1,1,0\\}$\n\n$G=\\{1,1,1,0,0,0,0,0,0,0\\}$\n\n$T=\\{0,0,0,0,1,1,1,1,1,1\\}$\n\n$A_*=\\{1,0,1,0\\}$\n\n$C_*=\\{0,1,0,0\\}$\n\n$G_*=\\{0,0,0,0\\}$\n\n$T_*=\\{0,0,0,1\\}$\n\n若某个位置 $S$ 和 $T$ 对应的序列同时为 $1$，那么贡献 $1$，否则贡献 $0$，也就是做乘法。那么匹配当且仅当四种字符的贡献和是串长。\n\n考虑怎么计算每种字符的贡献，显然把 $A$、$C$、$G$、$T$ 倒过来和 $A_*$、$C_*$、$G_*$、$T_*$ 做卷积即可。\n",
			"tags": [{"name":"做题记录"},{"name":"多项式、生成函数"},{"name":"数学"}],
			"title": "CF528D Fuzzy Search 做题记录",
			"link": "https://exber.qzz.io/post/CF528D%20Fuzzy%20Search%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-24 12:44:25"
		},
	
		{
			"abstract": "",
			"content": "### 0x00 基础知识\n\n并查集是一种简单但又不简单的数据结构，它通常用来处理元素分组问题。\n\n先看一道[例题](https://www.luogu.com.cn/problem/P3367):\n\n> $n$ 个元素 $m$ 个操作，初始时每个元素都属于独立的集合。每次操作为合并两个元素所在的集合或询问两个元素是否在一个集合内。\n\n容易发现这道题最大的难点就在于表示元素所在的集合。不妨**设 $fa_u$ 表示 $u$ 的“帮主”，即为代表 $u$ 所在的集合的元素**。那么**初始时显然 $fa_u=u$**。\n\n合并 $x,y$ 所在的集合时，我们**似乎**只需要让两位“帮主”打架，让 $fa_x=fa_y$。\n\n不过手玩一下就会发现这样合并显然是错的。假设现在的情况是这样的：\n\n![](../post-images/1679632729100.png)\n\n合并 $1$ 和 $3$ 之后：\n\n![](../post-images/1679632758861.png)\n\n容易发现，此时 $fa_1$ 并不是 $1$ 所在集合真正的“帮主”。所以**在找 $u$ 所在的集合的“帮主”时我们需要不断让 $u=fa_u$，即不停跳出“小帮派”，直到 $fa_u=u$**。\n\n找“帮主”代码如下：\n\n```cpp\nint fa[200005];\nint fnd(int x)\n{\n    return fa[x]==x?x:fnd(fa[x]);\n}\n```\n\n但是这个找“帮主”算法太慢了，接下来介绍两种优化：\n\n- **路径压缩**\n\n容易发现，我们在**找“帮主”的过程中可以记录下 $u$ 真正的“帮主”**：\n\n```cpp\nint fa[200005];\nint fnd(int x)\n{\n    return fa[x]==x?x:fa[x]=fnd(fa[x]);\n}\n```\n这样优化之后找“帮主”算法的时间复杂度大概是 $O(\\log n)$ 的，证明可以看[这里](https://www.cnblogs.com/Canopus-wym/p/10376053.html)。\n\n**对于一般的题目，这个优化已经够用了**。\n\n- **按轶合并**\n\n若不能路径压缩，那么在合并两个集合时我们可以**将“深度”大的集合合并到“深度”小的集合底下**，其中“深度”表示属于这个集合的元素中找到“帮主”最多需要跳的次数。\n\n- **启发式合并**\n\n可以保存集合的大小，**每次让小的集合的“帮主”被大的集合的“帮主”打败，即让 $fa_{\\text{小集合的“帮主”}}=\\text{大集合的“帮主”}$**。\n\n**这个优化配合上路径压缩之后找“帮主”算法的时间复杂度将被优化到 $\\alpha(n)$，其中 $\\alpha(n)$ 基本不会超过 $4$！**\n\n例题代码如下：（远古代码，将就着看吧）\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <math.h>\n#include <string.h>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cstdio>\nusing namespace std;\n\ntypedef long long lnt;\n\nconst int maxn=1e4+5;\n\nint h[maxn];\n\nint find(int a)\n{\n\tif(h[a]==a)\n\t{\n\t\treturn a;\n\t}\n\tint root=find(h[a]);\n\th[a]=root;\n\treturn root;\n}\n\nint hb(int a,int b)\n{\n\tint ar,br;\n\tar=find(a);\n\tbr=find(b);\n\th[br]=ar;\n}\n\nint is(int a,int b)\n{\n\tif(find(a)==find(b))\n\t{\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tint n,m;\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\th[i]=i;\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x,y,z;\n\t\tcin>>z>>x>>y;\n\t\tif(z==1)\n\t\t{\n\t\t\thb(x,y);\n\t\t}\n\t\telse if(z==2)\n\t\t{\n\t\t\tif(is(x,y))\n\t\t\t{\n\t\t\t\tcout<<\"Y\\n\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout<<\"N\\n\";\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n### 0x01 小技巧\n\n- **保存集合信息**\n\n有些题目需要我们维护集合的某些信息，例如大小，那么就可以**让“帮主”带上这些信息**。\n\n- **边带权**\n\n**有些时候，“帮主”对应着题目中某些特殊的元素，而我们要处理每个元素到它所对应的“帮主”的某些信息，那么我们就可以让并查集的边带上权值，在路径压缩的时候转移即可**。\n\n例如这道[题](https://www.luogu.com.cn/problem/P1196)，就可以维护 $dis_u$ 表示 $u$ 到“帮主”（领队）的距离。\n\n- **拆点**\n\n这个小技巧也是并查集的神奇所在。\n\n有些题目中元素会有多种状态。若有 $k$ 种，则可以**把元素 $i$ 拆成 $k$ 个元素：$i,i+n,i+2n\\dots i+(k-1)n$，这些元素分别代表状态为 $1,2,3\\dots k$ 的 $i$**。\n\n接下来，当得知\n\n> 若 $x$ 状态为 $a$，则 $y$ 状态一定为 $b$；若 $y$ 状态为 $b$，则 $x$ 状态一定为 $a$\n\n这种信息时，就可以**把 $x+(a-1)n$ 和 $y+(b-1)n$ 合并到一个集合里，表示它们是同一种情况**。\n\n这样就**可以通过已知条件求出所有可能的状态，并且若同一个元素的不同状态所代表的元素在一个集合里那么就说明无解**。\n\n例如 [P2024 [NOI2001] 食物链](https://www.luogu.com.cn/problem/P2024) 这题，就可以用 $x,x+n,x+2n$ 分别表示 $x$ 是 $A$、$x$ 是 $B$ 和 $x$ 是 $C$ 的情况。\n\n### 0x02 练习题目\n\n- [P1955 [NOI2015] 程序自动分析](https://www.luogu.com.cn/problem/P1955)\n\n- [P1196 [NOI2002] 银河英雄传说](https://www.luogu.com.cn/problem/P1196)\n\n- [P5937 [CEOI1999]Parity Game](https://www.luogu.com.cn/problem/P5937)\n\n- [P1525 [NOIP2010 提高组] 关押罪犯](https://www.luogu.com.cn/problem/P1525)\n\n- [CF1594D The Number of Imposters](https://www.luogu.com.cn/problem/CF1594D)\n\n- [CF1670C Where is the Pizza?](https://codeforces.com/contest/1670/problem/C)\n",
			"tags": [{"name":"学习笔记"},{"name":"数据结构"}],
			"title": "并查集学习笔记",
			"link": "https://exber.qzz.io/post/%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-03-24 12:38:04"
		},
	
		{
			"abstract": "",
			"content": "NTT 支持取模，没有精度问题，但是有模数限制。\n\nFFT 支持取模，模数没有限制，但是有精度限制。\n\n为了实现任意取模且几乎没有精度限制的多项式乘法，人们发明了 MTT。\n\n[模板题](https://www.luogu.com.cn/problem/P4245)\n\n### 基于 NTT 的实现\n\n显然**结果的实际值不超过 $10^9\\times 10^9\\times 10^5=10^{23}$**，那么我们**可以求出结果模三个满足 $ABC\\ge 10^{23}$ 的质数 $A$、$B$ 和 $C$ 的值，然后用中国剩余定理合并答案**。\n\n但是这种方法**需要 $9$ 次 NTT，常数极其巨大**。\n\n### 基于 FFT 的实现\n\n既然 FFT 有精度限制，那么我们就要想办法**降低运算所需要的精度**。\n\n不难想到，可以**令 $k=\\sqrt p$，$F(x)=kA_1(x)+B_1(x)$，$G(x)=kA_2(x)+B_2(x)$，那么有**：\n\n$$F*G=(kA_1+B_1)(kA_2+B_2)$$\n\n$$=k^2A_1A_2+k(A_1B_2+A_2B_1)+B_1B_2$$\n\n$\\operatorname{DFT}(A_1),\\operatorname{DFT}(A_2),\\operatorname{DFT}(B_1),\\operatorname{DFT}(B_2)$ 再 $\\operatorname{IDFT}(A_1A_2),\\operatorname{IDFT}(A_1B_2+A_2B_1),\\operatorname{DFT}(B_1B_2)$ 即可，共需 $7$ 次 FFT。\n\n可以再快点吗？\n\n当然可以！但是**太过复杂不便于记忆，而且优化效果貌似不够明显**，所以以后再补坑吧。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\nconst long long MS=500005;\nconst long double PI=acos(-1);\n\nstruct plex\n{\n    long double x,y;\n    plex(long double a=0,long double b=0) {x=a,y=b;}\n};\nplex operator+(plex a,plex b) {return plex(a.x+b.x,a.y+b.y);}\nplex operator-(plex a,plex b) {return plex(a.x-b.x,a.y-b.y);}\nplex operator*(plex a,plex b) {return plex(a.x*b.x-a.y*b.y,a.x*b.y+b.x*a.y);}\n\ninline int getlen(int n)\n{\n    int res=1;\n    while(res<n) res<<=1;\n    return res;\n}\nint p_rev[MS],p_rev_lstn;\ninline void FFT(int n,plex a[],int tpe)\n{\n    if(p_rev_lstn!=n)\n    {\n        p_rev_lstn=n;\n        for(int i=0;i<n;i++) p_rev[i]=(p_rev[i>>1]>>1)|((i&1)?n>>1:0);\n    }\n    for(int i=0;i<n;i++) if(p_rev[i]<i) swap(a[p_rev[i]],a[i]);\n    for(int mid=1;mid<n;mid<<=1)\n    {\n        int len=mid<<1;\n        plex Wn=plex(cos(2*PI/len),tpe*sin(2*PI/len));\n        for(int l=0;l<n-len+1;l+=len)\n        {\n            plex Wk=plex(1,0);\n            for(int k=0;k<mid;k++,Wk=Wk*Wn)\n            {\n                plex x=a[l+k],y=Wk*a[l+mid+k];\n                a[l+k]=x+y,a[l+mid+k]=x-y;\n            }\n        }\n    }\n}\ninline void DFT(int n,plex a[]) {FFT(n,a,1);}\ninline void IDFT(int n,plex a[])\n{\n    FFT(n,a,-1);\n    for(int i=0;i<n;i++) a[i].x/=n,a[i].y/=n;\n}\nplex A1[MS],B1[MS],A2[MS],B2[MS];\nplex p_mul_tmp1[MS],p_mul_tmp2[MS],p_mul_tmp3[MS];\ninline void PMUL(int n,int m,int resn,int F[],int G[],int res[],int p)\n{\n\tint len=getlen(n+m);\n\tint k=ceil(sqrt(p));\n\tfor(int i=0;i<n;i++) A1[i].x=F[i]/k,B1[i].x=F[i]%k;\n\tfor(int i=0;i<m;i++) A2[i].x=G[i]/k,B2[i].x=G[i]%k;\n\tDFT(len,A1),DFT(len,A2),DFT(len,B1),DFT(len,B2);\n\tfor(int i=0;i<len;i++) p_mul_tmp1[i]=A1[i]*A2[i],p_mul_tmp2[i]=A1[i]*B2[i]+A2[i]*B1[i],p_mul_tmp3[i]=B1[i]*B2[i];\n\tIDFT(len,p_mul_tmp1),IDFT(len,p_mul_tmp2),IDFT(len,p_mul_tmp3);\n\tfor(int i=0;i<resn;i++)\n\t{\n\t\tint x=(long long)(p_mul_tmp1[i].x+0.5)%p,y=(long long)(p_mul_tmp2[i].x+0.5)%p,z=(long long)(p_mul_tmp3[i].x+0.5)%p;\n\t\tres[i]=((1ll*k*k%p*x%p+1ll*k*y%p)%p+z)%p;\n\t}\n\tfor(int i=0;i<len;i++) A1[i]=A2[i]=B1[i]=B2[i]=p_mul_tmp1[i]=p_mul_tmp2[i]=p_mul_tmp3[i]=plex();\n}\n\nint n,m,p;\nint F[MS],G[MS],res[MS]; \n\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&p);\n\tn++;\n\tm++;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d\",&F[i]);\n\t\tF[i]=(F[i]%p+p)%p;\n\t}\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tscanf(\"%d\",&G[i]);\n\t\tG[i]=(G[i]%p+p)%p;\n\t}\n\tPMUL(n,m,n+m-1,F,G,res,p);\n\tfor(int i=0;i<n+m-1;i++)\n\t{\n\t\tprintf(\"%d \",res[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"学习笔记"},{"name":"数学"},{"name":"组合计数"},{"name":"多项式、生成函数"}],
			"title": "任意模数快速傅里叶变换（MTT）学习笔记",
			"link": "https://exber.qzz.io/post/%E4%BB%BB%E6%84%8F%E6%A8%A1%E6%95%B0%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%EF%BC%88MTT%EF%BC%89%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-03-24 12:33:01"
		},
	
		{
			"abstract": "> 给出一个长度为n的序列 $a_1,a_2...a_n$。求构造出一个序列 $i_1 < i_2 < ... < i_k(1\\le{k}\\le{n})$ 使得 $a_{i_1}\\&a_{i_2}\\&...\\&a_{i_k}=0$。求方案数模 $10^9+7$。\n> \n> 也就是从$\\{a_i\\}$ 里面选出一个非空子集使这些数按位与起来为0。\n",
			"content": "> 给出一个长度为n的序列 $a_1,a_2...a_n$。求构造出一个序列 $i_1 < i_2 < ... < i_k(1\\le{k}\\le{n})$ 使得 $a_{i_1}\\&a_{i_2}\\&...\\&a_{i_k}=0$。求方案数模 $10^9+7$。\n> \n> 也就是从$\\{a_i\\}$ 里面选出一个非空子集使这些数按位与起来为0。\n\n\n首先记 $x$“包含”$y$ 当且仅当 $x\\&y=y$，那么可以用 $dp_i$ 表示按位与和包含 $i$ 的最长子序列长度，有转移 $dp_{i-2^j}\\to dp_{i-2^j}+dp_{i}$，其中 $i$ 包含 $2^j$。边界是 $dp_{a_i}=1$。\n\n```cpp\nscanf(\"%d\",&n);\nfor(int i=1;i<=n;i++)\n{\n\tscanf(\"%d\",&a[i]);\n\tdp[a[i]]++;\n}\nfor(int j=0;j<=25;j++) // 注意转移顺序，要先枚举 j 再枚举 i，要不然会算重\n{\n\tfor(int i=1;i<=1000002;i++)\n\t{\n\t\tif((i>>j)&1)\n\t\t{\n\t\t\tdp[i^(1<<j)]=dp[i^(1<<j)]+dp[i];\n\t\t}\n\t}\n}\n```\n\n考虑答案的求解，令 $pd_i$ 表示与和包含 $i$ 的子序列个数，显然有 $pd_i=2^{dp_i}-1$。试着用容斥求出答案，令 $g_i$ 表示所有满足 $j$ 的二进制中有 $i$ 个 $1$ 的 $pd_j$ 的和，答案即为 $g_0-g_1+g_2-g_3+g_4-g_5+\\dots$\n\n完整代码：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int mod=1000000007;\n\nint n,a[1000005];\nint bse[1000005],dp[1000005],g[30];\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tdp[a[i]]++;\n\t}\n\tfor(int j=0;j<=25;j++) // 注意转移顺序，要先枚举 j 再枚举 i，要不然会算重\n\t{\n\t\tfor(int i=1;i<=1000002;i++)\n\t\t{\n\t\t\tif((i>>j)&1)\n\t\t\t{\n\t\t\t\tdp[i^(1<<j)]=dp[i^(1<<j)]+dp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbse[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tbse[i]=2ll*bse[i-1]%mod;\n\t}\n\tfor(int i=0;i<=1000002;i++)\n\t{\n\t\tint cnt=0;\n\t\tfor(int j=0;j<=25;j++)\n\t\t{\n\t\t\tcnt+=(i>>j)&1;\n\t\t}\n\t\tg[cnt]=((long long)g[cnt]+bse[dp[i]]-1+mod)%mod; // 长度为 dp[i] 的序列里取子序列有 2^dp[i]-1 种方案 \n\t}\n\tint ans=g[0];\n\tfor(int i=1;i<=25;i++)\n\t{\n\t\tif(i&1)\n\t\t{\n\t\t\tans=(ans-g[i]+mod)%mod;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tans=(ans+g[i])%mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"做题记录"},{"name":"组合计数"},{"name":"DP"}],
			"title": "CF449D Jzzhu and Numbers 做题记录",
			"link": "https://exber.qzz.io/post/CF449D%20Jzzhu%20and%20Numbers%20%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95",
			"date": "2023-03-23 16:38:16"
		},
	
		{
			"abstract": "",
			"content": "有了 NTT，就有了多项式全家桶……\n\n首先要感谢 @[command_block](https://www.luogu.com.cn/user/58705) 的文章[《NTT 与多项式全家桶》](https://www.luogu.com.cn/blog/command-block/ntt-yu-duo-xiang-shi-quan-jia-tong)以及 @[Epsilon_Cube](https://www.luogu.com.cn/user/372983)、@[MoYuFang](https://www.luogu.com.cn/user/474113) 和 @[_Diu_](https://www.luogu.com.cn/user/310802) 给予我的许多帮助。\n\n因为板子在不断修 bug，所以代码最后统一放。\n\n### 前置芝士\n\n- **多项式的各种运算是怎么定义的**\n\n由于我们只知道多项式加法和多项式乘法，但是这已经够了。所以**所有的多项式运算都是用多项式加法和乘法定义的**。\n\n- **次数界**\n\n很多时候我们只对多项式 $f$ 的前 $n$ 项感兴趣（这时往往 $f$ 会有无限项），所以需要在 $\\pmod{x^n}$ 的意义下运算。\n\n由于多项式加法和多项式乘法的结果只会从低次项向高次项贡献，所以有：\n\n$$\n\\begin{aligned}\nF(x)\\operatorname{mod}{x^n}+G(x)\\operatorname{mod}{x^n}&\\equiv F(x)+G(x)&\\pmod{x^n}\\\\\nF(x)\\operatorname{mod}{x^n}\\cdot G(x)\\operatorname{mod}{x^n}&\\equiv F(x)G(x)&\\pmod{x^n}\\\\\n\\end{aligned}\n$$\n\n即我们**可以在有次数界的情况下定义所有多项式运算**。\n\n- [简单微积分](https://zhuanlan.zhihu.com/p/94592123)\n\n### 一些记号\n\n- $[x^i]F(x)$：多项式 $F(x)$ 的 $i$ 次项的系数，**即 $x^i$ 的系数**；\n- $F_R(x)$：$n$ 次多项式的翻转 $F_R(x)=x^nF(\\frac{1}{x})$，**显然 $F_R(x)$ 的系数是 $F(x)$ 的系数的翻转**；\n- $F^{(n)}(x)$：**多项式 $F(x)$ 的 $n$ 阶导数**，即对 $F(x)$ 求导 $n$ 次的结果；\n\n### 多项式求导和积分\n\n定义多项式的求导：\n$$\nF^\\prime(x)=\\sum\\limits_{i=0}^{n-1} a_{i+1}(i+1)x^{i}\n$$\n\n定义多项式的积分（不定积分）：\n\n$$\n\\int F(x)\\,dx=C+\\sum\\limits_{i=1}^{n} \\dfrac{a_{i-1}x^{i}}{i}\n$$\n\n同样的，**多项式求导和积分也是互为逆操作**。\n\n### 多项式牛顿迭代\n\n这是一个比较重要的知识，有了它，就可以无脑推多项式各种操作的递推式了。\n\n> **形式：已知函数 $G$ 满足 $G(F(x))=0$，求 $F(x)\\operatorname{mod} x^n$。**\n\n实践中 $G$ 一般较为手动构造的简单函数。 \n\n> **结论：$F(x)\\equiv F_*(x)-\\dfrac{G(F_*(x))}{G'(F_*(x))}\\pmod{x^n}$，其中 $F_*(x)\\equiv F(x)\\pmod{x^{\\frac{n}{2}}}$，注意 $[x^0]G(F(x))=0$ 的解要单独求出。**\n\n和一般的牛迭十分相似，但是次数每次翻倍。证明如下：\n\n> 假设目前已经求出了 $F_*(x)$，考虑 $G(F(x))$在 $F_*(x)$ 处的泰勒展开：\n> $$\n> \\sum\\limits_{i=0}^{\\infin} \\frac{G^{(i)}(F_*(x))}{i!}(F(x)-F_*(x))^i\\equiv0\\pmod{x^n}\n> $$\n> 注意到 $F(x)-F_*(x)$ 的最低系数非 $0$ 项至少是 $x^{\\frac{n}{2}}$，那么对于所有 $i\\ge2$ 的 $i$ 都有 $(F(x)-F_*(x))^i\\equiv 0\\pmod{x^n}$，所以：\n> $$\n> \\begin{aligned}\n> G(F_*(x))+G'(F_*(x))(F(x)-F_*(x))&\\equiv0&\\pmod{x^n}\\\\\n> F(x)&\\equiv F_*(x)-\\frac{G(F_*(x))}{G'(F_*(x))}&\\pmod{x^n}\\\\\n> \\end{aligned}\n> $$\n> 证毕。\n\n### 多项式乘法逆\n\n[P4238 【模板】多项式乘法逆](https://www.luogu.com.cn/problem/P4238)\n\n假设已经求出了 $B_*(x)F(x)\\equiv 1\\pmod{x^{\\frac{n}{2}}}$，现在要求 $B(x)F(x)\\equiv1\\pmod{x^n}$，那么有：\n\n$$\n\\begin{aligned}\nG(B(x))=\\frac{1}{B(x)}-F(x)\\equiv 0\\pmod{x^n}\n\\end{aligned}\n$$\n\n则可以直接套牛顿迭代：\n$$\n\\begin{aligned}\nB(x)&\\equiv B_*(x)-\\frac{G(B_*(x))}{G'(B_*(x))}&\\pmod{x^n}\\\\\nB(x)&\\equiv B_*(x)-\\frac{\\frac{1}{B_*(x)}-F(x)}{-\\frac{1}{B_*^2(x)}}&\\pmod{x^n}\\\\\nB(x)&\\equiv B_*(x)+B_*(x)-B_*^2F(x)&\\pmod{x^n}\\\\\nB(x)&\\equiv 2B_*(x)-B_*^2F(x)&\\pmod{x^n}\\\\\n\\end{aligned}\n$$\n那么就可以做了，$[x^0]B(x)$ 需要求一次乘法逆元，时间复杂度为 $T(n)=T(\\frac{n}{2})+O(n\\log n)=O(n\\log n)$。\n\n不过还有个优化，注意到 NTT 的过程代入的是单位根，所以求的实际上是循环卷积：\n\n$$\nF(x)G(x)=\\sum\\limits_{k=0}^mx^k\\sum\\limits_{i+j\\mod m=k} f_ig_j\n$$\n观察倍增式子：\n\n$$\nB(x)\\equiv 2B_*(x)-B_*^2(x)F(x)\\pmod{x^n}\n$$\n\n需要用到乘法的只有 $B_*^2(x)F(x)$。\n\n先计算 $B_*(x)F(x)$，它们的次数分别是 $\\dfrac{len}{2}$ 和 $len$。\n\n**由于结果的第一项为 $1$，这个 $1$ 后面的 $\\dfrac{len}{2}-1$ 项都为 $0$，所以长度为 $len$ 的循环卷积只会破坏前面的 $1$ 和 $0$**。\n\n最后乘上一个 $B_*(x)$ 即可，此时循环卷积只会破坏前 $\\dfrac{len}{2}$ 项。\n\n### 多项式开根\n\n[P5205 【模板】多项式开根](https://www.luogu.com.cn/problem/P5205)\n\n[P5277 【模板】多项式开根（加强版）](https://www.luogu.com.cn/problem/P5277)\n\n假设已经求出了 $B_*^2(x)\\equiv F(x)\\pmod{x^{\\frac{n}{2}}}$，现在要求 $B(x)^2\\equiv F(x)\\pmod{x^n}$，那么有：\n\n$$\nG(B(x))=B^2(x)-F(x)\\equiv 0\\pmod{x^n}\n$$\n\n直接套牛迭：\n$$\n\\begin{aligned}\nB(x)&\\equiv B_*(x)-\\frac{G(B_*(x))}{G'(B_*(x))}&\\pmod{2^n}\\\\\nB(x)&\\equiv B_*(x)-\\frac{B_*^2(x)-F(x)}{2B_*(x)}&\\pmod{2^n}\\\\\nB(x)&\\equiv \\frac{2B_*(x)^2-B_*^2(x)+F(x)}{2B_*(x)}&\\pmod{2^n}\\\\\nB(x)&\\equiv \\frac{B_*^2(x)+F(x)}{2B_*(x)}&\\pmod{2^n}\\\\\n\\end{aligned}\n$$\n\n\n最后 $[x^0]B(x)$ 需要求一次二次剩余，可以用 BSGS/exBSGS 求单位根的高次同余方程来求解，再加上一个求逆，一个乘法，一个加法就做完了。\n\n时间复杂度为 $T(n)=T(\\frac{n}{2})+O(n\\log n)=O(n\\log n)$。\n\n### 多项式 $\\ln$\n\n[P4725 【模板】多项式对数函数（多项式 ln）](https://www.luogu.com.cn/problem/P4725)\n$$\n\\ln(A(x))\\equiv B(x)\\pmod{x^n}\n$$\n\n两边同时求导，得：\n\n$$\n\\ln'(A(x))A'(x)\\equiv B'(x)\\pmod{x^n}\n$$\n\n注意到 $\\ln'(x)=\\dfrac{1}{x}$，所以：\n\n$$\n\\dfrac{A'(x)}{A(x)}\\equiv B'(x)\\pmod{x^n}\n$$\n\n再积分回来：\n\n$$\nB(x)\\equiv \\int \\dfrac{A'(x)}{A(x)}dx\\pmod{x^n}\n$$\n\n所以一个求导，一个逆元，一个乘法，一个积分即可。\n\n注意由于 $[x^0]A(x)=1$，所以有 $[x^0]B(x)=0$。并且若 $[x^0]A(x)\\not=1$ 则无法求 $\\ln$ 因为求不出模意义下的 $\\ln([x^0]A(x))$。\n\n时间复杂度 $O(n\\log n)$。\n\n### 多项式 $\\exp$\n\n[P4726 【模板】多项式指数函数（多项式 exp）](https://www.luogu.com.cn/problem/P4726)\n\n$$\nB(x)\\equiv \\exp(A(x))\\pmod{x^n}\n$$\n\n我们设 $G(F(x))=\\ln(F(x))-A(x)$，那么显然 $G(B(x))\\equiv0\\pmod{x^n}$，可以使用牛顿迭代了。\n\n回忆牛迭式子：$F(x)\\equiv F_*(x)-\\dfrac{G(F_*(x))}{G'(F_*(x))}\\pmod{x^n}$\n\n显然，这里的 $G'(F(x))=\\dfrac{1}{F(X)}$，那么假设我们已经求出了 $B_*(x)\\equiv \\exp(A(x))\\pmod{x^{\\frac{n}{2}}}$，有：\n\n$$\n\\begin{aligned}\nB(x)&\\equiv B_*(x)-G(B_*(x))B_*(x)&\\pmod{x^n}\\\\\nB(x)&\\equiv B_*(x)-(\\ln(B_*(x))-A(x))B_*(x)&\\pmod{x^n}\\\\\nB(x)&\\equiv (1-\\ln(B_*(x))+A(x))B_*(x)&\\pmod{x^n}\\\\\n\\end{aligned}\n$$\n\n所以倍增求即可。\n\n注意由于 $[x^0]A(x)=0$，所以有 $[x^0]B(x)=1$。并且若 $[x^0]A(x)\\not=0$ 则无法求 $\\exp$ 因为求不出模意义下的 $\\exp([x^0]A(x))$。\n\n时间复杂度为 $T(n)=T(\\frac{n}{2})+O(n\\log n)=O(n\\log n)$。\n\n### 多项式快速幂\n\n[P5245 【模板】多项式快速幂](https://www.luogu.com.cn/problem/P5245)\n\n观察到 $(A(x))^k=\\exp(k\\ln(A(x)))$，所以一个 $\\ln$，一个逐项乘法，一个 $\\exp$ 就做完了。\n\n[P5273 【模板】多项式幂函数（加强版）](https://www.luogu.com.cn/problem/P5273)\n\n这题和上一题的区别在于有 $A_0\\not=1$ 的情况，这时我们就没办法求 $\\ln$ 和 $\\exp$ 了。\n\n但是 $A_0\\not=1$ 没关系，我们可以**让所有项都乘上 $\\dfrac{1}{A_0}$，最后再都乘上 $A_0^k$** 即可。\n\n遇到 $A_0=0$ 的情况也没关系，把系数往前移，求出答案后再移回去即可。不过**要注意原来前面 $cnt$ 个 $0$ 在做幂运算后会变成 $cnt\\times k$ 个 $0$**。\n\n### 多项式带余除法\n\n[P4512 【模板】多项式除法](https://www.luogu.com.cn/problem/P4512)\n\n发现余数很烦，所以我们想办法去掉它。\n\n舍弃多项式的项的方法是一般是加上次数界，但注意到次数界只能舍弃高次，所以**考虑把多项式的系数反过来搞**。\n\n那么回到题目的式子：\n\n$$\nF(x)=Q(x)G(x)+R(x)\n$$\n\n其中 $F$ 是 $n$ 次多项式（已知），$G$ 是 $m$ 次多项式（已知），$Q$ 是 $n-m$ 次多项式（未知），$R$ 是 $m-1$ 次多项式（未知）。\n\n换元，有：\n\n$$\nF(\\frac{1}{x})=Q(\\frac{1}{x})G(\\frac{1}{x})+R(\\frac{1}{x})\n$$\n\n同乘 $x^n$，有:\n\n$$\nx^nF(\\frac{1}{x})=x^nQ(\\frac{1}{x})G(\\frac{1}{x})+x^nR(\\frac{1}{x})\n$$\n\n发现 $x^nF(\\frac{1}{x})=F_R(x)$，$x^nQ(\\frac{1}{x})G(\\frac{1}{x})=Q_R(x)G_R(x)$，$x^nR(\\frac{1}{x})=x^{n-m+1}R_R(x)$，所以有：\n\n$$\nF_R(x)=Q_R(x)G_R(x)+x^{n-m+1}R_R(x)\n$$\n\n那么我们机智地加上次数界，$\\operatorname{mod}$ 上 $x^{n-m+1}$，就有：\n\n$$\nF_R(x)\\equiv Q_R(x)G_R(x)\\pmod{x^{n-m+1}}\n$$\n\n那么就可以求出 $Q_R(x)$ 了，系数反过来就是 $Q(x)$，然后即可用乘法和减法求出 $R(x)$，时间复杂度 $O(n\\log n)$。\n\n### 完整模板\n\n包括多项式多点求值、多项式快速插值。\n\n<details><summary>展开</summary><p>\n\n```cpp\nconst int p=998244353,ginv=332748118;\n\ninline void add(int &x,int y)\n{\n\tx+=y;\n\tif(x>=p) x-=p;\n}\ninline int gcd(int a,int b)\n{\n\tint t=a%b;\n\twhile(t!=0) a=b,b=t,t=a%b;\n\treturn b;\n}\ninline int qpow(int x,int y)\n{\n\tint res=1;\n\tfor(;y>0;y>>=1) res=((y&1)?1ll*res*x%p:res),x=1ll*x*x%p;\n\treturn res;\n}\ninline int exBSGS(int a,int b,int p)\n{\n\ta%=p,b%=p;\n\tif(b==1||p==1) return 0;\n\tint cnt=0,val=1;\n\twhile(1)\n\t{\n\t\tint d=gcd(a,p);\n\t\tif(d==1) break;\n\t\tif(b%d!=0) return -1;\n\t\tp/=d;\n\t\tb/=d;\n\t\tval=1ll*val*(a/d)%p;\n\t\tcnt++;\n\t\tif(val==b) return cnt;\n\t}\n\tmap<int,int> mp;\n\tint val2=1,t=sqrt(p)+1;\n\tfor(int B=1;B<=t;B++)\n\t{\n\t\tval2=1ll*val2*a%p;\n\t\tmp[1ll*b*val2%p]=B;\n\t}\n\tint cur=val;\n\tfor(int A=1;A<=t;A++)\n\t{\n\t\tcur=1ll*cur*val2%p;\n\t\tif(mp.find(cur)!=mp.end()) return A*t-mp[cur]+cnt;\n\t}\n\treturn -1;\n}\ninline int mosqrt(int x)\n{\n\tint bse=exBSGS(3,x,p);\n\tif(bse==-1||(bse&1)) return -1;\n\treturn qpow(3,bse/2);\n}\nnamespace PLOY\n{\n\tconst int MS=5000005;\n\n\ttypedef vector<int> ploy;\n\t\n\tinline ploy operator+(ploy a,ploy b);\n\tinline ploy operator+(ploy a,int b);\n\tinline ploy operator+(int a,ploy b);\n\t\n\tinline ploy operator-(ploy a,ploy b);\n\tinline ploy operator-(ploy a,int b);\n\tinline ploy operator-(int a,ploy b);\n\t\n\tinline ploy operator*(int b,ploy a);\n\tinline ploy operator*(ploy a,int b);\n\tinline ploy operator*(int b,ploy a);\n\t\n\tinline ploy inv(ploy a);\n\tinline ploy dao(ploy a);\n\tinline ploy jif(ploy a);\n\tinline ploy ln(ploy a);\n\tinline ploy exp(ploy a);\n\tinline ploy pow(ploy a,int b);\n\tinline ploy pow2(ploy a,int b,int b2); // b%p b2%(p-1)\n\t\n\tinline void divi(ploy a,ploy b,ploy &res,ploy &r);\n\tinline ploy operator%(ploy a,ploy b);\n\t\n\tinline vector<int> getval(ploy a,vector<int> x);\n\tinline ploy getploy(vector<int> x,vector<int> y);\n\t\n\tint p_rev[MS],p_rev_lstn;\n\tint p_tmpinv[MS];\n\tinline int getlen(int n)\n\t{\n\t\tint res=1;\n\t\twhile(res<n) res<<=1;\n\t\treturn res;\n\t}\n\tinline void NTT(ploy &a,int tpe)\n\t{\n\t\tint n=a.size();\n\t\tif(p_rev_lstn!=n)\n\t\t{\n\t\t\tp_rev_lstn=n;\n\t\t\tfor(int i=0;i<n;i++) p_rev[i]=(p_rev[i>>1]>>1)|((i&1)?n>>1:0);\n\t\t}\n\t\tfor(int i=0;i<n;i++) if(p_rev[i]<i) swap(a[p_rev[i]],a[i]);\n\t\tint g=tpe==1?3:ginv;\n\t\tfor(int mid=1;mid<n;mid<<=1)\n\t\t{\n\t\t\tint len=mid<<1,Wn=qpow(g,(p-1)/len);\n\t\t\tfor(int l=0;l<n-len+1;l+=len)\n\t\t\t{\n\t\t\t\tfor(int k=0,Wk=1;k<mid;k++,Wk=1ll*Wk*Wn%p)\n\t\t\t\t{\n\t\t\t\t\tint x=a[l+k],y=1ll*Wk*a[l+mid+k]%p;\n\t\t\t\t\ta[l+k]=(x+y)%p,a[l+mid+k]=(x-y+p)%p;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tinline void DFT(ploy &a){NTT(a,1);}\n\tinline void IDFT(ploy &a)\n\t{\n\t\tint n=a.size();\n\t\tNTT(a,-1);\n\t\tint inv=qpow(n,p-2);\n\t\tfor(int i=0;i<n;i++) a[i]=1ll*a[i]*inv%p;\n\t}\n\tinline ploy operator+(ploy a,ploy b)\n\t{\n\t\tif(a.size()<b.size()) swap(a,b);\n\t\tfor(int i=0;i<b.size();i++) add(a[i],b[i]);\n\t\treturn a;\n\t}\n\tinline ploy operator+(ploy a,int b){return add(a[0],b),a;}\n\tinline ploy operator+(int a,ploy b){return add(b[0],a),b;}\n\tinline ploy operator-(ploy a,ploy b)\n\t{\n\t\tif(a.size()<b.size()) a.resize(b.size(),0);\n\t\tfor(int i=0;i<b.size();i++) add(a[i],p-b[i]);\n\t\treturn a;\n\t}\n\tinline ploy operator-(ploy a,int b){return add(a[0],p-b),a;}\n\tinline ploy operator-(int a,ploy b)\n\t{\n\t\tadd(b[0],p-a);\n\t\tfor(int i=0;i<b.size();i++) b[i]=p-b[i];\n\t\treturn b;\n\t}\n\tinline ploy operator*(ploy a,int b)\n\t{\n\t\tfor(int i=0;i<a.size();i++) a[i]=1ll*a[i]*b%p;\n\t\treturn a;\n\t}\n\tinline ploy operator*(int b,ploy a)\n\t{\n\t\tfor(int i=0;i<a.size();i++) a[i]=1ll*a[i]*b%p;\n\t\treturn a;\n\t}\n\tinline ploy operator*(ploy a,ploy b)\n\t{\n\t\tint n=a.size()+b.size()-1,m=getlen(n);\n\t\ta.resize(m,0),b.resize(m,0);\n\t\tDFT(a),DFT(b);\n\t\tfor(int i=0;i<m;i++) a[i]=1ll*a[i]*b[i]%p;\n\t\tIDFT(a);\n\t\ta.resize(n,0);\n\t\treturn a;\n\t}\n\tinline ploy inv(ploy a)\n\t{\n\t\tint n=a.size(),m=getlen(n);\n\t    ploy res={qpow(a[0],p-2)};\n\t    for(int len=2;len<=m;len<<=1)\n\t    {\n\t    \tploy tmp=a;\n\t    \ttmp.resize(len,0);\n\t    \tres=res*2-res*res*tmp;\n\t    \tres.resize(len,0);\n\t    }\n\t    res.resize(n,0);\n\t    return res;\n\t}\n\tinline ploy sqrt(ploy a)\n\t{\n\t\tploy res={mosqrt(a[0])};\n\t    if(res[0]==-1) return ploy();\n\t    int n=a.size(),m=getlen(n)*2; // 不知道为什么要乘二\n\t    for(int len=2;len<=m;len<<=1)\n\t    {\n\t    \tploy tmp=a;\n\t    \ttmp.resize(len,0);\n\t    \tres=(res*res+tmp)*inv(res*2);\n\t    \tres.resize(len,0);\n\t    }\n\t    res.resize(n,0);\n\t    return res;\n\t}\n\tinline ploy dao(ploy a)\n\t{\n\t\tint n=a.size();ploy res=a;\n\t\tres[n-1]=0;for(int i=1;i<n;i++) res[i-1]=1ll*a[i]*i%p;\n\t\treturn res;\n\t}\n\tinline ploy jif(ploy a)\n\t{\n\t\tint n=a.size();ploy res=a;\n\t\tfor(int i=1;i<n;i++) if(p_tmpinv[i]==0) p_tmpinv[i]=(i==1?1:1ll*p_tmpinv[p%i]*(p-p/i)%p);\n\t\tres[0]=0;for(int i=1;i<n;i++) res[i]=1ll*a[i-1]*p_tmpinv[i]%p;\n\t\treturn res;\n\t}\n\tinline ploy ln(ploy a)\n\t{\n\t\tint n=a.size();\n\t\tploy res=jif(dao(a)*inv(a));\n\t\tres.resize(n,0);\n\t\treturn res;\n\t}\n\tinline ploy exp(ploy a)\n\t{\n\t\tint n=a.size(),m=getlen(n)*2;\n\t\tploy res={1};\n\t\tfor(int len=2;len<=m;len<<=1)\n\t\t{\n\t\t\tploy tmp=a;\n\t\t\ttmp.resize(len,0);\n\t\t\tres=(1-ln(res)+tmp)*res;\n\t\t\tres.resize(len,0);\n\t\t}\n\t\tres.resize(n,0);\n\t\treturn res;\n\t}\n\tinline ploy pow(ploy a,int b)\n\t{\n\t\tploy tmp=ln(a);\n\t\tfor(int i=0;i<a.size();i++) tmp[i]=1ll*tmp[i]*b%p;\n\t\treturn exp(tmp);\n\t}\n\tinline ploy pow2(ploy a,int b,int b2)\n\t{\n\t\tint n=a.size(),cnt=0;\n\t\tfor(int i=0;i<n&&a[i]==0;i++) cnt++;\n\t\tif(1ll*cnt*b2>=n) return ploy(n,0);\n\t\tint pos=cnt*b2,m=n-pos;\n\t\tploy tmp;\n\t\tfor(int i=cnt;i<cnt+m;i++) tmp.push_back(a[i]);\n\t\tint inv=qpow(tmp[0],p-2),ml=qpow(tmp[0],b2);\n\t\tfor(int i=0;i<m;i++) tmp[i]=1ll*tmp[i]*inv%p;\n\t\ttmp=pow(tmp,b);\n\t\tfor(int i=0;i<m;i++) tmp[i]=1ll*tmp[i]*ml%p;\n\t\tploy res(pos,0);\n\t\tfor(int i=0;i<m;i++) res.push_back(tmp[i]);\n\t\treturn res;\n\t}\n\tinline void divi(ploy a,ploy b,ploy &res,ploy &r)\n\t{\n\t\tint n=a.size(),m=b.size();\n\t\tif(n<m) return res={0},r=a,void();\n\t\tint rl=n-m+1;\n\t\tploy ta=a,tb=b;\n\t\treverse(ta.begin(),ta.end()),reverse(tb.begin(),tb.end());\n\t\tta.resize(rl,0),tb.resize(rl,0);\n\t\tres=ta*inv(tb);\n\t\tres.resize(rl,0);\n\t\treverse(res.begin(),res.end());\n\t\tr=a-b*res;\n\t\tr.resize(m-1,0);\n\t}\n\tinline ploy operator%(ploy a,ploy b)\n\t{\n\t\tploy res,r;\n\t\tdivi(a,b,res,r);\n\t\treturn r;\n\t}\n\tinline vector<int> getval(ploy a,vector<int> x)\n\t{\n\t\tint n=x.size();\n\t\tvector<ploy> ml(n<<2|1),res(n<<2|1);\n\t\tvector<pair<pair<int,int>,pair<int,int> > > sta;\n\t\tvector<int> ans(n);\n\t\tsta.emplace_back(make_pair(1,0),make_pair(0,n-1));\n\t\twhile(!sta.empty())\n\t\t{\n\t\t\tauto t=*sta.rbegin();\n\t\t\tsta.pop_back();\n\t\t\tint u=t.first.first,stp=t.first.second,l=t.second.first,r=t.second.second;\n\t\t\tif(l==r)\n\t\t\t{\n\t\t\t\tml[u]={p-x[l],1};\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint mid=l+r>>1;\n\t\t\tif(stp==0)\n\t\t\t{\n\t\t\t\tt.first.second++;\n\t\t\t\tsta.push_back(t);\n\t\t\t\tsta.emplace_back(make_pair(u<<1,0),make_pair(l,mid));\n\t\t\t}\n\t\t\telse if(stp==1)\n\t\t\t{\n\t\t\t\tt.first.second++;\n\t\t\t\tsta.push_back(t);\n\t\t\t\tsta.emplace_back(make_pair(u<<1|1,0),make_pair(mid+1,r));\n\t\t\t}\n\t\t\telse ml[u]=ml[u<<1]*ml[u<<1|1];\n\t\t}\n\t\tres[1]=a%ml[1];\n\t\tsta.emplace_back(make_pair(1,0),make_pair(0,n-1));\n\t\twhile(!sta.empty())\n\t\t{\n\t\t\tauto t=*sta.rbegin();\n\t\t\tsta.pop_back();\n\t\t\tint u=t.first.first,l=t.second.first,r=t.second.second;\n\t\t\tif(l==r)\n\t\t\t{\n\t\t\t\tans[l]=res[u][0];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint mid=l+r>>1;\n\t\t\tres[u<<1]=res[u]%ml[u<<1];\n\t\t\tres[u<<1|1]=res[u]%ml[u<<1|1];\n\t\t\tsta.emplace_back(make_pair(u<<1,0),make_pair(l,mid));\n\t\t\tsta.emplace_back(make_pair(u<<1|1,0),make_pair(mid+1,r));\n\t\t}\n\t\treturn ans;\n\t}\n\tinline ploy getploy(vector<int> x,vector<int> y)\n\t{\n\t\tint n=x.size();\n\t\tvector<ploy> ml(n<<2|1),res(n<<2|1);\n\t\tvector<pair<pair<int,int>,pair<int,int> > > sta;\n\t\tvector<int> ans(n);\n\t\tsta.emplace_back(make_pair(1,0),make_pair(0,n-1));\n\t\twhile(!sta.empty())\n\t\t{\n\t\t\tauto t=*sta.rbegin();\n\t\t\tsta.pop_back();\n\t\t\tint u=t.first.first,stp=t.first.second,l=t.second.first,r=t.second.second;\n\t\t\tif(l==r)\n\t\t\t{\n\t\t\t\tml[u]={p-x[l],1};\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint mid=l+r>>1;\n\t\t\tif(stp==0)\n\t\t\t{\n\t\t\t\tt.first.second++;\n\t\t\t\tsta.push_back(t);\n\t\t\t\tsta.emplace_back(make_pair(u<<1,0),make_pair(l,mid));\n\t\t\t}\n\t\t\telse if(stp==1)\n\t\t\t{\n\t\t\t\tt.first.second++;\n\t\t\t\tsta.push_back(t);\n\t\t\t\tsta.emplace_back(make_pair(u<<1|1,0),make_pair(mid+1,r));\n\t\t\t}\n\t\t\telse ml[u]=ml[u<<1]*ml[u<<1|1];\n\t\t}\n\t\tploy M=dao(ml[1]);\n\t\tvector<int> val=getval(M,x);\n\t\tfor(int i=0;i<n;i++) val[i]=1ll*qpow(val[i],p-2)*y[i]%p;\n\t\tsta.emplace_back(make_pair(1,0),make_pair(0,n-1));\n\t\twhile(!sta.empty())\n\t\t{\n\t\t\tauto t=*sta.rbegin();\n\t\t\tsta.pop_back();\n\t\t\tint u=t.first.first,stp=t.first.second,l=t.second.first,r=t.second.second;\n\t\t\tif(l==r)\n\t\t\t{\n\t\t\t\tres[u]={val[l]};\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint mid=l+r>>1;\n\t\t\tif(stp==0)\n\t\t\t{\n\t\t\t\tt.first.second++;\n\t\t\t\tsta.push_back(t);\n\t\t\t\tsta.emplace_back(make_pair(u<<1,0),make_pair(l,mid));\n\t\t\t}\n\t\t\telse if(stp==1)\n\t\t\t{\n\t\t\t\tt.first.second++;\n\t\t\t\tsta.push_back(t);\n\t\t\t\tsta.emplace_back(make_pair(u<<1|1,0),make_pair(mid+1,r));\n\t\t\t}\n\t\t\telse res[u]=res[u<<1]*ml[u<<1|1]+ml[u<<1]*res[u<<1|1];\n\t\t}\n\t\treturn res[1];\n\t}\n}\n```\n\n</p></details>\n\n### 更快的板子\n\n<details><summary>展开</summary><p>\n\n```cpp\n#include <bits/stdc++.h>\n\nusing ull = unsigned long long;\n\nconst int N = 280000;\nconst int Mod = 998244353;\n\ntypedef std::vector<int> Poly;\n\nnamespace Pol {\n\tint pow(int a, int b, int ans = 1);\n\tint add(int a, int b) {\n\t\treturn (a += b) >= Mod ? a -= Mod : a;\n\t}\n\tint sub(int a, int b) {\n\t\treturn (a -= b) < 0 ? a += Mod : a;\n\t}\n\tvoid inc(int &a, int b) {\n\t\t(a += b) >= Mod ? a -= Mod : a;\n\t}\n\tvoid dec(int &a, int b) {\n\t\t(a -= b) < 0 ? a += Mod : a;\n\t}\n\tvoid init_Poly(int n = N);\n\tvoid DIT(int *A, int lim);\n\tvoid DIF(int *A, int lim);\n\tPoly inv(Poly A, int n);\n\tPoly mult(const Poly &A, int n, const Poly &B, int m);\n\tPoly operator*(const Poly &A, const Poly &B) {\n\t\treturn mult(A, A.size(), B, B.size());\n\t}\n\tPoly Tmul(const Poly &A, int n, const Poly &B, int m);\n\tPoly getv(Poly A, int n, const std::vector<int> &f, int m);\n\tPoly drv(const Poly &A, int n);\n\tPoly itg(const Poly &A, int n);\n\tPoly ln(const Poly &A, int n);\n\tPoly exp(Poly A, int n);\n\tint fac[N], ifac[N], iv[N];\n\tPoly G[N << 1];\n\tull tmp[N];\n\tint gw[N];\n}  // namespace Pol\n\nint main() {\n\tPol::init_Poly();\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\tPoly F(n);\n\tfor (int i = 0; i < n; ++i) scanf(\"%d\", &F[i]);\n\tPoly G = Pol::ln(Pol::inv(Pol::exp(F, n), n), n);\n\tfor (int i = 0; i < n; ++i) printf(\"%d%c\", G[i], \" \\n\"[i == n - 1]);\n\tstd::vector<int> f(m);\n\tfor (int i = 0; i < m; ++i) scanf(\"%d\", &f[i]);\n\tG = Pol::getv(F, n, f, m);\n\tfor (int i = 0; i < m; ++i) printf(\"%d%c\", G[i], \" \\n\"[i == m - 1]);\n\treturn 0;\n}\n\nnamespace Pol {\n\tvoid DIT(int *A, int lim) {\n\t\tfor (int i = 0; i < lim; ++i) tmp[i] = A[i];\n\t\tfor (int l = 1; l < lim; l <<= 1) {\n\t\t\tull *k = tmp;\n\t\t\tfor (int *g = gw; k < tmp + lim; k += (l << 1), ++g) {\n\t\t\t\tfor (ull *x = k; x < k + l; ++x) {\n\t\t\t\t\tint o = x[l] % Mod;\n\t\t\t\t\tx[l] = 1ll * (*x + Mod - o) **g % Mod, *x += o;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint iv = pow(lim, Mod - 2);\n\t\tfor (int i = 0; i < lim; ++i) A[i] = 1ll * tmp[i] % Mod * iv % Mod;\n\t\tstd::reverse(A + 1, A + lim);\n\t}\n\tvoid DIF(int *A, int lim) {\n\t\tfor (int i = 0; i < lim; ++i) tmp[i] = A[i];\n\t\tfor (int l = lim / 2; l >= 1; l >>= 1) {\n\t\t\tull *k = tmp;\n\t\t\tfor (int *g = gw; k < tmp + lim; k += (l << 1), ++g) {\n\t\t\t\tfor (ull *x = k; x < k + l; ++x) {\n\t\t\t\t\tint o = 1ll * x[l] **g % Mod;\n\t\t\t\t\tx[l] = *x + Mod - o, *x += o;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < lim; ++i) A[i] = tmp[i] % Mod;\n\t}\n\tPoly mult(const Poly &A, int n, const Poly &B, int m) {\n\t\tif (n + m < 255) {\n\t\t\tPoly ans(n + m - 1);\n\t\t\tstd::fill(tmp, tmp + n + m, 0);\n\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t\tfor (int j = 0; j < m; ++j) tmp[i + j] += 1ll * A[i] * B[j] % Mod;\n\t\t\tfor (int i = 0; i < n + m - 1; ++i) ans[i] = tmp[i] % Mod;\n\t\t\treturn ans;\n\t\t}\n\t\tint lim = 1;\n\t\twhile (lim < (n + m - 1)) lim <<= 1;\n\t\tstatic int tA[N], tB[N];\n\t\tstd::copy_n(A.begin(), n, tA), std::fill(tA + n, tA + lim, 0);\n\t\tstd::copy_n(B.begin(), m, tB), std::fill(tB + m, tB + lim, 0);\n\t\tDIF(tA, lim), DIF(tB, lim);\n\t\tfor (int i = 0; i < lim; ++i) tA[i] = 1ll * tA[i] * tB[i] % Mod;\n\t\tDIT(tA, lim);\n\t\tPoly ans(n + m - 1);\n\t\tstd::copy_n(tA, n + m - 1, ans.begin());\n\t\treturn ans;\n\t}\n\tPoly Tmul(const Poly &A, int n, const Poly &B, int m) {\n\t\tif (n + m < 255) {\n\t\t\tPoly ans(m - n + 1);\n\t\t\tstd::fill(tmp, tmp + m - n + 2, 0);\n\t\t\tfor (int i = 0; i < m; ++i)\n\t\t\t\tfor (int j = i; j < n; ++j) tmp[j - i] += 1ll * B[i] * A[j] % Mod;\n\t\t\tfor (int i = 0; i < m - n + 1; ++i) ans[i] = tmp[i] % Mod;\n\t\t}\n\t\tint lim = 1;\n\t\twhile (lim < m) lim <<= 1;\n\t\tstatic int tA[N], tB[N];\n\t\tstd::reverse_copy(A.begin(), A.begin() + n, tA), std::fill(tA + n, tA + lim, 0);\n\t\tstd::copy_n(B.begin(), m, tB), std::fill(tB + m, tB + lim, 0);\n\t\tDIF(tA, lim), DIF(tB, lim);\n\t\tfor (int i = 0; i < lim; ++i) tA[i] = 1ll * tA[i] * tB[i] % Mod;\n\t\tDIT(tA, lim);\n\t\tPoly ans(m - n + 1);\n\t\tstd::copy_n(tA + n - 1, m - n + 1, ans.begin());\n\t\treturn ans;\n\t}\n\tPoly inv(Poly A, int n) {\n\t\tint lim = 1;\n\t\twhile (lim < (n << 1)) lim <<= 1;\n\t\tPoly F(lim), G(lim);\n\t\tA.resize(lim);\n\t\tG[0] = pow(A[0], Mod - 2);\n\t\tint now = 1;\n\t\tstatic int tA[N], tB[N];\n\t\twhile (now < n) {\n\t\t\tstd::copy_n(A.begin(), now << 1, F.begin());\n\t\t\tint lim = now << 2;\n\t\t\tstd::copy_n(G.begin(), lim, tA);\n\t\t\tstd::copy_n(F.begin(), lim, tB);\n\t\t\tDIF(tA, lim), DIF(tB, lim);\n\t\t\tfor (int i = 0; i < lim; ++i) tA[i] = 1ll * sub(2, 1ll * tA[i] * tB[i] % Mod) * tA[i] % Mod;\n\t\t\tDIT(tA, lim);\n\t\t\tstd::copy_n(tA, now << 1, G.begin());\n\t\t\tnow <<= 1;\n\t\t}\n\t\tG.resize(n);\n\t\treturn G;\n\t}\n\tPoly drv(const Poly &A, int n) {\n\t\tPoly ans(n - 1);\n\t\tfor (int i = 0; i < n - 1; ++i) ans[i] = 1ll * A[i + 1] * (i + 1) % Mod;\n\t\treturn ans;\n\t}\n\tPoly itg(const Poly &A, int n) {\n\t\tPoly ans(n + 1);\n\t\tfor (int i = 0; i < n; ++i) ans[i + 1] = 1ll * A[i] * iv[i + 1] % Mod;\n\t\treturn ans;\n\t}\n\tPoly ln(const Poly &A, int n) {\n\t\tPoly F = drv(A, n), G = inv(A, n);\n\t\tF = mult(F, n - 1, G, n);\n\t\tF.resize(n - 1);\n\t\tF = itg(F, n - 1);\n\t\treturn F;\n\t}\n\tPoly exp(Poly A, int n) {\n\t\tint lim = 1;\n\t\twhile (lim < (n << 1)) lim <<= 1;\n\t\tA.resize(lim);\n\t\tPoly L(lim);\n\t\tint now = 1;\n\t\tstatic int tF[N], tG[N], tL[N];\n\t\tstd::fill(tG, tG + lim, 0), std::fill(tF, tF + lim, 0);\n\t\ttG[0] = 1;\n\t\twhile (now < n) {\n\t\t\tint lim = now << 2;\n\t\t\tstd::copy_n(tG, now, L.begin());\n\t\t\tL = ln(L, std::min(now << 1, n));\n\t\t\tL.resize(lim);\n\t\t\tstd::copy_n(A.begin(), now << 1, tF);\n\t\t\tstd::copy_n(L.begin(), lim, tL);\n\t\t\tDIF(tF, lim), DIF(tG, lim), DIF(tL, lim);\n\t\t\tfor (int i = 0; i < lim; ++i) tG[i] = 1ll * tG[i] * sub(add(1, tF[i]), tL[i]) % Mod;\n\t\t\tDIT(tG, lim);\n\t\t\tstd::fill(tG + (now << 1), tG + lim, 0);\n\t\t\tnow <<= 1;\n\t\t}\n\t\tPoly G(n);\n\t\tstd::copy_n(tG, n, G.begin());\n\t\treturn G;\n\t}\n\tvoid getg(int x, int xl, int xr, const Poly &f, int m) {\n\t\tif (xl == xr) {\n\t\t\tG[x].resize(2);\n\t\t\tG[x][0] = 1;\n\t\t\tif (xl >= m)\n\t\t\t\tG[x][1] = 0;\n\t\t\telse\n\t\t\t\tG[x][1] = Mod - f[xl];\n\t\t\treturn;\n\t\t}\n\t\tint xm = (xl + xr) >> 1;\n\t\tgetg(x << 1, xl, xm, f, m), getg(x << 1 | 1, xm + 1, xr, f, m);\n\t\tG[x] = mult(G[x << 1], xm - xl + 2, G[x << 1 | 1], xr - xm + 1);\n\t}\n\tvoid getans(int x, int xl, int xr, Poly &ans, int m, const Poly &h) {\n\t\tif (xl >= m) return;\n\t\tif (xl == xr) return void(ans[xl] = h[0]);\n\t\tint xm = (xl + xr) >> 1;\n\t\tPoly hl = Tmul(G[x << 1 | 1], xr - xm + 1, h, xr - xl + 1);\n\t\tgetans(x << 1, xl, xm, ans, m, hl);\n\t\tPoly hr = Tmul(G[x << 1], xm - xl + 2, h, xr - xl + 1);\n\t\tgetans(x << 1 | 1, xm + 1, xr, ans, m, hr);\n\t}\n\tPoly getv(Poly A, int n, const std::vector<int> &f, int m) {\n\t\tn = std::max(n, m);\n\t\tA.resize(n);\n\t\tgetg(1, 0, n - 1, f, m);\n\t\tPoly now = inv(G[1], n);\n\t\tstd::reverse(now.begin(), now.begin() + n);\n\t\tPoly h = mult(now, n, A, n);\n\t\tfor (int i = 0; i < n; ++i) h[i] = h[i + n - 1];\n\t\th.resize(n);\n\t\tPoly ans(m);\n\t\tgetans(1, 0, n - 1, ans, m, h);\n\t\treturn ans;\n\t}\n\tvoid init_Poly(int n) {\n\t\tint t = 1;\n\t\twhile ((1 << t) < n) ++t;\n\t\tt = std::min(t - 1, 21);\n\t\tgw[0] = 1, gw[1 << t] = pow(31, 1 << (21 - t));\n\t\tfor (int i = t; i; --i) gw[1 << (i - 1)] = 1ll * gw[1 << i] * gw[1 << i] % Mod;\n\t\tfor (int i = 1; i < (1 << t); ++i) gw[i] = 1ll * gw[i & (i - 1)] * gw[i & -i] % Mod;\n\t\t--n;\n\t\tfac[0] = 1;\n\t\tfor (int i = 1; i <= n; ++i) fac[i] = 1ll * fac[i - 1] * i % Mod;\n\t\tifac[n] = Pol::pow(fac[n], Mod - 2);\n\t\tfor (int i = n - 1; i >= 0; --i) ifac[i] = 1ll * ifac[i + 1] * (i + 1) % Mod;\n\t\tfor (int i = 1; i <= n; ++i) iv[i] = 1ll * ifac[i] * fac[i - 1] % Mod;\n\t}\n\tint pow(int a, int b, int ans) {\n\t\twhile (b) {\n\t\t\tif (b & 1) ans = 1ll * ans * a % Mod;\n\t\t\ta = 1ll * a * a % Mod;\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn ans;\n\t}\n}  // namespace Pol\n```\n\n</p></details>\n",
			"tags": [{"name":"学习笔记"},{"name":"数学"},{"name":"组合计数"},{"name":"多项式、生成函数"}],
			"title": "多项式全家桶学习笔记",
			"link": "https://exber.qzz.io/post/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%85%A8%E5%AE%B6%E6%A1%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-03-23 16:32:09"
		},
	
		{
			"abstract": "",
			"content": "BSGS 是一个用来求高次同余方程的暴力算法。\n\n先看一道[例题](https://www.luogu.com.cn/problem/P3846):\n\n> 给定 $a,b,p$，保证 $a,b,p\\ge2$ 且 $\\operatorname{gcd}(a,p)=1$，求 $a^x\\equiv b\\pmod p$ 的最小自然数解 $x$。\n\n显然，我们可以暴力从小到大枚举 $x$，判断每个 $x$ 是否合法。根据欧拉的神奇定理，$a^{\\varphi(p)}\\equiv 1\\pmod p$，我们只需要枚举到 $\\varphi(p)$ 即可。时间复杂度 $O(p)$。\n\n这样显然不够好，很多时候 $p$ 都十分巨大。考虑优化，我们可以**把 $x$ 拆开，拆成 $x=tA-B$，其中 $B\\le t$**。那么有：\n\n$$a^{tA-B}\\equiv b\\pmod p$$\n\n$$a^{tA}\\equiv ba^B\\pmod p$$\n\n这样我们就可以**用一个哈希表存每个 $ba^B\\operatorname{mod} p$ 对应的最大的 $B$，然后枚举 $A$，快速找到 $a^{tA}$ 对应的 $B$，答案即为 $x=tA-B$**。\n\n显然，此时 $t$ 取 $\\left\\lceil\\sqrt p\\right\\rceil$ 是最优的。此时时间复杂度为 $O(\\left\\lceil\\sqrt p\\right\\rceil)$。如果用 map 来哈希的话时间复杂度会多只 $\\log$。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <map>\n\nusing namespace std;\n\ninline int BSGS(int a,int b,int p)\n{\n\tmap<int,int> mp;\n\tint val=1,t=sqrt(p)+1;\n\tfor(int B=1;B<=t;B++)\n\t{\n\t\tval=1ll*val*a%p;\n\t\tmp[1ll*b*val%p]=B;\n\t}\n\tint cur=val;\n\tfor(int A=1;A<=t;A++)\n\t{\n\t\tif(mp.find(val)!=mp.end())\n\t\t{\n\t\t\treturn A*t-mp[val];\n\t\t}\n\t\tval=1ll*val*cur%p;\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tint p,a,b;\n\tscanf(\"%d%d%d\",&p,&a,&b);\n\tint x=BSGS(a,b,p);\n\tif(x==-1)\n\t{\n\t\tputs(\"no solution\");\n\t\treturn 0;\n\t}\n\tprintf(\"%d\\n\",x);\n\treturn 0;\n}\n```\n\n但是有些时候，$\\gcd(a,p)\\not=1$，用不了 BSGS。这时候我们就需要 exBSGS 了。\n\n例如这道题：[P4195 【模板】扩展 BSGS/exBSGS](https://www.luogu.com.cn/problem/P4195)\n\n当 $\\gcd(a,p)\\not=1$ 时，我们令 $d=\\gcd(a,p)$，那么有：\n\n$$a^x\\equiv b\\pmod p$$\n\n$$\\dfrac{a}{d}a^{x-1}\\equiv \\dfrac{b}{d}\\pmod{\\dfrac{p}{d}}$$\n\n如果 $\\gcd(\\dfrac{a}{d},\\dfrac{p}{d})$ 仍然不为 $1$，那么**继续做下去，直到 $\\gcd(\\dfrac{a}{D},\\dfrac{p}{D})=1$ 为止**（$D$ 为所有 $d$ 的乘积）。\n\n这时我们的方程变成了这样（$cnt$ 是操作的次数）：\n\n$$\\dfrac{a^{cnt}}{D}a^{x-cnt}\\equiv \\dfrac{b}{D}\\pmod{\\dfrac{p}{D}}$$\n\n就可以用 BSGS 计算答案了。\n\n注意特判 $x=0$ 和 $x=cnt$ 的特殊情况。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <map>\n#include <cmath>\n\nusing namespace std;\n\ninline int gcd(int a,int b)\n{\n\tint t=a%b;\n\twhile(t>0)\n\t{\n\t\ta=b;\n\t\tb=t;\n\t\tt=a%b;\n\t}\n\treturn b;\n}\n\ninline int exBSGS(int a,int b,int p)\n{\n\ta%=p;\n\tb%=p;\n\tif(b==1||p==1)\n\t{\n\t\treturn 0;\n\t}\n\tint cnt=0,val=1;\n\twhile(1)\n\t{\n\t\tint d=gcd(a,p);\n\t\tif(d==1)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tif(b%d!=0)\n\t\t{\n\t\t\treturn -1;\n\t\t}\n\t\tcnt++;\n\t\tp/=d;\n\t\tb/=d;\n\t\tval=1ll*val*(a/d)%p;\n\t\tif(val==b)\n\t\t{\n\t\t\treturn cnt;\n\t\t}\n\t}\n\tmap<int,int> mp;\n\tint val2=1,t=sqrt(p)+1;\n\tfor(int B=1;B<=t;B++)\n\t{\n\t\tval2=1ll*val2*a%p;\n\t\tmp[1ll*b*val2%p]=B;\n\t}\n\tint cur=1ll*val2*val%p;\n\tfor(int A=1;A<=t;A++)\n\t{\n\t\tif(mp.find(cur)!=mp.end())\n\t\t{\n\t\t\treturn A*t-mp[cur]+cnt;\n\t\t}\n\t\tcur=1ll*cur*val2%p;\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tint a,b,p;\n\twhile(1)\n\t{\n\t\tscanf(\"%d%d%d\",&a,&p,&b);\n\t\tif(a==0&&b==0&&p==0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tint res=exBSGS(a,b,p);\n\t\tif(res<0)\n\t\t{\n\t\t\tputs(\"No Solution\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"%d\\n\",res);\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n### 练习题目\n\n- [SP3105 MOD - Power Modulo Inverted](https://www.luogu.com.cn/problem/SP3105)\n\n- [UVA10225 Discrete Logging](https://www.luogu.com.cn/problem/UVA10225)\n\n- [P2485 [SDOI2011]计算器](https://www.luogu.com.cn/problem/P2485)\n",
			"tags": [{"name":"学习笔记"},{"name":"数学"},{"name":"数论"}],
			"title": "BSGS 和 exBSGS 学习笔记",
			"link": "https://exber.qzz.io/post/BSGS%20%E5%92%8C%20exBSGS%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-03-23 16:31:31"
		},
	
		{
			"abstract": "",
			"content": "FFT 虽然奇妙，但是由于需要用浮点数，所以有精度问题。NTT 就是取模时 FFT 的一个完美替代品。\n\nFFT 有精度问题的原因显然是涉及了本原单位根，它要用三角函数求，那么我们可以**考虑找一个在模素数时的“本原单位根”**。\n\n### 原根\n\n众所周知，在模 $p$ 意义下只有 $p-1$ 个能代入多项式的值（$0$ 没用），所以我们只要找到一个能“遍历”这 $p-1$ 个值的数，就能构成一个“单位圆”，也就能找到“本原单位根”了。\n\n这个能构成“单位圆”的数就被称为原根 $g$。\n\n形式化的，$g$ 为模 $p$ 的原根，当且仅当在模 $p$ 意义下 $g^0\\not=g^1\\not=g^2\\not=...\\not=g^{p-2}$。\n\n也就是说在模世界的幂运算这张纸上，原根 $g$ 是一个圆。\n\n容易发现 $g$ 就是在模 $p$ 意义下的 $p-1$ 次本原单位根。\n\n可以证明，在模素数 $p$ 的意义下，$g$ 总是存在的。所以 **NTT 的模数必须要是素数**。\n\n我们考虑模 $p$ 意义下的 $n$ 次本原单位根 $\\omega_n$。**由于 $g$ 的次幂构成了“可以被分为 $p-1$ 等分的单位圆”，所以 $\\omega_n=g^{\\frac{p-1}{n}}$**。\n\n显然，**模 $p$ 意义下的 $\\omega_n$ 存在当且仅当 $n\\mid p-1$**。\n\n### NTT\n\n如果 $n=2^k$，那么我们可以把 FFT 中的虚数本原单位根都替换成模素数 $p$ 意义下的本原单位根，来实现 NTT。\n\n但因为必须满足 $2^k=n\\mid p-1$，所以 **NTT 对模数有特殊限制**。\n\nNTT 可用的模数 $p$ 需要满足：\n\n- $p$ 是个质数\n\n- $p=a\\cdot2^b+1$\n\n例如 $998244353$ 就是合法的，因为 $998244353=7\\cdot17\\cdot2^{23}+1$。它的一个原根是 $g=3$。\n\n还有 $167772161$ 和 $104857601$ 也是合法的，$g=3$ 都是它们的原根。\n\n[模板题](https://www.luogu.com.cn/problem/P3803)代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst long long MS=5000005;\nconst int p=998244353,ginv=332748118;\n\ninline int qpow(int x,int y)\n{\n    int res=1;\n    for(;y>0;y>>=1) res=((y&1)?1ll*res*x%p:res),x=1ll*x*x%p;\n    return res;\n}\ninline int getlen(int n)\n{\n    int res=1;\n    while(res<n) res<<=1;\n    return res;\n}\nint p_rev[MS],p_rev_lstn;\ninline void NTT(int n,int a[],int tpe)\n{\n    if(p_rev_lstn!=n)\n    {\n        p_rev_lstn=n;\n        for(int i=0;i<n;i++) p_rev[i]=(p_rev[i>>1]>>1)|((i&1)?n>>1:0);\n    }\n    for(int i=0;i<n;i++) if(p_rev[i]<i) swap(a[p_rev[i]],a[i]);\n    int g=tpe==1?3:ginv;\n    for(int mid=1;mid<n;mid<<=1)\n    {\n        int len=mid<<1,Wn=qpow(g,(p-1)/len);\n        for(int l=0;l<n-len+1;l+=len)\n        {\n            for(int k=0,Wk=1;k<mid;k++,Wk=1ll*Wk*Wn%p)\n            {\n                int x=a[l+k],y=1ll*Wk*a[l+mid+k]%p;\n                a[l+k]=(x+y)%p,a[l+mid+k]=(x-y+p)%p;\n            }\n        }\n    }\n}\ninline void DFT(int n,int a[]){NTT(n,a,1);}\ninline void IDFT(int n,int a[])\n{\n    NTT(n,a,-1);\n    int inv=qpow(n,p-2);\n    for(int i=0;i<n;i++) a[i]=1ll*a[i]*inv%p;\n}\n\nint n,m,a[MS],b[MS];\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tfor(int i=0;i<=m;i++)\n\t{\n\t\tscanf(\"%d\",&b[i]);\n\t}\n\tint len=getlen(n+m+1);\n\tDFT(len,a);\n\tDFT(len,b);\n\tfor(int i=0;i<len;i++)\n\t{\n\t\ta[i]=1ll*a[i]*b[i]%p;\n\t}\n\tIDFT(len,a);\n\tfor(int i=0;i<n+m+1;i++)\n\t{\n\t\tprintf(\"%d \",a[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"学习笔记"},{"name":"数学"},{"name":"组合计数"},{"name":"多项式、生成函数"}],
			"title": "快速数论变换（NTT）学习笔记",
			"link": "https://exber.qzz.io/post/%E5%BF%AB%E9%80%9F%E6%95%B0%E8%AE%BA%E5%8F%98%E6%8D%A2%EF%BC%88NTT%EF%BC%89%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-03-23 16:27:33"
		},
	
		{
			"abstract": "",
			"content": "### 多项式\n\n有 $n$ 次多项式可以形式化的写为：\n\n$$f(x)=\\sum\\limits_{i=0}^{n}a_ix^i$$\n\n其中序列 $a$ 可以叫做这个多项式的**系数序列**。\n\n在下文，我们会**用 $f_i$ 表示多项式 $f$ 的系数序列 $a$ 的第 $i$ 项，即为 $a_i$**。\n\n### 多项式的表示方法\n\n- 系数表示法\n\n显然，只要我们得知了系数序列，就可以唯一确定一个多项式。\n\n- 点值表示法\n\n对于一个 $n$ 次多项式，代入 $n+1$ 个**互不相同**的值 $x_i$，可以得到 $n+1$ 个满足 $y_i=f(x_i)$ 的 $y_i$。这时，序列 $x$ 和序列 $y$ 可以唯一确定 $f$。\n\n因为有了 $n+1$ 个点 $(x_i,y_i)$，就可以通过插值来确定 $f$。\n\n### 多项式的运算\n\n设 $f,g$ 是两个 $n$ 次多项式，有：\n\n$$(f+g)(x)=\\sum\\limits_{i=0}^n(f_i+g_i)x^i$$\n\n$$(f*g)(x)=\\sum\\limits_{k=0}^{2n}x^k\\sum\\limits_{i\\le n,j\\le n,i+j=k}f_ig_j$$\n\n多项式除法可以使用多项式求逆做。\n\n容易发现，在系数表示法下：\n\n- 多项式加法是 $O(n)$ 的，因为直接系数相加就行\n\n- 多项式乘法是 $O(n^2)$ 的，因为需要枚举 $i,j$\n\n而在点值表示法下：（注意此时的运算需要满足序列 $x$ 相同）\n\n- 多项式加法是 $O(n)$ 的，因为直接相加就行（乘法分配律）\n\n- 多项式乘法是 $O(n)$ 的，因为直接让 $y$ 相乘就行\n\n所以在点值表示法下做乘法运算是很优的！\n\n但是直接通过代入把系数表示法转换为点值表示法是 $O(n^2)$ 的，而 **FFT 就是把这一过程优化到了 $O(n\\log n)$**。\n\n### $n$ 次本原单位根\n\nFFT 能优化时间复杂度的一个重要原因是它**代入的不是随随便便的 $n+1$ 个不同的值，而是 $n$ 次本原单位根的 $0$ 次方、$1$ 次方一直到 $n$ 次方**。\n\n**$n$ 次单位根其实就是任意一个就是满足 $x^n=1$ 的 $x$，这个东西在实数范围显然只有不多于两个，但是在虚数范围就有 $n$ 个了。**\n\n\n**而 $n$ 次本原单位根则是一个特殊的 $n$ 次单位根 $\\omega_n$，满足 $\\omega_n^0\\not=\\omega_n^1\\not=\\omega_n^2\\not=\\dots\\not=\\omega_n^n$**。\n\n想要构造一个 $n$ 次本原单位根，最好的方法就是**把复平面上的单位圆平分成 $n$ 份**。例如六次本原单位根 $\\omega_6$：\n\n![](../post-images/1679559976196.webp)\n\n显然，$n$ 次本原单位根 $\\omega_n=\\operatorname{cos}(\\dfrac{2\\pi}{n})+\\operatorname{sin}(\\dfrac{2\\pi}{n})i$。\n\n我们考虑 $\\omega_n^2$ 是什么。因为虚数的乘法法则是模相乘，辐角相加，而 $\\omega_n$ 的模是 $1$，所以 **$\\omega_n^2$ 相当于 $\\omega^n$ 转了一下**：\n\n![](../post-images/1679559961806.webp)\n\n**所以 $\\omega_n^k=\\omega_n^{k\\mod n}$，相当于转一圈后会转回来。本原单位根会转是一个很重要的性质！**（虽然暂时没有用 ）\n\n### DFT 和 IDFT\n\n现在我们可以把单位根们代入多项式求值了，这就是 DFT。设 $f$ 是一个 $n-1$ 次多项式，那么有：\n\n$$\\hat f_k=\\sum\\limits_{i=0}^{n-1}f_i\\cdot\\omega_n^{ki}$$\n\n下面让我们证明 DFT 的逆变换 IDFT：\n\n\n$$f_k=\\dfrac{1}{n}\\sum\\limits_{i=0}^{n-1}\\hat f_i\\cdot\\omega_n^{-ki}$$\n\n****\n\n将 DFT 的柿子代入：\n\n$$f_k=\\dfrac{1}{n}\\sum\\limits_{i=0}^{n-1}\\omega_n^{-ki}\\sum\\limits_{j=0}^{n-1}f_j\\cdot\\omega_n^{ij}$$\n\n$$=\\dfrac{1}{n}\\sum\\limits_{j=0}^{n-1}f_j\\sum\\limits_{i=0}^{n-1}\\omega_n^{-ki}\\cdot\\omega_n^{ij}$$\n\n$$=\\dfrac{1}{n}\\sum\\limits_{j=0}^{n-1}f_j\\sum\\limits_{i=0}^{n-1}\\omega_n^{i(j-k)}$$\n\n考虑 $\\sum\\limits_{i=0}^{n-1}\\omega_n^{i(j-k)}$ 这部分：\n\n- 若 $j=k$，那么 $\\sum\\limits_{i=0}^{n-1}\\omega_n^{i(j-k)}=\\sum\\limits_{i=0}^{n-1}\\omega_n^{0}=n$\n\n- 若 $j\\not=k$，那么因为 $0\\le j,k<n$，所以 $|j-k|<n,\\omega_n^{j-k}\\not=0$，由等比数列求和公式得到：\n\n$$\\sum\\limits_{i=0}^{n-1}\\omega_n^{i(j-k)}=\\sum\\limits_{i=0}^{n-1}(\\omega_n^{j-k})^i$$\n\n$$=\\dfrac{1-(\\omega_n^{j-k})^n}{1-\\omega_n^{j-k}}$$\n\n$$=\\dfrac{1-(\\omega_n^n)^{j-k}}{1-\\omega_n^{j-k}}$$\n\n$$=\\dfrac{1-1}{1-\\omega_n^{j-k}}$$\n\n$$=0$$\n\n所以\n\n$$f_k=\\dfrac{1}{n}\\sum\\limits_{j=0}^{n-1}f_j\\cdot n\\cdot[j=k]$$\n\n$$=\\dfrac{1}{n}\\cdot n\\cdot f_k$$\n\n$$=f_k$$\n\n得证。\n\n****\n\n可以发现 DFT 和 IDFT 的柿子惊人地相似，只不过是多了个 $\\dfrac{1}{n}$ 和本原单位根指数上面的负号而已。所以我们**只需要解决 DFT，IDFT 就能迎刃而解**。\n\n### FFT\n\n设 $f$ 是一个次数为 $n-1$ 且 $n$ 是偶数的多项式（如果原来的 $n$ 是奇数那么可以补一项系数为 $0$ 的项），设 $m=\\dfrac{n}{2}$，那么有：\n\n$$f(x)=\\sum\\limits_{i=0}^{n-1}f_ix^i$$\n\n根据奇偶性分类，有：\n\n$$f(x)=\\sum\\limits_{i=0}^{m-1}f_{2i}x^{2i}+\\sum\\limits_{i=0}^{m-1}f_{2i+1}x^{2i+1}$$\n\n$$=\\sum\\limits_{i=0}^{m-1}f_{2i}x^{2i}+x\\sum\\limits_{i=0}^{m-1}f_{2i+1}x^{2i}$$\n\n定义 $f0(x)=\\sum\\limits_{i=0}^{m-1}f_{2i}x^{i}$，$f1(x)=\\sum\\limits_{i=0}^{m-1}f_{2i+1}x^{i}$，那么有：\n\n$$f(x)=f0(x^2)+x\n\\cdot f1(x^2)$$\n\n在代入单位根之前，我们先来看两个单位根的性质：\n\n$$\\omega_{2n}^{2k}=\\omega_{n}^k$$\n\n$$\\omega_{2n}^{n+k}=-\\omega_{2n}^k$$\n\n第一条性质是因为**以 $\\omega_{2n}$ 的辐角转 $2k$ 次相当于以 $\\omega_{n}$ 的辐角转 $k$ 次**。\n\n而第二条性质是因为**以 $\\omega_{2n}$ 的辐角转 $n$ 次就到达了 $-1$ 的位置**。\n\n记住这两条性质，代入单位根，对于满足 $0\\le k<m$ 的 $k$，有：\n\n$$f(\\omega_n^k)=f0(\\omega_n^{2k})+\\omega_n^k\\cdot f1(\\omega_n^{2k})$$\n\n$$=f0(\\omega_m^k)+\\omega_n^k\\cdot f1(\\omega_m^k)$$\n\n$$f(\\omega_n^{m+k})=f0(\\omega_n^{2(m+k)})+\\omega_n^{m+k}\\cdot f1(\\omega_n^{2(m+k)})$$\n\n$$=f0(\\omega_m^k)-\\omega_n^{k}\\cdot f1(\\omega_m^k)$$\n\n**以上两个柿子十分相似，所以被称作蝴蝶操作**。\n\n由蝴蝶操作不难得出，只要我们算出了 $f0(\\omega_m^0,\\omega_m^1,\\omega_m^2,\\dots,\\omega_m^{m-1})$ 和 $f1(\\omega_m^0,\\omega_m^1,\\omega_m^2,\\dots,\\omega_m^{m-1})$，就可以快速得到 $f(\\omega_n^0,\\omega_n^1,\\omega_n^2,\\dots,\\omega_n^{n-1})$。\n\n而 $f0(\\omega_m^0,\\omega_m^1,\\omega_m^2,\\dots,\\omega_m^{m-1})$ 和 $f1(\\omega_m^0,\\omega_m^1,\\omega_m^2,\\dots,\\omega_m^{m-1})$ 又可以递归下去算，所以我们**可以分治下去，用 $O(n\\log n)$ 的时间复杂度完成 DFT**！\n\n不过需要注意的是，**$n$ 必须是 $2$ 的幂，要不然无法分治**。\n\n**快速进行 IDFT 也相当好办，只要把 FFT 中用到的所有 $\\omega_n$ 换成 $\\omega_n^{-1}$ ，最后再把所有点值乘上 $\\dfrac{1}{n}$ 即可**。\n\n但是这还不够快，所以会被卡常。观察到影响效率的是按奇偶性分治，所以可以考虑令 $\\operatorname{rev}(x)$ 表示 $x$ 的二进制反过来组成的数，**令 $f^\\prime_i=f_{\\operatorname{rev}(i)}$，那么在 $f^\\prime$ 上的分治操作其实就是相邻两个序列的分治，这样可以大大加快 FFT 的速度，并且可以把 FFT 写成非递归的**。\n\n代码如下：（[模板题](https://www.luogu.com.cn/problem/P3803)）\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\nconst long long MS=5000005;\nconst double PI=acos(-1);\n\nstruct plex\n{\n    double x,y;\n    plex(double a=0,double b=0) {x=a,y=b;}\n};\nplex operator+(plex a,plex b) {return plex(a.x+b.x,a.y+b.y);}\nplex operator-(plex a,plex b) {return plex(a.x-b.x,a.y-b.y);}\nplex operator*(plex a,plex b) {return plex(a.x*b.x-a.y*b.y,a.x*b.y+b.x*a.y);}\n\ninline int getlen(int n)\n{\n    int res=1;\n    while(res<n) res<<=1;\n    return res;\n}\nint p_rev[MS],p_rev_lstn;\ninline void FFT(int n,plex a[],int tpe)\n{\n    if(p_rev_lstn!=n)\n    {\n        p_rev_lstn=n;\n        for(int i=0;i<n;i++) p_rev[i]=(p_rev[i>>1]>>1)|((i&1)?n>>1:0);\n    }\n    for(int i=0;i<n;i++) if(p_rev[i]<i) swap(a[p_rev[i]],a[i]);\n    for(int mid=1;mid<n;mid<<=1)\n    {\n        int len=mid<<1;\n        plex Wn=plex(cos(2*PI/len),tpe*sin(2*PI/len));\n        for(int l=0;l<n-len+1;l+=len)\n        {\n            plex Wk=plex(1,0);\n            for(int k=0;k<mid;k++,Wk=Wk*Wn)\n            {\n                plex x=a[l+k],y=Wk*a[l+mid+k];\n                a[l+k]=x+y,a[l+mid+k]=x-y;\n            }\n        }\n    }\n}\ninline void DFT(int n,plex a[]) {FFT(n,a,1);}\ninline void IDFT(int n,plex a[])\n{\n    FFT(n,a,-1);\n    for(int i=0;i<n;i++) a[i].x/=n,a[i].y/=n;\n}\n\nint n,m;\nplex a[MS],b[MS];\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tscanf(\"%lf\",&a[i].x);\n\t}\n\tfor(int i=0;i<=m;i++)\n\t{\n\t\tscanf(\"%lf\",&b[i].x);\n\t}\n\tint len=getlen(n+m+1);\n\tDFT(len,a);\n\tDFT(len,b);\n\tfor(int i=0;i<len;i++)\n\t{\n\t\ta[i]=a[i]*b[i];\n\t}\n\tIDFT(len,a);\n\tfor(int i=0;i<n+m+1;i++)\n\t{\n\t\tprintf(\"%d \",(int)(a[i].x+0.5));\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"学习笔记"},{"name":"数学"},{"name":"组合计数"},{"name":"多项式、生成函数"}],
			"title": "快速傅里叶变换（FFT）学习笔记",
			"link": "https://exber.qzz.io/post/%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%EF%BC%88FFT%EF%BC%89%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-03-23 16:25:24"
		},
	
		{
			"abstract": "",
			"content": "这是个大工程，以后会不断补充。\n\n# 最大流\n\n最大流的建模，往往是把流量和题目要求的东西直接关联起来，是最简单直白的建模。**最大流的模型有时候可以转化为二分图最大匹配**。\n\n## 拆点模型\n\n[P2472 [SCOI2007] 蜥蜴](https://www.luogu.com.cn/problem/P2472)\n\n网络流图中的点如果有流量限制，那么可以把一个点 $u$ 拆成入点 $u_1$ 和出点 $u_2$，$u_1$ 负责接收流量，$u_2$ 负责输送流量，$u1$ 向 $u2$ 连一条流量为点权的边即可。\n\n## 分层图模型\n\n[P2754 [CTSC1999]家园 / 星际转移问题](https://www.luogu.com.cn/problem/P2754)\n\n网络流图中的点如果会“动”，那么不妨按时间分层建图，模拟时间流逝。\n\n还有一类题比较特殊，要求最小层数。那么先判断无解，再不断加层直到满足条件即可。\n\n## 最小路径覆盖模型\n\n[P2764 最小路径覆盖问题](https://www.luogu.com.cn/problem/P2764)\n\n正难则反，首先考虑让所有点都自成路径，然后考虑尽可能通过边来“合并”这些路径。\n\n因为每个点只能在一条路径上，所以考虑拆点。把每个点 $u$ 拆成 $u_1$ 和 $u_2$，源点向 $U_1$ 连一条流量为 $1$ 的边，$u_2$ 向汇点连一条流量为 $1$ 的边，表示 $u$ 在路径上的前驱和后继只能有 $1$ 个节点。\n\n然后对于每条边 $(x,y)$，从 $x_1$ 向 $y_2$ 连一条边，表示 $y$ 可以做 $x$ 的后继，$x$ 可以做 $y$ 前驱。\n\n最后用 $n$ 减去最大流即可。\n\n可以发现此时的图其实是一个二分图，所以可以用二分图最大匹配代替网络流。\n\n## 流量平衡模型\n\n见 [网络流求最小费用特解（网络流解线性规划）学习笔记](http://www.ckjweb.tk/post/wang-luo-liu-qiu-zui-xiao-fei-yong-te-jie-wang-luo-liu-jie-xian-xing-gui-hua-xue-xi-bi-ji/)\n\n## 危桥模型\n\n[P3163 [CQOI2014]危桥](https://www.luogu.com.cn/problem/P3163)\n\n往返 $a_n$ 次相当于是从 $a_1$ 到 $a_2$ 走了 $2a_n$ 次，$b$ 也一样，所以问题转化为：\n\n> 有两组源汇点 $s1,t1$ 和 $s2,t2$，$s1\\to t1$ 最多流 $a1$ 的流量，$s2\\to t2$ 最多流 $a2$ 的流量，请判断能否满流。\n\n若直接源点向 $s1,s1$ 分别连流量为 $a1,a2$ 的边，$t1,t2$ 向汇点连流量为 $a1,a2$ 的边然后判是否满流，可能会出现这种情况：\n\n![](../post-images/1679559687299.png)\n\n即**所有满流的方案中**都会有一部分流量从 $s1$ 流到 $t2$，一部分流量从 $s2$ 流到 $t1$，此时实际上是不存在合法方案的，但是这样建图却会认为可以满流。\n\n解决方案很简单，我们**交换 $s2,t2$**，即从源点向 $t2$ 连流量为 $a2$ 的边，从 $s2$ 向汇点连流量为 $a2$ 的边，其余部分连边不变，再判断一次是否满流。若上图中的不合法情况必然出现，那么新图不可能满流；否则若新图上这种情况必定出现：\n\n![](../post-images/1679559676509.png)\n\n那么原图必定不可能满流。因为假若这两种情况同时出现，那么就可以这样流：\n\n![](../post-images/1679559661604.png)\n\n所以只要这两个图都能满流就证明原问题有解。\n\n类似的，这种建模方法应该还能推广到有 $n$ 对源汇点的情况，通过固定一对源汇点，枚举剩下的源汇点的交换与否，跑 $2^{n-1}$ 次最大流，则原问题有解当且仅当每次都是满流。\n\n# 最小割\n\n从最小割角度建模也是一种比较常见的建模方式。\n\n**设点 $u$ 最终在源点 $S$ 所在的连通块则 $b_u=1$，否则 $b_u=0$**。\n\n## 基本模型\n\n考虑最小割的数学定义：\n\n- 边 $(S,x,a)$ 对答案的贡献为 $a\\times (1-b_x)$；\n- 边 $(x,T,a)$ 对答案的贡献为 $a\\times b_x$；\n- 边 $(x,y,a)$ 对答案的贡献为 $a\\times b_x(1-b_y)$；\n\n所以基本限制如下：\n\n> 有 $n$ 个 01 变量 $b_i$，你需要确定每个 $b_i$ 的取值使得代价最小。\n>\n> 代价分为三类：\n>\n> - 若 $b_i=0$，有代价 $w1_i$；\n> - 若 $b_i=1$，有代价 $w2_i$；\n> - 若 $b_i=1$ 且 $b_j=0$，有代价 $w3_{i,j}$；\n\n基本模型如下：\n\n> 给第 $i$ 个元素建一个点 $i$。\n>\n> - 对于第一类限制，连边 $(S,i,w1_i)$；\n> - 对于第二类限制，连边 $(i,T,w2_i)$；\n> - 对于第三类限制，连边 $(i,j,w3_{i,j})$；\n\n## 混合模型\n\n相当于把基本模型中的 $S$ 换成别的点，流量不再由 $S$ 直接提供。\n\n可以看成多层基本模型。\n\n### 共同收益模型\n\n[P1361 小M的作物](https://www.luogu.com.cn/problem/P1361)\n\n诸如「对于所有 $u\\in A$，若 $\\sum b_u\\not=|A|$ 则有代价 $w$」的情况，可以新建一个点 $u$，连接边：\n\n- $(S,u,w)$；\n- $(u,x,\\inf)$，其中 $x\\in A$；\n\n同理，「对于所有 $u\\in A$，若 $\\sum b_u\\not=0$ 则有代价 $w$」的情况也可以类似做，新建一个点 $u$，连接边：\n\n- $(u,T,w)$；\n- $(x,u,\\inf)$，其中 $x\\in A$；\n\n建图是这样的：\n\n![](../post-images/1699518654262.png)\n\n### 切糕模型\n\n[P3227 [HNOI2013] 切糕](https://www.luogu.com.cn/problem/P3227)\n\n> 有 $n$ 个整数变量 $b_i$，第 $i$ 个变量取值范围 $[L_i,R_i]$。\n>\n> 代价分为两类：\n>\n> - $b_i=x$ 时有代价 $W_{i,x}$；\n> - $b_i\\ge x,b_j\\ge y$ 时有代价 $W_{i,x,j,y}$；\n\n直接看图吧：\n\n![](../post-images/1699517628442.bmp)\n\n### 混合模型\n\n各种模型的流量都可以不由 $S$ 直接提供。\n\n[P8215 [THUPC2022 初赛] 分组作业](https://www.luogu.com.cn/problem/P8215) | [题解](../P8215 [THUPC2022 初赛] 分组作业 做题记录)\n",
			"tags": [{"name":"学习笔记"},{"name":"图论"},{"name":"网络流"}],
			"title": "网络流的常见建模",
			"link": "https://exber.qzz.io/post/%E7%BD%91%E7%BB%9C%E6%B5%81%E7%9A%84%E5%B8%B8%E8%A7%81%E5%BB%BA%E6%A8%A1",
			"date": "2023-03-23 16:20:04"
		},
	
		{
			"abstract": "",
			"content": "整体二分，就是把查询放到一起二分，从而降低代码复杂度的一种**离线**算法。所以**想要使用整体二分需要保证查询的答案具有单调性和操作可以离线**。\n\n首先看一道例题：\n\n> 有一个空的可重集和 $m$ 个操作，每个操作有类型 $tpe_i$ 和一个参数 $x_i$。$tpe_i=1$ 的操作表示往可重集里添加 $x_i$，$tpe=_i2$ 的操作表示询问可重集内第 $x_i$ 小的数。\n\n> $1\\le m\\le 10^5$\n\n显然这道题可以用平衡树做，但是它太难写了。观察到**答案具有单调性，所以可以二分答案，用一个数据结构维护当前可重集内小于 $mid$ 的数的个数即可**。这样的时间复杂度是 $O(m\\log m)$ 的，但是仍然很难写。\n\n考虑降低代码复杂度。我们**可以先把所有操作离线下来，然后对于所有操作一起二分**。**“一起二分”就是将答案在 $[l,r]$ 区间内的询问和对这些询问的答案有影响的修改操作一起处理**，**设 $cur$ 表示 $[l,r]$ 内的操作序列，那么显然若 $l=r$，那么我们就已经找到答案了**。\n\n考虑 $l\\not=r$ 的情况。**设 $mid=\\left\\lfloor\\dfrac{l+r}{2}\\right\\rfloor$，那么我们需要把 $cur$ 分为两个操作序列 $lft$ 和 $rig$，其中 $lft$ 的答案在 $[l,mid]$ 内，$rig$ 的答案在 $[mid+1,r]$ 内，这样我们递归下去就可以求出答案了**。\n\n考虑怎么分组。**对于修改操作 $i$，显然若 $x_i \\le mid$ 那么这个操作会对 $lft$ 和 $rig$ 造成影响，但为了保证时间复杂度，我们只将它放入 $lft$ 中；否则只会对 $rig$ 造成影响，放入 $rig$ 中**。\n\n而对于询问操作 $i$，**我们可以计算出操作序列执行到 $i$ 时可重集内比 $mid$ 小的数的个数 $k$。若 $k\\ge x_i$，那么说明当前 $mid$ 大了或者对了，这个询问操作需要分到 $lft$ 里；否则说明当前 $mid$ 小了，这个询问操作需要分到 $rig$ 里**。 **但是注意，$k<x_i$ 即 $i$ 被分到 $rig$ 时，需要将 $x_i$ 减去** $k$。因为我们加入修改操作时把所有对两个操作序列都有影响的操作放进了 $lft$ 而没有加入 $rig$，所以我们需要额外计算上这些修改的贡献。\n\n容易发现，计算操作序列执行到 $i$ 时可重集内比 $mid$ 小的数的个数 $k$ 可以用一个变量 $cnt$ 简单统计。然后递归的层数是 $\\log m$，每一层会遍历一次所有操作，所以**时间复杂度为 $O(m\\log m)$**。\n\n考虑如何求第 $k$ 大值。显然可以只有分组部分有变化：\n\n**对于修改操作 $i$，显然若 $x_i > mid$ 那么这个操作会对 $lft$ 和 $rig$ 造成影响，但为了保证时间复杂度，我们只将它放入 $rig$ 中；否则只会对 $lft$ 造成影响，放入 $lft$ 中**。\n\n而对于询问操作 $i$，我们可以计算出操作序列执行到 $i$ 时可重集内比 $mid$ **大**的数的个数 $k$。**若 $k>=x_i$，那么说明当前 $mid$ 小了，这个询问操作需要分到 $rig$ 里；否则说明当前 $mid$ 大了或者对了，这个询问操作需要分到 $lft$ 里**。但是注意，$k<x_i$ **即 $i$ 被分到 $lft$ 时**，需要将 $x_i$ 减去 $k$。因为我们加入修改操作时把**所有对两个操作序列都有影响的操作放进了 $rig$ 而没有加入** $lft$，所以我们需要额外计算上这些修改的贡献。\n\n那么现在来看道例题吧：\n\n[P3332 [ZJOI2013]K大数查询](https://www.luogu.com.cn/problem/P3332)\n\n显然还是分组过程变了。发现变动的地方只是单点修改，整段查询变成了区间修改，区间查询。所以用线段树维护 $[l,r]$ 内可重集的并内比 $mid$ 大的数的个数 $k$ 即可。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nconst long long MS=50005;\n\nstruct node\n{\n\tint tpe,l,r,id;\n\tlong long val;\n};\n\nint n,m,quecnt;\nint ans[MS];\nlong long sum[MS<<2],lazy[MS<<2];\n\ninline void updata(int u)\n{\n\tsum[u]=sum[u<<1]+sum[u<<1|1];\n}\n\ninline void lazydown(int u,int l,int r)\n{\n\tif(lazy[u]==0)\n\t{\n\t\treturn;\n\t}\n\tint mid=l+r>>1;\n\tlazy[u<<1]+=lazy[u];\n\tlazy[u<<1|1]+=lazy[u];\n\tsum[u<<1]+=lazy[u]*(mid-l+1);\n\tsum[u<<1|1]+=lazy[u]*(r-mid);\n\tlazy[u]=0;\n}\n\nvoid upd(int u,int l,int r,int L,int R,long long k)\n{\n\tif(r<L||l>R)\n\t{\n\t\treturn;\n\t}\n\tif(l>=L&&r<=R)\n\t{\n\t\tlazy[u]+=k;\n\t\tsum[u]+=k*(r-l+1);\n\t\treturn;\n\t}\n\tlazydown(u,l,r);\n\tint mid=l+r>>1;\n\tif(L<=mid)\n\t{\n\t\tupd(u<<1,l,mid,L,R,k);\n\t}\n\tif(R>=mid+1)\n\t{\n\t\tupd(u<<1|1,mid+1,r,L,R,k);\n\t}\n\tupdata(u); \n}\n\nlong long que(int u,int l,int r,int L,int R)\n{\n\tif(r<L||l>R)\n\t{\n\t\treturn 0;\n\t}\n\tif(l>=L&&r<=R)\n\t{\n\t\treturn sum[u];\n\t}\n\tlazydown(u,l,r);\n\tint mid=l+r>>1;\n\tlong long res=0;\n\tif(L<=mid)\n\t{\n\t\tres+=que(u<<1,l,mid,L,R);\n\t}\n\tif(R>=mid+1)\n\t{\n\t\tres+=que(u<<1|1,mid+1,r,L,R);\n\t}\n\treturn res;\n}\n\nvoid slove(int l,int r,vector<node> &cur)\n{\n\tif(l==r)\n\t{\n\t\tfor(node x:cur)\n\t\t{\n\t\t\tif(x.tpe==2)\n\t\t\t{\n\t\t\t\tans[x.id]=l;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tint mid=l+r>>1;\n\tvector<node> lft,rig;\n\tfor(node x:cur)\n\t{\n\t\tif(x.tpe==1)\n\t\t{\n\t\t\tif(x.val<=mid)\n\t\t\t{\n\t\t\t\tlft.push_back(x);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\trig.push_back(x);\n\t\t\t\tupd(1,1,n,x.l,x.r,1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlong long vl=que(1,1,n,x.l,x.r);\n\t\t\tif(vl>=x.val)\n\t\t\t{\n\t\t\t\trig.push_back(x);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tx.val-=vl;\n\t\t\t\tlft.push_back(x);\n\t\t\t}\n\t\t}\n\t}\n\tfor(node x:rig)\n\t{\n\t\tif(x.tpe==1)\n\t\t{\n\t\t\tupd(1,1,n,x.l,x.r,-1);\n\t\t}\n\t}\n\tif(lft.size()>0)\n\t{\n\t\tslove(l,mid,lft);\n\t}\n\tif(rig.size()>0)\n\t{\n\t\tslove(mid+1,r,rig);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tvector<node> a;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tnode x;\n\t\tscanf(\"%d%d%d%lld\",&x.tpe,&x.l,&x.r,&x.val);\n\t\tif(x.tpe==2)\n\t\t{\n\t\t\tx.id=++quecnt;\n\t\t}\n\t\ta.push_back(x);\n\t}\n\tslove(-n,n,a);\n\tfor(int i=1;i<=quecnt;i++)\n\t{\n\t\tprintf(\"%d\\n\",ans[i]);\n\t}\n\treturn 0;\n}\n```\n\n### 练习题目\n\n- [P3527 [POI2011]MET-Meteors](https://www.luogu.com.cn/problem/P3527)\n",
			"tags": [{"name":"学习笔记"}],
			"title": "整体二分学习笔记",
			"link": "https://exber.qzz.io/post/%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-03-23 16:18:52"
		},
	
		{
			"abstract": "",
			"content": "由于网络流图中**除了源点和汇点外，其它节点都满足流入的流量等于流出的流量**。所以我们可以**通过把若干等式转换成图来求解最小费用的特解**，**不等式变形做一下差分变成等式也可以求**。\n\n具体的做法是，**先把每个等式都变形、化简，令每一个未知数都在且仅在两个等式里出现，且系数分别为 $+1$ 和 $-1$**。\n\n接下来：\n\n- 建立源点、汇点，并对每一个等式建一个点\n\n- **如果第 $i$ 个不等式右边的常量为非负整数 $w_i$，那么从 $i$ 向汇点连流量为 $w_i$，费用为 $0$ 的边**表示多余数量被吸走；**如果第 $i$ 个不等式右边的常量为负整数 $w_i$，那么从源点向 $i$ 连流量为 $-w_i$，费用为 $0$ 的边**表示少掉的流量被补充\n\n- **如果未知数 $x_i$ 在等式 $j$ 里的系数为 $-1$，在等式 $k$ 里的系数为 $+1$，并且这个未知数在最终计算答案的时候的系数为 $c_i$，那么从 $j$ 向 $k$ 连流量为 $\\inf$，费用为 $c_i$ 的边**，表示这个未知数的值从多出来的等式流向少掉的等式，且这个未知数增大需要收取费用（计算进答案）\n\n最后**判断有无可行解即判断是否满流**，而**最小解即为最小费用最大流**。\n\n[例题](https://www.luogu.com.cn/problem/P3980)\n\n先假设共 $3$ 天，第 $i$ 天招募 $p_i$ 人，共有 $3$ 类志愿者：\n\n- 第一类：从第 $1$ 天到第 $3$ 天，费用为 $c_1$，招募了 $b_1$ 人\n\n- 第二类：从第 $2$ 天到第 $3$ 天，费用为 $c_2$，招募了 $b_2$ 人\n\n- 第三类：从第 $1$ 天到第 $3$ 天，费用为 $c_3$，招募了 $b_3$ 人\n\n可以列出如下不等式：\n\n$$p_1=b_1+b_3\\ge a_1$$\n\n$$p_2=b_1+b_2+b_3\\ge a_2$$\n\n$$p_3=b_1+b_2\\ge a_3$$\n\n考虑转化成等式，设第 $i$ 天招募的人数超出最小人数 $d_i$ 人，显然 $d_i\\ge0$，那么有：\n\n$$p_1=b_1+b_3=a_1+d_1$$\n\n$$p_2=b_1+b_2+b_3=a_2+d_2$$\n\n$$p_3=b_1+b_2=a_3+d_3$$\n\n相邻两个等式相减（默认第 $0$ 个和第 $4$ 个等式为 $0$）:\n\n$$p_1=b_1+b_3=a_1+d_1$$\n\n$$p_2-p_1=b_2=a_2-a_1+d_2-d_1$$\n\n$$p_3-p_2=-b_3=a_3-a_2+d_3-d_2$$\n\n$$-p_3=-b_1-b_2=-a_3-d_3$$\n\n整理，消去 $p$，得：\n\n$$b_1+b_3-a_1-d_1=0$$\n\n$$b_2+a_1-a_2+d_1-d_2=0$$\n\n$$-b_3+a_2-a_3+d_2-d_3=0$$\n\n$$-b_1-b_2+a_3+d_3=0$$\n\n容易发现，这样构造可以令等式满足条件，所以可以建图跑最小费用最大流求解了。\n\n建图方式如下：\n\n- 建立源点、汇点和 $n+1$ 个等式点\n\n- 处理掉未知数 $d_i$ 和 $a_i$，$i$ 向 $i+1$ 连一条流量为 $\\inf$，费用为 $0$ 的边\n\n- 处理掉 $b_i$，对于第 $i$ 类志愿者，从 $s_i$ 向 $t_i$ 连一条流量为 $\\inf$，费用为 $c_i$ 的边，表示答案贡献式里的系数计算\n\n- 从源点向 $1$ 连一条流量为 $\\inf$，费用为 $0$ 的边；从 $n+1$ 向汇点连一条流量为 $\\inf$，费用为 $0$ 的边，让整张图“流起来”\n\n最后跑最小费用最大流求出最小费用即可。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nconst int S=5000005,MS=100005;\nconst long long inf=1000000007;\n\nint n,m,s,t;\nint esum,to[S],nxt[S],h[MS];\nlong long c[S],cost[S];\nlong long dis[MS];\nint cur[MS];\nbool vis[MS];\nlong long maxflow,mincost;\n\ninline void init()\n{\n\tesum=1;\n\tmemset(h,0,sizeof(h));\n\ts=0;\n\tt=n+2;\n}\n\ninline void add(int x,int y,long long w,long long v)\n{\n\tto[++esum]=y;\n\tc[esum]=w;\n\tcost[esum]=v;\n\tnxt[esum]=h[x];\n\th[x]=esum;\n}\n\ninline bool spfa()\n{\n\tmemset(dis,127,sizeof(dis));\n\tmemset(vis,0,sizeof(vis));\n\tlong long inf=dis[0];\n\tqueue<int> q;\n\tdis[s]=0;\n\tvis[s]=true;\n\tq.push(s);\n\twhile(!q.empty())\n\t{\n\t\tint u=q.front();\n\t\tq.pop();\n\t\tvis[u]=false;\n\t\tfor(int i=h[u];i;i=nxt[i])\n\t\t{\n\t\t\tint v=to[i];\n\t\t\tlong long w=cost[i];\n\t\t\tif(c[i]>0&&dis[u]+w<dis[v])\n\t\t\t{\n\t\t\t\tdis[v]=dis[u]+w;\n\t\t\t\tif(!vis[v])\n\t\t\t\t{\n\t\t\t\t\tvis[v]=true;\n\t\t\t\t\tq.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[t]<inf;\n}\n\nlong long dfs(int u,long long w)\n{\n\tif(u==t)\n\t{\n\t\treturn w;\n\t}\n\tvis[u]=true;\n\tlong long sum=0;\n\tfor(int &i=cur[u];i;i=nxt[i])\n\t{\n\t\tint v=to[i];\n\t\tif(c[i]>0&&dis[v]==dis[u]+cost[i]&&!vis[v])\n\t\t{\n\t\t\tlong long re=dfs(v,min(w,c[i]));\n\t\t\tmincost+=re*cost[i];\n\t\t\tc[i]-=re;\n\t\t\tc[i^1]+=re;\n\t\t\tw-=re;\n\t\t\tsum+=re;\n\t\t\tif(w==0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvis[u]=false;\n\treturn sum;\n}\n\ninline void mcmf()\n{\n\tmincost=0;\n\tmaxflow=0;\n\twhile(spfa())\n\t{\n\t\tfor(int i=s;i<=t;i++)\n\t\t{\n\t\t\tcur[i]=h[i];\n\t\t}\n\t\tmaxflow+=dfs(s,1e17);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tinit();\n\tadd(s,1,inf,0);\n\tadd(1,s,0,0);\n\tadd(n+1,t,inf,0);\n\tadd(t,n+1,0,0); \n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tlong long x;\n\t\tscanf(\"%lld\",&x);\n\t\tadd(i,i+1,inf-x,0);\n\t\tadd(i+1,i,0,0);\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint l,r;\n\t\tlong long need;\n\t\tscanf(\"%d%d%lld\",&l,&r,&need);\n\t\tadd(l,r+1,1e17,need);\n\t\tadd(r+1,l,0,-need);\n\t}\n\tmcmf();\n\tprintf(\"%lld\\n\",mincost);\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"学习笔记"},{"name":"图论"},{"name":"网络流"}],
			"title": "网络流求最小费用特解（网络流解线性规划）学习笔记",
			"link": "https://exber.qzz.io/post/%E7%BD%91%E7%BB%9C%E6%B5%81%E6%B1%82%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E7%89%B9%E8%A7%A3%EF%BC%88%E7%BD%91%E7%BB%9C%E6%B5%81%E8%A7%A3%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%EF%BC%89%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-03-23 16:17:59"
		},
	
		{
			"abstract": "",
			"content": "有些树上操作题目需要换根操作，用普通的树链剖分无法解决此类问题。这时我们就需要改造一下树剖，令它支持换根操作。\n\n首先**肯定不可能每次都重新剖分，因为那样会 TLE**。那么**考虑以 $1$ 为根剖，记下当前的跟 $rt$，对于每个操作特殊处理**。\n\n- **最近公共祖先**\n\n考虑**用 $\\operatorname{lca}(x,y)$ 表示以 $1$ 为根时 $x$ 和 $y$ 的最近公共祖先，用 $\\operatorname{LCA}(x,y)$ 表示换根后 $x$ 和 $y$ 的最近公共祖先（这里默认 $x$ 深度小于等于 $y$）**。 \n\n1. 若 $\\operatorname{lca}(x,y)=x$：（图中绿色节点是 $x$，红色节点是 $y$，不同颜色的节点是不同情况下 $rt$ 的位置）\n\n![](../post-images/1679559339340.webp)\n\n(1) 若 $rt$ 位于黄色区域，即 $\\operatorname{lca}(x,rt)=x\\land\\operatorname{lca}(y,rt)=y$，那么 $\\operatorname{LCA}(x,y)=y$\n\n(2) 若 $rt$ 位于橙色区域，即 $\\operatorname{lca}(x,rt)=x\\land\\operatorname{lca}(y,rt)\\not=y$，那么 $\\operatorname{LCA}(x,y)=\\operatorname{lca}(y,rt)$\n\n(3) 若 $rt$ 位于粉色区域，即 $\\operatorname{lca}(x,rt)\\not=x$，那么 $\\operatorname{LCA}(x,y)=\\operatorname{lca}(x,y)$\n\n1. 若 $\\operatorname{lca}(x,y)\\not=x$：（图中绿色节点是 $x$，红色节点是 $y$，不同颜色的节点是不同情况下 $rt$ 的位置）\n\n![](../post-images/1679559324709.webp)\n\n(1) 若 $rt$ 位于灰色区域，即 $\\operatorname{lca}(x,rt)=x$，那么 $\\operatorname{LCA}(x,y)=x$\n\n(2) 若 $rt$ 位于蓝色区域，即 $\\operatorname{lca}(x,rt)=y$，那么 $\\operatorname{LCA}(x,y)=y$\n\n(3) 若 $rt$ 位于粉色区域，即 $\\operatorname{lca}(x,rt)=\\operatorname{lca}(y,rt)$，那么 $\\operatorname{LCA}(x,y)=\\operatorname{lca}(x,y)$\n\n(4) 若 $rt$ 位于橙色区域，即 $(\\operatorname{lca}(x,rt)=rt\\land\\operatorname{lca}(y,rt)=\\operatorname{lca}(x,y))\\lor(\\operatorname{lca}(x,rt)=\\operatorname{lca}(x,y)\\land\\operatorname{lca}(y,rt)=y)$，那么 $\\operatorname{LCA}(x,y)=rt$\n\n(5) 若以上条件均不满足，那么若 $\\operatorname{lca}(x,rt)=\\operatorname{lca}(x,y)$，那么 $\\operatorname{LCA}(x,y)=\\operatorname{lca}(x,rt)$，否则 $\\operatorname{LCA}(x,y)=\\operatorname{lca}(y,rt)$\n\n代码如下：\n\n```cpp\ninline int getLCA(int x,int y)\n{\n\tif(dep[x]>dep[y])\n\t{\n\t\tswap(x,y);\n\t}\n\tint xr=getlca(x,rt),yr=getlca(y,rt),xy=getlca(x,y);\n\tif(xy==x)\n\t{\n\t\tif(xr==x&&yr==y)\n\t\t{\n\t\t\treturn y;\n\t\t}\n\t\tif(xr==x)\n\t\t{\n\t\t\treturn yr;\n\t\t}\n\t\treturn x;\n\t}\n\telse\n\t{\n\t\tif(xr==x||yr==y)\n\t\t{\n\t\t\treturn xr==x?x:y;\n\t\t}\n\t\tif(xr==yr)\n\t\t{\n\t\t\treturn xy;\n\t\t}\n\t\tif((xr==rt&&yr==xy)||(xr==xy&&yr==rt))\n\t\t{\n\t\t\treturn rt;\n\t\t}\n\t\treturn xr==xy?yr:xr;\n\t}\n}\n```\n\n- **链上询问/修改**\n\n显然**无论根怎么换，链 $(u,v)$ 上的节点都不会改变，所以直接修改**即可。\n\n- **子树内询问/修改**\n\n图中绿色节点是 $x$。\n\n![](../post-images/1679559307313.webp)\n\n1. 若 $rt=x$，那么查询/修改整棵子树\n\n2. 若 $rt$ 位于黄色区域，即 $\\operatorname{lca}(x,rt)=x，那么查询/修改 $x$ 子树除了 $rt$ 方向儿子的子树外所有的节点\n\n3. 否则说明 $rt$ 位于粉色区域，那么查询/求改 $x$ 子树即可\n\n代码如下：\n\n```cpp\ninline int jump(int x,int k)\n{\n\tfor(int i=25;i>=0;i--)\n\t{\n\t\tif(k&(1<<i))\n\t\t{\n\t\t\tx=up[x][i];\n\t\t}\n\t}\n\treturn x;\n}\n\ninline int quesubtree(int x)\n{\n\tif(x==rt)\n\t{\n\t\treturn que(1,1,n,1,n);\n\t}\n\tint xr;\n\tif(dep[rt]>dep[x]&&up[xr=jump(rt,dep[rt]-dep[x]-1)][0]==x)\n\t{\n\t\tif(id[xr]==1)\n\t\t{\n\t\t\treturn que(1,1,n,R[xr]+1,n);\n\t\t}\n\t\tif(R[xr]==n)\n\t\t{\n\t\t\treturn que(1,1,n,1,id[xr]-1);\n\t\t}\n\t\treturn min(que(1,1,n,1,id[xr]-1),que(1,1,n,R[xr]+1,n));\n\t}\n\treturn que(1,1,n,id[x],R[x]);\n}\n```\n\n[模板题](https://www.luogu.com.cn/problem/P3979)代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst long long S=1000005,MS=100005;\nconst int inf=2147483647;\n\nint n,m,val[MS];\nint esum,to[S],nxt[S],h[MS];\nint up[MS][30],dep[MS],siz[MS],hson[MS];\nint cnt,id[MS],top[MS],a[MS],R[MS];\nint minn[MS<<2],lazy[MS<<2];\nint rt;\n\ninline void add(int x,int y)\n{\n\tto[++esum]=y;\n\tnxt[esum]=h[x];\n\th[x]=esum;\n}\n\nvoid dfs1(int u,int fa) \n{\n\tup[u][0]=fa;\n\tfor(int i=1;i<=25;i++)\n\t{\n\t\tup[u][i]=up[up[u][i-1]][i-1];\n\t}\n\tdep[u]=dep[fa]+1;\n\tsiz[u]=1;\n\tfor(int i=h[u];i;i=nxt[i])\n\t{\n\t\tint v=to[i];\n\t\tif(v==fa)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tdfs1(v,u);\n\t\tsiz[u]+=siz[v];\n\t\tif(siz[v]>siz[hson[u]])\n\t\t{\n\t\t\thson[u]=v;\n\t\t}\n\t}\n}\n\nvoid dfs2(int u,int tpf)\n{\n\tid[u]=++cnt;\n\ttop[u]=tpf;\n\ta[cnt]=val[u];\n\tif(hson[u]!=0)\n\t{\n\t\tdfs2(hson[u],tpf);\n\t}\n\tfor(int i=h[u];i;i=nxt[i])\n\t{\n\t\tint v=to[i];\n\t\tif(v==up[u][0]||v==hson[u])\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tdfs2(v,v);\n\t}\n\tR[u]=cnt;\n}\n\nvoid build(int u,int l,int r)\n{\n\tlazy[u]=-1;\n\tif(l==r)\n\t{\n\t\tminn[u]=a[l];\n\t\treturn;\n\t}\n\tint mid=l+r>>1;\n\tbuild(u<<1,l,mid);\n\tbuild(u<<1|1,mid+1,r);\n\tminn[u]=min(minn[u<<1],minn[u<<1|1]);\n}\n\nvoid upd(int u,int l,int r,int L,int R,int k)\n{\n\tif(l>R||r<L)\n\t{\n\t\treturn;\n\t}\n\tif(l>=L&&r<=R)\n\t{\n\t\tminn[u]=k;\n\t\tlazy[u]=k;\n\t\treturn;\n\t}\n\tif(lazy[u]!=-1)\n\t{\n\t\tminn[u<<1]=lazy[u];\n\t\tminn[u<<1|1]=lazy[u];\n\t\tlazy[u<<1]=lazy[u];\n\t\tlazy[u<<1|1]=lazy[u];\n\t\tlazy[u]=-1;\n\t}\n\tint mid=l+r>>1;\n\tif(L<=mid)\n\t{\n\t\tupd(u<<1,l,mid,L,R,k);\n\t}\n\tif(R>=mid+1)\n\t{\n\t\tupd(u<<1|1,mid+1,r,L,R,k);\n\t}\n\tminn[u]=min(minn[u<<1],minn[u<<1|1]);\n}\n\nint que(int u,int l,int r,int L,int R)\n{\n\tif(l>R||r<l)\n\t{\n\t\treturn inf;\n\t}\n\tif(l>=L&&r<=R)\n\t{\n\t\treturn minn[u];\n\t}\n\tif(lazy[u]!=-1)\n\t{\n\t\tminn[u<<1]=lazy[u];\n\t\tminn[u<<1|1]=lazy[u];\n\t\tlazy[u<<1]=lazy[u];\n\t\tlazy[u<<1|1]=lazy[u];\n\t\tlazy[u]=-1;\n\t}\n\tint mid=l+r>>1,res=inf;\n\tif(L<=mid)\n\t{\n\t\tres=min(res,que(u<<1,l,mid,L,R));\n\t}\n\tif(R>=mid+1)\n\t{\n\t\tres=min(res,que(u<<1|1,mid+1,r,L,R));\n\t}\n\treturn res;\n}\n\ninline int jump(int x,int k)\n{\n\tfor(int i=25;i>=0;i--)\n\t{\n\t\tif(k&(1<<i))\n\t\t{\n\t\t\tx=up[x][i];\n\t\t}\n\t}\n\treturn x;\n}\n\ninline int getlca(int x,int y)\n{\n\tif(dep[x]<dep[y])\n\t{\n\t\tswap(x,y);\n\t}\n\tfor(int i=25;i>=0;i--)\n\t{\n\t\tif(dep[up[x][i]]>=dep[y])\n\t\t{\n\t\t\tx=up[x][i];\n\t\t}\n\t}\n\tif(x==y)\n\t{\n\t\treturn x;\n\t}\n\tfor(int i=25;i>=0;i--)\n\t{\n\t\tif(up[x][i]!=up[y][i])\n\t\t{\n\t\t\tx=up[x][i];\n\t\t\ty=up[y][i];\n\t\t}\n\t}\n\treturn up[x][0];\n}\n\ninline int getLCA(int x,int y)\n{\n\tif(dep[x]>dep[y])\n\t{\n\t\tswap(x,y);\n\t}\n\tint xr=getlca(x,rt),yr=getlca(y,rt),xy=getlca(x,y);\n\tif(xy==x)\n\t{\n\t\tif(xr==x&&yr==y)\n\t\t{\n\t\t\treturn y;\n\t\t}\n\t\tif(xr==x)\n\t\t{\n\t\t\treturn yr;\n\t\t}\n\t\treturn x;\n\t}\n\telse\n\t{\n\t\tif(xr==x||yr==y)\n\t\t{\n\t\t\treturn xr==x?x:y;\n\t\t}\n\t\tif(xr==yr)\n\t\t{\n\t\t\treturn xy;\n\t\t}\n\t\tif((xr==rt&&yr==xy)||(xr==xy&&yr==rt))\n\t\t{\n\t\t\treturn rt;\n\t\t}\n\t\treturn xr==xy?yr:xr;\n\t}\n}\n\ninline void updpath(int x,int y,int k)\n{\n\twhile(top[x]!=top[y])\n\t{\n\t\tif(dep[top[x]]>dep[top[y]])\n\t\t{\n\t\t\tupd(1,1,n,id[top[x]],id[x],k);\n\t\t\tx=up[top[x]][0];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tupd(1,1,n,id[top[y]],id[y],k);\n\t\t\ty=up[top[y]][0];\n\t\t}\n\t}\n\tupd(1,1,n,min(id[x],id[y]),max(id[x],id[y]),k);\n}\n\ninline int quesubtree(int x)\n{\n\tif(x==rt)\n\t{\n\t\treturn que(1,1,n,1,n);\n\t}\n\tint xr;\n\tif(dep[rt]>dep[x]&&up[xr=jump(rt,dep[rt]-dep[x]-1)][0]==x)\n\t{\n\t\tif(id[xr]==1)\n\t\t{\n\t\t\treturn que(1,1,n,R[xr]+1,n);\n\t\t}\n\t\tif(R[xr]==n)\n\t\t{\n\t\t\treturn que(1,1,n,1,id[xr]-1);\n\t\t}\n\t\treturn min(que(1,1,n,1,id[xr]-1),que(1,1,n,R[xr]+1,n));\n\t}\n\treturn que(1,1,n,id[x],R[x]);\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);\n\t\tadd(y,x);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&val[i]);\n\t}\n\tscanf(\"%d\",&rt);\n\tdfs1(1,0);\n\tdfs2(1,1);\n\tbuild(1,1,n);\n\twhile(m--)\n\t{\n\t\tint op;\n\t\tscanf(\"%d\",&op);\n\t\tif(op==1)\n\t\t{\n\t\t\tscanf(\"%d\",&rt);\n\t\t}\n\t\telse if(op==2)\n\t\t{\n\t\t\tint x,y,k;\n\t\t\tscanf(\"%d%d%d\",&x,&y,&k);\n\t\t\tupdpath(x,y,k);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint x;\n\t\t\tscanf(\"%d\",&x);\n\t\t\tprintf(\"%d\\n\",quesubtree(x));\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n### 练习题目\n\n- [CF916E Jamie and Tree](https://www.luogu.com.cn/problem/CF916E)\n",
			"tags": [{"name":"学习笔记"},{"name":"数据结构"}],
			"title": "换根树剖学习笔记",
			"link": "https://exber.qzz.io/post/%E6%8D%A2%E6%A0%B9%E6%A0%91%E5%89%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-03-23 16:14:28"
		},
	
		{
			"abstract": "",
			"content": "有些时候，我们想要计算一个集合 $S$ 里元素的最小值/最大值，设最小值为 $\\operatorname{MIN}(S)=\\min\\limits_{x\\in S}x$，最大值为 $\\operatorname{MAX}(S)=\\max\\limits_{x\\in S}x$。\n\n但是有时我们想要求 $\\operatorname{MIN}(S)$，但却很难求，反而 $\\operatorname{MAX}(S)$ 很好求；或者想要求 $\\operatorname{MAX}(S)$，但却很难求，反而 $\\operatorname{MIN}(S)$ 很好求。那么这时就**可以通过 Min-Max 容斥来实现 $\\operatorname{MIN}(S)$ 和 $\\operatorname{MAX}(S)$ 的互相转化**，从而求得 $\\operatorname{MIN}(S)$ 或者 $\\operatorname{MAX}(S)$。\n\n### 朴素 Min-Max 容斥\n\nMin-Max 容斥，先给出式子：\n\n$$\n\\operatorname{MIN}(S)=\\sum\\limits_{T\\subseteq S}(-1)^{|T|+1}\\operatorname{MAX}(T)\\\\\n\\operatorname{MAX}(S)=\\sum\\limits_{T\\subseteq S}(-1)^{|T|+1}\\operatorname{MIN}(T)\\\\\n$$\n\n先考虑第一个式子的证明：\n\n> 首先假设 $S$ 内元素互不相同（离散化），然后**令 $S$ 中元素升序排列后的数列为 $A$**。\n>\n> 令 $\\operatorname{MAX}(T)=A_i$，有以下两种情况：\n>\n> - $i=1$，那么显然 $|T|=1$，此时 $\\operatorname{MAX}(T)=\\operatorname{MIN}(S)$，$T$ 的贡献也就是 $(-1)^2\\operatorname{MIN}(S)=\\operatorname{MIN}(S)$；\n>\n> - $i>1$，那么集合内显然不可能存在满足 $j>i$ 的 $A_{j}$，那么只有 $2^{i-1}$ 个集合贡献为 $A_i$，显然有 $2^{i-2}$ 个集合的大小是奇数，$2^{i-2}$ 个集合的大小是偶数，**它们抵消了，所以此时 $T$ 的贡献是 $0$**；\n\n第二个式子证明过程大体相同，只不过 $A$ 换成了降序排列。\n\nMin-Max 的优点在于它能**实现 $f(\\operatorname{MIN}(S))$ 和 $f(\\operatorname{MAX}(S))$ 的不涉及到取 $\\min$ 和取 $\\max$ 操作的互相转化，其中 $f$ 是任意一个线性函数**，例如**期望**。\n\n理解了它的原理后也不难推出式子：\n\n$$\nf(\\operatorname{MIN}(S))=\\sum\\limits_{T\\subseteq S}(-1)^{|T|+1}f(\\operatorname{MAX}(T))\\\\\nf(\\operatorname{MAX}(S))=\\sum\\limits_{T\\subseteq S}(-1)^{|T|+1}f(\\operatorname{MIN}(T))\\\\\n$$\n\n### Kth-Min-Max 容斥\n\nMin-Max 容斥的另一个优点在于，它**还能求出集合 $S$ 的第 $k$ 大/小 $\\operatorname{MAX}_k(S)$ 和 $\\operatorname{MIN}_k(S)$**，推导如下：\n\n考虑令 $\\operatorname{MIN}_k(S)=\\sum\\limits_{T\\subseteq S}F(|T|)\\operatorname{MAX}(T)$，构造 $F$。\n\n类似的，假设 $S$ 内元素互不相同（离散化），然后**令 $S$ 中元素降升序排列后的数列 $A$**。\n\n我们设 $\\operatorname{MAX}(T)=A_p$ 那么显然只有 $T$ 不包含满足 $j>p$ 的 $A_j$ 才能让 $\\operatorname{MAX}(T)=A_p$，即**有 $p-1$ 个数可供选择，所以对于所有满足 $\\operatorname{MAX}(T)=A_p$ 的 $T$，它的系数 $F$ 是**：\n\n$$\n\\sum\\limits_{i=0}^{p-1}\\dbinom{p-1}{i}F(i+1)\n$$\n\n求和函数的变量 $i$ 表示除了 $A_p$ 外多选的元素，然后 $F(i+1)$ 表示选那么多数的贡献系数，$\\dbinom{p-1}{i}$ 表示可以随便选择。\n\n然后我们想让 $F$ 满足：\n\n$$\n\\sum\\limits_{i=0}^{p-1}\\dbinom{p-1}{i}F(i+1)=[p=k]\n$$\n\n即：\n\n$$\n\\sum\\limits_{i=0}^{p}\\dbinom{p}{i}F(i+1)=[p=k-1]\n$$\n\n二项式反演一下：\n\n$$\n[p=k+1]=\\sum\\limits_{i=0}^{p}\\dbinom{p}{i}F(i+1)\\Rightarrow F(p+1)=\\sum\\limits_{i=0}^{p}(-1)^{p-i}\\dbinom{p}{i}[i=k-1]\n$$\n\n即：\n\n$$F(p)=(-1)^{p-k}\\dbinom{p-1}{k-1}$$\n\n所以：\n\n$$\n\\operatorname{MIN}_k(S)=\\sum\\limits_{T\\subseteq S}(-1)^{|T|-k}\\dbinom{|T|-1}{k-1}\\operatorname{MAX}(T)\\\\\n\\operatorname{MAX}_k(S)=\\sum\\limits_{T\\subseteq S}(-1)^{|T|-k}\\dbinom{|T|-1}{k-1}\\operatorname{MIN}(T)\n$$\n\n代入 $k=1$ 验证：\n\n$$\n\\begin{aligned}\n\\operatorname{MIN}_1(S)&=\\sum\\limits_{T\\subseteq S}(-1)^{|T|-1}\\dbinom{|T|-1}{1-1}\\operatorname{MAX}(T)\\\\\n&=\\sum\\limits_{T\\subseteq S}(-1)^{|T|-1}\\operatorname{MAX}(T)\\\\\n\\end{aligned}\n$$\n\n发现得到了之前的式子，所以我们推对了。\n\n同样的，Kth-Min-Max 容斥也可以套上任意线性函数。\n\n### 应用\n\n#### [HDU 4624 Endless Spin](https://vjudge.csgrandeur.cn/problem/HDU-4624)\n\n双倍经验：[ABC242Ex Random Painting](https://atcoder.jp/contests/abc242/tasks/abc242_h)\n\n要求所有球均被染色的时间，可以通过 Min-Max 容斥转化为求一个子集 $S$ 中的球最早被染色的时间 $Tme_S$。\n\n进一步的，若 $S$ 中的球被染色的概率为 $p$，那么 $Tme_S$ 就等于 $\\frac{1}{p}$。\n\n而被染色的概率很好求，只要求出能给这些球染色的区间个数 $sum$，除以总的区间个数 $\\binom{n}{2}+n$ 即可。\n\n那么直接设 $dp_{i,j}$ 表示前 $i$ 个球处理完毕，当前子集 $S$ 选了球 $i$ 且不被染色的选区间的方案数为 $j$ 的选子集的方案数，转移的时候把容斥系数也乘进去，最后套 Min-Max 的式子即可。\n\n时间复杂度 $O(n^4)$。\n\n",
			"tags": [{"name":"学习笔记"},{"name":"数学"},{"name":"组合计数"}],
			"title": "Min-Max 容斥学习笔记",
			"link": "https://exber.qzz.io/post/Min-Max%20%E5%AE%B9%E6%96%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-03-23 16:12:27"
		},
	
		{
			"abstract": "",
			"content": "二项式反演在需要容斥问题的中经常出现，也是很多知识的基础。\n\n## 引入\n\n首先设 $A_1,A_2,\\dots,A_n$ 是 $n$ 个集合，那么有：\n$$\n|A_i\\cup A_2\\cup\\dots\\cup A_n|=\\left(\\sum\\limits_{1\\le i\\le n}|A_i|\\right)-\\left(\\sum\\limits_{1\\le i<j\\le n}|A_i\\cap A_j|\\right)+\\left(\\sum\\limits_{1\\le i<j<k\\le n}|A_i\\cap A_j\\cap A_k|\\right)-\\dots+(-1)^{n-1}\\times|A_1\\cap A_2\\cap\\dots\\cap A_n|\n$$\n这其实很好理解，就是减掉算重一次的，加上算重两次的，减掉算重三次的……\n\n变形一下，有：（$A_i^c$ 是 $A_i$ 的补集，$S$ 是全集）\n$$\n|A_i^c\\cap A_2^c\\cap\\dots\\cap A_n^c|=|S|-\\left(\\sum\\limits_{1\\le i\\le n}|A_i|\\right)+\\left(\\sum\\limits_{1\\le i<j\\le n}|A_i\\cap A_j|\\right)-\\left(\\sum\\limits_{1\\le i<j<k\\le n}|A_i\\cap A_j\\cap A_k|\\right)+\\dots+(-1)^n\\times|A_1\\cap A_2\\cap\\dots\\cap A_n|\n$$\n由于补集的补集是原集，所以有：\n$$\n|A_i\\cap A_2\\cap\\dots\\cap A_n|=|S|-\\left(\\sum\\limits_{1\\le i\\le n}|A_i^c|\\right)+\\left(\\sum\\limits_{1\\le i<j\\le n}|A_i^c\\cap A_j^c|\\right)-\\left(\\sum\\limits_{1\\le i<j<k\\le n}|A_i^c\\cap A_j^c\\cap A_k^c|\\right)+\\dots+(-1)^n\\times|A_1^c\\cap A_2^c\\cap\\dots\\cap A_n^c|\n$$\n\n考虑一种特殊情况，集合的交集大小之和集合个数有关。设 $f(n)$ 表示 $n$ 个集合的补集的交集大小，$g(n)$ 表示 $n$ 个集合的交集大小，那么上面两条式子可以写成：\n$$\nf(n)=\\sum\\limits_{i=0}^n(-1)^i\\binom{n}{i}g(i)\n$$\n\n$$\ng(n)=\\sum\\limits_{i=0}^n(-1)^i\\binom{n}{i}f(i)\n$$\n\n所以这两条式子是等价的关系，那么有：\n$$\nf(n)=\\sum\\limits_{i=0}^n(-1)^i\\binom{n}{i}g(i)\\iff g(n)=\\sum\\limits_{i=0}^n(-1)^i\\binom{n}{i}f(i)\n$$\n这就是二项式反演的形式一。\n\n## 更多形式\n\n### 形式二\n\n$$\nf(n)=\\sum\\limits_{i=0}^n\\dbinom{n}{i}g(i)\\iff g(n)=\\sum\\limits_{i=0}^n(-1)^{n-i}\\dbinom{n}{i}f(i)\n$$\n\n证明：\n\n令 $h(n)=(-1)^n g(n)$，那么带入形式一有 $f(n)=\\sum\\limits_{i=0}^n\\binom{n}{i}h(i)\\iff \\frac{h(n)}{(-1)^n}=g(n)=\\sum\\limits_{i=0}^n(-1)^i\\binom{n}{i}f(i)$，整理后即得证。\n\n### 形式三\n\n$$\nf(n)=\\sum\\limits_{i=n}^m\\binom{i}{n}g(i)\\iff g(n)=\\sum\\limits_{i=n}^m(-1)^{i-n}\\binom{i}{n}f(i)\n$$\n\n证明：\n\n组合意义是 $f(n)$ 表示钦定 $n$ 个选，$g(n)$ 表示恰好选 $n$ 个。因为 $f(n)$ 同一种方案会计算多次，具体的，选 $n$ 个的方案钦定选 $i$ 个就会重复计算 $\\binom{n}{i}$ 次，所以 $f(n)=\\sum\\limits_{i=n}^m\\binom{i}{n}g(i)$。而\n$$\n\\begin{aligned}\ng(n)&=\\sum\\limits_{i=n}^m(-1)^{i-n}\\binom{i}{n}f(i)\\\\\n&=\\sum\\limits_{i=n}^m(-1)^{i-n}\\binom{i}{n}\\sum\\limits_{j=i}^m\\binom{j}{i}g(j)\\\\\n&=\\sum\\limits_{j=n}^mg(j)\\sum\\limits_{i=n}^j(-1)^{i-n}\\binom{i}{n}\\binom{j}{i}\\\\\n&=\\sum\\limits_{j=n}^mg(j)\\sum\\limits_{i=n}^j(-1)^{i-n}\\frac{i!}{n!(i-n)!}\\frac{j!}{i!(j-i)!}\\\\\n&=\\sum\\limits_{j=n}^mg(j)\\sum\\limits_{i=n}^j(-1)^{i-n}\\frac{j!}{n!(i-n)!(j-i)!}\\\\\n&=\\sum\\limits_{j=n}^mg(j)\\sum\\limits_{i=n}^j(-1)^{i-n}\\frac{j!(j-n)!}{n!(i-n)!(j-i)!(j-n)!}\\\\\n&=\\sum\\limits_{j=n}^m\\binom{j}{n}g(j)\\sum\\limits_{i=n}^j(-1)^{i-n}\\binom{j-n}{i-n}\\\\\n&=\\sum\\limits_{j=n}^m\\binom{j}{n}g(j)\\sum\\limits_{i=0}^{j-n}(-1)^{i}\\binom{j-n}{i}\\\\\n&=\\sum\\limits_{j=n}^m\\binom{j}{n}g(j)(1-1)^{j-n}\\\\\n&=\\sum\\limits_{j=n}^m\\binom{j}{n}g(j)[j==n]\\\\\n&=\\binom{n}{n}g(n)\\\\\n&=g(n)\\\\\n\\end{aligned}\n$$\n所以得证。\n\n## 例题\n\n[bzoj 2839 集合计数](https://vjudge.csgrandeur.cn/problem/黑暗爆炸-2839#author=0)\n\n设 $f(i)$ 表示钦定交集有 $i$ 个的方案数，$g(i)$ 表示交集恰好有 $i$ 个的方案数，那么有 $f(i)=\\binom{n}{i}(2^{2^{n-i}}-1)$，$f(i)=\\sum\\limits_{j=i}^n\\binom{j}{i}g(j)$，反演一下得到 $g(i)=\\sum\\limits_{j=i}^n(-1)^{j-i}\\binom{j}{i}f(j)$，由于只要算一次，所以直接算就行了。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst int S=1000005,p=1000000007;\n\nint fra[S],inv[S];\nint n,k;\nint f[S];\n\ninline int qpow(int x,int y,int p)\n{\n\tint res=1;\n\tfor(;y>0;y>>=1,x=1ll*x*x%p) res=(y&1)?1ll*res*x%p:res;\n\treturn res;\n}\n\ninline int C(int n,int m)\n{\n\treturn 1ll*fra[n]*inv[n-m]%p*inv[m]%p;\n}\n\nint main()\n{\n\tfra[0]=1;\n\tfor(int i=1;i<=S-3;i++) fra[i]=1ll*fra[i-1]*i%p;\n\tinv[S-3]=qpow(fra[S-3],p-2,p);\n\tfor(int i=S-3;i>=1;i--) inv[i-1]=1ll*inv[i]*i%p;\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i=0;i<=n;i++) f[i]=1ll*C(n,i)*((long long)qpow(2,qpow(2,n-i,p-1),p)-1+p)%p;\n\tint ans=0;\n\tfor(int i=k;i<=n;i++)\n\t{\n\t\tint pre=1ll*C(i,k)*f[i]%p;\n\t\tif(i-k&1) ans=(ans-pre+p)%p;\n\t\telse ans=(ans+pre)%p;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n\n## 习题\n\n- [P4859 已经没有什么好害怕的了](https://www.luogu.com.cn/problem/P4859)\n\n- [P5505 [JSOI2011]分特产](https://www.luogu.com.cn/problem/P5505)\n\n",
			"tags": [{"name":"学习笔记"},{"name":"数学"},{"name":"组合计数"}],
			"title": "二项式反演学习笔记",
			"link": "https://exber.qzz.io/post/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-03-23 16:11:37"
		},
	
		{
			"abstract": "",
			"content": "树上最小 k 覆盖问题是一种很典型的树上贪心问题，这里做一下小结。\n\n树上最小 k 覆盖问题的形式一般是：\n\n> 给定一棵树，边有边权，点 $u$ 有满足 $d_u\\in\\{0,1\\}$ 的点权 $d_u$，称所有满足 $d_u=1$ 的 $u$ 为“关键点”。\n\n> 你需要选中一些点，令所有的“关键点”被这些点覆盖。一个“关键点”$x$ 被“覆盖”了当且仅当存在一个你选中的点 $y$，满足 $x$ 和 $y$ 之间的距离小于等于 $k$，你需要最小化选中的点的数量。\n\n**这个问题有诸多变形，比较常见的是配合二分答案来考**。\n\n我们可以使用树上贪心来解决这个问题。\n\n首先设 $f_u$ 表示 $u$ 子树内距离 $u$ 最远的**未被覆盖**的关键点距 $u$ 的距离，显然 $f_u=\\max\\{f_x+1,x\\in son_u\\}$。\n\n考虑距离 $u$ 最远的未被覆盖的关键点 $v$，**$v$ 显然有可能被 $u$ 子树里的点覆盖，也有可能被 $u$ 的父亲覆盖，或者被 $u$ 的兄弟子树里的点覆盖**。那么我们先考虑被 $u$ 的子树里的点覆盖的情况，显然画出来时这样的：（**黄色节点代表 $v$，绿色节点代表一个已经被选中且覆盖黄色节点的点 $w$**）\n\n![](../post-images/1679559019559.webp)\n\n显然，**$v$ 和 $w$ 不可能是 $u$ 的同一个儿子的子孙，因为那样的话 $v$ 早就已经被 $w$ 覆盖了**。所以 $v$ 和 $w$ 之间的距离就是 $v$ 和 $u$ 的距离加上 $w$ 和 $u$ 的距离，也就是 $f_u$ 加上 $w$ 和 $u$ 的距离。那么我们就要**让  $w$ 和 $u$ 的距离尽可能短**，不妨设它为 $g_u$，那么显然 $g_u=\\min\\{g_x+1,x\\in son_u\\}$。\n\n接下来分类讨论：\n\n- 若 $f_u+g_u\\le k$，那么 $u$ 的子树能自给自足，这时 $f_u=-\\inf$，表示 $u$ 的字树内没有关键点未被覆盖；\n\n- 若 $f_u=k$，说明 $v$ 必须被 $u$ 覆盖了，这时需要选中 $u$，同时整棵 $u$ 的子树都会被覆盖，则 $f_u=-\\inf$，$g_u=0$，$ans++$；\n\n- 若 $d_u=1$ 且 $g_u>k$，说明 $u$ 是关键点且不能被它子树内之前选中的点覆盖，那么果断交给自己的父亲和兄弟子树，$f_u=\\max(f_u,0)$。\n\n**这三种情况有可能同时成立多种，但并不互相干扰，所以需要写成三个 if 并行**。\n\n最后注意**若 $f_1\\ge0$ 说明还有关键点没被覆盖，等着 $1$ 号节点的父亲和兄弟子树覆盖它们。但是 $1$ 号节点没有父亲和兄弟，此时直接选中 $1$ 号节点即可，$ans++$**。\n\n[例题](https://www.luogu.com.cn/problem/P3523)代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst long long S=1000005,MS=300005;\nconst int inf=1e8;\n\nint n,m,d[MS];\nint esum,to[S],nxt[S],h[MS];\nint tot,f[MS],g[MS];\n\ninline void add(int x,int y)\n{\n\tto[++esum]=y;\n\tnxt[esum]=h[x];\n\th[x]=esum;\n}\n\nvoid dfs(int u,int fa,int mid)\n{\n\tf[u]=-inf;\n\tg[u]=inf;\n\tfor(int i=h[u];i;i=nxt[i])\n\t{\n\t\tint v=to[i];\n\t\tif(v==fa)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(v,u,mid);\n\t\tf[u]=max(f[u],f[v]+1);\n\t\tg[u]=min(g[u],g[v]+1);\n\t}\n\tif(f[u]+g[u]<=mid)\n\t{\n\t\tf[u]=-inf;\n\t}\n\tif(d[u]==1&&g[u]>mid)\n\t{\n\t\tf[u]=max(f[u],0);\n\t}\n\tif(f[u]==mid)\n\t{\n\t\tf[u]=-inf;\n\t\tg[u]=0;\n\t\ttot++;\n\t}\n}\n\ninline bool check(int mid)\n{\n\ttot=0;\n\tdfs(1,0,mid);\n\tif(f[1]>=0)\n\t{\n\t\ttot++;\n\t}\n\treturn tot<=m;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&d[i]);\n\t}\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);\n\t\tadd(y,x);\n\t}\n\tint l=0,r=n,ans=-1;\n\twhile(l<=r)\n\t{\n\t\tint mid=l+r>>1;\n\t\tif(check(mid))\n\t\t{\n\t\t\tans=mid;\n\t\t\tr=mid-1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tl=mid+1;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n\n### 练习题目\n\n- [P3942 将军令](https://www.luogu.com.cn/problem/P3942)\n",
			"tags": [{"name":"学习笔记"},{"name":"小技巧"}],
			"title": "树上最小 k 覆盖问题学习笔记",
			"link": "https://exber.qzz.io/post/%E6%A0%91%E4%B8%8A%E6%9C%80%E5%B0%8F%20k%20%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-03-23 16:09:02"
		},
	
		{
			"abstract": "",
			"content": "动态 dp，其实是一个**用线段树+矩阵乘法来实现带修快速对一段区间进行 dp** 的算法。\n\n## Part 1 序列上动态 DP\n\n### 主体思路\n\n首先学过矩阵快速幂优化递推的同学肯定都知道，**矩阵乘法本质上可以是 dp 的转移**。\n\n那么我们就**可以在构造出状态 $i-1\\to$ 状态 $i$ 的转移矩阵后，使用线段树维护这些矩阵，实现快速进行 dp**。\n\n但是有个问题，**有些 dp 需要最大值和最小值操作。这时，我们就可以重新定义一下矩阵乘法了：**\n\n$$C_{i,j}=\\max\\limits_{k} A_{i,k}+B_{k,j}$$\n\n或者\n\n$$C_{i,j}=\\min\\limits_{k} A_{i,k}+B_{k,j}$$\n\n稍加思考可以发现，这样定义矩阵乘法，可以方便大多数 dp 的转移：\n\n- **若某一项需要加上 $x$，那么对应位置设为 $x$**\n\n- **若某一项不能算进答案，那么对应位置设为 $-inf/inf$**\n\n而且它**满足结合律**。\n\n但是**如果某一项需要乘上系数，dp 转移还需要最大/最小值，那么动态 dp 就无法解决了**。\n\n由于线段树的操作是 $O(\\log n)$ 的，所以**动态 dp 的单次时间复杂度是 $O(\\log n)$**。\n\n### 例题讲解\n\n#### [SP1043 GSS1 - Can you answer these queries I](https://www.luogu.com.cn/problem/SP1043)\n\n可以发现，这道题和小白逛公园十分类似，但我们尝试使用动态 dp 求解。\n\n考虑朴素的 dp，定义 $f_i$ 为以 $i$ 结尾的最大子段和，$g_i=\\max\\limits_{j\\le i} f_j$。\n\n那么易得转移方程：\n\n$$\\begin{cases}f_i=\\max(f_{i-1}+a_i,a_i)\\\\g_i=\\max(g_{i-1},f_i)\\end{cases}$$\n\n接下来考虑转移矩阵的构造。\n\n设当前已经求出了 $f_i$ 和 $g_i$，要求 $f_{i+1}$ 和 $g_{i+1}$。\n\n那么设当前矩阵为 $\\begin{bmatrix}f_i&0&g_i\\end{bmatrix}$，则可以构造转移矩阵：\n\n$$\\begin{bmatrix}f_i&0&g_i\\end{bmatrix}\\cdot\\begin{bmatrix}a_i&-inf&a_i\\\\a_i&0&a_i\\\\-inf&-inf&0\\end{bmatrix}=\\begin{bmatrix}f_{i+1}&0&g_{i+1}\\end{bmatrix}$$\n\n**注意此时的矩阵乘法是重新定义过的：$C_{i,j}=\\max\\limits_{k} A_{i,k}+B_{k,j}$。**\n\n推出转移矩阵后，我们只要造一棵线段树来维护就好了。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nconst long long MS=50005;\n\nstruct mrt\n{\n\tint n,m;\n\tlong long dat[15][15];\n}tree[MS<<4];\n\nint n,m;\nlong long a[MS];\n\ninline long long read()\n{\n\tlong long s=0,w=1,ch=getchar();\n\twhile(ch<'0'||ch>'9') ch=='-'?w=-1,ch=getchar():ch=getchar();\n\twhile(ch>='0'&&ch<='9') s=(s<<1)+(s<<3)+(ch^48),ch=getchar();\n\treturn s*w;\n}\n\ninline mrt mrtmul(mrt x,mrt y)\n{\n\tif(x.n==-1&&x.m==-1)\n\t{\n\t\treturn y;\n\t}\n\tif(y.n==-1&&y.m==-1)\n\t{\n\t\treturn x;\n\t}\n\tmrt res;\n\tres.n=x.n;\n\tres.m=y.m;\n\tfor(int i=1;i<=res.n;i++)\n\t{\n\t\tfor(int j=1;j<=res.m;j++)\n\t\t{\n\t\t\tres.dat[i][j]=-1e17;\n\t\t}\n\t}\n\tfor(int i=1;i<=x.n;i++)\n\t{\n\t\tfor(int j=1;j<=y.m;j++)\n\t\t{\n\t\t\tfor(int k=1;k<=x.m;k++)\n\t\t\t{\n\t\t\t\tres.dat[i][j]=max(res.dat[i][j],x.dat[i][k]+y.dat[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\ninline void updata(int u)\n{\n\ttree[u]=mrtmul(tree[u<<1],tree[u<<1|1]);\n}\n\nvoid build(int u,int l,int r)\n{\n\tif(l==r)\n\t{\n\t\ttree[u].n=3;\n\t\ttree[u].m=3;\n\t\ttree[u].dat[1][1]=a[l];\n\t\ttree[u].dat[1][2]=-1e17;\n\t\ttree[u].dat[1][3]=a[l];\n\t\ttree[u].dat[2][1]=a[l];\n\t\ttree[u].dat[2][2]=0;\n\t\ttree[u].dat[2][3]=a[l];\n\t\ttree[u].dat[3][1]=-1e17;\n\t\ttree[u].dat[3][2]=-1e17;\n\t\ttree[u].dat[3][3]=0;\n\t\treturn;\n\t}\n\tint mid=l+r>>1;\n\tbuild(u<<1,l,mid);\n\tbuild(u<<1|1,mid+1,r);\n\tupdata(u);\n}\n\nvoid que(int u,int l,int r,int L,int R,mrt& res)\n{\n\tif(r<L||l>R)\n\t{\n\t\treturn;\n\t}\n\tif(l>=L&&r<=R)\n\t{\n\t\tres=mrtmul(res,tree[u]);\n\t\treturn;\n\t}\n\tint mid=l+r>>1;\n\tif(L<=mid)\n\t{\n\t\tque(u<<1,l,mid,L,R,res);\n\t}\n\tif(R>=mid+1)\n\t{\n\t\tque(u<<1|1,mid+1,r,L,R,res);\n\t}\n}\n\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\ta[i]=read();\n\t}\n\tbuild(1,1,n);\n\tm=read();\n\twhile(m--)\n\t{\n\t\tint x,y;\n\t\tx=read();\n\t\ty=read();\n\t\tif(x>y)\n\t\t{\n\t\t\tswap(x,y);\n\t\t}\n\t\tif(x==y)\n\t\t{\n\t\t\tprintf(\"%lld\\n\",a[x]);\n\t\t\tcontinue;\n\t\t}\n\t\tmrt tmp;\n\t\ttmp.n=-1;\n\t\ttmp.m=-1;\n\t\tque(1,1,n,x+1,y,tmp);\n\t\tmrt ans;\n\t\tans.n=1;\n\t\tans.m=3;\n\t\tans.dat[1][1]=a[x];\n\t\tans.dat[1][2]=0;\n\t\tans.dat[1][3]=a[x];\n\t\tans=mrtmul(ans,tmp);\n\t\tprintf(\"%lld\\n\",ans.dat[1][3]);\n\t}\n\treturn 0;\n}\n```\n\n#### [SP1716 GSS3 - Can you answer these queries III](https://www.luogu.com.cn/problem/SP1716)\n\n可以发现这题是上题的加强版，动态 dp 的强大之处也在这题体现了。\n\n这题多了一个单点修改的操作，那么只要对于修改的那个位置单独重新构造矩阵即可。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nconst long long MS=50005;\n\nstruct mrt\n{\n\tint n,m;\n\tlong long dat[15][15];\n}tree[MS<<4];\n\nint n,m;\nlong long a[MS];\n\ninline long long read()\n{\n\tlong long s=0,w=1,ch=getchar();\n\twhile(ch<'0'||ch>'9') ch=='-'?w=-1,ch=getchar():ch=getchar();\n\twhile(ch>='0'&&ch<='9') s=(s<<1)+(s<<3)+(ch^48),ch=getchar();\n\treturn s*w;\n}\n\ninline mrt mrtmul(mrt x,mrt y)\n{\n\tif(x.n==-1&&x.m==-1)\n\t{\n\t\treturn y;\n\t}\n\tif(y.n==-1&&y.m==-1)\n\t{\n\t\treturn x;\n\t}\n\tmrt res;\n\tres.n=x.n;\n\tres.m=y.m;\n\tfor(int i=1;i<=res.n;i++)\n\t{\n\t\tfor(int j=1;j<=res.m;j++)\n\t\t{\n\t\t\tres.dat[i][j]=-1e17;\n\t\t}\n\t}\n\tfor(int i=1;i<=x.n;i++)\n\t{\n\t\tfor(int j=1;j<=y.m;j++)\n\t\t{\n\t\t\tfor(int k=1;k<=x.m;k++)\n\t\t\t{\n\t\t\t\tres.dat[i][j]=max(res.dat[i][j],x.dat[i][k]+y.dat[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\ninline void updata(int u)\n{\n\ttree[u]=mrtmul(tree[u<<1],tree[u<<1|1]);\n}\n\nvoid build(int u,int l,int r)\n{\n\tif(l==r)\n\t{\n\t\ttree[u].n=3;\n\t\ttree[u].m=3;\n\t\ttree[u].dat[1][1]=a[l];\n\t\ttree[u].dat[1][2]=-1e17;\n\t\ttree[u].dat[1][3]=a[l];\n\t\ttree[u].dat[2][1]=a[l];\n\t\ttree[u].dat[2][2]=0;\n\t\ttree[u].dat[2][3]=a[l];\n\t\ttree[u].dat[3][1]=-1e17;\n\t\ttree[u].dat[3][2]=-1e17;\n\t\ttree[u].dat[3][3]=0;\n\t\treturn;\n\t}\n\tint mid=l+r>>1;\n\tbuild(u<<1,l,mid);\n\tbuild(u<<1|1,mid+1,r);\n\tupdata(u);\n}\n\nvoid upd(int u,int l,int r,int pos,long long val)\n{\n\tif(l==r)\n\t{\n\t\ttree[u].n=3;\n\t\ttree[u].m=3;\n\t\ttree[u].dat[1][1]=val;\n\t\ttree[u].dat[1][2]=-1e17;\n\t\ttree[u].dat[1][3]=val;\n\t\ttree[u].dat[2][1]=val;\n\t\ttree[u].dat[2][2]=0;\n\t\ttree[u].dat[2][3]=val;\n\t\ttree[u].dat[3][1]=-1e17;\n\t\ttree[u].dat[3][2]=-1e17;\n\t\ttree[u].dat[3][3]=0;\n\t\treturn;\n\t}\n\tint mid=l+r>>1;\n\tif(pos<=mid)\n\t{\n\t\tupd(u<<1,l,mid,pos,val);\n\t}\n\telse\n\t{\n\t\tupd(u<<1|1,mid+1,r,pos,val);\n\t}\n\tupdata(u);\n}\n\nvoid que(int u,int l,int r,int L,int R,mrt& res)\n{\n\tif(r<L||l>R)\n\t{\n\t\treturn;\n\t}\n\tif(l>=L&&r<=R)\n\t{\n\t\tres=mrtmul(res,tree[u]);\n\t\treturn;\n\t}\n\tint mid=l+r>>1;\n\tif(L<=mid)\n\t{\n\t\tque(u<<1,l,mid,L,R,res);\n\t}\n\tif(R>=mid+1)\n\t{\n\t\tque(u<<1|1,mid+1,r,L,R,res);\n\t}\n}\n\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\ta[i]=read();\n\t}\n\tbuild(1,1,n);\n\tm=read();\n\twhile(m--)\n\t{\n\t\tint ty;\n\t\tty=read();\n\t\tif(ty==0)\n\t\t{\n\t\t\tint x=read();\n\t\t\tlong long y=read();\n\t\t\ta[x]=y;\n\t\t\tupd(1,1,n,x,y);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint x=read();\n\t\t\tint y=read();\n\t\t\tif(x>y)\n\t\t\t{\n\t\t\t\tswap(x,y);\n\t\t\t}\n\t\t\tif(x==y)\n\t\t\t{\n\t\t\t\tprintf(\"%lld\\n\",a[x]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmrt tmp;\n\t\t\ttmp.n=-1;\n\t\t\ttmp.m=-1;\n\t\t\tque(1,1,n,x+1,y,tmp);\n\t\t\tmrt ans;\n\t\t\tans.n=1;\n\t\t\tans.m=3;\n\t\t\tans.dat[1][1]=a[x];\n\t\t\tans.dat[1][2]=0;\n\t\t\tans.dat[1][3]=a[x];\n\t\t\tans=mrtmul(ans,tmp);\n\t\t\tprintf(\"%lld\\n\",ans.dat[1][3]);\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n#### [CF750E New Year and Old Subsequence](https://www.luogu.com.cn/problem/CF750E)\n\n我们可以设 $f_{i,0/1/2/3/4}$ 表示前 $i$ 个字符，包含 $\\varnothing/2/20/201/2017$ 至少需要删除多少个字符，那么转移方程：\n\n$$\\begin{cases}f_{i,0}=f_{i-1,0}+[s_i=2]\\\\f_{i,1}=\\min(f_{i-1,1}+[s_i=0],f_{i-1,0}[s_i=2])\\\\f_{i,2}=\\min(f_{i-1,2}+[s_i=1],f_{i-1,1}[s_i=0])\\\\f_{i,3}=\\min(f_{i-1,3}+[s_i=7\\vee s_i=6],f_{i-1,2}[s_i=1])\\\\f_{i,4}=\\min(f_{i-1,4}+[s_i=6],f_{i-1,3}[s_i=7])\\end{cases}$$\n\n构造转移矩阵即可。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst long long MS=200000;\nconst int inf=1e8;\n\nstruct mrt\n{\n\tint n,m;\n\tint dat[6][6];\n}tree[(MS<<2)+5];\n\nint n,m;\nchar a[MS+5];\n\ninline void mrtmul(mrt &res,mrt x,mrt y)\n{\n\tif(x.n==-1&&x.m==-1)\n\t{\n\t\tres=y;\n\t\treturn;\n\t}\n\tif(y.n==-1&&y.m==-1)\n\t{\n\t\tres=x;\n\t\treturn;\n\t}\n\tres.n=x.n;\n\tres.m=y.m;\n\tfor(int i=1;i<=res.n;i++)\n\t{\n\t\tfor(int j=1;j<=res.m;j++)\n\t\t{\n\t\t\tres.dat[i][j]=inf;\n\t\t}\n\t}\n\tfor(int i=1;i<=res.n;i++)\n\t{\n\t\tfor(int j=1;j<=res.m;j++)\n\t\t{\n\t\t\tfor(int k=1;k<=x.m;k++)\n\t\t\t{\n\t\t\t\tres.dat[i][j]=min(res.dat[i][j],x.dat[i][k]+y.dat[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void updata(int u)\n{\n\tmrtmul(tree[u],tree[u<<1],tree[u<<1|1]);\n}\n\nvoid build(int u,int l,int r)\n{\n\tif(l==r)\n\t{\n\t\ttree[u].n=5;\n\t\ttree[u].m=5;\n\t\tfor(int i=1;i<=5;i++)\n\t\t{\n\t\t\tfor(int j=1;j<=5;j++)\n\t\t\t{\n\t\t\t\ttree[u].dat[i][j]=inf;\n\t\t\t}\n\t\t}\n\t\ttree[u].dat[1][1]=a[l]==2;\n\t\ttree[u].dat[1][2]=(a[l]!=2)*inf;\n\t\ttree[u].dat[2][2]=a[l]==0;\n\t\ttree[u].dat[2][3]=(a[l]!=0)*inf;\n\t\ttree[u].dat[3][3]=a[l]==1;\n\t\ttree[u].dat[3][4]=(a[l]!=1)*inf;\n\t\ttree[u].dat[4][4]=a[l]==6||a[l]==7;\n\t\ttree[u].dat[4][5]=(a[l]!=7)*inf;\n\t\ttree[u].dat[5][5]=a[l]==6;\n\t\treturn;\n\t}\n\tint mid=l+r>>1;\n\tbuild(u<<1,l,mid);\n\tbuild(u<<1|1,mid+1,r);\n\tupdata(u);\n}\n\nvoid que(int u,int l,int r,int L,int R,mrt &res)\n{\n\tif(r<L||l>R)\n\t{\n\t\treturn;\n\t}\n\tif(l>=L&&r<=R)\n\t{\n\t\tmrtmul(res,res,tree[u]);\n\t\treturn;\n\t}\n\tint mid=l+r>>1;\n\tif(L<=mid)\n\t{\n\t\tque(u<<1,l,mid,L,R,res);\n\t}\n\tif(R>=mid+1)\n\t{\n\t\tque(u<<1|1,mid+1,r,L,R,res);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",a+1);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\ta[i]-='0';\n\t}\n\tbuild(1,1,n);\n\twhile(m--)\n\t{\n\t\tint l,r;\n\t\tscanf(\"%d%d\",&l,&r);\n\t\tif(l>r)\n\t\t{\n\t\t\tswap(l,r);\n\t\t}\n\t\tif(r-l+1<4)\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\tcontinue;\n\t\t}\n\t\tmrt tmp;\n\t\ttmp.n=-1;\n\t\ttmp.m=-1;\n\t\tque(1,1,n,l+1,r,tmp);\n\t\tmrt ans;\n\t\tans.n=1;\n\t\tans.m=5;\n\t\tans.dat[1][1]=a[l]==2;\n\t\tans.dat[1][2]=(a[l]!=2)*inf;\n\t\tans.dat[1][3]=inf;\n\t\tans.dat[1][4]=inf;\n\t\tans.dat[1][5]=inf;\n\t\tmrtmul(ans,ans,tmp);\n\t\tprintf(\"%d\\n\",ans.dat[1][5]>n?-1:ans.dat[1][5]);\n\t}\n\treturn 0;\n}\n```\n\n### 练习题目\n\n- [CF573D Bear and Cavalry](https://www.luogu.com.cn/problem/CF573D)\n\n- [CF1609E William The Oblivious](https://www.luogu.com.cn/problem/CF1609E)\n\n## Part 2 树上动态 DP\n看一道例题：[P4719 【模板】\"动态 DP\"&动态树分治](https://www.luogu.com.cn/problem/P4719)\n\n> 给你一棵树，点有点权，带修，每次修改完输出最大独立集的大小。\n\n我们设 $f_{u,0/1}$ 表示点 $u$ 没选/选了时 $u$ 的子树的最大收益，那么显然有：\n\n$$\\begin{cases}f_{u,0}=\\sum\\limits_{j}\\max(f_{j,0},f_{j,1})\\\\f_{u,1}=\\sum\\limits_{j}f_{j,0}\\end{cases}$$\n\n其中 $j$ 是 $i$ 的一个儿子。\n\n但是当你尝试构造转移矩阵时，你就会发现这是一对多的转移，不好维护，所以我们可以**跑一下树剖，并且引入一个 $g_{u,0/1}$ 表示点 $u$ 的所有轻儿子可选可不选/都不选时的最大收益**，那么有转移：\n\n$$\\begin{cases}g_{u,0}=\\sum\\limits_{j}\\max(f_{j,0},f_{j,1})\\\\g_{u,1}=a_u+\\sum\\limits_{j}f_{j,0}\\end{cases}$$\n\n其中 $j$ 是 $u$ 的一个轻儿子。\n\n$$\\begin{cases}f_{u,0}=\\max(f_{v,0},f_{v,1})+g_{u,0}\\\\f_{u,1}=f_{v,0}+g_{u,1}\\end{cases}$$\n\n其中 $v$ 是 $u$ 的重儿子。\n\n这样可以构造转移矩阵了：（其中的**矩阵乘法是重新定义的**：$C_{i,j}=\\max\\limits_{k} A_{i,k}+B_{k,j}$）\n\n$$\\begin{bmatrix}g_{u,0}&g_{u,0}\\\\g_{u,1}&-\\inf\\end{bmatrix}\\cdot\\begin{bmatrix}f_{v,0}\\\\f_{v,1}\\end{bmatrix}=\\begin{bmatrix}f_{u,0}\\\\f_{u,1}\\end{bmatrix}$$\n\n这么构造是因为**跑完树剖之后求一段区间矩阵的乘积是从深度小的往深度大的乘过去**。\n\n考虑怎么修改，假设当前要修改 $u$，那么我们可以**求出 $u$ 所在的重链在修改 $u$ 前的答案 $frt_{0/1}$，然后修改 $u$，接下来求出修改 $u$ 后的答案 $lst_{0/1}$**。\n\n然后，我们考虑修改 $u$ 对它所属重链顶端的节点的父亲的贡献，设 $u$ 所属重链顶端的节点的父亲为 $p$，$p$ 的父节点为 $q$，**那么显然 $p$ 是 $q$ 的轻儿子，那么我们令**\n\n$$g_{q,0}=g_{q,0}-\\max(frt_0,frt_1)+\\max(lst_0,lst_1)\\text{，}g_{q,1}=g_{q,1}-frt_0+lst_0$$\n\n然后又会发现，**这个是关于 $q$ 和它的重链的修改。所以我们不断地跳、修改即可**。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst long long S=200005,MS=100005;\nconst int inf=50000005;\n\nstruct mrt\n{\n\tint n,m;\n\tint dat[4][4];\n}tree[MS<<2];\n\nint n,m;\nint val[MS];\nint esum,to[S],nxt[S],h[MS];\nint f[MS][2],g[MS][2];\nint fat[MS],siz[MS],hson[MS];\nint cnt,id[MS],vl[MS],a[MS][2],top[MS],depp[MS];\nmrt b[MS];\n\ninline void add(int x,int y)\n{\n\tto[++esum]=y;\n\tnxt[esum]=h[x];\n\th[x]=esum;\n}\n\nvoid dfs1(int u,int fa)\n{\n\tf[u][1]=val[u];\n\tfat[u]=fa;\n\tsiz[u]=1;\n\tfor(int i=h[u];i;i=nxt[i])\n\t{\n\t\tint v=to[i];\n\t\tif(v==fa)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tdfs1(v,u);\n\t\tf[u][0]+=max(f[v][0],f[v][1]);\n\t\tf[u][1]+=f[v][0];\n\t\tsiz[u]+=siz[v];\n\t\tif(siz[v]>siz[hson[u]])\n\t\t{\n\t\t\thson[u]=v;\n\t\t}\n\t}\n}\n\nvoid dfs2(int u,int fa,int tpf)\n{\n\tg[u][1]=val[u];\n\tfor(int i=h[u];i;i=nxt[i])\n\t{\n\t\tint v=to[i];\n\t\tif(v==fa||v==hson[u])\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tg[u][0]+=max(f[v][0],f[v][1]);\n\t\tg[u][1]+=f[v][0];\n\t}\n\tid[u]=++cnt;\n\tvl[cnt]=val[u];\n\ta[cnt][0]=g[u][0];\n\ta[cnt][1]=g[u][1];\n\ttop[u]=tpf;\n\tdepp[tpf]=cnt;\n\tif(hson[u]!=0)\n\t{\n\t\tdfs2(hson[u],u,tpf);\n\t}\n\tfor(int i=h[u];i;i=nxt[i])\n\t{\n\t\tint v=to[i];\n\t\tif(v==fa||v==hson[u])\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tdfs2(v,u,v);\n\t}\n}\n\ninline void mrtmul(mrt& res,mrt x,mrt y)\n{\n\tif(x.n==-1&&x.m==-1)\n\t{\n\t\tres=y;\n\t\treturn;\n\t}\n\tif(y.n==-1&&y.m==-1)\n\t{\n\t\tres=x;\n\t\treturn;\n\t}\n\tres.n=x.n;\n\tres.m=y.m;\n\tfor(int i=1;i<=res.n;i++)\n\t{\n\t\tfor(int j=1;j<=res.m;j++)\n\t\t{\n\t\t\tres.dat[i][j]=-inf;\n\t\t}\n\t}\n\tfor(int i=1;i<=res.n;i++)\n\t{\n\t\tfor(int j=1;j<=res.m;j++)\n\t\t{\n\t\t\tfor(int k=1;k<=x.m;k++)\n\t\t\t{\n\t\t\t\tres.dat[i][j]=max(res.dat[i][j],x.dat[i][k]+y.dat[k][j]); \n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void updata(int u)\n{\n\tmrtmul(tree[u],tree[u<<1],tree[u<<1|1]);\n}\n\nvoid build(int u,int l,int r)\n{\n\tif(l==r)\n\t{\n\t\ttree[u].n=2;\n\t\ttree[u].m=2;\n\t\ttree[u].dat[1][1]=a[l][0];\n\t\ttree[u].dat[1][2]=a[l][0];\n\t\ttree[u].dat[2][1]=a[l][1];\n\t\ttree[u].dat[2][2]=-inf;\n\t\tb[l]=tree[u];\n\t\treturn;\n\t}\n\tint mid=l+r>>1;\n\tbuild(u<<1,l,mid);\n\tbuild(u<<1|1,mid+1,r);\n\tupdata(u);\n}\n\nvoid que(int u,int l,int r,int L,int R,mrt& res)\n{\n\tif(r<L||l>R)\n\t{\n\t\treturn;\n\t}\n\tif(l>=L&&r<=R)\n\t{\n\t\tmrtmul(res,res,tree[u]);\n\t\treturn;\n\t}\n\tint mid=l+r>>1;\n\tif(L<=mid)\n\t{\n\t\tque(u<<1,l,mid,L,R,res);\n\t}\n\tif(R>=mid+1)\n\t{\n\t\tque(u<<1|1,mid+1,r,L,R,res);\n\t}\n}\n\nvoid upd(int u,int l,int r,int pos)\n{\n\tif(l==r)\n\t{\n\t\ttree[u]=b[l];\n\t\treturn;\n\t}\n\tint mid=l+r>>1;\n\tif(pos<=mid)\n\t{\n\t\tupd(u<<1,l,mid,pos);\n\t}\n\telse\n\t{\n\t\tupd(u<<1|1,mid+1,r,pos);\n\t}\n\tupdata(u);\n}\n\ninline void updnode(int u,int k)\n{\n\tb[id[u]].dat[2][1]+=k-vl[id[u]];\n\tvl[id[u]]=k;\n\twhile(u!=0)\n\t{\n\t\tmrt frt,lst;\n\t\tfrt.n=-1;\n\t\tfrt.m=-1;\n\t\tlst.n=-1;\n\t\tlst.m=-1;\n\t\tque(1,1,n,id[top[u]],depp[top[u]],frt);\n\t\tupd(1,1,n,id[u]);\n\t\tque(1,1,n,id[top[u]],depp[top[u]],lst);\n\t\tu=fat[top[u]];\n\t\tb[id[u]].dat[1][1]+=max(lst.dat[1][1],lst.dat[2][1])-max(frt.dat[1][1],frt.dat[2][1]);\n\t\tb[id[u]].dat[1][2]=b[id[u]].dat[1][1];\n\t\tb[id[u]].dat[2][1]+=lst.dat[1][1]-frt.dat[1][1];\n\t}\n}\n\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&val[i]);\n\t}\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);\n\t\tadd(y,x);\n\t}\n\tdfs1(1,0);\n\tdfs2(1,0,1);\n\tbuild(1,1,n);\n\twhile(m--)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tupdnode(x,y);\n\t\tmrt ans;\n\t\tans.n=-1;\n\t\tans.m=-1;\n\t\tque(1,1,n,id[top[1]],depp[top[1]],ans);\n\t\tprintf(\"%d\\n\",max(ans.dat[1][1],ans.dat[2][1]));\n\t}\n\treturn 0;\n}\n```\n\n### 练习题目\n\n- [P5024 [NOIP2018 提高组] 保卫王国](https://www.luogu.com.cn/problem/P5024)\n\n- [P3781 [SDOI2017]切树游戏](https://www.luogu.com.cn/problem/P3781)\n",
			"tags": [{"name":"学习笔记"},{"name":"数据结构"}],
			"title": "动态 DP 学习笔记",
			"link": "https://exber.qzz.io/post/%E5%8A%A8%E6%80%81%20DP%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-03-23 12:58:12"
		},
	
		{
			"abstract": "",
			"content": "高斯消元是一个用来求解多元一次方程的算法，它求解 $n$ 元一次方程的**时间复杂度是 $O(n^3)$**。\n\n### 做法\n\n我们考虑这样的一个三元一次方程组：\n\n$$\\begin{cases}x_1+2x_2=3\\\\x_2+x_3=5\\\\\nx_1+3x_3=10\\end{cases}$$\n\n把每一条方程的未知数补全：\n\n$$\\begin{cases}x_1+2x_2+0x_3=3\\\\0x_1+x_2+x_3=5\\\\\nx_1+0x_2+3x_3=10\\end{cases}$$\n\n然后我们就**可以不关心具体的未知数了，只用关心系数**。方程组也就可以写成一个矩阵：\n\n$$\\begin{bmatrix}1&2&0&3\\\\0&1&1&5\\\\1&0&3&10\\end{bmatrix}$$\n\n其中前三列表示系数，最后一列是方程右边的常数。\n\n考虑方程的求解。很明显**可以先加减消元，让某个方程只剩下一个未知数。再代入消元，求出所有未知数**。\n\n首先我们让矩阵第三行的方程减去第一行的方程，消掉 $x_1$：\n\n$$\\begin{bmatrix}1&2&0&3\\\\0&1&1&5\\\\0&-2&3&7\\end{bmatrix}$$\n\n然后让矩阵第三行的方程减去 $-2$ 倍的第二行的方程，消掉 $x_2$：\n\n$$\\begin{bmatrix}1&2&0&3\\\\0&1&1&5\\\\0&0&5&17\\end{bmatrix}$$\n\n接下来我们就可以求出 $x_3$ 的值了，然后再**一步一步往回代，就可以解出所有未知数了**。\n\n[模板题](https://www.luogu.com.cn/problem/P3389)代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\nconst long long MS=105;\nconst double zeo=0.0001;\n\nint n;\ndouble a[MS][MS],res[MS];\n\ninline bool slove()\n{\n\t// 加减消元过程 \n\tfor(int i=1;i<=n;i++) // 枚举每一个方程，用第 i 个方程消去未知数 x[i] \n\t{\n\t\tif(fabs(a[i][i])<=zeo) // 如果当前这个方程不含未知数 x[i]（系数为 0），那么去找一个含有它的方程交换一下 \n\t\t{\n\t\t\tbool f=false; // 是否能找到 \n\t\t\tfor(int j=i+1;j<=n;j++)\n\t\t\t{\n\t\t\t\tif(fabs(a[j][i])>zeo) // 找到了 \n\t\t\t\t{\n\t\t\t\t\tfor(int k=1;k<=n+1;k++) // 交换 \n\t\t\t\t\t{\n\t\t\t\t\t\tswap(a[i][k],a[j][k]);\n\t\t\t\t\t}\n\t\t\t\t\tf=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!f) // 条件不足，无法解出方程 \n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tfor(int j=i+1;j<=n;j++) // 消去后面的方程中的未知数 x[i] \n\t\t{\n\t\t\tdouble bs=a[j][i]/a[i][i]; // 第 j 个方程需要减去第 i 个方程的 bs 倍 \n\t\t\tfor(int k=1;k<=n+1;k++) // 减去 \n\t\t\t{\n\t\t\t\ta[j][k]-=a[i][k]*bs;\n\t\t\t}\n\t\t}\n\t}\n\t// 代入消元过程 \n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tfor(int j=i+1;j<=n;j++) // x[i+1...n] 已经计算完成，直接代入 \n\t\t{\n\t\t\ta[i][n+1]-=a[i][j]*res[j];\n\t\t}\n\t\tres[i]=a[i][n+1]/a[i][i]; // 消完元后只剩下 x[i]，可以直接求出 \n\t}\n\treturn true;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n+1;j++)\n\t\t{\n\t\t\tscanf(\"%lf\",&a[i][j]);\n\t\t}\n\t}\n\tif(!slove())\n\t{\n\t\tputs(\"No Solution\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tprintf(\"%.2lf\\n\",res[i]);\n\t}\n\treturn 0;\n}\n```\n\n### 练习题目\n\n- [P4035 [JSOI2008]球形空间产生器](https://www.luogu.com.cn/problem/P4035)\n\n- [P2455 [SDOI2006]线性方程组](https://www.luogu.com.cn/problem/P2455)\n\n- [P3232 [HNOI2013]游走](https://www.luogu.com.cn/problem/P3232)\n\n- [CF24D Broken robot](https://www.luogu.com.cn/problem/CF24D)\n\n- [P5643 [PKUWC2018]随机游走](https://www.luogu.com.cn/problem/P5643)\n",
			"tags": [{"name":"学习笔记"},{"name":"数学"},{"name":"数论"}],
			"title": "高斯消元学习笔记",
			"link": "https://exber.qzz.io/post/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-03-23 12:56:43"
		},
	
		{
			"abstract": "",
			"content": "差分约束系统，其实是一个**类似网络流的，求一类不等式方程组的解的算法**。\n\n### 基本形式\n\n差分约束系统主要用求这样的不等式方程组的一个解：\n\n$$\\begin{cases}x_{a_1}-x_{b_1}\\le y_1\\\\x_{a_2}-x_{b_2}\\le y_2\\\\x_{a_3}-x_{b_3}\\le y_3\\\\\\qquad\\cdots\\cdots\\\\x_{a_m}-x_{b_m}\\le y_m\\\\\\end{cases}$$\n\n其中 $1\\le a_i,b_i\\le n$。\n\n我们先考虑其中的一条不等式 $x_{a_1}-x_{b_1}\\le y_1$，很明显可以转化为 $x_{a_1}\\le x_{b_1}+y_1$。\n\n观察这个等式，很容易联想到**最短路中，点 $u$ 和点 $v$ 中间如果有一条长度为 $w$ 的边，那么这两个点之间的最短路长度一定小于等于 $w$。所以，我们可以把这 $m$ 个方程转换为 $m$ 条边，建出一个有向图来。**\n\n建完图后，我们**考虑加一个大源点 $0$，向每一个未知数连一条长度为 $0$ 的边。这样，以 $0$ 作为源点跑出来的最短路，就是整个方程组的解了**。\n\n不过注意到，**如果有负环，那么最短路是跑不出来的，这意味着方程组无解**。\n\n[模板题](https://www.luogu.com.cn/problem/P5960)代码：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nconst long long S=10000005,MS=100005;\n\nint n,m;\nint esum,to[S],nxt[S],c[S],h[MS];\nint dis[MS],vis[MS];\nbool inq[MS];\n\ninline void add(int x,int y,int w)\n{\n\tto[++esum]=y;\n\tc[esum]=w;\n\tnxt[esum]=h[x];\n\th[x]=esum;\n}\n\ninline bool slove()\n{\n\tdis[0]=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tdis[i]=1e9;\n\t}\n\tmemset(vis,0,sizeof(vis));\n\tmemset(inq,0,sizeof(inq));\n\tqueue<int> q;\n\tq.push(0);\n\tinq[0]=true;\n\twhile(!q.empty())\n\t{\n\t\tint u=q.front();\n\t\tq.pop();\n\t\tinq[u]=false;\n\t\tvis[u]++;\n\t\tif(vis[u]>n)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tfor(int i=h[u];i;i=nxt[i])\n\t\t{\n\t\t\tint v=to[i],w=c[i];\n\t\t\tif(dis[u]+w<dis[v])\n\t\t\t{\n\t\t\t\tdis[v]=dis[u]+w;\n\t\t\t\tif(!inq[v])\n\t\t\t\t{\n\t\t\t\t\tinq[v]=true;\n\t\t\t\t\tq.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x,y,w;\n\t\tscanf(\"%d%d%d\",&x,&y,&w);\n\t\tadd(y,x,w);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tadd(0,i,0);\n\t}\n\tbool can=slove();\n\tif(!can)\n\t{\n\t\tputs(\"NO\");\n\t}\n\telse\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tprintf(\"%d \",dis[i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}\n```\n\n### 一些变形\n\n- 遇到 $x_{a_i}\\ge x_{b_i}+y_i$，可以反过来连边，变成 $x_{b_i}\\le x_{a_i}-y_i$，或者同时乘以 $-1$，将符号反过来\n\n- 遇到 $x_{a_i}-x_{b_i}=y_i$，可以转化为两个不等式：$x_{a_i}\\le x_{b_i}+y_i$ 和 $x_{a_i}\\ge x_{b_i}+y_i$\n\n- 遇到 $[s_i,t_i]$ 的和为 $v_i$ 这类问题时，可以用前缀和转换为 $sum_{t_i}-sum_{s_i-1}=v_i$\n\n### 练习题目\n\n- [自己选着做吧……](https://www.luogu.com.cn/problem/list?tag=185)\n",
			"tags": [{"name":"学习笔记"},{"name":"图论"}],
			"title": "差分约束系统学习笔记",
			"link": "https://exber.qzz.io/post/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-03-23 12:56:01"
		},
	
		{
			"abstract": "",
			"content": "这东西也叫 baka's trick。\n\n众所周知，**添加元素方便但删除元素不方便的情况下可以用回滚莫队来代替莫队**，那尺取可以用什么代替呢？\n\n**回滚尺取**！\n\n## 具体做法\n\n设要处理的数组长度为 $n$，且从 $1$ 开始编号，位置 $i$ 的状态为 $a_i$。\n\n首先引入一个指针 $mid$，令它初始为 $1$。\n\n然后令左指针 $l$ 指向 $mid$。设当前状态为 $L$，在 $l\\ge 1$ 且 $L\\cup a_l$ 合法的情况下不断让 $L=L\\cup a_l$ 且左移 $l$。并记录下这一过程下的 $L$，记 $l$ 为 $x$ 时的 $L$ 为 $tmp_x$。\n\n接下来令右指针 $r$ 指向 $mid+1$，设当前状态为 $R$：\n\n1. 令 $R=R\\cup a_r$\n\n2. 在 $tmp_l\\cup R$ 不合法的情况下不断右移 $l$ 指针，直到 $l>mid$ 或者 $tmp_l\\cup R$ 合法\n\n3. 若此时 $l\\le mid$，那么更新答案；否则令 $mid=r$，跳出循环\n\n4. 令 $r=r+1$，若 $l>n$，那么跳出循环；否则，返回步骤 $1$\n\n跳出循环后注意 $l$ 大于 $n$ 的话就说明计算完了，可以结束整个尺取。\n\n伪代码如下：\n\n\n```cpp\n// merge(val,val2)：返回状态 val 和状态 val2 合并后的状态 \n// cant(val)：若状态 val 合法，返回 true，否则返回 false\nint ans=0;\nfor(int mid=1;mid<n;)\n{\n\tint l,r;\n\t// 左移 l，记录下一路上 [l,mid] 的状态 \n\tint L=0;\n\tfor(l=mid;l>=1;l--)\n\t{\n\t\tL=merge(L,a[l]);\n\t\ttmp[l]=L;\n\t\tif(cant(L)) \n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\tl++;\n\t// 右移 r \n\tint R=0;\n\tfor(r=mid+1;r<=n;r++)\n\t{\n\t\tR=merge(R,a[r]);\n\t\twhile(l<=mid&&cant(merge(tmp[l],R))) // 不断右移 l 直到状态合法或者 l 大于 mid \n\t\t{\n\t\t\tl++;\n\t\t}\n\t\tif(l<=mid)\n\t\t{\n\t\t\tans=max(ans,r-l+1); // 更新答案 \n\t\t}\n\t\telse\n\t\t{\n\t\t\tmid=r; // 开始新一轮尺取 \n\t\t\tbreak;\n\t\t}\n\t}\n\tif(r>n) // 计算完了，尺取结束 \n\t{\n\t\tbreak;\n\t}\n}\n```\n\n## 经典例题\n\n[CF1548B Integers Have Friends](https://www.luogu.com.cn/problem/CF1548B)\n\n考虑 $x,y$ 对 $m$ 取余的结果相同这个东西的本质。\n\n设 $x\\mod m=y\\mod m=k$，那么 $|(x-k)-(y-k)|$ 一定可以被 $m$ 整除，即 $|x-y|$ 可以被 $m$ 整除。\n\n考虑推广到三个数，设它们为 $x,y,z$。显然只有当 $\\gcd(|x-y|,|y-z|)> 1$ 时才能够找到合法的 $m$。\n\n所以这个问题便转化为求一个最长的区间 $[l,r]$，使得 $\\gcd(|a_l-a_{l+1}|,|a_{l+1}-a_{l+2}|,\\cdots,|a_{m-1}-a_m|)>1$。\n\n很明显，普通的尺取无法处理这个问题，因为添加元素很简单，但是删除元素很难。所以我们需要使用回滚尺取。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nint n;\nlong long a[200005],tmp[200005];\n\ninline long long gcd(long long a,long long b)\n{\n\tif(a==0||b==0)\n\t{\n\t\treturn a+b;\n\t}\n\tlong long t=a%b;\n\twhile(t!=0)\n\t{\n\t\ta=b;\n\t\tb=t;\n\t\tt=a%b;\n\t}\n\treturn b;\n}\n\ninline long long ckjabs(long long x)\n{\n\treturn x<0?-x:x;\n}\n\nint main()\n{\n\tint _;\n\tscanf(\"%d\",&_);\n\twhile(_--)\n\t{\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tscanf(\"%lld\",&a[i]);\n\t\t}\n\t\tint ans=1;\n\t\tfor(int mid=1;mid<n;)\n\t\t{\n\t\t\tint l,r;\n\t\t\tlong long L=0;\n\t\t\tfor(l=mid;l>=1;l--)\n\t\t\t{\n\t\t\t\tL=gcd(L,ckjabs(a[mid]-a[l]));\n\t\t\t\ttmp[l]=L;\n\t\t\t\tif(L==1)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tl++;\n\t\t\tlong long R=0;\n\t\t\tfor(r=mid+1;r<=n;r++)\n\t\t\t{\n\t\t\t\tR=gcd(R,ckjabs(a[r]-a[mid]));\n\t\t\t\twhile(l<=mid&&gcd(R,tmp[l])==1)\n\t\t\t\t{\n\t\t\t\t\tl++;\n\t\t\t\t}\n\t\t\t\tif(l<=mid)\n\t\t\t\t{\n\t\t\t\t\tans=max(ans,r-l+1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmid=r;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(r>n)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"学习笔记"},{"name":"小技巧"}],
			"title": "回滚尺取（不删除尺取）学习笔记",
			"link": "https://exber.qzz.io/post/%E5%9B%9E%E6%BB%9A%E5%B0%BA%E5%8F%96%EF%BC%88%E4%B8%8D%E5%88%A0%E9%99%A4%E5%B0%BA%E5%8F%96%EF%BC%89%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-03-23 12:53:04"
		},
	
		{
			"abstract": "",
			"content": "**基环树，又称环套树**。顾名思义，就是有环的树，所以它**是个图**。\n\n## 概念及定义\n\n**基环树，是一个有 $n$ 个节点和 $n$ 条边组成的无向连通图**。由于比树多了条边，所以它会出现环。\n\n很明显**基环树只有一个环**，因为如果有多个环的话，那么整张图不会联通。\n\n而**基环树森林则是由许多连通块构成的无向图，满足每个连通块都是基环树**。\n\n一般来讲，只要看到 $n$ 个点 $n$ 条边、每个点都有且仅有一个仇人/上级/xxx 这种条件，这个图就一定是基环树森林。\n\n基环树的例子：\n\n![](../post-images/1679546781674.webp)\n\n## 处理方法\n\n常见的题型就是在基环树上 dp。\n\n有两种方法，第一种是**把环拎出来，对于环下面挂着的树进行 dp，然后信息合并到环上处理**：\n\n![](../post-images/1679546805563.webp)\n\n还有一种是**断掉环的一条边，然后分类讨论进行 dp，最后合并答案**。\n\n![](../post-images/1679546821377.webp)\n\n比较常见的是第二种。\n\n## 经典题目\n\n### CF711D Directed Roads\n\n[链接](https://www.luogu.com.cn/problem/CF711D)\n\n由于有 $n$ 个点 $n$ 条边，$i$ 只会连向 $a_i$，所以是个基环树。\n\n但是又没说联通，所以是基环树森林。\n\n可以先找出所有的环，那么不被环包含的边可以随便定方向。\n\n设当前找到的环的长度为 $len$，那么想要形成环只会有两种定方向的方式，所以不形成环的方案数是 $2^{len}-2$。\n\n答案即为 $2^{n-\\sum len}\\sum 2^{len}-2$。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst long long S=500005,MS=200005,mod=1000000007;\n\nint n;\nint esum,to[S],nxt[S],h[MS];\nint dep[MS],vis[MS];\n\ninline void add(int x,int y)\n{\n\tto[++esum]=y;\n\tnxt[esum]=h[x];\n\th[x]=esum;\n}\n\nvoid dfs(int u,int fa,int &len)\n{\n\tdep[u]=dep[fa]+1;\n\tvis[u]=1;\n\tfor(int i=h[u],cnt=0;i;i=nxt[i])\n\t{\n\t\tint v=to[i];\n\t\tif(v==fa)\n\t\t{\n\t\t\tif(cnt==1)\n\t\t\t{\n\t\t\t\tlen=2;\n\t\t\t}\n\t\t\tcnt++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(vis[v]==1)\n\t\t{\n\t\t\tlen=dep[u]-dep[v]+1;\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(v,u,len);\n\t}\n\tvis[u]=2;\n}\n\ninline long long qpow(long long a,long long b)\n{\n\tlong long res=1,tmp=a;\n\twhile(b>0)\n\t{\n\t\tif(b&1)\n\t\t{\n\t\t\tres=res*tmp%mod;\n\t\t}\n\t\ttmp=tmp*tmp%mod;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tadd(i,x);\n\t\tadd(x,i);\n\t}\n\tlong long ans=1,sum=n;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(vis[i]==0)\n\t\t{\n\t\t\tint len;\n\t\t\tdfs(i,0,len);\n\t\t\tsum-=len;\n\t\t\tans=ans*(qpow(2,len)-2)%mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",qpow(2,sum)*ans%mod);\n\treturn 0;\n}\n```\n\n### P1453 城市环路\n\n[链接](https://www.luogu.com.cn/problem/P1453)\n\n很容易发现是个基环树，那么可以使用第二种方法，断掉一条边之后做没有上司的舞会。\n\n但是有一些细节。首先断掉的边还是存在的，设这条边连接的两点为 $x,y$，那么最后要么 $x$ 不选 $y$ 选，要么都不选，要么 $x$ 选 $y$ 不选。前两种情况很好做，但是最后一种情况就有点难了。需要将 $y$ 的人流量设为 $-inf$ 再 dp。\n\n最后需要注意一种很烦人的环：\n\n![](../post-images/1679546853119.webp)\n\n这种情况下断掉 $u,v$ 之间的边后它们会不连通，所以断边后需要分别以 $u$ 和 $v$ 为根做 dp，然后计算贡献。\n\n这题数据太水了所以上图的情况如果不特判也能过。\n\n### P2607 [ZJOI2008]骑士\n\n[链接](https://www.luogu.com.cn/problem/P2607)\n\n其实是城市环路的加强版，注意一下是个基环树森林即可。\n\n### P4381 [IOI2008] Island\n\n[链接](https://www.luogu.com.cn/problem/P4381)\n\n首先读题，可以发现这是个基环树森林。然后看一下坐船的条件：\n\n> 你可以选择这种方法，仅当没有任何桥和以前使用过的渡船的组合可以由 S 走到 D (当检查是否可到达时，你应该考虑所有的路径，包括经过你曾游览过的那些岛)。\n\n再结合一下样例解释，你就会惊喜的发现，坐船其实就是从基环树森林里的一棵基环树走到另一棵基环树上，然后一棵基环树走了之后就不能回来了。\n\n所以问题转化为所有基环树的最长链之和。\n\n首先考虑单棵基环树的最长链。把环拎出来后，最长链的组成方法有：\n\n- 一棵吊着的树的直径\n\n- 一棵吊着的树的高度+环上的一段边+另一棵不同的吊着的树的高度\n\n所以我们可以使用第一种方法，计算出每棵吊着的树的直径和高度，然后考虑合并。\n\n第一种直径的组成方式很明显可以处理，而第二种就有点麻烦了。我们记编号为 $i$ 的节点的子树的深度为 $w_i$，然后断环为链，很明显环变成了这样的东西：\n\n![](../post-images/1679546872182.webp)\n\n然后做滑动的窗口即可。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <vector> \n\nusing namespace std;\n\nconst long long S=2000005,MS=1000005;\n\nstruct node\n{\n\tint id;\n\tlong long w,val;\n}cir[MS];\n\nint n;\nint esum,to[S],nxt[S],h[MS];\nlong long c[S];\nint vis[MS];\nlong long dp[MS][2],maxdep[MS],trd;\nlong long sum[MS],que[MS];\nint tot;\n\ninline void add(int x,int y,long long w)\n{\n\tto[++esum]=y;\n\tc[esum]=w;\n\tnxt[esum]=h[x];\n\th[x]=esum;\n}\n\nbool dfs(int u,int fa)\n{\n\tbool res=false;\n\tvis[u]=1;\n\tfor(int i=h[u],cnt=0;i;i=nxt[i])\n\t{\n\t\tint v=to[i];\n\t\tif(v==fa)\n\t\t{\n\t\t\tif(cnt==1)\n\t\t\t{\n\t\t\t\tcir[++tot]=(node){u,0,c[i]};\n\t\t\t\tvis[fa]=4;\n\t\t\t\tres=true;\n\t\t\t}\n\t\t\tcnt++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(vis[v]==1)\n\t\t{\n\t\t\tcir[++tot]=(node){u,0,c[i]};\n\t\t\tvis[v]=4;\n\t\t\tres=true;\n\t\t\tcontinue;\n\t\t}\n\t\tif(vis[v]!=0)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tif(dfs(v,u))\n\t\t{\n\t\t\tif(vis[u]!=2)\n\t\t\t{\n\t\t\t\tcir[++tot]=(node){u,0,c[i]};\n\t\t\t\tif(vis[u]==4)\n\t\t\t\t{\n\t\t\t\t\tvis[fa]=2;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvis[fa]=2;\n\t\t\t}\n\t\t\tres=true;\n\t\t}\n\t}\n\tvis[u]=2;\n\treturn res;\n}\n\nvoid dfs2(int u,int fa,int rt)\n{\n\tdp[u][0]=dp[u][1]=0;\n\tmaxdep[u]=0;\n\tfor(int i=h[u];i;i=nxt[i])\n\t{\n\t\tint v=to[i];\n\t\tlong long w=c[i];\n\t\tif(v==fa||v==rt)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tdfs2(v,u,rt);\n\t\tmaxdep[u]=max(maxdep[u],w+maxdep[v]);\n\t\tlong long val=w+dp[v][0];\n\t\tif(val>=dp[u][0])\n\t\t{\n\t\t\tdp[u][1]=dp[u][0];\n\t\t\tdp[u][0]=val;\n\t\t}\n\t\telse if(val>=dp[u][1])\n\t\t{\n\t\t\tdp[u][1]=val;\n\t\t}\n\t}\n\ttrd=max(trd,dp[u][1]+dp[u][0]);\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x;\n\t\tlong long L;\n\t\tscanf(\"%d%lld\",&x,&L);\n\t\tadd(i,x,L);\n\t\tadd(x,i,L);\n\t}\n\tlong long ans=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(vis[i]==0)\n\t\t{\n\t\t\ttot=0;\n\t\t\tdfs(i,0);\n\t\t\tlong long curans=0;\n\t\t\tint m=tot;\n\t\t\tfor(int j=1;j<=m/2;j++)\n\t\t\t{\n\t\t\t\tswap(cir[j],cir[m-j+1]);\n\t\t\t}\n\t\t\tfor(int j=1;j<=m;j++)\n\t\t\t{\n\t\t\t\tint u=cir[j].id;\n\t\t\t\ttrd=0;\n\t\t\t\tdfs2(u,cir[j==1?m:j-1].id,cir[j==m?1:j+1].id);\n\t\t\t\tcurans=max(curans,trd);\n\t\t\t\tcir[j].w=maxdep[u];\n\t\t\t}\n\t\t\tfor(int j=1;j<=m;j++)\n\t\t\t{\n\t\t\t\tcir[++tot]=cir[j];\n\t\t\t}\n\t\t\tint newsiz=m*2-1;\n\t\t\tfor(int j=1;j<=newsiz;j++)\n\t\t\t{\n\t\t\t\tsum[j]=sum[j-1]+cir[j].val;\n\t\t\t}\n\t\t\tint hed=1,til=0;\n\t\t\tfor(int j=1;j<=newsiz;j++)\n\t\t\t{\n\t\t\t\twhile(hed<=til&&que[hed]<=j-m)\n\t\t\t\t{\n\t\t\t\t\thed++;\n\t\t\t\t}\n\t\t\t\tif(hed<=til)\n\t\t\t\t{\n\t\t\t\t\tcurans=max(curans,(cir[que[hed]].w+sum[j-1]-sum[que[hed]-1])+cir[j].w);\n\t\t\t\t}\n\t\t\t\twhile(hed<=til&&(cir[que[til]].w+sum[j-1]-sum[que[til]-1])<=cir[j].w)\n\t\t\t\t{\n\t\t\t\t\ttil--;\n\t\t\t\t}\n\t\t\t\tque[++til]=j;\n\t\t\t}\n\t\t\tans+=curans;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n```\n\n## 细节\n\n最重要的细节就是\n\n![](../post-images/1679546886992.webp)\n\n这种环的处理和基环树森林的处理。\n\n## 练习题目\n\n- [P5022 [NOIP2018 提高组] 旅行](https://www.luogu.com.cn/problem/P5022)\n\n- [P3533 [POI2012]RAN-Rendezvous](https://www.luogu.com.cn/problem/P3533)\n\n- [P7981 [JRKSJ R3] system](https://www.luogu.com.cn/problem/P7981)\n\n- [P1399 [NOI2013] 快餐店](https://www.luogu.com.cn/problem/P1399)\n\n- [CF835F Roads in the Kingdom](https://www.luogu.com.cn/problem/CF835F)\n\n- [P2081 [NOI2012] 迷失游乐园](https://www.luogu.com.cn/problem/P2081)\n",
			"tags": [{"name":"学习笔记"},{"name":"图论"}],
			"title": "基环树学习笔记",
			"link": "https://exber.qzz.io/post/%E5%9F%BA%E7%8E%AF%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-03-23 12:45:01"
		},
	
		{
			"abstract": "",
			"content": "这篇学习笔记大部分内容参考自任之洲的论文《积性函数求和的几种方法》。\n\n### 0 前置知识\n\n- [数论分块](../整除分块学习笔记/)\n\n### 1 一些定义\n\n**数论函数的定义** \n\n定义域为正整数域，陪域为负数域的函数被称为**数论函数**。\n\n**积性函数的定义**\n\n设 $f$ 为一个数论函数，若对于每一对互质的 $a,b$ 均满足 $f(ab)=f(a)f(b)$，则 $f$ 为**积性函数**。\n\n特别的，设 $g$ 为一个数论函数，若对于每一对 $a,b$ 均班满足 $g(ab)=g(a)g(b)$，则 $g$ 为**完全积性函数**。\n\n#### 1.1 常见的积性函数\n\n- 除数函数 $\\sigma_k(n)$：$n$ 的所有因数的 $k$ 次方和\n\n- 欧拉函数 $\\varphi(n)$：不超过 $n$ 且与 $n$ 互质的正整数个数\n\n- 莫比乌斯函数：\n\n$$\\mu(n)=\\begin{cases}1&\\,n=1\\\\(-1)^k&\\,n \\text{ 为 } k \\text{ 个不同的质数之积}\\\\ 0&\\text{其它情况}\\end{cases}$$\n\n#### 1.2 常见的完全积性函数\n\n- 单位函数：\n\n$$\\epsilon(n)=\\begin{cases}1&n=1\\\\0&n>1\\end{cases}$$\n\n### 2 莫比乌斯反演\n\n#### 2.1 狄利克雷卷积\n\n定义两个数论函数 $f(n),g(n)$ 的狄利克雷卷积为：（记作 $(f*g)(n)$）\n\n$$(f*g)(n)=\\sum\\limits_{d|n}f(d)g(\\dfrac{n}{d})$$\n\n狄利克雷卷积满足以下运算定律：\n\n- 交换律：$f*g=g*f$\n\n- 结合律: $(f*g)*h=f*(g*h)$\n\n- 分配律：$f*(g+h)=f*g+f*h$\n\n- 单位元：$f*\\epsilon=f$\n\n- 若 $f,g$ 均为积性函数，则 $f*g$ 也为积性函数\n\n#### 2.2 莫比乌斯反演\n\n**定理 2.1.** $\\mu *1=\\epsilon$，即：（其中函数 $1$ 为返回值恒为 $1$ 的常数函数）\n\n$$\\sum\\limits_{d|n}\\mu(d)=\\epsilon(n)$$\n\n**证明**\n\n设 $n$ 有 $k$ 个不同的质因子，则\n\n$$\\sum\\limits_{d|n}\\mu(d)=\\sum\\limits_{i=0}^k (-1)^i\\operatorname{C}_k^i=\\sum\\limits_{i=0}^k \\operatorname{C}_k^i(-1)^i1^{k-i}$$\n\n根据[二项式定理](https://zhuanlan.zhihu.com/p/37314812)，可得：（这里规定 $0^0=1$）\n\n$$\\sum\\limits_{i=0}^k \\operatorname{C}_k^i(-1)^i1^{k-i}=(1-1)^k=0^k=\\epsilon(n)$$\n\n所以**莫比乌斯函数相当于是狄利克雷卷积下 $1$ 的逆元**。\n\n**定理 2.2.**\n\n设 $f,g$ 是两个数论函数，且满足\n\n$$f(n)=\\sum\\limits_{d|n} g(d)$$\n\n则它们也满足\n\n$$g(n)=\\sum\\limits_{d|n} \\mu(d)f(\\dfrac{n}{d})$$\n\n反之亦然，即\n\n$$f=g*1\\Leftrightarrow g=\\mu*f$$\n\n**证明**\n\n$$f=g*1$$\n\n两边同时卷上 $\\mu$，得：\n\n$$f*\\mu=g*1*\\mu$$\n\n根据定理 2.1 得：\n\n$$f*\\mu=g$$\n\n两侧都卷上 $1$，得：\n\n$$f=g*1$$\n\n### 3 一些应用\n\n[P2257 YY的GCD](https://www.luogu.com.cn/problem/P2257)\n\n>求\n>$$\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^m[\\gcd(i,j)\\in Prime]$$\n\n首先枚举质数 $p$，则原式可化为：\n\n$$\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^m[\\gcd(i,j)=p]$$\n\n\n即\n\n$$\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{p}\\rfloor}\\sum\\limits_{j=1}^{\\lfloor\\frac{m}{p}\\rfloor}[\\gcd(i,j)=1]$$\n\n也就是\n\n$$\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{p}\\rfloor}\\sum\\limits_{j=1}^{\\lfloor\\frac{m}{p}\\rfloor}\\epsilon(\\gcd(i,j)=1)$$\n\n通过定理 2.1 展开得\n\n\n$$\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{p}\\rfloor}\\sum\\limits_{j=1}^{\\lfloor\\frac{m}{p}\\rfloor}\\sum\\limits_{d|\\gcd(i,j)}\\mu(d)$$\n\n变换求和顺序，得\n\n$$\\sum\\limits_{d=1}\\mu(d)\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{p}\\rfloor}[d|i]\\sum\\limits_{j=1}^{\\lfloor\\frac{m}{p}\\rfloor}[d|j]$$\n\n$\\because1\\sim \\lfloor\\dfrac{n}{p}\\rfloor\\text{ 中有 }\\left\\lfloor \\dfrac{\\lfloor\\dfrac{n}{p}\\rfloor}{d} \\right\\rfloor\\text{个 }d\\text{ 的倍数}$\n\n$\\therefore$ 得\n\n$$\\sum\\limits_{d=1}\\mu(d)\\left\\lfloor \\dfrac{\\lfloor\\dfrac{n}{p}\\rfloor}{d} \\right\\rfloor\\left\\lfloor \\dfrac{\\lfloor\\dfrac{m}{p}\\rfloor}{d} \\right\\rfloor$$\n\n即\n\n$$\\sum\\limits_{d=1}^{\\min(\\lfloor\\frac{n}{p}\\rfloor,\\lfloor\\frac{m}{p}\\rfloor)}\\mu(d)\\lfloor\\dfrac{n}{pd}\\rfloor\\lfloor\\dfrac{m}{pd}\\rfloor$$\n\n显然可以使用数论分块求解。\n\n但是这样还不够优，考虑继续化简：\n\n设 $T=pd$，则原式变为\n\n$$\\sum\\limits_{d=1}^{\\min(\\lfloor\\frac{n}{p}\\rfloor,\\lfloor\\frac{m}{p}\\rfloor)}\\mu(d)\\lfloor\\dfrac{n}{T}\\rfloor\\lfloor\\dfrac{m}{T}\\rfloor$$\n\n也就是\n\n$$\\sum\\limits_{T=1}^{\\min(n,m)}\\lfloor\\dfrac{n}{T}\\rfloor\\lfloor\\dfrac{m}{T}\\rfloor\\sum\\limits_{p\\in Prime,p|T}\\mu(\\dfrac{T}{p})$$\n\n容易发现，最后那个求和可以预处理，最后套一下整除分块即可。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst long long S=1e7+1;\n\nint n,m;\nbool nop[S+5];\nint tot,prime[S+5];\nint mu[S+5];\nlong long sum[S+5];\n\ninline int read()\n{\n\tint s=0,w=1,ch=getchar();\n\twhile(ch<'0'||ch>'9') ch=='-'?w=-1,ch=getchar():ch=getchar();\n\twhile(ch>='0'&&ch<='9') s=(s<<1)+(s<<3)+(ch^48),ch=getchar();\n\treturn s*w;\n}\n\ninline void writen(long long x)\n{\n\tif(x>9) writen(x/10);\n\tputchar(x%10|48);\n}\n\ninline void init()\n{\n\tnop[1]=true;\n\tmu[1]=1;\n\tfor(register int i=2;i<=S;++i)\n\t{\n\t\tif(!nop[i])\n\t\t{\n\t\t\tprime[++tot]=i;\n\t\t\tmu[i]=-1;\n\t\t}\n\t\tfor(register int j=1;j<=tot;++j)\n\t\t{\n\t\t\tif(i*prime[j]>S)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnop[i*prime[j]]=true;\n\t\t\tif(i%prime[j]==0)\n\t\t\t{\n\t\t\t\tmu[i*prime[j]]=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmu[i*prime[j]]=-mu[i];\n\t\t}\n\t}\n\tfor(int i=1;i<=tot;++i)\n\t{\n\t\tfor(int j=1;j*prime[i]<=S;++j)\n\t\t{\n\t\t\tsum[j*prime[i]]+=mu[j];\t\n\t\t}\n\t}\n\tfor(int i=1;i<=S;++i)\n\t{\n\t\tsum[i]+=sum[i-1];\n\t}\n}\n\nint main()\n{\n\tinit();\n\tint _=read();\n\twhile(_--)\n\t{\n\t\tn=read();\n\t\tm=read();\n\t\tif(n>m)\n\t\t{\n\t\t\tswap(n,m);\n\t\t}\n\t\tlong long ans=0;\n\t\tfor(int l=1;l<=n;)\n\t\t{\n\t\t\tint r=min(n/(n/l),m/(m/l));\n\t\t\tans+=(sum[r]-sum[l-1])*(n/l)*(m/l);\n\t\t\tl=r+1;\n\t\t}\n\t\twriten(ans);\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}\n```\n\n****\n\n[P2522 [HAOI2011]Problem b](https://www.luogu.com.cn/problem/P2522)\n\n>求\n$$\\sum\\limits_{i=a}^b\\sum\\limits_{j=c}^d[\\gcd(i,j)=k]$$\n\n根据容斥原理，这个柿子可以分成四块，每一块的形式都是\n\n$$\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^m[\\gcd(i,j)=k]$$\n\n即\n\n$$\\sum\\limits_{d=1}^{\\min(\\lfloor\\frac{n}{k}\\rfloor,\\lfloor\\frac{m}{k}\\rfloor)}\\mu(d)\\lfloor\\dfrac{n}{kd}\\rfloor\\lfloor\\dfrac{m}{kd}\\rfloor$$\n\n可以使用数论分块求解。\n\n#### 4 练习题目\n\n[P1829 [国家集训队]Crash的数字表格 / JZPTAB](https://www.luogu.com.cn/problem/P1829)\n\n[P3455 [POI2007]ZAP-Queries](https://www.luogu.com.cn/problem/P3455)\n\n[P3327 [SDOI2015]约数个数和](https://www.luogu.com.cn/problem/P3327)\n\n[P6810 「MCOI-02」Convex Hull 凸包](https://www.luogu.com.cn/problem/P6810)\n",
			"tags": [{"name":"学习笔记"},{"name":"数学"},{"name":"数论"}],
			"title": "莫比乌斯反演学习笔记",
			"link": "https://exber.qzz.io/post/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-03-21 15:49:52"
		},
	
		{
			"abstract": "",
			"content": "~~树链剖分，就是用来增加代码长度的……~~\n\n~~反正我模板题写了 4 kb/ll~~\n\n**树链剖分，简称树剖，是用来把一棵树划分成很多条互不相交的链，再用类似线段树的数据结构来维护信息的。通常，“树剖”指的是树链剖分中的重链剖分。**\n\n[模板题](https://www.luogu.com.cn/problem/P3384)\n\n首先看一些定义：\n\n- 重儿子：对于每一个非叶节点，它所有儿子中子树最大的节点\n\n- 轻儿子：不是重儿子的其他儿子\n\n- 重边：一个非叶节点连向它的重儿子的边\n\n- 轻边：一个非叶节点连向它的轻儿子的边\n\n- 重链：以一个轻儿子开始，由若干条重边连接而成的链（**单独一个轻儿子也能作为一条重链**）\n\n![](../post-images/1679384894413.webp)\n\n很容易发现，**每条重链都不会相交，这样我们就可以使用类似线段树这样的数据结构来维护这些重链了**。\n\n然后我们很显然**可以在 $O(n)$ 的时间复杂度内求出节点 $u$ 的父节点 $fat_u$、子树大小 $siz_u$ 和重儿子 $hson_u$。**\n\n代码如下：\n\n```cpp\nvoid dfs1(int u,int fa)\n{\n\tfat[u]=fa;\n\tsiz[u]=1;\n\tdep[u]=dep[fa]+1;\n\tfor(int i=h[u];i;i=nxt[i])\n\t{\n\t\tint v=to[i];\n\t\tif(v==fa)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tdfs1(v,u);\n\t\tsiz[u]+=siz[v];\n\t\tif(siz[v]>siz[hson[u]])\n\t\t{\n\t\t\thson[u]=v;\n\t\t}\n\t}\n}\n```\n\n接下来，我们**考虑将整棵树映射到一个序列上，再使用线段树去维护它**。很显然，**可以使用 dfs 序，然后只要先递归重儿子，就可以保证同一条重链的区间是连续的了**。\n\n具体的做法是，**再跑一遍 dfs，在 $O(n)$ 的时间复杂度内求出新的序列 $a$、节点 $u$ 在新序列中的编号 $id_u$、节点 $u$ 所属链的开头的节点 $top_u$ 和节点 $u$ 子树在新序列中的右端点 $R_u$**。\n\n代码如下：\n\n```cpp\nvoid dfs2(int u,int tpf,int fa) // tpf 是 u 所属的重链的开头节点 \n{\n\tid[u]=++cnt;\n\ta[cnt]=val[u];\n\ttop[u]=tpf;\n\tif(hson[u]==0) // 如果没有重儿子说明是叶子 \n\t{\n\t\tR[u]=cnt;\n\t\treturn;\n\t}\n\tdfs2(hson[u],tpf,u); // 先递归重儿子，因为它和 u 属于同一条重链 \n\tfor(int i=h[u];i;i=nxt[i])\n\t{\n\t\tint v=to[i];\n\t\tif(v==fa||v==hson[u])\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tdfs2(v,v,u); // 对于轻儿子，直接新开一条重链 \n\t}\n\tR[u]=cnt;\n}\n```\n\n现在我们已经成功地把树“剖开”了，接下来的工作就是使用线段树来维护新的序列。\n\n首先看两个对于 $x$ 的子树的操作。很显然，$x$ 的子树对应的区间是 $[id_x,R_x]$，那么子树加和子树和查询就相当于在这个区间上操作。\n\n代码如下：\n\n```cpp\ninline void addsubtree(int u,long long k)\n{\n\tupd(1,1,n,id[u],R[u],k);\n}\n\ninline long long quesubtree(int u)\n{\n\treturn que(1,1,n,id[u],R[u]);\n}\n```\n\n而对于两个节点 $x,y$ 的最短路径的操作，可以**让它们不断往上跳重链，直到两点在同一重链里**。\n\n具体的做法是，**不断令所在重链开始节点的深度较大的那个节点往上跳一整条链，并计算这条链的贡献**。\n\n画出来是这样的：\n\n![](../post-images/1679384924928.webp)\n\n代码如下：\n\n```cpp\ninline void addpath(int x,int y,long long k)\n{\n\twhile(top[x]!=top[y])\n\t{\n\t\tif(dep[top[x]]>dep[top[y]])\n\t\t{\n\t\t\tupd(1,1,n,id[top[x]],id[x],k); // 贡献 \n\t\t\tx=fat[top[x]]; // 往上跳 \n\t\t}\n\t\telse\n\t\t{\n\t\t\tupd(1,1,n,id[top[y]],id[y],k); // 贡献 \n\t\t\ty=fat[top[y]]; // 往上跳 \n\t\t}\n\t}\n\tupd(1,1,n,min(id[x],id[y]),max(id[x],id[y]),k); // 最后的一小段 \n}\n\ninline long long quepath(int x,int y) // 同理 \n{\n\tlong long res=0;\n\twhile(top[x]!=top[y])\n\t{\n\t\tif(dep[top[x]]>dep[top[y]])\n\t\t{\n\t\t\tres=(res+que(1,1,n,id[top[x]],id[x]))%p;\n\t\t\tx=fat[top[x]];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tres=(res+que(1,1,n,id[top[y]],id[y]))%p;\n\t\t\ty=fat[top[y]];\n\t\t}\n\t}\n\tres=(res+que(1,1,n,min(id[x],id[y]),max(id[x],id[y])))%p;\n\treturn res;\n}\n```\n\n复杂度证明：\n\n首先**子树操作的复杂度显然是 $O(\\log n)$**。\n\n然后**对于最短路径操作，由于 $u$ 的轻儿子的子树大小最多是 $\\lfloor\\dfrac{siz_u}{2}\\rfloor$，所以最多只会跳 $\\log n$ 次重边，那么时间复杂度就是 $O(\\log^2n)$**。\n\n综上，**树剖的时间复杂度为 $O(\\log^2n)$**。\n\n模板题代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst long long S=200005,MS=100005;\n\nint n,m,r;\nlong long p,val[MS];\nint esum,to[S],nxt[S],h[MS];\nint fat[MS],siz[MS],hson[MS],dep[MS];\nint cnt,id[MS],top[MS],R[MS];\nlong long a[MS];\nlong long sum[MS<<2],lazy[MS<<2];\n\ninline void add(int x,int y)\n{\n\tto[++esum]=y;\n\tnxt[esum]=h[x];\n\th[x]=esum;\n}\n\nvoid dfs1(int u,int fa)\n{\n\tfat[u]=fa;\n\tsiz[u]=1;\n\tdep[u]=dep[fa]+1;\n\tfor(int i=h[u];i;i=nxt[i])\n\t{\n\t\tint v=to[i];\n\t\tif(v==fa)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tdfs1(v,u);\n\t\tsiz[u]+=siz[v];\n\t\tif(siz[v]>siz[hson[u]])\n\t\t{\n\t\t\thson[u]=v;\n\t\t}\n\t}\n}\n\nvoid dfs2(int u,int tpf,int fa) // tpf 是 u 所属的重链的开头节点 \n{\n\tid[u]=++cnt;\n\ta[cnt]=val[u];\n\ttop[u]=tpf;\n\tif(hson[u]==0) // 如果没有重儿子说明是叶子 \n\t{\n\t\tR[u]=cnt;\n\t\treturn;\n\t}\n\tdfs2(hson[u],tpf,u); // 先递归重儿子，因为它和 u 属于同一条重链 \n\tfor(int i=h[u];i;i=nxt[i])\n\t{\n\t\tint v=to[i];\n\t\tif(v==fa||v==hson[u])\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tdfs2(v,v,u); // 对于轻儿子，直接新开一条重链 \n\t}\n\tR[u]=cnt;\n}\n\ninline void updata(int u)\n{\n\tsum[u]=(sum[u<<1]+sum[u<<1|1])%p;\n}\n\ninline void lazydown(int u,int l,int r)\n{\n\tif(lazy[u]==0)\n\t{\n\t\treturn;\n\t}\n\tint mid=l+r>>1;\n\tsum[u<<1]=(sum[u<<1]+lazy[u]*(mid-l+1))%p;\n\tsum[u<<1|1]=(sum[u<<1|1]+lazy[u]*(r-mid))%p;\n\tlazy[u<<1]=(lazy[u<<1]+lazy[u])%p;\n\tlazy[u<<1|1]=(lazy[u<<1|1]+lazy[u])%p;\n\tlazy[u]=0;\n}\n\nvoid build(int u,int l,int r)\n{\n\tif(l==r)\n\t{\n\t\tsum[u]=a[l];\n\t\treturn;\n\t}\n\tint mid=l+r>>1;\n\tbuild(u<<1,l,mid);\n\tbuild(u<<1|1,mid+1,r);\n\tupdata(u);\n}\n\nvoid upd(int u,int l,int r,int L,int R,long long k)\n{\n\tif(r<L||l>R)\n\t{\n\t\treturn;\n\t}\n\tif(l>=L&&r<=R)\n\t{\n\t\tsum[u]=(sum[u]+k*(r-l+1))%p;\n\t\tlazy[u]=(lazy[u]+k)%p;\n\t\treturn;\n\t}\n\tlazydown(u,l,r);\n\tint mid=l+r>>1;\n\tif(L<=mid)\n\t{\n\t\tupd(u<<1,l,mid,L,R,k);\n\t}\n\tif(r>=mid+1)\n\t{\n\t\tupd(u<<1|1,mid+1,r,L,R,k);\n\t}\n\tupdata(u);\n}\n\nlong long que(int u,int l,int r,int L,int R)\n{\n\tif(r<L||l>R)\n\t{\n\t\treturn 0;\n\t}\n\tif(l>=L&&r<=R)\n\t{\n\t\treturn sum[u];\n\t}\n\tlazydown(u,l,r);\n\tint mid=l+r>>1;\n\tlong long res=0;\n\tif(L<=mid)\n\t{\n\t\tres=(res+que(u<<1,l,mid,L,R))%p;\n\t}\n\tif(R>=mid+1)\n\t{\n\t\tres=(res+que(u<<1|1,mid+1,r,L,R))%p;\n\t}\n\treturn res;\n}\n\ninline void addpath(int x,int y,long long k)\n{\n\twhile(top[x]!=top[y])\n\t{\n\t\tif(dep[top[x]]>dep[top[y]])\n\t\t{\n\t\t\tupd(1,1,n,id[top[x]],id[x],k); // 贡献 \n\t\t\tx=fat[top[x]]; // 往上跳 \n\t\t}\n\t\telse\n\t\t{\n\t\t\tupd(1,1,n,id[top[y]],id[y],k); // 贡献 \n\t\t\ty=fat[top[y]]; // 往上跳 \n\t\t}\n\t}\n\tupd(1,1,n,min(id[x],id[y]),max(id[x],id[y]),k); // 最后的一小段 \n}\n\ninline long long quepath(int x,int y) // 同理 \n{\n\tlong long res=0;\n\twhile(top[x]!=top[y])\n\t{\n\t\tif(dep[top[x]]>dep[top[y]])\n\t\t{\n\t\t\tres=(res+que(1,1,n,id[top[x]],id[x]))%p;\n\t\t\tx=fat[top[x]];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tres=(res+que(1,1,n,id[top[y]],id[y]))%p;\n\t\t\ty=fat[top[y]];\n\t\t}\n\t}\n\tres=(res+que(1,1,n,min(id[x],id[y]),max(id[x],id[y])))%p;\n\treturn res;\n}\n\ninline void addsubtree(int u,long long k)\n{\n\tupd(1,1,n,id[u],R[u],k);\n}\n\ninline long long quesubtree(int u)\n{\n\treturn que(1,1,n,id[u],R[u]);\n}\n\nint main()\n{\n\tscanf(\"%d%d%d%lld\",&n,&m,&r,&p);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld\",&val[i]);\n\t\tval[i]%=p;\n\t}\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);\n\t\tadd(y,x);\n\t}\n\tdfs1(r,0);\n\tdfs2(r,r,0);\n\tbuild(1,1,n);\n\twhile(m--)\n\t{\n\t\tint ty;\n\t\tscanf(\"%d\",&ty);\n\t\tif(ty==1)\n\t\t{\n\t\t\tint x,y;\n\t\t\tlong long z;\n\t\t\tscanf(\"%d%d%lld\",&x,&y,&z);\n\t\t\taddpath(x,y,z);\n\t\t}\n\t\telse if(ty==2)\n\t\t{\n\t\t\tint x,y;\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tprintf(\"%lld\\n\",quepath(x,y));\n\t\t}\n\t\telse if(ty==3)\n\t\t{\n\t\t\tint x;\n\t\t\tlong long z;\n\t\t\tscanf(\"%d%lld\",&x,&z);\n\t\t\taddsubtree(x,z);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint x;\n\t\t\tscanf(\"%d\",&x);\n\t\t\tprintf(\"%lld\\n\",quesubtree(x));\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n### 练习题目\n\n[P2146 [NOI2015] 软件包管理器](https://www.luogu.com.cn/problem/P2146)\n\n[P2486 [SDOI2011]染色](https://www.luogu.com.cn/problem/P2486)\n\n[P2590 [ZJOI2008]树的统计](https://www.luogu.com.cn/problem/P2590)\n\n[P3178 [HAOI2015]树上操作](https://www.luogu.com.cn/problem/P3178)\n",
			"tags": [{"name":"学习笔记"},{"name":"数据结构"}],
			"title": "树链剖分学习笔记",
			"link": "https://exber.qzz.io/post/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-03-21 15:47:24"
		},
	
		{
			"abstract": "",
			"content": "整除分块主要是用来求这么一个柿子的：\n\n$$\\sum\\limits_{i=1}^n \\lfloor \\dfrac{n}{i}\\rfloor$$\n\n这个东西在 $n$ 很小的情况下是可以暴力做的，但是如果 $n$ 太大就不行了。\n\n首先我们先打表找一下规律，输出一下 $n=30$ 时 $\\lfloor\\dfrac{n}{i}\\rfloor$ 的值：\n\n```\n30 15 10 7 6 5 4 3 3 3 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n```\n\n很容易发现，整个序列是单调不增的，而且会出现一些很长的值相同的连续段。\n\n那么我们可以**考虑每个连续段里的点的贡献一起计算，假设我们现在已经知道一个块的左端点为 $l$，那么我们只需要求出这个块的右端点 $r$ 就行了**。\n\n我们推一下柿子：\n\n$$\\because \\lfloor\\dfrac{n}{r}\\rfloor=\\lfloor\\dfrac{n}{l}\\rfloor$$\n\n$$\\therefore \\lfloor\\dfrac{n}{l}\\rfloor\\le\\dfrac{n}{r}<\\lceil\\dfrac{n}{l}\\rceil$$\n\n省略上界：\n\n$$\\dfrac{n}{r}\\ge\\lfloor\\dfrac{n}{l}\\rfloor$$\n\n两边同时取倒数，得：（**不等式要变号**）\n\n$$\\dfrac{r}{n}\\le\\dfrac{1}{\\lfloor\\dfrac{n}{l}\\rfloor}$$\n\n两边同时乘上 $n$，得：\n\n$$r\\le\\dfrac{n}{\\lfloor\\dfrac{n}{l}\\rfloor}$$\n\n$$\\because r \\color{Black}\\colorbox{White}{是整数，且} r \\color{Black}\\colorbox{White}{最大}$$\n\n$$\\therefore r=\\left\\lfloor\\dfrac{n}{\\lfloor\\dfrac{n}{l}\\rfloor}\\right\\rfloor$$\n\n所以可以得出，**如果一个块的左端点是 $l$，那么右端点就是 $\\left\\lfloor\\dfrac{n}{\\lfloor\\dfrac{n}{l}\\rfloor}\\right\\rfloor$**。\n\n我们考虑推广一下它，易得出如果要求\n\n$$\\sum\\limits_{i=1}^n \\lfloor \\dfrac{k}{i}\\rfloor$$\n\n的话，**左端点为 $l$ 的块的右端点是 $\\min(n,\\left\\lfloor\\dfrac{k}{\\lfloor\\dfrac{k}{l}\\rfloor}\\right\\rfloor)$**。\n\n那么这样做的时间复杂度是多少的呢？**很明显是 $O(\\sqrt k)$ 的，因为 $\\lfloor\\dfrac{k}{i}\\rfloor$ 只有 $\\sqrt k$ 种取值，所以也就只有 $\\sqrt k$ 个块**。\n\n现在我们来看一道例题：([P2261 [CQOI2007]余数求和](https://www.luogu.com.cn/problem/P2261))\n\n> 求 $\\operatorname{G}(n,k)=\\sum\\limits_{i=1}^n k\\mod i$\n\n推一下柿子：\n\n$$\\sum\\limits_{i=1}^n k\\mod i$$\n\n$$=\\sum\\limits_{i=1}^n k-i\\lfloor\\dfrac{k}{i}\\rfloor$$\n\n$$=nk-\\sum\\limits_{i=1}^n i\\lfloor\\dfrac{k}{i}\\rfloor$$\n\n现在问题变为要求 $\\sum\\limits_{i=1}^n i\\lfloor\\dfrac{k}{i}\\rfloor$ 的值了。我们可以运用刚刚的结论，求出每一个块的左右端点后，用 $\\dfrac{k}{l}$ 乘上 $\\sum\\limits_{i=l}^r i$。$\\sum\\limits_{i=l}^r i$ 很显然可以 $O(1)$ 求出来。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nlong long n,k;\n\ninline long long getsum(long long l,long long r)\n{\n\treturn (l+r)*(r-l+1)/2;\n}\n\nint main()\n{\n\tscanf(\"%lld%lld\",&n,&k);\n\tlong long ans=0;\n\tfor(long long l=1;l<=n&&k/l>0;) // 如果 k/l=0，那么会 RE，仔细想想，这个块肯定是对答案没贡献的，所以直接跳出循环 \n\t{\n\t\tlong long r=min(k/(k/l),n); // 记得取 min \n\t\tans+=getsum(l,r)*(k/l);\n\t\tl=r+1;\n\t}\n\tprintf(\"%lld\\n\",k*n-ans);\n\treturn 0;\n}\n```\n\n再看一道进阶版的题：\n\n[P2260 [清华集训2012]模积和](https://www.luogu.com.cn/problem/P2260)\n\n首先我们**令 $n$ 为 $n,m$ 中较小的一个，$m$ 为另一个**。\n\n推一下柿子，不难得出：（推柿子还是自己推推比较好，给个思路：总体减去 $i=j$ 的，实在不行可以看 [这里](https://www.luogu.com.cn/blog/command-block/zheng-chu-fen-kuai-ru-men-xiao-ji)）\n\n$$\\color{Black}\\colorbox{White}{原式}=\\operatorname{F}(n)\\operatorname{F}(m)-n^2m+n\\operatorname{G}(n,m)+m\\operatorname{G}(n,n)-\\sum\\limits_{i=1}^n i^2\\lfloor\\dfrac{n}{i}\\rfloor\\lfloor\\dfrac{m}{i}\\rfloor$$\n\n其中：\n\n$$\\operatorname{G}(n,k)=\\sum\\limits_{i=1}^n i\\lfloor\\dfrac{k}{i}\\rfloor$$\n\n$$\\operatorname{F}(n)=\\sum\\limits_{i=1}^n n-i\\lfloor\\dfrac{n}{i}\\rfloor=n^2-\\operatorname{G}(n,n)$$\n\n现在考虑求解 $\\sum\\limits_{i=1}^n i^2\\lfloor\\dfrac{n}{i}\\rfloor\\lfloor\\dfrac{m}{i}\\rfloor$，容易发现，**$\\lfloor\\dfrac{n}{i}\\rfloor\\lfloor\\dfrac{m}{i}\\rfloor$ 是单调不增的，所以可以使用数论分块，左端点为 $l$ 的块右端点就是 $\\min(\\left\\lfloor\\dfrac{n}{\\lfloor\\dfrac{n}{l}\\rfloor}\\right\\rfloor,\\left\\lfloor\\dfrac{m}{\\lfloor\\dfrac{m}{l}\\rfloor}\\right\\rfloor)$，$i^2$ 的和则可以使用公式来求解。**\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nconst long long mod=19940417,inv2=9970209,inv6=3323403;\n\nlong long n,m;\n\ninline long long G(long long n,long long k)\n{\n\tlong long res=0;\n\tfor(long long l=1;l<=n&&k/l>0;)\n\t{\n\t\tlong long r=min(k/(k/l),n);\n\t\tres+=(l+r)*(r-l+1)%mod*inv2%mod*(k/l)%mod;\n\t\tres%=mod;\n\t\tl=r+1;\n\t}\n\treturn res;\n}\n\ninline long long F(long long n)\n{\n\treturn (((n*n%mod-G(n,n))%mod)+mod)%mod;\n}\n\ninline long long sum(long long x) // 小学奥数的知识：1^2+2^2+3^2+...+x^2 \n{\n\treturn x*(x+1)%mod*(x+x+1)%mod*inv6%mod;\n}\n\nint main()\n{\n\tscanf(\"%lld%lld\",&n,&m);\n\tif(n>m)\n\t{\n\t\tlong long t=n;\n\t\tn=m;\n\t\tm=t;\n\t}\n\tlong long ans=F(n)*F(m)%mod-n*n%mod*m%mod+n*G(n,m)%mod+m*G(n,n)%mod; // 疯狂取模，少一个可能就会 WA \n\tans=(ans%mod+mod)%mod;\n\tfor(long long l=1;l<=n;)\n\t{\n\t\tlong long r=min(n/(n/l),m/(m/l));\n\t\tans-=((sum(r)-sum(l-1))%mod+mod)%mod*(n/l)%mod*(m/l)%mod;\n\t\tans=(ans%mod+mod)%mod;\n\t\tl=r+1;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n```\n\n### 练习题目\n\n[UVA11526 H(n)](https://www.luogu.com.cn/problem/UVA11526)\n\n[P3935 Calculating](https://www.luogu.com.cn/problem/P3935)\n",
			"tags": [{"name":"学习笔记"},{"name":"数学"},{"name":"数论"}],
			"title": "整除分块学习笔记",
			"link": "https://exber.qzz.io/post/%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-03-21 15:35:04"
		},
	
		{
			"abstract": "",
			"content": "CDQ 分治，据说是由陈丹琦最先引入国内 OI 圈的。它与 dp 类似，是一种思想，而不是一种具体的算法。\n\nCDQ 分治一般用来解决点对的问题，例如[P3810 【模板】三维偏序（陌上花开）](https://www.luogu.com.cn/problem/P3810)这道题：\n\n```\n给定 n 个元素，每个元素有权值 a_i,b_i,c_i。\n\n规定 f(i) 为满足 a_j<=a_i,b_j<=b_i,c_j<=c_i 且 j!=i 的 j 的个数。\n\n求所有 0<=x<n 的 ans(x) 表示有多少个满足 f(i)=x 的 i。\n```\n\nCDQ 分治的步骤大体如下：\n\n- 二分一个 $mid$\n\n- 递归处理所有 $i,j\\le mid$ 的点对和所有 $i,j\\ge mid+1$ 的点对\n\n- 设法处理所有 $i\\le mid,j\\ge mid+1$ 的点对\n\n没错，归并排序求逆序对也是类似的思路，所以可以说归并排序求逆序对也是一种 CDQ 分治（\n\n回到例题，首先考虑一个弱智版问题：\n\n> 每个元素只有一个属性 a_i\n\n很明显排一次序就行了。\n\n再来看一个难一点的\n\n> 每个元素有两个属性 a_i 和 b_i\n\n可以先按 $a_i$ 排序，然后再用树状数组计算贡献。\n\n```cpp\nsort(a+1,a+n+1,cmpa); // 按 a_i 排序\nfor(int i=1;i<=n;i++)\n{\n    // 下文 add 函数和 que 函数分别是树状数组的单点修改和前缀和查询\n    a[i].ans=que(a[i].b); // 查询\n    add(a[i].b,1); // 插入树状数组\n}\n```\n\n回到例题，首先对 $a_i$ 排序，这样我们就消去了一个关键字。由于有重复的元素，所以我们可以做一下去重（其实不去重也没什么关系）。\n\n接下来，我们可以**使用 CDQ 分治来再去一个关键字**。\n\n具体的做法是，递归分治完两边后，需要计算 $x\\in[l,mid]$ 对 $y\\in[mid+1,r]$ 的贡献，那么由于 $a_x\\le y_x$，所以可以先对两个区间的 $b_i$ 排序，然后用树状数组统计答案。\n\n排序部分可以用归并排序，省去一些时间。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nstruct node\n{\n\tint a,b,c,cnt,ans;\n}a[100005],tmp[100005];\n\nint n,k;\nint c[200005],ans[100005];\n\ninline bool cmpa(node x,node y)\n{\n\tif(x.a==y.a)\n\t{\n\t\tif(x.b==y.b)\n\t\t{\n\t\t\treturn x.c<y.c;\n\t\t}\n\t\treturn x.b<y.b;\n\t}\n\treturn x.a<y.a;\n}\n\ninline bool cmpb(node x,node y)\n{\n\tif(x.b==y.b)\n\t{\n\t\treturn x.c<y.c;\n\t}\n\treturn x.b<y.b;\n}\n\ninline void add(int pos,int val)\n{\n\tfor(int i=pos;i<=k;i+=i&-i)\n\t{\n\t\tc[i]+=val; \n\t}\n}\n\ninline int que(int pos)\n{\n\tint res=0;\n\tfor(int i=pos;i>=1;i-=i&-i)\n\t{\n\t\tres+=c[i];\n\t}\n\treturn res;\n}\n\nvoid slove(int l,int r)\n{\n\t// “分” \n\tif(l==r)\n\t{\n\t\treturn;\n\t}\n\tint mid=l+r>>1;\n\tslove(l,mid);\n\tslove(mid+1,r);\n\t// “治”\n\tint j=l,tot=0;\n\tfor(int i=mid+1;i<=r;i++) // 归并排序，计算贡献 \n\t{\n\t\twhile(j<=mid&&a[j].b<=a[i].b) \n\t\t{\n\t\t\tadd(a[j].c,a[j].cnt); \n\t\t\ttmp[++tot]=a[j++];\n\t\t}\n\t\ta[i].ans+=que(a[i].c);\n\t\ttmp[++tot]=a[i];\n\t}\n\twhile(j<=mid)\n\t{\n\t\tadd(a[j].c,a[j].cnt);\n\t\ttmp[++tot]=a[j++];\n\t}\n\tfor(int i=l;i<=mid;i++) // 清空树状数组，这样写比 memset 快一点（ \n\t{\n\t\tadd(a[i].c,-a[i].cnt);\n\t}\n\tfor(int i=l;i<=r;i++)\n\t{\n\t\ta[i]=tmp[i-l+1];\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d%d%d\",&a[i].a,&a[i].b,&a[i].c);\n\t}\n\tsort(a+1,a+n+1,cmpa);\n\tint tot=0;\n\tfor(int i=1,sum=0;i<=n;i++) // 去重 \n\t{\n\t\tsum++;\n\t\tif(a[i].a!=a[i+1].a||a[i].b!=a[i+1].b||a[i].c!=a[i+1].c) \n\t\t{\n\t\t\ta[++tot]=a[i];\n\t\t\ta[tot].cnt=sum;\n\t\t\tsum=0;\n\t\t}\n\t}\n\tslove(1,tot);\n\tfor(int i=1;i<=tot;i++)\n\t{\n\t\tans[a[i].ans+a[i].cnt-1]+=a[i].cnt; // 计算答案，<= a_i 的有 a_i.ans 个，再算上 = a_i 的，最后减去重复计算的 a_i \n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tprintf(\"%d\\n\",ans[i]);\n\t}\n\treturn 0;\n}\n```\n做完这道题，可以发现 CDQ 分治处理偏序问题的本质是消关键字（\n\n所以四维偏序可以使用 CDQ 分治套 CDQ 分治来做（（（\n\n### 练习题目\n\n[P3157 [CQOI2011]动态逆序对](https://www.luogu.com.cn/problem/P3157)\n\n[UVA11990 ``Dynamic'' Inversion](https://www.luogu.com.cn/problem/UVA11990)\n",
			"tags": [{"name":"学习笔记"}],
			"title": "CDQ 分治学习笔记",
			"link": "https://exber.qzz.io/post/CDQ%20%E5%88%86%E6%B2%BB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-03-21 15:32:45"
		},
	
		{
			"abstract": "",
			"content": "### #0 一些定义\n\n对于带权有向图 $G$：\n\n- 定义 $(x\\to y,w)$ 为一条权值为 $w$ 的从 $x$ 连向 $y$ 的有向边；\n- 定义 $V(G)$ 为图 $G$ 的点集，$E(G)$ 为 $G$ 的边集；\n\n### #1 什么是网络流\n\n##### 定义 1.1（网络、源点汇点、容量）\n\n> 定义**网络** $(G,S,T)$ 如下：\n>\n> - $G$ 是一个**边带非负权**的**有向图**，$S$ 和 $T$ 是 $G$ 中的节点；\n> - $S$ 被称为**源点**，$T$ 被称为**汇点**；\n> - 对于 $G$ 中的边 $(x\\to y,w)$，$w$ 被称为改边的**容量**；\n\n##### 定义 1.2（流、流量）\n\n> 对于一个网络 $(G,S,T)$，定义一组**流** $F=f_{[1,|E(G)|]}$，其中 $f_i$ 为第 $i$ 条边**被使用的流量**，需要满足：\n>\n> - $\\forall 1\\le i\\le|E(G)|$，有 $f_i\\le w_i$；\n> - $\\forall u\\in V(G),u\\notin\\{S,T\\}$，有 $\\sum\\limits_{(x_i\\to y_i,w_i)\\in E(G),y_i=u} f_i=\\sum\\limits_{(x_i\\to y_i,w_i)\\in E(G),x_i=u} f_i$，即流入该点的流量和等于流出该点的流量和；\n>\n> 定义流 $F$ 的**流量** $|F|$ 为 $\\sum\\limits_{(x_i\\to y_i,w_i)\\in E(G),y_i=T} f_i$，即流到汇点 $T$ 的流量和。\n\n形象地：\n\n>对于一个带权有向图 $G$ 及图上的两个点 $S$（源点）和 $T$（汇点），可以这样看待这张有向图：\n>\n>- 将点看作水池，边看作水管，则有向边 $(x\\to y,w)$ 表示单位时间内最多 $w$ 单位的水可以通过该水管从水池 $x$ 流向水池 $y$；\n>- 源点 $S$ 是水源，单位时间内能提供无限单位的水；\n>- 汇点 $T$ 是排水口，单位时间内能接受无限单位的水；\n>\n>流就是让水从水源流到排水口而不爆水管的方案，流量就是方案中从排水口排走的水量。\n\n### #2 网络最大流\n\n##### 定义 2.1（有源汇最大流）\n\n> 对于一个网络 $(G,S,T)$，定义其上的**最大流** $\\text{MaxFlow}(G,S,T)$ 为**一组满足 $|F|$ 最大的流** $F$。\n>\n> 严格的定义理应是满足 $|F|$ 最大的 $F$ 构成的集合，简便起见就不这样记了。\n\n例如对于这个网络：\n\n![](../post-images/1744607924138.png)\n\n其一组最大流（流量为 $9$）如下：（边权为该边使用的流量）\n\n![](../post-images/1744607927650.png)\n\n#### 2.1 最大流的求解\n\n#### 2.1.1 反向边的引入\n\n考虑贪心，不断找到从 $S$ 到 $T$ 且容量均 $>0$ 的路径（增广路），即通过这条路径可以让至少 $1$ 的流量从 $S$ 流到 $T$，那么将答案增加 $1$，并将路径上边的容量全部减少 $1$。\n\n##### 定义 2.1.1（增广路）\n\n> 定义一条增广路为一条从 $S$ 到 $T$ 路径，满足路径上边的容量均 $>0$。\n\n##### 定义 2.1.2 pre（增广）\n\n> 对于一条增广路 $p$，定义增广操作：\n>\n> - 令 $w(p)=\\min\\limits_{(x_i\\to y_i,w_i)\\in p}\\{w_i\\}$，即 $p$ 中的边的最小容量；\n> - 令 $p$ 中边的容量均减少 $w(p)$；\n> - 令答案（最大流大小）增加 $w(p)$；\n\n那么上述贪心实际上就是不断找增广路进行增广的过程。\n\n但这个贪心是错的，对于一个这样的最大流大小为 $2$ 的网络：\n\n![](../post-images/1744608596062.png)\n\n贪心会求出这样的最大流，大小为 $1$：\n\n![](../post-images/1744608723415.png)\n\n因此参考反悔贪心，引入反悔（退流）思想。\n\n具体的，对于每条边 $(x\\to y,w)$，建立反向边 $(y\\to x,0)$：\n\n![](../post-images/1744609403805.png)\n\n并修改增广的定义：\n\n##### 定义 2.1.2（增广）\n\n> 对于一条增广路 $p$，定义增广操作：\n>\n> - 令 $w(p)=\\min\\limits_{(x_i\\to y_i,w_i)\\in p}\\{w_i\\}$，即 $p$ 中的边的最小容量；\n> - 令 $p$ 中边的容量均减少 $w(p)$，**令 $p$ 中边对应的反向边的容量均增加 $w(p)$**；\n> - 令答案（最大流大小）增加 $w(p)$；\n\n例如对于例子中的网络，进行一轮新的增广后是这样的：\n\n![](../post-images/1744609634644.png)\n\n不难发现现在网络中还存在增广路，还能进行增广操作：\n\n![](../post-images/1744609781523.png)\n\n那么修正后的贪心就成功求出了一组最大流，**最终每条边反向边的容量即为这组最大流中该边使用的流量**。\n\n这其实是一个反悔贪心，增广过程中走反向边相当于退流。\n\n容易证明，不断重复上述操作一定能求出一组最大流。\n\n#### 2.1.2 EK 算法\n\n直接模拟上述过程，可以得出求解网络流的朴素算法。\n\n建完图后，用 bfs 来找增广路，并记录下每个点的前驱节点（令其入队的点）以便找到增广路上的边。如果 bfs 时访问到了汇点，那么就找到了一条增广路。\n\n为了储存反向边，不妨令边的编号从 $2$ 开始，并令编号为 $i$ 的边和编号为 $i\\oplus 1$ 的边互为反向边。这样实现起来会方便很多。\n\n不断跑 bfs 找增广路去进行增广操作直到 $S$ 和 $T$ 不连通，即可求解出网络的一组最大流。该算法被称作 EK 算法，时间复杂度是 $O((n+m)V)$ 的，其中 $V$ 是最大流的大小，即值域。\n\n#### 2.1.3 dinic 算法\n\ndinic 算法是 EK 算法的一种改进，其可以同时增广多条增广路。\n\n其大体流程如下：\n\n- 每次增广前先跑一次 bfs，将节点按照距离 $S$ 的最短路（边数）$dep_u$ 分层，增广时要求增广路相邻点的 $dep_u$ 恰好相差 $1$；\n- 接下来跑 dfs，对所有满足条件的增广路同时进行增广操作；\n- 不断重复上两步直至 bfs 时 $S$ 不能到达 $T$，即不存在增广路；\n\n伪代码如下：\n\n```cpp\nint dfs(int u,int w) // u 表示当前节点的编号，w 表示流向当前点的流量，返回值为成功增广的流量\n{\n    int sum=0;\n\t遍历所有从 u 出发的边 i\n\t{\n\t\tint v=i 到达的节点;\n\t\tif(dep[v]==dep[u]+1)\n\t\t{\n\t\t\tint re=dfs(v,min(w,i 的容量));\n\t\t\tif(re!=0)\n\t\t\t{\n\t\t\t\t更新正向边和反向边的容量;\n                w-=re;\n\t\t\t\tsum+=re;\n\t\t\t}\n\t\t}\n\t}\n\treturn sum;\n}\nint dinic()\n{\n    int res=0;\n    while(bfs 可以到达 汇点) res+=dfs(s,inf);\n    return res;\n}\n```\n\n此外，dinic 算法还有几个优化，分别是**当前弧优化**和**断层优化**：\n\n- 当前弧优化：把已经“榨干”（容量为 $0$）的边删掉；\n- 断层优化：把已经“榨干”的节点“删掉”（`return` 时若 `sum==0` 则令 `dep[u]=0`）；\n\n一般默认会加上这两个优化。\n\ndinic 的最劣复杂度为 $O(n^2m)$，证明考虑每次找到的增广路边数一定最小，故 $dep_T$ 递增；而单次 dfs 中每条增广路都会删掉至少一条边（当前弧优化）故最多有 $m$ 条增广路，而每条增广路长度至多为 $n$。\n\n并且 dinic 在容量均为 $1$ 的网络上的复杂度为 $O(m\\sqrt n)$，具体证明及更多关于复杂度的信息可以看[Dinic的几种复杂度 - myee - 博客园](https://www.cnblogs.com/myee/p/dinic-algorithm.html)。\n\n但由于网络流题目的图一般都有特殊性质，故加上优化后的 dinic 常常十分快速，基本不会被卡，在 OI 中最常用。\n\n求解网络流还有 ISAP 和 HLPP，由于太过复杂且 OI 中不考，故不再介绍。\n\n### #3 最小费用最大流\n\n在最小费用最大流问题中，每条边新增了一个**单位代价 $w_i$**，表示这条边流过 $1$ 流量需要 $w_i$ 的代价，需要求解一组总代价最小的最大流。\n\n也可以使用 dinic 算法解决，每次增广单位代价最小的增广路即可，正确性显然。建边时反向边代价为 $-w_i$，而且 bfs 需要换成 spfa，且增广时要求增广路相邻点的 $dep_u$ 恰好相差它们之间的边的代价。\n\n值得注意的是，由于代价可能为 $0$，所以 dfs 时需要防止重复访问点。\n\n### #4 有向图最小割\n\n##### 定义 4.1（有向图的割）\n\n> 对于一个带权有向图 $G$ 及图上的两个点 $S$ 和 $T$，定义一组 $S$ 到 $T$ 的割 $C$ 如下：\n>\n> - $C\\in E(G)$；\n> - 删掉 $C$ 中的边后 $S$ 不能到达 $T$；\n>\n> 定义割 $C$ 的大小 $|C|$ 为 $\\sum\\limits_{(x_i\\to y_i,w_i)\\in C} w_i$，即割中的边权和。\n\n##### 定义 4.2（有向图的最小割）\n\n> 对于一个带权有向图 $G$ 及图上的两个点 $S$ 和 $T$，定义其最小割 $\\text{MinCut}(G,S,T)$ 为 $|C|$ 最小的一组割 $C$。\n\n##### 定理 4.1（最大流等于最小割）\n\n> 对于一个带权有向图 $G$ 及图上的两个点 $S$ 和 $T$，有：\n> $$\n> |\\text{MaxFlow}(G,S,T)|=|\\text{MinCut}(G,S,T)|\n> $$\n\n证明很简单，首先由于跑完最大流算法后 $S$ 不能到达 $T$，故 $|\\text{MaxFlow}(G,S,T)|\\ge|\\text{MinCut}(G,S,T)|$，又显然 $|\\text{MaxFlow}(G,S,T)|\\le |\\text{MinCut}(G,S,T)|$（最大流中满流的边集构成割），故得证。\n\n更详细的证明可以自行上网寻找。\n\n并且根据一组最大流 $F$，可以简单地构造出最小割：\n\n- 令每条边的剩余容量 $c_i$ 为 $w_i-f_i$；\n- 从 $S$ 出发，只经过 $c_i>0$ 的边，求出能到达的点集 $A$；\n- 一组最小割 $C$ 即为 $\\{(x\\to y,w)\\in E(G)|x\\in A,y\\in (V(G)-A)\\}$，即一端在 $A$ 中的边的集合；\n\n### #5 有上下界网络流\n\n#### 5.1 有上下界循环可行流\n\n> $n$ 个点，$m$ 条有向边，每条边有一个流量下界 $l_i$ 和流量上界 $r_i$，求该图的一个循环可行流，即你需要构造 $m$ 个变量 $f_i$ 满足：\n>\n> - 流量合法：$\\forall i,l_i\\le f_i\\le r_i$；\n> - 流量平衡：对于每个点 $i$，设 $I_i$ 为 $i$ 的入边集合，$U_i$ 为 $i$ 的出边集合，那么有：$\\sum\\limits_{j\\in I_i} f_j=\\sum\\limits_{j\\in U_i}f_j$；\n\n考虑每条边先钦定流过 $l_i$ 的流量，转化为每条边只有流量上界 $r_i-l_i$，那么流量有可能不平衡。\n\n考虑用点与源点 $S$ 或汇点 $T$ 的连边刻画每个点的额外流量。记 $b_i=\\sum\\limits_{j\\in I_i} l_j-\\sum\\limits_{j\\in U_i}l_j$，即每个点进入的流量减出去的流量，那么：\n\n- 若 $b_i<0$，连接边 $(i\\to T,-b_i)$；\n- 若 $b_i>0$，连接边 $(S\\to i,b_i)$；\n\n原先的边 $i$ 直接连 $(x_i\\to y_i,r_i-l_i)$。\n\n跑最大流，若所有 $(i\\to T,-b_i)$ 和 $(S\\to i,b_i)$ 均满流，则有解，否则无解。设跑完后第 $i$ 条边的流量为 $c_i$，则第 $i$ 条边的流量为 $l_i+c_i$。\n\n时间复杂度和最大流相同。\n\n#### 5.2 有上下界有源汇最大流\n\n考虑将其转化为循环流来消去上下界，设源点为 $s$，汇点为 $t$，则不难发现相当于从 $s$ 出发的流量等于到达 $t$ 的流量，连边 $(t\\to s,[0,\\infin])$。\n\n跑出循环流后，记 $res$ 为 $(t\\to s,[0,\\infin])$ 的。接下来把 $(t\\to s,[0,\\infin])$ 去掉，设第 $i$ 条边在循环流中流过了 $c_i$ 流量，则连接边 $(x_i\\to y_i)$ 时：\n\n- 正向边流量为 $r_i-c_i$；\n- 反向边流量为 $c_i-l_i$；\n\n则答案即为 $res$ 加上当前图从 $s$ 到 $t$ 的最大流。\n\n#### 5.3 有上下界有源汇最小流\n\n最大流是尽可能从 $s$ 流到 $t$，那么最小流就是尽可能从 $t$ 退回 $s$。\n\n跑出 $t$ 到 $s$ 的最大流 $rf$，答案即为 $res-rf$。\n\n### #6 常见模型&技巧\n\n[网络流的常见建模](../post/wang-luo-liu-de-chang-jian-jian-mo)\n",
			"tags": [{"name":"学习笔记"},{"name":"图论"},{"name":"网络流"}],
			"title": "网络流学习笔记",
			"link": "https://exber.qzz.io/post/%E7%BD%91%E7%BB%9C%E6%B5%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-03-21 15:27:18"
		},
	
		{
			"abstract": "",
			"content": "后缀数组又名 SA，它是一种十分实用的字符串处理工具，在很多地方能替代后缀自动机。\n\n后缀数组的作用是**在 $O(n\\log n)$ 时间复杂度内求出一个字符串 $S$ 的所有后缀的排名**。\n\n为了下文表述方便，我们先规定几个记号：\n\n**记 $b_i$ 为字符串 $S$ 从 $i$ 开始的后缀，$str[l,r]$ 表示 $str$ 的第 $l$ 到第 $r$ 这段区间里的字符组成的字符串，$sa_i$ 为排名为 $i$ 的后缀的起始位置，$rk_i$ 为 $b_i$ 的排名。很明显，$sa$ 和 $rk$ 互为逆操作。**\n\n我们可以先考虑一个弱智问题：\n\n> 对所有后缀的第一个字符排序。\n\n很明显，这个东西**可以用桶排序来解决，但是注意会有并列的情况**。\n\n对于并列的情况，为了方便以后的处理，我们**令 $rk$ 相同但 $sa$ 不相同**。\n\n代码如下：\n\n```cpp\nstruct node\n{\n\tint x,pos;\n}tmp[1000005],tmp2[1000005];\n\nint n;\nchar s[1000005];\nint sa[1000005],rk[1000005];\nint tot[1000005];\n\ninline void fastsort(int w) // w 为值域 \n{\n\tfor(int i=0;i<=w;i++) tot[i]=0;\n\t// 桶排序，tot[i] 表示权值 <= i 的元素个数 \n\tfor(int i=1;i<=n;i++) tot[tmp[i].x]++;\n\tfor(int i=1;i<=w;i++) tot[i]+=tot[i-1];\n\t// 获得排序后的数组，并复制到 tmp\n\t// 对于下面这个 for 的解释：\n\t// 由于 x 可能相同，所以权值为 tmp[i].x 的点可能有多个\n\t// 那么它们的排名区间是 [  tot[tmp[i].x-1]+1 , tot[tmp[i].x]  ] \n\t// 由于排序最好是稳定的（即相同元素不改变相对位置），所以我们要从后往前跑循环，即从后往前插入到排名区间里 \n\tfor(int i=n;i>=1;i--) tmp2[tot[tmp[i].x]--]=tmp[i];\n\tfor(int i=1;i<=n;i++) tmp[i]=tmp2[i]; // 复制 \n}\n\ninline void sasort() // 弱智问题的解法 \n{\n\tfor(int i=1;i<=n;i++) tmp[i]=(node){(int)s[i],i}; // 注意要记录位置 \n\tfastsort(256);\n\tfor(int i=1;i<=n;i++) sa[i]=tmp[i].pos; // 不考虑并列的话排名为 i 的后缀就是 b[tmp[i].pos]\n\tfor(int i=1;i<=n;i++) rk[tmp[i].pos]=rk[tmp[i-1].pos]+(tmp[i].x!=tmp[i-1].x); // 注意只有元素不一样排名才增加 \n}\n```\n\n解决完这个弱智问题后，我们来看一个进阶版的问题：\n\n> 对所有后缀的前两个字符排序，即对所有关键字 $<S_i,S_{i+1}>$ 排序。\n\n这个问题使用桶排序有点难解决，但还是可做的。\n\n首先对第二关键字排序，**求出 $tp_i$ 表示在第二关键字中排名为 $i$ 的元素的位置，并列则按位置排序**。\n\n然后求出第一关键字 $\\le x$ 的元素个数 $tot_x$。\n\n通过弱智问题代码注释中的结论，我们知道第一关键字为 $x$ 的排名区间为：\n\n$$[tot_{x-1}+1,tot_x]$$\n\n又因为第二关键字中排名为 $i$ 的元素的位置为 $tp_i$，所以我们可以**从后往前遍历 $tp$ 数组，把 $tp_i$ 从后往前依次加进元素 $i$ 对应的排名区间内，这样不但保证排序正确，还能保证这个排序是稳定的**。\n\n代码如下：\n\n```cpp\nstruct node\n{\n\tint x,y,pos;\n}tmp[1000005],tmp2[1000005];\n\nint n;\nchar s[1000005];\nint sa[1000005],rk[1000005];\nint tp[1000005],tot[1000005];\n\ninline void fastsort(int w)\n{ \n\tfor(int i=0;i<=w;i++) tot[i]=0;\n\t// 对第二关键字排序，求出 tp[i] 表示第二关键字中排名第 i 的关键字的位置（相当于第二关键字的 sa） \n\tfor(int i=1;i<=n;i++) tot[tmp[i].y]++;\n\tfor(int i=1;i<=w;i++) tot[i]+=tot[i-1];\n\tfor(int i=n;i>=1;i--) tp[tot[tmp[i].y]--]=i;\n\tfor(int i=0;i<=w;i++) tot[i]=0;\n\t// 对第一关键字排序 \n\tfor(int i=1;i<=n;i++) tot[tmp[i].x]++;\n\tfor(int i=1;i<=w;i++) tot[i]+=tot[i-1];\n\t// 结合起来 \n\tfor(int i=n;i>=1;i--) tmp2[tot[tmp[tp[i]].x]--]=tmp[tp[i]];\n\tfor(int i=1;i<=n;i++) tmp[i]=tmp2[i];\n}\n\ninline void sasort() // 进阶问题的解法\n{\n\tfor(int i=1;i<=n-1;i++) tmp[i]=(node){(int)s[i],(int)s[i+1],i}; // 只有 n-1 个元素有两个关键字 \n\ttmp[n]=(node){(int)s[n],0,i}; // 没有第二关键字，那么令它为 0 \n\tfastsort(256);\n\tfor(int i=1;i<=n;i++) sa[i]=tmp[i].pos;\n\tfor(int i=1;i<=n;i++) rk[tmp[i].pos]=rk[tmp[i-1].pos]+(tmp[i].x!=tmp[i-1].x||tmp[i].y!=tmp[i-1].y);\n}\n```\n\n我们再来考虑一个问题：\n\n> 对所有后缀的前四个字符排序，即对所有关键字 $<S_i,S_{i+1},S_{i+2},S_{i+3}>$ 排序。\n\n对于这个问题，我们并不需要重新写一个排序，因为那样太麻烦了。我们**只需要先对 $<S_i,S_{i+1}>$ 排序，再对 $<rk_i,rk_{i+2}>$ 排序即可。因为和 $b_i[3,4]$ 最相似的长度为 $2$ 的前缀是 $b_{i+2}[1,2]$，我们就可以把 $b_i[1,2]$ 和 $b_{i+2}[3,4]$ 拼接起来排序。**\n\n所以，我们**可以使用倍增来排序所有后缀**！\n\n[模板题](https://www.luogu.com.cn/problem/P3809)代码如下：\n\n```cpp\n// P3809\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nstruct node\n{\n\tint x,y,pos;\n}tmp[1000005],tmp2[1000005];\n\nint n;\nchar s[1000005];\nint sa[1000005],rk[1000005];\nint tp[1000005],tot[1000005];\n\ninline void fastsort(int w)\n{\n\tfor(int i=0;i<=w;i++) tot[i]=0;\n\t// 对第二关键字排序，求出 tp[i] 表示第二关键字中排名第 i 的关键字的位置（相当于第二关键字的 sa） \n\tfor(int i=1;i<=n;i++) tot[tmp[i].y]++;\n\tfor(int i=1;i<=w;i++) tot[i]+=tot[i-1];\n\tfor(int i=n;i>=1;i--) tp[tot[tmp[i].y]--]=i;\n\tfor(int i=0;i<=w;i++) tot[i]=0;\n\t// 对第一关键字排序 \n\tfor(int i=1;i<=n;i++) tot[tmp[i].x]++;\n\tfor(int i=1;i<=w;i++) tot[i]+=tot[i-1];\n\t// 结合起来 \n\tfor(int i=n;i>=1;i--) tmp2[tot[tmp[tp[i]].x]--]=tmp[tp[i]];\n\tfor(int i=1;i<=n;i++) tmp[i]=tmp2[i];\n}\n\ninline void sasort()\n{\n\t// 对第一个字符排序 \n\tfor(int i=1;i<=n;i++) tmp[i]=(node){(int)s[i],0,i};\n\tfastsort(256);\n\tfor(int i=1;i<=n;i++) sa[i]=tmp[i].pos;\n\tfor(int i=1;i<=n;i++) rk[tmp[i].pos]=rk[tmp[i-1].pos]+(tmp[i].x!=tmp[i-1].x||tmp[i].y!=tmp[i-1].y);\n\t// 倍增 \n\tfor(int p=1;p<=n;p<<=1)\n\t{\n\t\tfor(int i=1;i<=n-p;i++) tmp[i]=(node){rk[i],rk[i+p],i};\n\t\t// b[i] 已经根据前 p 个字符排过序了 \n\t\t// 所以和 b[i] 的第 p+1 ~ p+p 个字符最相似的是 b[rk[i+p]] 的前 p 个字符 \n\t\tfor(int i=n-p+1;i<=n;i++) tmp[i]=(node){rk[i],0,i}; // 没有第二关键字，那么设为 0 \n\t\tfastsort(rk[sa[n]]); // 排序，注意值域是 rk[sa[n]] 即最大的 rk 值 \n\t\tfor(int i=1;i<=n;i++) sa[i]=tmp[i].pos;\n\t\tfor(int i=1;i<=n;i++) rk[tmp[i].pos]=rk[tmp[i-1].pos]+(tmp[i].x!=tmp[i-1].x||tmp[i].y!=tmp[i-1].y);\n\t\tif(rk[sa[n]]>=n) break;\n\t}\n}\n\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tsasort();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tprintf(\"%d \",sa[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n```\n\n接下来我们考虑一个很经典的问题：（[P2408 不同子串个数](https://www.luogu.com.cn/problem/P2408)）\n\n> 求出某个字符串的不同子串个数。\n\n我们**记 $b_{sa_i}$ 和 $b_{sa_i-1}$ 的最长公共前缀长度为 $height_i$，$b_{i}$ 和 $b_{sa_{rk_i-1}}$ 的最长公共前缀长度为 $h_i$。很明显 $h_i=height_{rk_i}$**。\n\n那么很显然可以用暴力，**不断让 $h_i$ 增加直到 $h_i$ 大于两个后缀长度中最小的那个或者两个后缀的第 $h_i+1$ 个字符不同**。\n\n但是有个很巧妙的柿子：\n\n$$h_i\\ge h_{i-1}-1$$\n\n证明如下:（转载自[这里](https://www.jianshu.com/p/3a87254a5b80)）\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ldf34bwk.png)\n\n最后 **$b_i$ 对答案的贡献即为 $(n-i+1)-h_i$**。\n\n题目代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nstruct node\n{\n\tint x,y,pos;\n}tmp[100005],tmp2[100005];\n\nint n;\nchar s[100005];\nint tot[100005],tp[100005];\nint sa[100005],rk[100005];\nint h[100005];\n\ninline void fastsort(int w)\n{\n\tfor(int i=0;i<=w;i++) tot[i]=0;\n\tfor(int i=1;i<=n;i++) tot[tmp[i].y]++;\n\tfor(int i=1;i<=w;i++) tot[i]+=tot[i-1];\n\tfor(int i=n;i>=1;i--) tp[tot[tmp[i].y]--]=i;\n\tfor(int i=0;i<=w;i++) tot[i]=0;\n\tfor(int i=1;i<=n;i++) tot[tmp[i].x]++;\n\tfor(int i=1;i<=w;i++) tot[i]+=tot[i-1];\n\tfor(int i=n;i>=1;i--) tmp2[tot[tmp[tp[i]].x]--]=tmp[tp[i]];\n\tfor(int i=1;i<=n;i++) tmp[i]=tmp2[i];\n}\n\ninline void sasort()\n{\n\tfor(int i=1;i<=n;i++) tmp[i]=(node){(int)s[i],0,i};\n\tfastsort(256);\n\tfor(int i=1;i<=n;i++) sa[i]=tmp[i].pos;\n\tfor(int i=1;i<=n;i++) rk[tmp[i].pos]=rk[tmp[i-1].pos]+(tmp[i].x!=tmp[i-1].x||tmp[i].y!=tmp[i-1].y);\n\tfor(int p=1;p<=n;p<<=1)\n\t{\n\t\tfor(int i=1;i<=n-p;i++) tmp[i]=(node){rk[i],rk[i+p],i};\n\t\tfor(int i=n-p+1;i<=n;i++) tmp[i]=(node){rk[i],0,i};\n\t\tfastsort(n);\n\t\tfor(int i=1;i<=n;i++) sa[i]=tmp[i].pos;\n\t\tfor(int i=1;i<=n;i++) rk[tmp[i].pos]=rk[tmp[i-1].pos]+(tmp[i].x!=tmp[i-1].x||tmp[i].y!=tmp[i-1].y);\n\t\tif(rk[sa[n]]>=n) break;\n\t}\n}\n\ninline void geth()\n{\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint k=max(h[i-1]-1,0);\n\t\tint pos=sa[rk[i]-1];\n\t\twhile(i+k<=n&&pos+k<=n&&s[i+k]==s[pos+k])\n\t\t{\n\t\t\tk++;\n\t\t}\n\t\th[i]=k;\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",s+1);\n\tsasort();\n\tgeth();\n\tlong long ans=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tans+=(n-i+1)-h[i];\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n```\n\n### 练习题目\n\n[P3763 [TJOI2017]DNA](https://www.luogu.com.cn/problem/P3763)\n\n[P2463 [SDOI2008] Sandy 的卡片](https://www.luogu.com.cn/problem/P2463)\n\n[P2852 [USACO06DEC]Milk Patterns G](https://www.luogu.com.cn/problem/P2852)\n\n[P3181 [HAOI2016]找相同字符](https://www.luogu.com.cn/problem/P3181)\n",
			"tags": [{"name":"学习笔记"},{"name":"数据结构"},{"name":"字符串"}],
			"title": "后缀数组学习笔记",
			"link": "https://exber.qzz.io/post/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-03-21 15:26:26"
		},
	
		{
			"abstract": "",
			"content": "### 算法介绍\n\nManacher 是一个求解字符串的回文子串的算法。\n\n考虑这样的一道[例题](https://www.luogu.com.cn/problem/P3805)：\n\n\n> 给定字符串 $S$，询问所有子串中的最长回文子串长度。例如\n> `ebaabaf` 最长的回文子串是 `baab`。\n> \n> $1\\le|S|\\le 1.1\\times 10^7$。\n\n很明显能使用中心点和往一端拓展的长度来确定一个回文子串，但由于回文串分为奇回文串和偶回文串，而奇回文串的中心是字符，偶回文串的中心确是字符的间隔处，所以可以**在两个字符中间加入 `#`，来使得所有回文子串都变为奇回文串**。\n\n例如字符串 `dbaabab` 就变成了 `#d#b#a#a#b#a#b#`； \n\n原串中的回文子串 `aba` 对应转化串中的 `#a#b#a#`；\n\n原串中的回文子串 `baab` 对应转化串中的 `#b#a#a#b#`。\n\n这样一来，奇/偶回文子串的中心都在字符上。只不过，奇回文子串的中心在转化串里是原串的字符；而偶回文子串的中心在转化串里是 `#` 间隔符。\n\n但是这样一来，同一个回文子串我们就会计算两遍，因为 `a#b#a` 和 `#a#b#a#` 都对应原串中的 `aba`。所以如果一个字符作为中心在转化串中最多能扩展 $L$ 位，那么在原串中它最多**只能拓展 $\\lfloor \\dfrac{L}{2}\\rfloor$ 位**。\n\n预处理完转换串后，我们就可以开始求解答案了。**设 $ext_i$ 表示从第 $i$ 位开始拓展，最多可以拓展的位数。即满足 $S_{i-ext_i}\\ne S_{i+ext_i}$ 的最小的值**。（注意是在转换串上）\n\n首先考虑暴力求解。可以枚举每一个 $i$，然后往两边暴力拓展，直到遇到不同的字符。\n\n但我们考虑以下这种情况：\n\n> 求以 `xyzdabaaabaefeaba[a]abadxyz` 中被框起来的字符 `a` 为回文中\n> 心的最长回文子串。\n\n假如我们知道\n\n`xyz [dabaaabaefeabaaabad] xyz`\n\n和\n\n`xyz d[abaaaba]efeabaaabad xyz`\n\n被框起来的部分都是回文子串，那么我们就可以得出需要求解的回文子串**至少包含下面被框起来的部分**：\n\n`xyz dabaaabaefe[abaaaba]d xyz`\n\n这条特质是由回文串的对称性引出的，也就是说**被大回文串包含的小回文串可以以大回文串中心“对过去”。**\n\n所以转移过程中，我们需要记录下对于当前的 $i$，以 $pos$ 为中心的回文子串中，右端点最靠右的那个 $pos$，即**找到 $pos+ext_{pos}$ 最大的 $pos$。（$1\\le pos\\le i-1$）**\n\n![](../post-images/1679383538113.png)\n\n- 如果 $pos+ext_{pos}> i$，那么 $i$ 在 $pos$ 为中心的最长回文子串内，直接让 $ext_i=\\min(ext_{pos}+pos-i,ext_{pos*2-i})$ 然后暴力拓展即可。\n\n- 否则直接暴力拓展\n\n最后更新一下 $pos$ 即可。\n\n然后还有一个很重要的细节，为了防止算法跑出去，所以要**在转化串开头和结尾分别加上 `@` 和 `&` 两个哨兵**。\n\n模板代码：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nint n;\nchar s[30000005];\nint ext[30000005];\n\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\t// 预处理转化串 \n\tfor(int i=n;i>=1;i--) s[i*2]=s[i];\n\tn=n*2+1;\n\tfor(int i=1;i<=n;i+=2) s[i]='#';\n\t// 加入哨兵 \n\ts[0]='@',s[n+1]='&';\n\tint ans=0;\n\tfor(int i=1,pos=0;i<=n;i++)\n\t{\n\t\tif(pos+ext[pos]>i) ext[i]=min(pos+ext[pos]-i,ext[pos*2-i]); // 运用特质拓展 \n\t\twhile(s[i+ext[i]]==s[i-ext[i]]) ext[i]++; // 暴力拓展 \n\t\tif(i+ext[i]>pos+ext[pos]) pos=i; // 更新 pos \n\t\tans=max(ans,ext[i]-1);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n\n### 时空复杂度分析\n\n- **空间复杂度**\n\n  显然是 $O(n)$ 的，但是注意要开两倍空间。\n\n- **时间复杂度**\n\n  考虑 $r=pos+ext_{pos}$ 在算法过程中的变化，分为两种情况：\n\n  - 当前的 $i$ 运用特质拓展了：\n\n    此时要么 $i$ 不会再暴力拓展，要么是这种情况：\n\n    ![](../post-images/1679383524277.png)\n\n    这样每暴力拓展一次 $r$ 就一定会往右移一位。\n\n  - 当前的 $i$ 未运用性质拓展，那么每暴力拓展一次 $r$ 就一定会往右移一位。\n\n  最后我们得到了一个结论：**每次暴力拓展都会令 $r$ 右移一位**，那么暴力拓展的次数上限是 $n$，算法时间复杂度自然为 $O(n)$。\n\n  注意到每次暴力拓展都有可能是找到了一个新的回文子串，所以**一个字符串 $S$ 的本质不同回文子串个数最多是 $n$**。\n\n### 一些性质\n\n- 一个字符串 $S$ 的本质不同回文子串个数最多是 $n$；\n\n- 最长回文子串为 $\\max\\{ext_i-1\\}$；\n- 回文子串个数即为 $\\sum\\lfloor \\dfrac{ext_i}{2}\\rfloor$；\n\n### 练习题目\n\n[P1659 [国家集训队]拉拉队排练](https://www.luogu.com.cn/problem/P1659)\n\n[P4555 [国家集训队]最长双回文串](https://www.luogu.com.cn/problem/P4555)\n\n[P6216 回文匹配](https://www.luogu.com.cn/problem/P6216)\n\n[P5446 [THUPC2018]绿绿和串串](https://www.luogu.com.cn/problem/P5446)\n\n[P3501 [POI2010]ANT-Antisymmetry](https://www.luogu.com.cn/problem/P3501)\n\n[P4287 [SHOI2011]双倍回文](https://www.luogu.com.cn/problem/P4287)\n",
			"tags": [{"name":"学习笔记"},{"name":"数据结构"},{"name":"字符串"}],
			"title": "Manacher 算法学习笔记",
			"link": "https://exber.qzz.io/post/Manacher%20%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-03-21 15:24:31"
		},
	
		{
			"abstract": "",
			"content": "EXCRT 其实和 CRT 半毛钱关系都没有……\n\n我们在 CRT 中需要用到求逆元的操作：\n\n$$\\operatorname{inv}(\\dfrac{M}{b_i},b_i)$$\n\n但是如果 $b_i$ 不满足两两互质，我们就无法求出逆元，这样 CRT 就用不了了。\n\n为了解决这个问题，求出 $b_i$ 不一定两两互质时同余方程组\n\n$$\\begin{cases}x\\equiv a_1\\pmod{b_1}\\\\x\\equiv a_2\\pmod{b_2}\\\\x\\equiv a_3\\pmod{b_3}\\\\\\qquad\\dots\\dots\\\\x\\equiv a_n\\pmod{b_n}\\end{cases}$$\n\n的解，EXCRT 就诞生了。\n\n****\n\n首先考虑两个方程的情况：\n\n$$\\begin{cases}x\\equiv a_1\\pmod{b_1}\\\\x\\equiv a_2\\pmod{b_2}\\end{cases}$$\n\n可以转化为这样：\n\n$$\\begin{cases}x=a_1+k_1\\cdot b_1\\\\x=a_2+k_2\\cdot b_2\\end{cases}$$\n\n即：\n\n$$a_1+k_1\\cdot b_1=a_2+k_2\\cdot b_2$$\n\n移项：\n\n$$k_1\\cdot b_1-k_2\\cdot b_2=a_2-a_1$$\n\n这个柿子很明显能使用 exgcd 求解。\n\n很明显，若 $a_2-a_1\\mod{\\gcd(b_1,b_2)} \\ne 0$ 那么无解。\n\n设 $y_1,y_2$ 满足 $y_1\\cdot b_1+y_2\\cdot b_2=\\gcd(b_1,b_2)$，则 $k_1=y1\\cdot \\dfrac{a_2-a_1}{\\gcd(b_1,b_2)},k_2=-y_2\\cdot \\dfrac{a_2-a_1}{\\gcd(b_1,b_2)}$。\n\n所以我们可以求出这个方程组的**一个解**为 $x=a_1+y1\\cdot \\dfrac{a_2-a_1}{\\gcd(b_1,b_2)}\\cdot b_1$。\n\n很明显最小正整数解就是 $x_{min}=x\\mod{\\operatorname{lcm}(b_1,b_2)}$，但由于 $x$ 有可能是负数，所以**取模时需要特殊处理**。\n\n接下来 EXCRT 的核心思想来了：\n\n我们可以**把 $x=a_1+y1\\cdot \\dfrac{a_2-a_1}{\\gcd(b_1,b_2)}\\cdot b_1\\mod{\\operatorname{lcm}(b_1,b_2)}$ 改写成同余方程**，即：\n\n$x\\equiv a_1+y1\\cdot \\dfrac{a_2-a_1}{\\gcd(b_1,b_2)}\\cdot b_1\\mod{\\operatorname{lcm}(b_1,b_2)}\\pmod{\\operatorname{lcm}(b_1,b_2)}$\n\n这时，我们就**成功把两个同余方程合并为了一个**！\n\n所以只要一直合并下去，就能得到最终的解了。\n\n[模板题](https://www.luogu.com.cn/problem/P4777)代码：（需要高精所以开了 `__int128`）\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nint n;\n__int128 a[100005],b[100005];\n\ninline __int128 read()\n{\n\t__int128 s=0;\n\tint w=1,ch=getchar();\n\twhile(ch<'0'||ch>'9') ch=='-'?w=-1,ch=getchar():ch=getchar();\n\twhile(ch>='0'&&ch<='9') s=(s<<1)+(s<<3)+(ch^48),ch=getchar();\n\treturn s;\n}\n\nvoid writen(__int128 x)\n{\n\tif(x<0) putchar('-'),writen(-x);\n\tx>9?writen(x/10),putchar(x%10|48):putchar(x|48);\n}\n\ninline __int128 lcm(__int128 a,__int128 b)\n{\n\t__int128 tmpa=a,tmpb=b;\n\t__int128 t=a%b;\n\twhile(t!=0)\n\t{\n\t\ta=b;\n\t\tb=t;\n\t\tt=a%b;\n\t}\n\treturn tmpa*tmpb/b;\n}\n\n__int128 exgcd(__int128 a,__int128 b,__int128 &x,__int128 &y)\n{\n\tif(a<b)\n\t{\n\t\treturn exgcd(b,a,y,x);\n\t}\n\tif(b==0)\n\t{\n\t\tx=1;\n\t\ty=0;\n\t\treturn a;\n\t}\n\t__int128 tmpx,tmpy;\n\t__int128 res=exgcd(b,a%b,tmpx,tmpy);\n\tx=tmpy;\n\ty=tmpx-a/b*tmpy;\n\treturn res;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tb[i]=read();\n\t\ta[i]=read();\n\t}\n\ta[1]=(a[1]%b[1]+b[1])%b[1];\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\t__int128 rig=a[i]-a[i-1];\n\t\t__int128 y1,y2;\n\t\t__int128 g=exgcd(b[i-1],b[i],y1,y2);\n\t\tif(rig%g!=0)\n\t\t{\n\t\t\tputs(\"Impossible!\");\n\t\t\tbreak;\n\t\t}\n\t\ty1*=rig/g;\n\t\ta[i]=a[i-1]+b[i-1]*y1;\n\t\tb[i]=lcm(b[i-1],b[i]);\n\t\ta[i]=(a[i]%b[i]+b[i])%b[i];\n\t}\n\twriten(a[n]);\n\tputchar('\\n');\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"学习笔记"},{"name":"数学"},{"name":"数论"}],
			"title": "扩展中国剩余定理(EXCRT)学习笔记",
			"link": "https://exber.qzz.io/post/%E6%89%A9%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86%28EXCRT%29%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-03-21 15:21:14"
		},
	
		{
			"abstract": "",
			"content": "中国剩余定理(CRT)是用来求这样的一个不定方程组的解的：\n\n$$\\begin{cases}x\\equiv a_1\\pmod{b_1}\\\\x\\equiv a_2\\pmod{b_2}\\\\x\\equiv a_3\\pmod{b_3}\\\\\\qquad\\dots\\dots\\\\x\\equiv a_n\\pmod{b_n}\\end{cases}$$\n\n**其中 $b_i$ 两两互质**。\n\n****\n\n我们可以先考虑一个简单点的问题：\n\n$$\\begin{cases}x\\equiv 2\\pmod{3}\\\\x\\equiv 3\\pmod{5}\\\\x\\equiv 2\\pmod{7}\\end{cases}$$\n\n我们可以：\n\n- 令 $y_1$ 除以 $3$ 余 $2$，除以 $5$ 余 $0$，除以 $7$ 余 $0$\n\n- 令 $y_2$ 除以 $3$ 余 $0$，除以 $5$ 余 $3$，除以 $7$ 余 $0$\n\n- 令 $y_3$ 除以 $3$ 余 $0$，除以 $5$ 余 $0$，除以 $7$ 余 $2$\n\n那么**这个方程组的一个解就是 $x=y_1+y_2+y_3$**。\n\n继续对 $y_1$ 分解（其实对 $y_2$ 和 $y_3$ 也同理），**令 $z$ 除以 $3$ 余 $1$，除以 $5$ 余 $0$，除以 $7$ 余 $0$**，那么显然有 $y_1=z*2$。\n\n令 $M=\\prod\\limits_{i=1}^nb_i=105$，那么 $z$ 肯定能被 $\\dfrac{M}{b_1}=\\dfrac{105}{3}=35$ 整除，不妨令 $z=35k$。那么 $35k\\equiv 1\\pmod{b_1}$ 即 $35k\\equiv 1\\pmod{3}$。很明显，**$k$ 就是 $35$ 在模 $3$ 意义下的逆元**。\n\n所以 $y_1=a_1\\cdot\\dfrac{M}{b_1}\\cdot\\operatorname{inv}(\\dfrac{M}{b_1},b_1)$ 即 $y_1=2*35*2=140$。\n\n归纳一下，$y_i=a_i\\cdot\\dfrac{M}{b_i}\\cdot\\operatorname{inv}(\\dfrac{M}{b_i},b_i)$，那么 $x=\\sum\\limits_{i=1}^n a_i\\cdot\\dfrac{M}{b_i}\\cdot\\operatorname{inv}(\\dfrac{M}{b_i},b_i)$。\n\n但由于这时候求出的 $x$ 只是任意解，最小解 $x_{min}$ 即为 $x\\mod{\\operatorname{lcm}(b_1,b_2,b_3,\\dots,b_n)}$。\n\n****\n\n所以方程组\n\n\n$$\\begin{cases}x\\equiv a_1\\pmod{b_1}\\\\x\\equiv a_2\\pmod{b_2}\\\\x\\equiv a_3\\pmod{b_3}\\\\\\qquad\\dots\\dots\\\\x\\equiv a_n\\pmod{b_n}\\end{cases}$$\n\n的最小解为：\n\n$$x_{min}=\\sum\\limits_{i=1}^n a_i\\cdot\\dfrac{M}{b_i}\\cdot\\operatorname{inv}(\\dfrac{M}{b_i},b_i)\\mod{\\operatorname{lcm}(b_1,b_2,b_3,\\dots,b_n)}$$\n\n其中 $M=\\prod\\limits_{i=1}^nb_i$。\n\n可以发现 $\\dfrac{M}{b_i}$ 其实能用前缀和维护。\n\n[模板题](https://www.luogu.com.cn/problem/P1495)代码：\n\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nint n;\nlong long a[15],b[15];\nlong long sum[2][15];\n\nlong long exgcd(long long a,long long b,long long &x,long long &y)\n{\n\tif(a<b)\n\t{\n\t\treturn exgcd(b,a,y,x);\n\t}\n\tif(b==0)\n\t{\n\t\tx=1;\n\t\ty=0;\n\t\treturn a;\n\t}\n\tlong long tmpx,tmpy;\n\tlong long res=exgcd(b,a%b,tmpx,tmpy);\n\tx=tmpy;\n\ty=tmpx-a/b*tmpy;\n\treturn res;\n}\n\ninline long long inv(long long a,long long p) // 扩欧求逆元 \n{\n\tlong long x,y;\n\tif(exgcd(a,p,x,y)!=1)\n\t{\n\t\treturn -1;\n\t}\n\treturn (x%p+p)%p;\n}\n\ninline long long lcm(long long a,long long b)\n{\n\tlong long tmpa=a,tmpb=b;\n\tlong long t=a%b;\n\twhile(t!=0)\n\t{\n\t\ta=b;\n\t\tb=t;\n\t\tt=a%b;\n\t}\n\treturn tmpa*tmpb/b;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tlong long llcm=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld%lld\",&b[i],&a[i]);\n\t\tllcm=lcm(llcm,b[i]);\n\t}\n\t// 前缀和维护 M/b_i \n\tsum[0][0]=sum[1][n+1]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tsum[0][i]=sum[0][i-1]*b[i];\n\t}\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tsum[1][i]=sum[1][i+1]*b[i];\n\t}\n\tlong long ans=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tans+=a[i]*sum[0][i-1]*sum[1][i+1]*inv(sum[0][i-1]*sum[1][i+1],b[i]);\n\t}\n\tprintf(\"%lld\\n\",ans%llcm); // 求最小解 \n\treturn 0;\n}\n```\n",
			"tags": [{"name":"学习笔记"},{"name":"数学"},{"name":"数论"}],
			"title": "中国剩余定理(CRT)学习笔记",
			"link": "https://exber.qzz.io/post/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86%28CRT%29%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-03-21 15:19:53"
		},
	
		{
			"abstract": "",
			"content": "### 前置芝士\n\nexgcd 就是用来求解 $ax+by=\\gcd(a,b)$ 这个方程的最小整数解的（$a,b \\in \\mathbb{N^*}$）。\n\n拿到这个柿子，第一步当然是推导、化简啦。\n\n### 推导过程\n\n首先为了方便推导，令 $a\\ge b$；\n\n很明显，若 $b=0$，则 $\\gcd(a,b)=a,x=1,y=0$；\n\n对于 $b\\ne 0$ 的情况：\n\n设 $x=x^\\prime,y=y^\\prime$ 为 $bx+(a\\%b)y=\\gcd(b,a\\%b)$ 的最小整数解；\n\n$$\\because \\gcd(a,b)=\\gcd(b,a\\%b)$$\n\n$$\\therefore ax+by=bx^\\prime+(a\\%b)y^\\prime$$\n\n$$\\because a\\ge b$$\n\n$$\\therefore a\\%b=a-b\\lfloor\\dfrac{a}{b}\\rfloor$$\n\n$$\\therefore ax+by=bx^\\prime+(a-b\\lfloor\\dfrac{a}{b}\\rfloor)y^\\prime$$\n\n$$\\qquad \\qquad \\,\\,\\,= bx^\\prime+ay^\\prime-b\\lfloor\\dfrac{a}{b}\\rfloor y^\\prime$$\n\n$$\\qquad \\qquad \\,\\,\\,= ay^\\prime+b(x^\\prime-\\lfloor\\dfrac{a}{b}\\rfloor y^\\prime)$$\n\n而我们想要令 $x,y$ 最小，所以 $x=y^\\prime,y=x^\\prime-\\lfloor\\dfrac{a}{b}\\rfloor y^\\prime$。\n\n### 模板代码\n\n```cpp\nint exgcd(int a,int b,int &x,int &y) // x 和 y 是引用，因为我懒得写结构体…… \n{\n\tif(a<b) // 如果 a < b 那么交换 a 和 b 来求 \n\t{\n\t\treturn exgcd(b,a,y,x);\n\t}\n\tif(b==0) // 如果 b 为 0，那么 gcd(a,b) = a，x = 1，y = 0 \n\t{\n\t\tx=1;\n\t\ty=0;\n\t\treturn a;\n\t}\n\t// 其它情况 \n\tint tmpx,tmpy;\n\tint res=exgcd(b,a%b,tmpx,tmpy);\n\tx=tmpy;\n\ty=tmpx-a/b*tmpy;\n\treturn res;\n}\n```\n\n### 应用（求乘法逆元）\n\n$exgcd$ 可以干很多事情，甚至还有 $exexgcd$……（扩展扩展欧几里得函数）\n\n所以理解好它很重要 awa\n\n$exgcd$ 的一个比较常见的用途是求乘法逆元。\n\n设 $a$ 在 $\\mod{b}$ 意义下的逆元是 $a^*$，那么\n\n$$a\\cdot a^* \\equiv 1\\mod{b}$$\n\n即\n\n$$b\\mid (a\\cdot a^*-1)$$\n\n\n设 $\\dfrac{a\\cdot a^*-1}{b}$ 为 $y$，那么\n\n$$a^*\\cdot a -1=by$$\n\n即\n\n$$a^*\\cdot a-by=1$$\n\n这个方程就是 $ax+by=\\gcd(a,b)$ 的形式，所以我们可以得知**$x$ 的逆元存在的必要条件是 $x$ 和模数 $p$ 互质**。\n\n所以我们只需要使用 $exgcd$ 就可以求出逆元了。\n\n求逆元代码如下：([P5431 【模板】乘法逆元 2](https://www.luogu.com.cn/problem/P5431))\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nint n;\nlong long p,k;\nlong long a[5000005],sum[2][5000005];\n\ninline long long read()\n{\n\tlong long s=0,w=1,ch=getchar();\n\twhile(ch<'0'||ch>'9') ch=='-'?w=-1,ch=getchar():ch=getchar();\n\twhile(ch>='0'&&ch<='9') s=(s<<1)+(s<<3)+(ch^48),ch=getchar();\n\treturn s*w;\n}\n\nlong long exgcd(long long a,long long b,long long &x,long long &y) // x 和 y 是引用，因为我懒得写结构体…… \n{\n\tif(a<b) // 如果 a < b 那么交换 a 和 b 来求 \n\t{\n\t\treturn exgcd(b,a,y,x);\n\t}\n\tif(b==0) // 如果 b 为 0，那么 gcd(a,b) = a，x = 1，y = 0 \n\t{\n\t\tx=1;\n\t\ty=0;\n\t\treturn a;\n\t}\n\t// 其它情况 \n\tlong long tmpx,tmpy;\n\tlong long res=exgcd(b,a%b,tmpx,tmpy);\n\tx=tmpy;\n\ty=tmpx-a/b*tmpy;\n\treturn res;\n}\n\ninline long long inv(long long val) // exgcd 求乘法逆元 \n{\n\tlong long x,y;\n\tif(exgcd(val,p,x,y)!=1)\n\t{\n\t\treturn -1;\n\t}\n\treturn (x%p+p)%p;\n}\n\nint main()\n{\n\tscanf(\"%d%lld%lld\",&n,&p,&k);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\ta[i]=read();\n\t}\n\tsum[0][0]=1;\n\tsum[1][n+1]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tsum[0][i]=sum[0][i-1]*a[i]%p;\n\t}\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tsum[1][i]=sum[1][i+1]*a[i]%p;\n\t}\n\tlong long summ=0,base=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tbase=base*k%p;\n\t\tsumm+=base*sum[0][i-1]%p*sum[1][i+1]%p;\n\t\tsumm%=p;\n\t}\n\tprintf(\"%lld\\n\",summ*inv(sum[0][n])%p);\n\treturn 0;\n}\n```\n\n### 练习题目\n\n[P2613 【模板】有理数取余](https://www.luogu.com.cn/problem/P2613)\n\n[P1516 青蛙的约会](https://www.luogu.com.cn/problem/P1516)\n",
			"tags": [{"name":"学习笔记"},{"name":"数学"},{"name":"数论"}],
			"title": "扩展欧几里得算法学习笔记",
			"link": "https://exber.qzz.io/post/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-03-21 15:17:58"
		},
	
		{
			"abstract": "",
			"content": "### 指数级搜索（exponetial search）\n\n这是一种用于处理 $\\operatorname{check}(l,mid)$ 时间复杂度为 $O(mid-l+1)$ 即时间复杂度和序列长度相关的搜索算法。\n\n一般用于需要**在序列上不断二分划分出一段段互不相交的合法区间**的题目中。\n\n发现二分的问题在于从 $i$ 出发找以 $i$ 开头的合法区间的右端点 $r$ 的时候时间复杂度为 $O((n-i)\\log(n-i))$，总时间复杂度最坏为 $O(n^2\\log n)$，无法接受。\n\n不难发现问题在于二分的区间太大了，不妨先**从小到大**枚举 $j$，找到第一个满足 $\\operatorname{check}(i,i+2^j-1)=true$ 的 $j$，然后在 $[i,i+2^j-1]$ 里二分，这样二分的时间复杂度就是 $O((r-i+1)\\log(r-i+1))$ 也就是只和当前区间的长度有关，均摊时间复杂度即为 $O(n\\log n)$。\n\n<details><summary>参考代码</summary><p>\n\n```cpp\nfor(int i=1;i<=n;i++)\n{\n    int rb=-1;\n    for(int j=0;j<=20;j++)\n    {\n        int pre=min(i+(1<<j)-1,n);\n        if(chk(i,pre))\n        {\n            rb=pre;\n            break;\n        }\n    }\n    if(rb==-1) break;\n    int lb=i,nxt=0;\n    while(lb<=rb)\n    {\n        int mid=lb+rb>>1;\n        if(chk(i,mid)) nxt=mid,rb=mid-1;\n        else lb=mid+1;\n    }\n    ans[++anscnt]=nxt;\n    i=nxt;\n}\n```\n</p></details>\n\n### $\\gcd(a^x-1,a^y-1)=a^{\\gcd(x,y)}-1$\n\n证明：\n\n> $$x\\ge y\\\\\\begin{aligned}&\\gcd(a^x-1,a^y-1)\\\\&=\\gcd(a^x-1-a^{x-y}\\times(a^y-1),a^y-1)\\\\&=\\gcd(a^{x-y}-1,a^y-1)\\\\&...\\\\&=a^{\\gcd(x,y)}-1\\end{aligned}$$\n\n### 大小 $\\le k$ 的点覆盖的爆搜\n\n每次找到还没被删掉的度数最大的点 $u$，若其度数 $\\le 2$，则图为若干环和链，可以直接处理。\n\n否则枚举 $u$ 删还是不删，若 $u$ 不删则其所有邻居都要被删，故有关于点覆盖大小限制 $k$ 的时间复杂度递推式 $T(k)=T(k-1)+T(k-3)+O(n)$，这个在 $k=30$ 时大约是 $10^5O(n)$。\n\n### 把 $<x$ 的看作 $0$，$\\ge x$ 的看作 $1$\n\n这个技巧通常搭配二分 $x$ 来使用，或者直接考虑 $01$ 序列然后通过这个套路证明某些东西。\n\n例题 1：[Magic Breeding](https://www.luogu.com.cn/problem/CF878D)\n\n例题 2：【2025NOI模拟赛20】排列\n\n<details><summary>题解</summary><p>\n\n> 考虑每次询问二分答案 $ans$，对于每个初始数列 $1\\le i\\le k$，设 $b_i=[a_{i,y}\\ge ans]$，那么每次修改操作就相当于让 $b_{cnt}=b_{x}\\&b_y$ 或者 $b_x|b_y$，其中 $\\&$ 和 $|$ 是按位与和按位或操作。最后若 $b_{x}=1$ 则 $ans$ 合法，往上二分，否则往下二分。\n>\n> 观察到 $k$ 很小，$b_i$ 只有两种取值，所以可以把 $b_{[1,k]}$ 压缩成一个二进制数，用 bitset 存下 $b_{[1,k]}$ 每种情况的 $b_x$ 的取值，修改的时候简单按位操作，二分的时候直接查询即可。\n>\n> 时间复杂度 $O(q\\max(\\frac{2^k}{64},k\\log V))$。\n</p></details>\n\n例题 2：[A Serious Referee](https://www.luogu.com.cn/problem/CF1552G)\n\n<details><summary>题解</summary><p>\n\n> 显然，对于所有的 $1\\le i\\le n$，设 $b_{i,j}=[a_j\\ge a_i]$。若每个 $b_i$ 都能被排序，那么显然 $a$ 能被排序。因为每个 $b_i$ 都能被排序代表排序后不会有任何逆序对。\n>\n> 那么用搜索+剪枝即可。\n</p></details>\n\n\n### 曼哈顿距离和切比雪夫距离互转\n\n曼哈顿距离：$|x1-x2|+|y1-y2|$\n\n切比雪夫距离：$\\max(|x1-x2|,|y1-y2|)$\n\n把所有点 $(x,y)$ 变成 $(x+y,x-y)$ 后两点之间的切比雪夫距离就等于原来的曼哈顿距离，把所有点 $(x,y)$ 变成 $(\\frac{x+y}{2},\\frac{x-y}{2})$ 后两点的曼哈顿距离就等于原来的切比雪夫距离。\n\n[bzoj3170 松鼠聚会](https://vjudge.csgrandeur.cn/problem/黑暗爆炸-3170)  [AT_code_festival_2017_quala_d](https://www.luogu.com.cn/problem/AT_code_festival_2017_quala_d)  [P3439](https://www.luogu.com.cn/problem/P3439)  [P2906](https://www.luogu.com.cn/problem/P2906)  [P5098](https://www.luogu.com.cn/problem/P5098)  [P4648](https://www.luogu.com.cn/problem/P4648)  [P7561](https://www.luogu.com.cn/problem/P7561)\n\n### 网格空间连通性容斥（便便容斥）\n\n#### 是否矩形\n\n网格空间中的黑块形成矩形，当且仅当所有 $2\\times 2$ 小正方形（可超出边界）中：\n\n- 恰好有 $4$ 个小正方形包含恰好一个黑块（限制外围拐点数）；\n- 没有小正方形包含恰好三个黑块（限制没有洞）；\n\n相当于包含一个黑块的小正方形个数加上包含三个黑块的小正方形个数 $=4$。\n\n#### 连通块个数\n\n在二维网格图中数中间没有洞的四向连通块个数可以这样容斥：\n\n![](../post-images/1680078167324.png)\n\n可以通过做四次扫描线来解决。\n\n八连通也是类似的：\n\n![](../post-images/1680079301015.png)\n\n并且这还可以拓展到高维空间，相当于是高维面积乘上 $-1^{\\text{砍掉一面的维度的个数}}$ 的容斥系数然后加起来。\n\n\n\n### $\\sum\\limits_{d|n}O(\\sqrt d)=O(n^{\\frac{3}{4}})$\n\n不会证，感性理解一下就是 $\\sum\\limits_{d=1}^{\\sqrt n}\\sqrt d+\\sqrt{\\frac{n}{d}}$ 是 $O(n^{\\frac{3}{4}})$ 级别的。\n\n以后可以大胆写整除分块套整除分块。\n\n### Jerry Wen 定理\n\n> 解的一些必要/充分条件的并，很有可能就是解的充要条件。\n\n一些博弈论、图论、构造题可以尝试找必要/充分条件刻画解的充要条件。\n\n### 按 $r$ 分块\n\n某些题目中 $|i-j|\\le r$ 的无序点对 $(i,j)$ 才有贡献，此时可以按 $r$ 分块（$[1,r]$、$[r+1,2r]$ 等等为一块）。这样做的好处：\n\n- 令 $i>j$，考虑固定 $i$ 后有贡献的点对 $(i,j)$ 的集合 $S$；\n- 贡献可以分为块内贡献和块间（$i$ 所在块和上一块）贡献；\n- 块内贡献：正着扫，$S$ 中只会加入新元素；\n- 块间贡献：倒着扫，$S$ 中同样只会加入新元素；\n\n注意要先处理块间贡献。\n\n例题：[【2023成都集训模拟赛04】op](../【2023成都集训模拟赛04】op 做题记录)\n\n### 同余最短路\n\n当模 $p$ 同余的所有状态等价，要求 $d_i$ 表示模 $p$ 为 $i$ 的状态中最小的那个时，一般建出 $p$ 个点代表状态等价类，把状态间的转移映射成这些点间的边，跑最短路求 $d_i$。\n\n典型应用：\n\n- 给一些数，求至少要拼几次才能拼出模 $p$ 为 $i$ 的数；\n- 给一些数，求这些数完全背包后能表示的数的个数；\n- 给一些数，求这些数完全背包后不能表示的最小/最大数；\n\n例题：\n\n- [ARC084D Small Multiple](https://atcoder.jp/contests/arc084/tasks/arc084_b)\n- [【2023NOIP模拟赛09】补幺梨](../【2023NOIP模拟赛09】补幺梨 做题记录/)\n\n### 贡献为函数时考虑拆开再算新增贡献\n\n例题：\n\n- [【2023NOI模拟赛36】A](../【2023NOI模拟赛36】A 做题记录)\n- [AGC065A Shuffle and mod K](https://atcoder.jp/contests/agc065/tasks/agc065_a)\n\n### 各种组合意义\n\n#### 排列\n\n- 考虑建立一个 $n\\times n$ 的网格，只有 $(i,p_i)$ 有标记；\n  - [CF1909F2](https://www.luogu.com.cn/problem/CF1909F2)\n- 考虑连有向边 $(i,p_i)$，形成若干个置换环；\n\n### $O(k\\log k+mk)$ 求 $k$ 次多项式 $n$ 次幂的前 $m$ 项\n\n假设要求 $[x^{[0,m-1]}]f(x)^n$，设 $g(x)=f(x)^n$，对 $g(x)$ 求导，则：\n$$\n\\begin{aligned}\ng(x)'&=f'(x)\\times n\\times f(x)^{n-1}\\\\\ng(x)'f(x)&=nf'(x)g(x)\n\\end{aligned}\n$$\n那么将 $g(x)$ 展开成幂级数即可根据 $f(x)$ 得到 $g_{[i-k,i-1]}\\to g_i$ 的递推关系，多项式快速幂预处理 $g_{[0,k-1]}$ 然后递推即可。\n\n### 倍增并查集\n\n用于快速维护两个区间内元素对应相等（$A_{l1}=B_{l2},A_{l1+1}=B_{l2+1},\\dots,A_{r1}=B_{r2}$）。\n\n类似倍增，建 $\\log$ 层点，然后并查集。\n\n新增相等关系的时候类似倍增拆成两对区间分别向等，最后从上到下遍历每一层下放相等关系。\n\n具体的，若第 $i$ 层时 $[l,l+2^i-1]$ 所在集合的根为 $[p,p+2^i-1]$，那么下放相等关系 $[l,l+2^{i-1}-1]=[p,p+2^{i-1}-1]$，$[l+2^{i-1},l+2^{i}-1]=[p+2^{i-1},p+2^{i}-1]$。\n\n而当维护的相等关系在同一个序列上时，可以在线做，每次暴力下放。这样由于每一层只会合并 $O(n)$ 次，所以总复杂度是 $O(nm\\log n)$ 的，其中 $m$ 是并查集复杂度。\n\n例题：\n\n- [P3295 [SCOI2016] 萌萌哒](https://www.luogu.com.cn/problem/P3295)\n- 【2025NOI模拟赛10】简单题\n\n\n### 判断无向图 $G$ 的某个边集 $S$ 是否为割\n\n即判断割掉 $S$ 中的边后 $G$ 是否不连通。\n\n考虑 dfs 树，为每条返祖边赋一个随机权值，每条树边的权值则是所有跨过它的返祖边权值的 xor 和。\n\n那么 $S$ 为割当且仅当存在 $S$ 的一个非空子集 $T$ 满足 $T$ 中边权值 xor 和为 $0$（线性基包含 $0$）。\n\n证明考虑若 $T$ 非空且其中边权值 xor 和为 $0$，则显然每个包含一条非树边的简单环都会是以下两种情况之一：\n\n- 未被割掉边\n- 被割掉至少两条边\n\n并且所有边中至少割掉了两条边。\n\n理解一下就容易发现满足这些条件的边集一定是 $G$ 的一个割。\n\n这个做法还可以解决二分割（割掉边后是否是二分图）的题目：\n\n- [QOJ1351 Koosaga's Problem](https://qoj.ac/contest/506/problem/1351)\n\n### 扣掉一个物品的 01 背包\n\n劲题。\n\n可以做到 $O(nk\\log n)$。\n\n具体的，考虑类似线段树一样分治，处理区间 $[l,r]$ 的时候先加入 $[l,mid]$ 中的物品，递归右半边；再撤销掉 $[l,mid]$ 中的物品（通过开桶记录加入前的状态实现），递归左半边。这样递归到单点的时候就求出了答案。\n\n时间复杂度是 $T(n)=O(nk)+2T(\\frac{n}{2})=O(nk\\log n)$ 的。\n\n### 一个 log 求两个单调序列的第 $k$ 小\n\n其实可以拓展到求 $m$ 个单调序列的第 $k$ 小，不过 log 的底数会变，常数有点大。\n\n假设要求两个单调不降序列 $a,b$ 的第 $k$ 小，那么若 $a_{\\lfloor k/2\\rfloor}<b_{\\lfloor k/2\\rfloor}$ 则可以删去 $a$ 的前 $\\lfloor k/2\\rfloor$ 个数，并将 $k$ 减去 $\\lfloor k/2\\rfloor$。正确性考虑前 $k$ 小肯定是 $a_{[1,x]}$ 和 $b_{[1,y]}$（$x+y=k$），那么 $x$ 和 $y$ 一定有至少一个大于等于 $\\lfloor k/2\\rfloor$。\n\n某些题目中 $a$ 和 $b$ 是非负序列的前缀和，且非负序列带单点修。那么可以考虑对于 $a$ 和 $b$ 都建出线段树，然后在线段树上二分，维护 $x$ 所在的区间 $[lx,rx]$ 和 $y$ 所在的区间 $[ly,ry]$，不难发现每次肯定能砍掉某个区间的一半（$k$ 较小的时候砍掉后一半，否则砍掉前一半）。\n\n<details><summary>代码</summary><p>\n\n```cpp\n#include \"mitsuha.h\"\n#include <vector>\n#include <cstdio>\n#include <map>\n\nusing namespace std;\n\nnamespace Exber\n{\n\tconst int S=20005;\n\t\n\tstruct data\n\t{\n\t\tData x;\n\t\tint id;\n\t};\n\tint cnt;\n\tmap<pair<int,int>,bool> cmp;\n\tmap<pair<int,int>,data> add;\n\tinline data operator+(data x,data y)\n\t{\n\t\tint ix=x.id,iy=y.id;\n\t\tif(ix>iy) swap(ix,iy);\n\t\tauto u=make_pair(ix,iy);\n\t\tif(add.find(u)!=add.end()) return add[u];\n\t\treturn add[u]=data{x.x+y.x,++cnt};\n\t}\n\tinline bool operator<(data x,data y)\n\t{\n\t\tauto u=make_pair(x.id,y.id);\n\t\tif(cmp.find(u)!=cmp.end()) return cmp[u]; \n\t\treturn cmp[u]=(x.x<y.x);\n\t}\n\tinline bool operator>(data x,data y){return !(x<y);}\n\t\n\tint n;\n\tdata a[S],b[S];\n\tdata ta[S<<2],tb[S<<2];\n\tinline void upda(data tr[],int u){tr[u]=tr[u<<1]+tr[u<<1|1];}\n\tvoid build(data tr[],data a[],int u,int l,int r)\n\t{\n\t\tif(l==r) return tr[u]=a[l],void();\n\t\tint mid=l+r>>1;\n\t\tbuild(tr,a,u<<1,l,mid),build(tr,a,u<<1|1,mid+1,r);\n\t\tupda(tr,u);\n\t}\n\tvoid updp(data tr[],data a[],int u,int l,int r,int p)\n\t{\n\t\tif(l==r) return tr[u]=a[l],void();\n\t\tint mid=l+r>>1;\n\t\tif(p<=mid) updp(tr,a,u<<1,l,mid,p);\n\t\telse updp(tr,a,u<<1|1,mid+1,r,p);\n\t\tupda(tr,u);\n\t}\n\tinline void init(int N,int Q,vector<Data> A,vector<Data> B)\n\t{\n\t\tn=N;\n\t\tcnt=0;\n\t\tfor(int i=1;i<=n;i++) a[i]=data{A[i-1],++cnt},b[i]=data{B[i-1],++cnt};\n\t\tbuild(ta,a,1,1,n),build(tb,b,1,1,n);\n\t}\n\tinline void update(int op,int x,Data y)\n\t{\n\t\tif(op==1)\n\t\t{\n\t\t\ta[x]=data{y,++cnt};\n\t\t\tupdp(ta,a,1,1,n,x);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tb[x]=data{y,++cnt};\n\t\t\tupdp(tb,b,1,1,n,x);\n\t\t}\n\t}\n\tData que(int ua,int la,int ra,int ub,int lb,int rb,int k,data sma,data smb)\n\t{\n//\t\tprintf(\"[%d %d] [%d %d] %d %d %d\\n\",la,ra,lb,rb,k,sma.a,smb.a);\n\t\tif(la!=ra&&lb!=rb)\n\t\t{\n\t\t\tint mida=la+ra>>1;\n\t\t\tint midb=lb+rb>>1;\n\t\t\tint lsa=mida-la+1;\n\t\t\tint lsb=midb-lb+1;\n\t\t\tif(lsa>=k) return que(ua<<1,la,mida,ub,lb,rb,k,sma,smb);\n\t\t\tif(lsb>=k) return que(ua,la,ra,ub<<1,lb,midb,k,sma,smb);\n\t\t\tif(lsa+lsb<k)\n\t\t\t{\n\t\t\t\tdata sa=sma+ta[ua<<1];\n\t\t\t\tdata sb=smb+tb[ub<<1];\n\t\t\t\tif(sa<sb) return que(ua<<1|1,mida+1,ra,ub,lb,rb,k-lsa,sa,smb);\n\t\t\t\telse \t  return que(ua,la,ra,ub<<1|1,midb+1,rb,k-lsb,sma,sb);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdata sa=sma+ta[ua<<1]+a[mida+1];\n\t\t\t\tdata sb=smb+tb[ub<<1]+b[midb+1];\n\t\t\t\tif(sa>sb) return que(ua<<1,la,mida,ub,lb,rb,k,sma,smb);\n\t\t\t\telse\t  return que(ua,la,ra,ub<<1,lb,midb,k,sma,smb);\n\t\t\t}\n\t\t}\n\t\telse if(la!=ra)\n\t\t{\n\t\t\tint mida=la+ra>>1;\n\t\t\tint lsa=mida-la+1;\n\t\t\tdata sa=sma+ta[ua<<1];\n\t\t\tdata sb=smb+b[lb];\n\t\t\tif(lsa+(sa>sb)>=k) return que(ua<<1,la,mida,ub,lb,rb,k,sma,smb);\n\t\t\telse\t\t\t   return que(ua<<1|1,mida+1,ra,ub,lb,rb,k-lsa,sa,smb);\n\t\t}\n\t\telse if(lb!=rb)\n\t\t{\n\t\t\tint midb=lb+rb>>1;\n\t\t\tint lsb=midb-lb+1;\n\t\t\tdata sb=smb+tb[ub<<1];\n\t\t\tdata sa=sma+a[la];\n\t\t\tif(lsb+(sb>sa)>=k) return que(ua,la,ra,ub<<1,lb,midb,k,sma,smb);\n\t\t\telse\t   \t\t   return que(ua,la,ra,ub<<1|1,midb+1,rb,k-lsb,sma,sb);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdata sa=sma+a[la];\n\t\t\tdata sb=smb+b[lb];\n\t\t\tif(sa>sb) swap(sa,sb);\n\t\t\treturn k==1?sa.x:sb.x;\n\t\t}\n\t}\n\tinline Data query(int k)\n\t{\n//\t\tputs(\"------\");\n\t\treturn que(1,1,n,1,1,n,k,data{emptyData,0},data{emptyData,0});\n\t}\n}\n\nvoid init(int N, int Q, vector<Data> A, vector<Data> B){Exber::init(N,Q,A,B);}\nvoid update(int op, int x, Data y){Exber::update(op,x,y);}\nData query(int k){return Exber::query(k);}\n```\n\n</p></details>\n\n### 网格图分治求多组询问最短路\n\n类似 $(x,y)$ 向 $(x+1,y)$ 和 $(y+1,x)$ 连边的这种网格图，可以使用分治求多组询问的两点最短/长路：\n\n> 考虑现在分治的 $[1,n]\\times [1,m]$ 的子矩阵，假设 $n>m$，那么横着切一刀，即令 $mid=\\lfloor\\frac{n}{2}\\rfloor$，预处理出 $(mid,*)$ 这条线上的点到每个其它点和其它点到它们的最短/长路，即可处理所有跨过这条线的询问（因为这些询问的路径一定会经过这条线）。分治处理 $[1,mid]\\times [1,m]$ 和 $[mid+1,n]\\times [1,m]$。\n>\n> $n<m$ 的情况也是类似的。\n>\n> 设点数为 $n$，时间复杂度为 $T(n)=O(n\\sqrt n)+2T(\\frac{n}{2})=O(n\\sqrt n)$。\n\n例题：\n\n- [P9040 [PA 2021] Desant 2](https://www.luogu.com.cn/problem/P9040)\n\n### 观察四边形不等式\n\n这里讨论最小化 $w(l,r)$ 的情况。\n\n可以观察对于任意 $l_1<l_2$，是否有 $\\Delta_1=w(l_1,r+1)-w(l_1,r)$ 小于等于 $\\Delta_2=w(l_2,r+1)-w(l_2,r)$。\n\n这是因为 $w(l_1,r)+w(l_2,r+1)=w(l_1,r+1)+w(l_2,r)+\\Delta_1-\\Delta_2$。\n\n例题：\n\n- [P9732 [CEOI 2023] Trade](https://www.luogu.com.cn/problem/P9732)\n\n### 01 on Tree\n\n经常想不到，可以推广为多个序列归并的形式。\n\n[AGC023F 01 on Tree 做题记录](../AGC023F 01 on Tree 做题记录/)\n\n- [QOJ2070 Heavy Stones](https://qoj.ac/problem/2070)\n",
			"tags": [{"name":"学习笔记"},{"name":"小技巧"}],
			"title": "各种小技巧",
			"link": "https://exber.qzz.io/post/%E5%90%84%E7%A7%8D%E5%B0%8F%E6%8A%80%E5%B7%A7",
			"date": "2023-03-21 15:15:51"
		},
	
		{
			"abstract": "",
			"content": "[P3808 AC 自动机（简单版）](https://www.luogu.com.cn/problem/P3808)\n\n> 给定 $n$ 个模式串 $t_i$ 和一个文本串 $s$，求出 $s$ 中有多少个 $t_i$ 出现了。\n\n考虑先将所有模式串插入到一棵 Trie 树中，然后在上面跑（不停从点 $u$ 走到 $u$ 的边权为 $s_i$ 的儿子，即令 $u$ 变为 $son_{u,s_i}$）。这样若当前点 $u$ 为某个 $t_i$ 对应的点（可以在插入时给这个点打标记），则说明 $t_i$ 在 $s$ 中出现了。\n\n但是这样不停跑可能会出现这样的情况：当前位于点 $u$，而 $son_{u,s_i}=0$ 即不存在对应的儿子，此时我们无法直接走到 $son_{u,s_i}$。不妨称这种情况为“失配”。\n\n解决办法很简单，假设第一次出现这种情况时跑完了 $s_{[1,i]}$，当前在点 $u$ 且 $son_{u,s_{i+1}}=0$。则此时 $u$ 对应的字符串是 $s_{[1,i]}$。为了能继续往下跑，我们可以跳到一个 Trie 树上的节点 $v$，使得 $v$ 代表的字符串是 $s_{[1,i]}$ 的后缀，且 $v\\not=u$：\n\n![](../post-images/1754896341401.png)\n\n如果这样的 $v$ 有很多个，那么跳到最深（代表的字符串最长）的那个一定是最优的（因为从它出发能跳到其它合法的 $v$）。并且由于 Trie 中每个点的字符串两两不同，故最深的 $v$ 一定只有一个。\n\n不妨令 $fail_u$ 为最深的这样的 $v$，即对应字符串是点 $u$ 对应字符串的后缀且深度最大的点 $v$（需满足 $v\\not=u$）。\n\n考虑 $fail$ 的求解。注意到 $fail_u$ 的深度一定小于 $u$ 的深度，故可以使用 bfs 求解。先将 $fail_0$ 以及所有 $0$ 的儿子的 $fail$ 设为 $0$。对于一个点 $u$ 及 $v=son_{u,i}\\not=0$：\n\n- 令 $p=fail_u$ 并不断令 $p=fail_p$，直到：\n  - $p=0$，则令 $fail_v=0$；\n  - $son_{p,i}\\not=0$，则令 $fail_v=son_{p,i}$；\n\n暴力跳太慢了，不妨在 $son_{u,i}=0$ 时令 $son_{u,i}=son_{fail_u,i}$，这样就不用暴力跳了：\n\n- 若 $son_{u,i}\\not=0$，则令 $fail_{son_{u,i}}=son_{fail_u,i}$；\n\n即 $son_{u,i}$ 实际上变成了：\n\n- 从 $u$ 出发，不断令 $u=fail_u$ 直到边权为 $i$ 的儿子 $v$ 存在，$son_{u,i}$ 就为这个 $v$；\n\n求 $fail$ 数组的代码如下：\n\n```cpp\ninline void build()\n{\n\tqueue<int> q; \n\tfail[0]=0;\n\tfor(int i=0;i<26;i++)\n\t{\n\t\tint v=son[0][i];\n\t\tif(v!=0) fail[v]=0,q.push(v);\n\t}\n\twhile(!q.empty())\n\t{\n\t\tint u=q.front();\n\t\tq.pop();\n\t\tfor(int i=0;i<26;i++)\n\t\t{\n\t\t\tint v=son[u][i];\n\t\t\tif(v!=0) fail[v]=son[fail[u]][i],q.push(v);\n\t\t\telse son[u][i]=son[fail[u]][i];\n\t\t}\n\t}\n}\n```\n\n对于例题，不难发现当在点 $u$ 时，实际上能匹配 $u,fail_u,fail_{fail_u},\\dots$ 对应的字符串，即不断跳 $fail$ 经过的点都能匹配到。故还需记录一个点是否被跳过了，如果经过跳过的点就停止跳 $fail$：\n\n```cpp\ninline int calc(char* s,int n) // sum[u] 表示有多少个文本串等于 u 表示的字符串\n{\n\tint u=0,res=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint id=s[i]-'a'; \n\t\tu=son[u][id];\n\t\tint v=u;\n\t\twhile(v!=0&&sum[v]!=-1) // 跳到根节点或者跳到过就不用跳 \n\t\t{\n\t\t\tres+=sum[v]; // 计算贡献 \n\t\t\tsum[v]=-1;   // 标记跳到过了 \n\t\t\tv=fail[v];   // 继续跳 fail \n\t\t}\n\t}\n\treturn res;\n}\n```\n\n实际上，由于每个点只有一个 $fail$，且不断跳 $fail$ 必定停留在点 $0$，故 $fail$ 实际上是一棵根为 $0$，包含所有 Trie 中节点的树，即 fail 树。\n\n练习：\n\n- [P3796 【模板】AC自动机（加强版）](https://www.luogu.com.cn/problem/P3796)\n- [P5357 【模板】AC自动机（二次加强版）](https://www.luogu.com.cn/problem/P5357)\n- [P5231 [JSOI2012]玄武密码](https://www.luogu.com.cn/problem/P5231)\n- [P3966 [TJOI2013]单词](https://www.luogu.com.cn/problem/P3966)\n- [P2322 [HNOI2006]最短母串问题](https://www.luogu.com.cn/problem/P2322)\n- [P3121 [USACO15FEB]Censoring G](https://www.luogu.com.cn/problem/P3121)\n- [P2444 [POI2000]病毒](https://www.luogu.com.cn/problem/P2444)\n",
			"tags": [{"name":"学习笔记"},{"name":"数据结构"},{"name":"字符串"}],
			"title": "AC 自动机学习笔记",
			"link": "https://exber.qzz.io/post/AC%20%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-03-21 15:10:07"
		},
	
		{
			"abstract": "",
			"content": "这篇学习笔记写的没有[这篇题解](https://ncc79601.blog.luogu.org/scan-line)好/kk\n\n**扫描线是一种线段树的巧妙运用**，通常用来解决一些图形的面积/周长问题。\n\n先从最经典的问题入手：\n\n```\n求 n 个矩形的面积并。\n```\n\n—— [P5490 【模板】扫描线](https://www.luogu.com.cn/problem/P5490)\n\n首先画个图，最烦人的肯定是下面这种情况：\n\n![](../post-images/1679380951928.webp)\n\n**两个矩形有相交的部分，最朴素的想法当然是减掉它**。但是我们求的是 $n$ 个矩形的面积并，所以**不可行**。\n\n我们可以转换一下思维，**把图中所有与 $Y$ 轴平行的线段都标红、延长（称其为扫描线）**，可以得到这样的一个图：\n\n![](../post-images/1679380944814.webp)\n\n很容易发现，**这四条扫描线把矩形割开了，而相邻的两条线之间的部分一定是规则的矩形**。\n\n于是我们可以**考虑使用某种数据结构维护两条扫描线之间的矩形投影到 $X$ 轴之后的总长度**。很显然这东西能用线段树维护，**让线段树的 $sum_u$ 存储节点 $u$ 所代表的区间中被矩形覆盖的长度，$all_u$ 储存节点 $u$ 所代表的区间共被多少个矩形完全覆盖，$sum_1$ 就是总长度了**。\n\n但还有一个问题，那就是坐标有可能非常大，所以我们需要对 $x$ 坐标进行离散化，然后**让节点 $u$ 维护 $[pos_{l_u},pos_{r_u+1}]$ 的信息**。\n\n模板题代码：\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nstruct node\n{\n\tlong long y,lx,rx;\n\tbool in;\n}a[2000005];\n\nint n;\nint tot;\nlong long pos[2000005];\nint all[8000005];\nlong long sum[8000005];\n\ninline bool cmp(node x,node y)\n{\n\treturn x.y<y.y;\n}\n\ninline void upd(int u,int l,int r)\n{\n\tif(all[u]!=0)\n\t{\n\t\tsum[u]=pos[r+1]-pos[l];\n\t}\n\telse\n\t{\n\t\tsum[u]=sum[u<<1]+sum[u<<1|1];\n\t}\n}\n\nvoid add(int u,int l,int r,long long L,long long R,int val)\n{\n\tif(pos[l]>=L&&pos[r+1]<=R)\n\t{\n\t\tall[u]+=val;\n\t\tupd(u,l,r);\n\t\treturn;\n\t}\n\tint mid=l+r>>1;\n\tif(L<pos[mid+1])\n\t{\n\t\tadd(u<<1,l,mid,L,R,val);\n\t}\n\tif(R>pos[mid+1])\n\t{\n\t\tadd(u<<1|1,mid+1,r,L,R,val);\n\t}\n\tupd(u,l,r);\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tlong long x1,y1,x2,y2;\n\t\tscanf(\"%lld%lld%lld%lld\",&x1,&y1,&x2,&y2);\n\t\tlong long lx=min(x1,x2),rx=max(x1,x2),ly=min(y1,y2),ry=max(y1,y2);\n\t\tpos[++tot]=lx;\n\t\ta[tot]=(node){ry,lx,rx,true};\n\t\tpos[++tot]=rx;\n\t\ta[tot]=(node){ly,lx,rx,false};\n\t}\n\tsort(a+1,a+n*2+1,cmp);\n\tsort(pos+1,pos+tot+1);\n\ttot=unique(pos+1,pos+tot+1)-(pos+1);\n\tlong long ans=0;\n\tfor(int i=1;i<n*2;i++)\n\t{\n\t\tadd(1,1,tot-1,a[i].lx,a[i].rx,a[i].in?1:-1);\n\t\tans+=sum[1]*(a[i+1].y-a[i].y);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n```\n\n不过给[P1856 [IOI1998] [USACO5.5] 矩形周长Picture](https://www.luogu.com.cn/problem/P1856)的更简单的解法。其实**可以先按 $x$ 轴扫描一下这些矩形，再按 $y$ 轴扫描一下这些矩形，最后将扫描得到的周长相加就可以了，完全不用题解区里那么难**。\n\n完整代码：\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nstruct nodey\n{\n\tlong long y,lx,rx;\n\tbool inl;\n}liny[200005];\n\nstruct nodex\n{\n\tlong long x,ly,ry;\n\tbool inl;\n}linx[200005];\n\nint n;\nint tot[2];\nlong long pos[2][200005];\nlong long sum[2][800005];\nint all[2][800005];\n\ninline long long ckjabs(long long x)\n{\n\treturn x<0?-x:x;\n}\n\ninline bool cmpy(nodey x,nodey y)\n{\n\treturn x.y<y.y;\n}\n\ninline bool cmpx(nodex x,nodex y)\n{\n\treturn x.x<y.x;\n}\n\ninline void upd(int id,int u,int l,int r)\n{\n\tif(all[id][u]!=0)\n\t{\n\t\tsum[id][u]=pos[id][r+1]-pos[id][l];\n\t}\n\telse\n\t{\n\t\tsum[id][u]=sum[id][u<<1]+sum[id][u<<1|1];\n\t}\n}\n\nvoid add(int id,int u,int l,int r,long long L,long long R,int val)\n{\n\tif(pos[id][l]>=L&&pos[id][r+1]<=R)\n\t{\n\t\tall[id][u]+=val;\n\t\tupd(id,u,l,r);\n\t\treturn;\n\t}\n\tint mid=l+r>>1;\n\tif(L<pos[id][mid+1])\n\t{\n\t\tadd(id,u<<1,l,mid,L,R,val);\n\t}\n\tif(R>pos[id][mid+1])\n\t{\n\t\tadd(id,u<<1|1,mid+1,r,L,R,val);\n\t}\n\tupd(id,u,l,r);\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tlong long x1,y1,x2,y2;\n\t\tscanf(\"%lld%lld%lld%lld\",&x1,&y1,&x2,&y2);\n\t\tlong long lx=min(x1,x2),rx=max(x1,x2);\n\t\tlong long ly=min(y1,y2),ry=max(y1,y2);\n\t\tpos[0][++tot[0]]=lx;\n\t\tpos[0][++tot[0]]=rx;\n\t\tpos[1][++tot[1]]=ly;\n\t\tpos[1][++tot[1]]=ry;\n\t\tliny[i]=(nodey){ly,lx,rx,true};\n\t\tliny[n+i]=(nodey){ry,lx,rx,false};\n\t\tlinx[i]=(nodex){lx,ly,ry,true};\n\t\tlinx[n+i]=(nodex){rx,ly,ry,false};\n\t}\n\tsort(liny+1,liny+n*2+1,cmpy);\n\tsort(linx+1,linx+n*2+1,cmpx);\n\tsort(pos[0]+1,pos[0]+tot[0]+1);\n\tsort(pos[1]+1,pos[1]+tot[1]+1);\n\ttot[0]=unique(pos[0]+1,pos[0]+tot[0]+1)-(pos[0]+1);\n\ttot[1]=unique(pos[1]+1,pos[1]+tot[1]+1)-(pos[1]+1);\n\tlong long ans=0;\n\tlong long lst=0;\n\tfor(int i=1;i<n*2;i++)\n\t{\n\t\tadd(0,1,1,tot[0]-1,liny[i].lx,liny[i].rx,liny[i].inl?1:-1);\n\t\tans+=ckjabs(sum[0][1]-lst);\n\t\tlst=sum[0][1]; \n\t}\n\tans+=lst;\n\tlst=0;\n\tfor(int i=1;i<n*2;i++)\n\t{\n\t\tadd(1,1,1,tot[1]-1,linx[i].ly,linx[i].ry,linx[i].inl?1:-1);\n\t\tans+=ckjabs(sum[1][1]-lst);\n\t\tlst=sum[1][1];\n\t}\n\tans+=lst;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"学习笔记"},{"name":"数据结构"}],
			"title": "扫描线学习笔记",
			"link": "https://exber.qzz.io/post/%E6%89%AB%E6%8F%8F%E7%BA%BF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-03-21 14:40:15"
		},
	
		{
			"abstract": "",
			"content": "顾名思义，fhq-Treap 就是由 fhq 大佬改进的一种 Treap。**它的核心思想是不使用旋转操作，而是使用分裂和合并操作来同时维护二叉搜索树的特性和二叉堆的特性**。\n\n首先是分裂操作，顾名思义，就是把一棵 fhq-Treap 分裂成两颗 fhq-Treap。**分裂有两种方式，一种是按照权值分裂，还有一种是按照大小分裂**。而**前者更常用**，后者则通常是用来维护区间的。\n\n按照权值分裂的代码如下：\n\n```cpp\nvoid split(int u,int val,int &x,int &y) // 按权值分裂以 u 为根的树（x 子树上的所有权值都 < val，y 子树上的所有权值都 >= val） \n{\n\tif(u==0) // 如果没得分裂了 \n\t{\n\t\tx=y=0; // 赋值为 0 \n\t\treturn;\n\t}\n\tif(tree[u].val<val) // 如果 u 的权值比 val 小，那么 u 属于 x 的子树 \n\t{\n\t\tx=u; // 赋值 \n\t\tsplit(tree[u].r,val,tree[u].r,y); // 递归分裂当前 u 的右儿子（u 的左儿子都比 val 小，都属于 x 的子树） \n\t}\n\telse // 否则 u 属于 y 的子树 \n\t{\n\t\ty=u; // 赋值 \n\t\tsplit(tree[u].l,val,x,tree[u].l); // 递归分裂当前 u 的左儿子（u 的右儿子都 >= val，都属于 y 的子树） \n\t}\n\tupd(u); // 不要忘记更新节点信息 \n}\n```\n\n按大小分裂的代码如下：\n\n```cpp\nvoid split(int u,int val,int &x,int &y)\n{\n\tif(u==0)\n\t{\n\t\tx=y=0;\n\t\treturn;\n\t}\n\tif(tree[tree[u].lson].sum<val)\n\t{\n\t\tx=u;\n\t\tsplit(tree[u].rson,val-tree[tree[u].lson].sum-1,tree[u].rson,y);\n\t}\n\telse\n\t{\n\t\ty=u;\n\t\tsplit(tree[u].lson,val,x,tree[u].lson);\n\t}\n\tupd(u);\n}\n```\n\n然后是合并操作，即把两棵树合并成一棵树。合并的时候注意要同时满足二叉搜索树的特性和二叉堆的的特性。\n\n```cpp\nint merge(int x,int y) // 合并 x 的子树和 y 的子树，返回合并之后的根（x 的子树的权值必须保证都小于 y 的子树的权值） \n{\n\tif(x==0||y==0) return x+y; // 有一棵子树为空，那么返回另一棵子树的根 \n\tif(tree[x].w>tree[y].w) // 我们要保证 w 满足大根堆的特性，所以如果 x 的 w 大于 y 的 w，那么就要把 y 接到 x 下面，\n\t// 又因为 x 的子树的权值都小于 y 的子树的权值，所以 y 要接到 x 的右儿子，即让 x 的右儿子和 y 合并 \n\t{\n\t\ttree[x].r=merge(tree[x].r,y);\n\t\tupd(x); // 记得更新节点信息 \n\t\treturn x;\n\t}\n\telse // 同理 \n\t{\n\t\ttree[y].l=merge(x,tree[y].l); \n\t\tupd(y); // 记得更新节点信息 \n\t\treturn y;\n\t}\n}\n```\n\n解决了这两个最核心也最难的操作后，剩下的操作就简单了。\n\n**插入操作就相当于把整棵树扒开，然后再把要插入的节点放进去，最后再缝合起来**。这种十分暴力的行为很好写，而且还不容易出错，代码如下：\n\n```cpp\ninline void ins(int val) // 插入 \n{\n\tint x,y;\n\tsplit(rt,val,x,y); // 扒开整棵树 \n\tint u=++cnt; // 新建一个节点 \n\ttree[u].val=val;\n\ttree[u].sum=1;\n\ttree[u].w=rand();\n\trt=merge(x,merge(u,y)); // 放进去，缝合起来 \n}\n```\n\n**删除操作则相当于扒开整棵树，找到要删除的子树的根，合并它的左右儿子，再把整棵树缝合起来**。同样很暴力，代码如下：\n\n```cpp\ninline void del(int val) // 删除 \n{\n\tint x,y,z;\n\tsplit(rt,val,x,y); // 先把整棵树分为权值都小于 val 的子树 x 和权值都大于等于 val 的子树 y \n\tsplit(y,val+1,y,z); // 再把 y 的子树里权值大于 val 的子树分割出来，此时 y 子树内的权值都等于 val \n\tif(y!=0) y=merge(tree[y].l,tree[y].r); // 如果存在权值为 val 的节点，即 y!=0，则合并 y 的左右儿子 \n\trt=merge(x,merge(y,z)); // 缝合整棵树 \n}\n```\n\n**查询 `val` 的排名则相当于把扒开整棵树，然后记录下权值小于 `val` 的子树的大小 + 1，再缝合整棵树，最后返回之前记录下的答案**。代码如下：\n\n```cpp\ninline int getrk(int val) // 求 val 的排名 \n{\n\tint x,y;\n\tsplit(rt,val,x,y); // 扒开整棵树 \n\tint res=tree[x].sum+1; // 记录下权值都小于 val 的子树的大小 + 1（答案） \n\trt=merge(x,y); // 缝合整棵树 \n\treturn res; // 返回答案 \n}\n```\n\n查询排名为 `val` 的数是唯一一个没有那么暴力的操作，它是直接在 fhq-Treap ~~那布满伤痕的身体~~上进行遍历来求答案的：\n\n```cpp\ninline int getbyrk(int val) // 获取排名为 val 的数 \n{\n\tint u=rt; // 从根开始遍历 \n\twhile(1)\n\t{\n\t\tif(tree[tree[u].l].sum+1==val) break; // 如果左子树大小 + 1 == val，那么答案就是当前节点的值 \n\t\telse if(tree[tree[u].l].sum+1>val) u=tree[u].l; // 如果左子树大小 + 1 > val，那么答案在当前节点的左子树 \n\t\telse // 否则答案在当前右子树 \n\t\t{\n\t\t\tval-=tree[tree[u].l].sum+1; // 记得把 val 减去左子树大小 + 1 \n\t\t\tu=tree[u].r; \n\t\t}\n\t}\n\treturn tree[u].val; // 返回答案 \n}\n```\n\n**求前驱后继也相当于把整棵树扒开，然后再处理，最后缝合上**：\n\n```cpp\ninline int getfrt(int val) // 求前驱 \n{\n\tint x,y;\n\tsplit(rt,val,x,y); // 把整棵树扒开，前驱肯定在 x 的子树内 \n\tint u=x;\n\twhile(1) // 由于前驱是 x 子树内最大的那个值，所以要一直往右儿子去 \n\t{\n\t\tif(tree[u].r!=0) u=tree[u].r;\n\t\telse break;\n\t}\n\trt=merge(x,y); // 缝合好 \n\treturn tree[u].val; // 返回答案 \n}\n\ninline int getnxt(int val) // 求后继 \n{\n\tint x,y;\n\tsplit(rt,val+1,x,y); // 把整棵树扒开，后继肯定在 y 的子树内 \n\tint u=y;\n\twhile(1) // 由于后继是 y 子树内最小的那个值，所以要一直往左儿子去 \n\t{\n\t\tif(tree[u].l!=0) u=tree[u].l;\n\t\telse break;\n\t}\n\trt=merge(x,y); // 缝合好 \n\treturn tree[u].val; // 返回答案 \n}\n```\n\n最终[模板题](https://www.luogu.com.cn/problem/P3369)代码如下：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n\nusing namespace std;\n\nstruct node\n{\n\tint val,w;\n\tint sum;\n\tint l,r;\n}tree[100005];\n\nint q;\nint cnt,rt;\n\ninline void upd(int u)\n{\n\ttree[u].sum=tree[tree[u].l].sum+tree[tree[u].r].sum+1;\n}\n\nvoid split(int u,int val,int &x,int &y) // 按权值分裂以 u 为根的树（x 子树上的所有权值都 < val，y 子树上的所有权值都 >= val） \n{\n\tif(u==0) // 如果没得分裂了 \n\t{\n\t\tx=y=0; // 赋值为 0 \n\t\treturn;\n\t}\n\tif(tree[u].val<val) // 如果 u 的权值比 val 小，那么 u 属于 x 的子树 \n\t{\n\t\tx=u; // 赋值 \n\t\tsplit(tree[u].r,val,tree[u].r,y); // 递归分裂当前 u 的右儿子（u 的左儿子都比 val 小，都属于 x 的子树） \n\t}\n\telse // 否则 u 属于 y 的子树 \n\t{\n\t\ty=u; // 赋值 \n\t\tsplit(tree[u].l,val,x,tree[u].l); // 递归分裂当前 u 的左儿子（u 的右儿子都 >= val，都属于 y 的子树） \n\t}\n\tupd(u); // 不要忘记更新节点信息 \n}\n\nint merge(int x,int y) // 合并 x 的子树和 y 的子树，返回合并之后的根（x 的子树的权值必须保证都小于 y 的子树的权值） \n{\n\tif(x==0||y==0) return x+y; // 有一棵子树为空，那么返回另一棵子树的根 \n\tif(tree[x].w>tree[y].w) // 我们要保证 w 满足大根堆的特性，所以如果 x 的 w 大于 y 的 w，那么就要把 y 接到 x 下面，\n\t// 又因为 x 的子树的权值都小于 y 的子树的权值，所以 y 要接到 x 的右儿子，即让 x 的右儿子和 y 合并 \n\t{\n\t\ttree[x].r=merge(tree[x].r,y);\n\t\tupd(x); // 记得更新节点信息 \n\t\treturn x;\n\t}\n\telse // 同理 \n\t{\n\t\ttree[y].l=merge(x,tree[y].l); \n\t\tupd(y); // 记得更新节点信息 \n\t\treturn y;\n\t}\n}\n\ninline void ins(int val) // 插入 \n{\n\tint x,y;\n\tsplit(rt,val,x,y); // 扒开整棵树 \n\tint u=++cnt; // 新建一个节点 \n\ttree[u].val=val;\n\ttree[u].sum=1;\n\ttree[u].w=rand();\n\trt=merge(x,merge(u,y)); // 放进去，缝合起来 \n}\n\ninline void del(int val) // 删除 \n{\n\tint x,y,z;\n\tsplit(rt,val,x,y); // 先把整棵树分为权值都小于 val 的子树 x 和权值都大于等于 val 的子树 y \n\tsplit(y,val+1,y,z); // 再把 y 的子树里权值大于 val 的子树分割出来，此时 y 子树内的权值都等于 val \n\tif(y!=0) y=merge(tree[y].l,tree[y].r); // 如果存在权值为 val 的节点，即 y!=0，则合并 y 的左右儿子 \n\trt=merge(x,merge(y,z)); // 缝合整棵树 \n}\n\ninline int getrk(int val) // 求 val 的排名 \n{\n\tint x,y;\n\tsplit(rt,val,x,y); // 扒开整棵树 \n\tint res=tree[x].sum+1; // 记录下权值都小于 val 的子树的大小 + 1（答案） \n\trt=merge(x,y); // 缝合整棵树 \n\treturn res; // 返回答案 \n}\n\ninline int getbyrk(int val) // 获取排名为 val 的数 \n{\n\tint u=rt; // 从根开始遍历 \n\twhile(1)\n\t{\n\t\tif(tree[tree[u].l].sum+1==val) break; // 如果左子树大小 + 1 == val，那么答案就是当前节点的值 \n\t\telse if(tree[tree[u].l].sum+1>val) u=tree[u].l; // 如果左子树大小 + 1 > val，那么答案在当前节点的左子树 \n\t\telse // 否则答案在当前右子树 \n\t\t{\n\t\t\tval-=tree[tree[u].l].sum+1; // 记得把 val 减去左子树大小 + 1 \n\t\t\tu=tree[u].r; \n\t\t}\n\t}\n\treturn tree[u].val; // 返回答案 \n}\n\ninline int getfrt(int val) // 求前驱 \n{\n\tint x,y;\n\tsplit(rt,val,x,y); // 把整棵树扒开，前驱肯定在 x 的子树内 \n\tint u=x;\n\twhile(1) // 由于前驱是 x 子树内最大的那个值，所以要一直往右儿子去 \n\t{\n\t\tif(tree[u].r!=0) u=tree[u].r;\n\t\telse break;\n\t}\n\trt=merge(x,y); // 缝合好 \n\treturn tree[u].val; // 返回答案 \n}\n\ninline int getnxt(int val) // 求后继 \n{\n\tint x,y;\n\tsplit(rt,val+1,x,y); // 把整棵树扒开，后继肯定在 y 的子树内 \n\tint u=y;\n\twhile(1) // 由于后继是 y 子树内最小的那个值，所以要一直往左儿子去 \n\t{\n\t\tif(tree[u].l!=0) u=tree[u].l;\n\t\telse break;\n\t}\n\trt=merge(x,y); // 缝合好 \n\treturn tree[u].val; // 返回答案 \n}\n\nint main()\n{\n\tsrand(time(NULL));\n\tscanf(\"%d\",&q);\n\twhile(q--)\n\t{\n\t\tint opt,x;\n\t\tscanf(\"%d%d\",&opt,&x);\n\t\tif(opt==1) ins(x);\n\t\tif(opt==2) del(x);\n\t\tif(opt==3) printf(\"%d\\n\",getrk(x));\n\t\tif(opt==4) printf(\"%d\\n\",getbyrk(x));\n\t\tif(opt==5) printf(\"%d\\n\",getfrt(x));\n\t\tif(opt==6) printf(\"%d\\n\",getnxt(x));\n\t}\n\treturn 0;\n}\n```\n",
			"tags": [{"name":"学习笔记"},{"name":"数据结构"},{"name":"平衡树"}],
			"title": "fhq-Treap 学习笔记",
			"link": "https://exber.qzz.io/post/fhq-Treap%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-03-21 13:57:59"
		},
	
		{
			"abstract": "",
			"content": "Treap 是平衡树的一种，也是一棵[笛卡尔树](../笛卡尔树学习笔记/)。**它是一种随机数据结构，相当于 $w_i$ 是随机数的笛卡尔树**。\n\n[模板题](https://www.luogu.com.cn/problem/P3369)\n\n首先对于一个节点，我们**不仅需要保存二叉搜索树的几个值，还要保存 $w_i$**。节点结构体定义如下：\n\n```cpp\nstruct node\n{\n    int val,w; // 数值，权值 w \n    int cnt,sum; // 数值个数，子树大小 \n    int l,r; // 左右儿子 \n}tree[100005];\n```\n\n朴素的笛卡尔树并没有插入和删除的操作，而作为平衡树，Treap 必须支持这两种操作。但是**插入和删除的过程中还要维护堆的特性，需要进行旋转操作**，即二叉堆中的把某个儿子提上来。\n\n由于旋转时还需要维护二叉搜索树的特性，所以旋转稍微有点复杂：\n\n![](../post-images/1679378235803.webp)\n\n这样旋转不但可以做到把某个儿子提上来，还可以维护二叉搜索树的特性。\n\n左旋右旋代码如下：\n\n```cpp\ninline void upd(int u)\n{\n    tree[u].sum=tree[tree[u].l].sum+tree[tree[u].r].sum+tree[u].cnt;\n}\n\ninline void lrot(int &u) // 左旋 \n{\n\tint t=tree[u].r; // 先存下 Y 的编号\n    tree[u].r=tree[t].l; // 右儿子变成 B \n    tree[t].l=u; // Y 的左儿子变成 X \n    tree[t].sum=tree[u].sum; // Y 变成了之前 X 的子树的根 \n    upd(u); // 更新 X 的子树大小 \n    u=t; // 完成旋转 \n}\n\ninline void rrot(int &u) // 右旋，和左旋原理一样 \n{\n\tint t=tree[u].l;\n    tree[u].l=tree[t].r;\n    tree[t].r=u;\n    tree[t].sum=tree[u].sum;\n    upd(u);\n    u=t;\n}\n```\n\n有了左旋右旋，插入和删除就不难实现了。\n\n插入：\n\n```cpp\nvoid ins(int &u,int val) // 插入 \n{\n    if(u==0) // 如果递归到了空节点，那么在这里插入 \n    {\n        u=++cnt;\n        tree[u].val=val;\n        tree[u].cnt=1;\n        tree[u].sum=1;\n        tree[u].w=rand(); // 随机化权值 w \n        return;\n    }\n    tree[u].sum++; // 子树大小 ++ \n    if(val==tree[u].val) tree[u].cnt++; // 如果找到了值为 val 的节点，那么该节点的数值个数 ++ \n    else if(val<tree[u].val)\n    {\n        ins(tree[u].l,val); // 往左子树插入 \n        if(tree[tree[u].l].w<tree[u].w) rrot(u); // 维护二叉堆的性质 \n    }\n    else\n    {\n        ins(tree[u].r,val); // 往右子树插入 \n        if(tree[tree[u].r].w<tree[u].w) lrot(u); // 维护二叉堆的性质 \n    }\n}\n```\n\n删除：（返回值为成不成功，即有没有找到值为 `val` 的节点）\n\n```cpp\nbool del(int &u,int val) // 删除 \n{\n    if(u==0) return false; // 递归到了空节点，删除失败 \n    if(val==tree[u].val) // 找到了 \n    {\n        if(tree[u].cnt>1) // 删除之后节点还存在 \n        {\n        \ttree[u].sum--;\n            tree[u].cnt--;\n            return true; // 删除成功 \n        }\n        else\n        {\n        \tif(tree[u].l==0||tree[u].r==0) // 只有一个儿子或者没有儿子，那么直接用儿子替换当前节点 \n\t\t\t{\n\t\t\t\tu=tree[u].l+tree[u].r;\n\t\t\t\treturn true; // 删除成功 \n\t\t\t}\n            else // 有两个儿子，那么我们可以把当前节点通过左旋右旋往下移动，直到可以直接删除 \n            {\n                if(tree[tree[u].l].w<tree[tree[u].r].w) // 需要提左儿子上来 \n                {\n                    rrot(u); // 右旋 \n                    return del(u,val); // 递归，注意递归的节点必须是 u \n                }\n                else // 需要提右儿子上来 \n                {\n                    lrot(u);\n                    return del(u,val); // 递归，注意递归的节点必须是 u \n                }\n            }\n        }\n    }\n    else if(val<tree[u].val) \n\t{\n\t\tbool f=del(tree[u].l,val); // 往左子树递归 \n\t\tif(f) tree[u].sum--; // 如果删除成功，那么子树大小 -- \n\t\treturn f;\n\t}\n\telse\n\t{\n\t\tbool f=del(tree[u].r,val); // 往右子树递归 \n\t\tif(f) tree[u].sum--; // 如果删除成功，那么子树大小 -- \n\t\treturn f;\n\t}\n}\n```\n\n解决了插入删除两个比较困难的操作后，剩下的操作就非常好实现了。\n\n求排名：\n\n```cpp\nint getrk(int u,int val)\n{\n    if(u==0) return 1;\n    if(tree[u].val==val) return tree[tree[u].l].sum+1;\n    else if(val<tree[u].val) return getrk(tree[u].l,val);\n    else return tree[tree[u].l].sum+tree[u].cnt+getrk(tree[u].r,val);\n}\n```\n\n求排名为 `val` 的数：\n\n```cpp\nint getbyrk(int u,int val)\n{\n    if(u==0) return 0;\n    if(val<=tree[tree[u].l].sum) return getbyrk(tree[u].l,val);\n    else if(val<=tree[tree[u].l].sum+tree[u].cnt) return tree[u].val;\n    else return getbyrk(tree[u].r,val-tree[tree[u].l].sum-tree[u].cnt);\n}\n```\n\n求前驱后继：\n\n```cpp\nint getfrt(int u,int val)\n{\n    if(u==0) return -inf;\n    if(val<=tree[u].val) return getfrt(tree[u].l,val);\n    else return max(tree[u].val,getfrt(tree[u].r,val));\n}\n\nint getnxt(int u,int val)\n{\n    if(u==0) return inf;\n    if(val>=tree[u].val) return getnxt(tree[u].r,val);\n    else return min(tree[u].val,getnxt(tree[u].l,val));\n}\n```\n\n完整代码：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n\nusing namespace std;\n\n#define inf (((long long)1<<31)-1)\n\nstruct node\n{\n    int val,w; // 数值，权值 w \n    int cnt,sum; // 数值个数，子树大小 \n    int l,r; // 左右儿子 \n}tree[100005];\n\nint q,cnt,rt;\n\ninline void upd(int u)\n{\n    tree[u].sum=tree[tree[u].l].sum+tree[tree[u].r].sum+tree[u].cnt;\n}\n\ninline void lrot(int &u) // 左旋 \n{\n\tint t=tree[u].r; // 先存下 Y 的编号\n    tree[u].r=tree[t].l; // 右儿子变成 B \n    tree[t].l=u; // Y 的左儿子变成 X \n    tree[t].sum=tree[u].sum; // Y 变成了之前 X 的子树的根 \n    upd(u); // 更新 X 的子树大小 \n    u=t; // 完成旋转 \n}\n\ninline void rrot(int &u) // 右旋，和左旋原理一样 \n{\n\tint t=tree[u].l;\n    tree[u].l=tree[t].r;\n    tree[t].r=u;\n    tree[t].sum=tree[u].sum;\n    upd(u);\n    u=t;\n}\n\nvoid ins(int &u,int val) // 插入 \n{\n    if(u==0) // 如果递归到了空节点，那么在这里插入 \n    {\n        u=++cnt;\n        tree[u].val=val;\n        tree[u].cnt=1;\n        tree[u].sum=1;\n        tree[u].w=rand(); // 随机化权值 w \n        return;\n    }\n    tree[u].sum++; // 子树大小 ++ \n    if(val==tree[u].val) tree[u].cnt++; // 如果找到了值为 val 的节点，那么该节点的数值个数 ++ \n    else if(val<tree[u].val)\n    {\n        ins(tree[u].l,val); // 往左子树插入 \n        if(tree[tree[u].l].w<tree[u].w) rrot(u); // 维护二叉堆的性质 \n    }\n    else\n    {\n        ins(tree[u].r,val); // 往右子树插入 \n        if(tree[tree[u].r].w<tree[u].w) lrot(u); // 维护二叉堆的性质 \n    }\n}\n\nbool del(int &u,int val) // 删除 \n{\n    if(u==0) return false; // 递归到了空节点，删除失败 \n    if(val==tree[u].val) // 找到了 \n    {\n        if(tree[u].cnt>1) // 删除之后节点还存在 \n        {\n        \ttree[u].sum--;\n            tree[u].cnt--;\n            return true; // 删除成功 \n        }\n        else\n        {\n        \tif(tree[u].l==0||tree[u].r==0) // 只有一个儿子或者没有儿子，那么直接用儿子替换当前节点 \n\t\t\t{\n\t\t\t\tu=tree[u].l+tree[u].r;\n\t\t\t\treturn true; // 删除成功 \n\t\t\t}\n            else // 有两个儿子，那么我们可以把当前节点通过左旋右旋往下移动，直到可以直接删除 \n            {\n                if(tree[tree[u].l].w<tree[tree[u].r].w) // 需要提左儿子上来 \n                {\n                    rrot(u); // 右旋 \n                    return del(u,val); // 递归，注意递归的节点必须是 u \n                }\n                else // 需要提右儿子上来 \n                {\n                    lrot(u);\n                    return del(u,val); // 递归，注意递归的节点必须是 u \n                }\n            }\n        }\n    }\n    else if(val<tree[u].val) \n\t{\n\t\tbool f=del(tree[u].l,val); // 往左子树递归 \n\t\tif(f) tree[u].sum--; // 如果删除成功，那么子树大小 -- \n\t\treturn f;\n\t}\n\telse\n\t{\n\t\tbool f=del(tree[u].r,val); // 往右子树递归 \n\t\tif(f) tree[u].sum--; // 如果删除成功，那么子树大小 -- \n\t\treturn f;\n\t}\n}\n\nint getrk(int u,int val)\n{\n    if(u==0) return 1;\n    if(tree[u].val==val) return tree[tree[u].l].sum+1;\n    else if(val<tree[u].val) return getrk(tree[u].l,val);\n    else return tree[tree[u].l].sum+tree[u].cnt+getrk(tree[u].r,val);\n}\n\nint getbyrk(int u,int val)\n{\n    if(u==0) return 0;\n    if(val<=tree[tree[u].l].sum) return getbyrk(tree[u].l,val);\n    else if(val<=tree[tree[u].l].sum+tree[u].cnt) return tree[u].val;\n    else return getbyrk(tree[u].r,val-tree[tree[u].l].sum-tree[u].cnt);\n}\n\nint getfrt(int u,int val)\n{\n    if(u==0) return -inf;\n    if(val<=tree[u].val) return getfrt(tree[u].l,val);\n    else return max(tree[u].val,getfrt(tree[u].r,val));\n}\n\nint getnxt(int u,int val)\n{\n    if(u==0) return inf;\n    if(val>=tree[u].val) return getnxt(tree[u].r,val);\n    else return min(tree[u].val,getnxt(tree[u].l,val));\n}\n\nint main()\n{\n  \tsrand(time(NULL));\n    scanf(\"%d\",&q);\n    while(q--)\n    {\n        int opt,x;\n        scanf(\"%d%d\",&opt,&x);\n        if(opt==1) ins(rt,x);\n        if(opt==2) del(rt,x);\n        if(opt==3) printf(\"%d\\n\",getrk(rt,x));\n        if(opt==4) printf(\"%d\\n\",getbyrk(rt,x));\n        if(opt==5) printf(\"%d\\n\",getfrt(rt,x));\n        if(opt==6) printf(\"%d\\n\",getnxt(rt,x));\n    }\n    return 0;\n}\n```\n",
			"tags": [{"name":"学习笔记"},{"name":"数据结构"},{"name":"平衡树"}],
			"title": "Treap 学习笔记",
			"link": "https://exber.qzz.io/post/Treap%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-03-21 13:55:57"
		},
	
		{
			"abstract": "",
			"content": "笛卡尔树是一种特殊的二叉树，**它的每个节点有两个权值 $k_i$ 和 $w_i$**。**对于权值 $k_i$，满足二叉搜索树的特性**，即父节点的 $k_i$ 严格大于它左儿子的 $k_i$，它右儿子的 $k_i$ 又严格大于它的 $k_i$。而**对于权值 $w_i$，满足小根堆的特性**，即父节点的 $w_i$ 小于等于它儿子的 $w_i$。\n\n\n例如下图就是一棵 $w_i$ 为圆圈里的数的笛卡尔树。\n\n![](../post-images/1679364393896.webp)\n\n考虑笛卡尔树的构建。**首先对 $k_i$ 排过序，那么新加进来的节点肯定在右链上**（右链即从根节点一直往右儿子去所形成的链）。此时可以**使用单调栈来维护右链，进行 $O(n)$ 的建树**。\n\n建树过程类似下图（圆圈里的数为 $w_i$）：\n\n![](../post-images/1679364398543.webp)\n\n建树代码：\n\n```cpp\nsta[++top]=1;\nfor(int i=2;i<=n;i++)\n{\n\twhile(w[sta[top]]>w[i]&&top>0)\n\t{\n\t\ttop--;\n\t}\n\tif(top==0)\n\t{\n\t\tson[i][0]=sta[top+1];\n\t}\n\telse\n\t{\n\t\tson[i][0]=son[sta[top]][1];\n\t\tson[sta[top]][1]=i;\n\t}\n\tsta[++top]=i;\n}\n```\n\n练习题目：\n\n- [P5854 【模板】笛卡尔树](https://www.luogu.com.cn/problem/P5854)\n\n- [P1377 [TJOI2011]树的序](https://www.luogu.com.cn/problem/P1377)\n\n- [SP3734 PERIODNI - Periodni](https://www.luogu.com.cn/problem/SP3734)\n\n- [P6453 [COCI2008-2009#4] F](https://www.luogu.com.cn/problem/P6453)\n\n- [P7988 [USACO21DEC] HILO G](https://www.luogu.com.cn/problem/P7988)\n",
			"tags": [{"name":"学习笔记"},{"name":"数据结构"},{"name":"平衡树"}],
			"title": "笛卡尔树学习笔记",
			"link": "https://exber.qzz.io/post/%E7%AC%9B%E5%8D%A1%E5%B0%94%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-03-21 10:03:53"
		},
	
		{
			"abstract": "",
			"content": "欧拉函数，一般写作 $\\varphi$ 或者 $\\phi$。$\\varphi(x)$ 表示的是 **$[1,x]$ 区间内有多少个数与 $x$ 互质（最大公因数为 `1`）**。\n\n- 性质 1：当 $p$ 为质数时 $\\varphi(p)=p-1$。\n\n- 性质 2：设 $p_i$ 表示 $x$ 的第 $i$ 个质因子，$n$ 表示 $x$ 的质因子个数，则 $\\varphi(x)=x\\prod\\limits_{i=1}^n\\frac{p_i-1}{p_i}$。\n\n> 只有不是 $x$ 的质因子的倍数的数才和 $x$ 互质；\n>\n> 第一个质因子的倍数共有 $x\\times \\frac{1}{p_i}$ 个，那么和第一个质因子互质的数就有 $x\\times \\frac{p_i-1}{p_i}$ 个；\n>\n> 这 $x\\times \\frac{p_i-1}{p_i}$ 个数里，和第二个质因子互质的个数又有 $x\\times \\frac{p_i-1}{p_i}$ 个；\n>\n> 一直乘下去，便得到 $\\varphi(x)=x\\prod\\limits_{i=1}^n\\frac{p_i-1}{p_i}$。\n\n- 性质 3：$\\varphi(xy)=\\varphi(x)\\varphi(y)\\times\\frac{\\gcd(x,y)}{\\varphi(\\gcd(x,y))}$\n\n> 考虑 $\\varphi(x)=x\\prod\\limits_{i=1}^n\\frac{p_i-1}{p_i}$，观察到 $\\varphi(x)\\varphi(y)=xy\\prod\\limits_{i=1}^m\\frac{p_i-1}{p_i}$ 多乘了 $\\gcd(x,y)$ 的质因子的 $\\frac{p_i-1}{p_i}$，所以要除掉 $\\frac{\\varphi(\\gcd(x,y))}{\\gcd(x,y)}$。\n\n- 性质 4：若 $p$ 是 $x$ 的一个质因子，$\\varphi(xp)=\\varphi(x)\\cdot p$。\n\n> **若 $gcd(x,y) = 1$，$gcd(x,y+x) = 1$**。\n\n- 性质 5：$\\sum\\limits_{d|n}\\varphi(d)=n$\n\n> **设 $n$ 个分数 $\\dfrac{1}{n}\\dfrac{2}{n}\\dfrac{3}{n}...\\dfrac{n}{n}$，全部化到最简后，分母显然全部是 $n$ 的因子，而分母 $d$ 有 $\\varphi(d)$ 个**，又因为分母总共有 $n$ 个，所以得证。\n\n以上性质的具体证明可以看[这篇文章](https://blog.csdn.net/qq_37493070/article/details/81988725)。\n\n有了这些特质，我们便可以结合欧拉筛来实现 $O(n)$ 求 $x\\in[1,n]$ 的 $\\varphi(x)$ 了。\n\n代码如下：\n\n```cpp\nint fhi[100005];\nbool nop[100005];\nint tot,prime[100005];\nint n;\n\nvoid init()\n{\n\tnop[0]=true; // 0 不是质数\n\tnop[1]=true; // 1 不是质数\n\tfhi[1]=1; // 1 和 1 互质（\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tif(!nop[i])\n\t\t{\n\t\t\tprime[++tot]=i;\n\t\t\tfhi[i]=i-1; // 是一个质数，fhi(i) 满足性质 1\n\t\t}\n\t\tfor(int j=1;j<=tot;j++)\n\t\t{\n\t\t\tif(i*prime[j]>n)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnop[i*prime[j]]=true;\n\t\t\tif(i%prime[j]==0)\n\t\t\t{\n\t\t\t\tfhi[i*prime[j]]=fhi[i]*prime[j]; // prime[j] 是 i 的一个质因子，满足性质 4\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfhi[i*prime[j]]=fhi[i]*fhi[prime[j]]; // i 和 prime[j] 互质，满足性质 3\n\t\t}\n\t}\n}\n```\n\n### 练习题目\n\n[P2158 [SDOI2008] 仪仗队](https://www.luogu.com.cn/problem/P2158)\n\n[P2398 GCD SUM](https://www.luogu.com.cn/problem/P2398)\n\n[P1390 公约数的和](https://www.luogu.com.cn/problem/P1390)\n\n[P2568 GCD](https://www.luogu.com.cn/problem/P2568)\n\n[LOJ 6179 Pyh 的求和](https://loj.ac/p/6179)\n\n",
			"tags": [{"name":"学习笔记"},{"name":"数学"},{"name":"数论"}],
			"title": "欧拉函数学习笔记",
			"link": "https://exber.qzz.io/post/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-03-21 10:02:56"
		},
	
		{
			"abstract": "",
			"content": "Trie，即字典树，也就是一颗功能上很像字典的树。\n\nTrie 经常**用于维护一些关于字符串的东西**，例如给定一些字符串，询问给定的字符串里有没有 $s$。又例如给定一些字符串，询问给定的字符串里有多少个前缀为 $s$。\n\nTrie 的主要思路是**以空间换时间**，每**一条边上都有一个字符类型的权值，根节点到节点 $x$ 的路径上所有字符拼接起来便是 $x$ 所代表的的字符串。**\n\n注意 **Trie 的节点里还要保存它所表示的字符串是不是给出的字符串。**\n\n**经典例题**\n\n[P2580 于是他错误的点名开始了](https://www.luogu.com.cn/problem/P2580)\n\n完整代码：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nint n,m;\nchar s[105];\nint sons[500005][26]; // 大小是 50*10000 \nint cnt;\nbool vis[500005],endd[500005];\n\nvoid ins(int u,string str)\n{\n\tif(str.empty()) // 搞完了，标记一下这个点代表的字符串是给定的\n\t{\n\t\tendd[u]=true;\n\t\treturn;\n\t}\n\tif(sons[u][str[0]-'a']==0)\n\t{\n\t\tsons[u][str[0]-'a']=++cnt; // 没有这个儿子，新开一个点\n\t}\n\tins(sons[u][str[0]-'a'],str.substr(1)); // 递归下去\n}\n\nint que(int u,string str)\n{\n\tif(str.empty()) // 搞完了\n\t{\n\t\tif(endd[u]) // 是给定的字符串\n\t\t{\n\t\t\tif(vis[u]) // 访问过\n\t\t\t{\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\tvis[u]=true;\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\tif(sons[u][str[0]-'a']==0) // 没有节点可以代表 str\n\t{\n\t\treturn 0;\n\t}\n\treturn que(sons[u][str[0]-'a'],str.substr(1)); // 递归下去\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tcnt=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%s\",s);\n\t\tins(1,s);\n\t}\n\tscanf(\"%d\",&m);\n\twhile(m--)\n\t{\n\t\tscanf(\"%s\",s);\n\t\tint res=que(1,s);\n\t\tputs(res==1?\"OK\":(res==2?\"REPEAT\":\"WRONG\"));\n\t}\n\treturn 0;\n}\n```\n\n[LOJ2742 销售基因链（JOI Open 2016 T2 「RNA 鎖の販売 / Selling RNA Strands」）](https://vjudge.csgrandeur.cn/problem/LibreOJ-2742)\n\n[JOI 原题](https://contests.ioi-jp.org/open-2016/index.html)\n\n首先对所有字符串和其翻转串建出 Trie 树，这样问题就变成了求同时在两棵树的两个子树中的字符串的个数。\n\n考虑 dfs 序，把子树映射为区间之后就变成了二维数点问题，可以直接离线下来做。\n\n代码如下：\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n\nusing namespace std;\n\nconst int S=5000005;\n\nstruct node\n{\n\tint x,y;\n}a[S],que[S];\n\nstruct node2\n{\n\tint x,y,id,tpe;\n};\n\nint n,q;\nchar str[S];\nint cnt1=1,son1[S][4];\nint cnt2=1,son2[S][4];\nvector<int> idx1[S],idx2[S];\nint tt1,dfn1[S];\nint tt2,dfn2[S];\nint lx[S],rx[S],ly[S],ry[S];\nint m;\nnode2 pts[S];\nint c[S],res[S];\n\ninline int id(char x)\n{\n\treturn x=='A'?0:(x=='U'?1:(x=='G'?2:3));\n}\n\nvoid ins1(int idd)\n{\n\tint u=1,n=strlen(str+1);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x=id(str[i]);\n\t\tif(son1[u][x]==0) son1[u][x]=++cnt1;\n\t\tu=son1[u][x];\n\t}\n\tidx1[u].push_back(idd);\n}\n\nvoid ins2(int idd)\n{\n\tint u=1,n=strlen(str+1);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x=id(str[i]);\n\t\tif(son2[u][x]==0) son2[u][x]=++cnt2;\n\t\tu=son2[u][x];\n\t}\n\tidx2[u].push_back(idd);\n}\n\nvoid dfs1(int u)\n{\n\tlx[u]=dfn1[u]=++tt1;\n\tfor(int i:idx1[u]) a[i].x=tt1;\n\tfor(int i=0;i<4;i++) if(son1[u][i]!=0) dfs1(son1[u][i]); \n\trx[u]=tt1;\n}\n\nvoid dfs2(int u)\n{\n\tly[u]=dfn2[u]=++tt2;\n\tfor(int i:idx2[u]) a[i].y=tt2;\n\tfor(int i=0;i<4;i++) if(son2[u][i]!=0) dfs2(son2[u][i]);\n\try[u]=tt2;\n}\n\nint got1()\n{\n\tint u=1,n=strlen(str+1);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x=id(str[i]);\n\t\tu=son1[u][x];\n\t}\n\treturn u;\n}\n\nint got2()\n{\n\tint u=1,n=strlen(str+1);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x=id(str[i]);\n\t\tu=son2[u][x];\n\t}\n\treturn u;\n}\n\nvoid addd(int pos,int val)\n{\n\tfor(int i=pos;i<=S-3;i+=i&-i) c[i]+=val;\n}\n\nint quee(int pos)\n{\n\tint res=0;\n\tfor(int i=pos;i>=1;i-=i&-i) res+=c[i];\n\treturn res;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&q);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%s\",str+1);\n\t\tins1(i);\n\t\tint len=strlen(str+1);\n\t\tfor(int j=1;j<=len/2;j++) swap(str[j],str[len-j+1]);\n\t\tins2(i);\n\t}\n\tdfs1(1),dfs2(1);\n\tfor(int i=1;i<=q;i++)\n\t{\n\t\tscanf(\"%s\",str+1);\n\t\tque[i].x=got1();\n\t\tscanf(\"%s\",str+1);\n\t\tint len=strlen(str+1);\n\t\tfor(int j=1;j<=len/2;j++) swap(str[j],str[len-j+1]);\n\t\tque[i].y=got2();\n\t}\n\tfor(int i=1;i<=q;i++)\n\t{\n//\t\tprintf(\"[%d %d] [%d %d]\\n\",lx[que[i].x],rx[que[i].x],ly[que[i].y],ry[que[i].y]);\n\t\tif(que[i].x==0||que[i].y==0) continue;\n\t\tpts[++m]=(node2){rx[que[i].x],ry[que[i].y],i,1};\n\t\tpts[++m]=(node2){lx[que[i].x]-1,ry[que[i].y],i,-1};\n\t\tpts[++m]=(node2){rx[que[i].x],ly[que[i].y]-1,i,-1};\n\t\tpts[++m]=(node2){lx[que[i].x]-1,ly[que[i].y]-1,i,1};\n\t}\n\tsort(a+1,a+n+1,[&](node x,node y){return x.x<y.x;});\n\tsort(pts+1,pts+m+1,[&](node2 x,node2 y){return x.x<y.x;});\n//\tfor(int i=1;i<=n;i++) printf(\"%d %d\\n\",a[i].x,a[i].y);\n\tfor(int i=1,j=1;i<=m;i++)\n\t{\n\t\twhile(j<=n&&a[j].x<=pts[i].x) addd(a[j++].y,1);\n\t\tint pre=quee(pts[i].y);\n\t\tres[pts[i].id]+=pre*pts[i].tpe;\n\t}\n\tfor(int i=1;i<=q;i++) printf(\"%d\\n\",res[i]);\n\treturn 0;\n}\n```\n\n",
			"tags": [{"name":"学习笔记"},{"name":"数据结构"},{"name":"字符串"}],
			"title": "Trie 学习笔记",
			"link": "https://exber.qzz.io/post/Trie%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-03-21 10:01:46"
		},
	
		{
			"abstract": "",
			"content": "最小割树，顾名思义，就是**用来快速求出两点之间最小割的一种树**。\n\n**经典例题**\n\n[P4897 【模板】最小割树（Gomory-Hu Tree）](https://www.luogu.com.cn/problem/P4897)\n\n不难发现，求出两点之间的最小割为 $val$ 后，**整个图会被分成互不连通的两部分，不妨使用集合 $A$ 和集合 $B$ 表示**。不难发现，**对于所有 $x\\in A,y\\in B$，都有 $\\operatorname{mincut}(x,y)\\le val$（$\\forall x\\in A,y\\in B,\\exists \\operatorname{mincut}(x,y)\\le val$）**。\n\n根据这条性质，我们便可以画一个这样的图：\n\n![](../post-images/1679363999778.webp)\n\n接下来，我们可以再细分下去：\n\n![](../post-images/1679363996082.webp)\n\n然后继续细分：\n\n![](../post-images/1679363990343.webp)\n\n这样，我们就造出了一棵树。不难发现，**树上 $x,y$ 两点之间的路径上的最小边权和便是 $\\operatorname{mincut}(x,y)$，用倍增即可实现 $O(\\log n)$ 最小割查询**。\n\n完整代码：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\n#define S 100005\n#define MS 1005\n\nint n,m,q,s,t;\nint ineu[S],inev[S],inew[S];\nint esum,to[S],c[S],nxt[S],h[MS];\nint dep[MS],cur[MS];\nint esum2,to2[S],c2[S],nxt2[S],h2[MS];\nint nd[MS],tot1,tmp1[MS],tot2,tmp2[MS];\nint depp[MS],up[MS][30],minn[MS][30];\n\ninline void init()\n{\n\tesum=1;\n\tmemset(h,0,sizeof(h));\n}\n\ninline void add(int x,int y,int w)\n{\n\tto[++esum]=y;\n\tc[esum]=w;\n\tnxt[esum]=h[x];\n\th[x]=esum;\n}\n\ninline void add2(int x,int y,int w)\n{\n\tto2[++esum2]=y;\n\tc2[esum2]=w;\n\tnxt2[esum2]=h2[x];\n\th2[x]=esum2;\n}\n\ninline bool bfs()\n{\n\tmemset(dep,0,sizeof(dep));\n\tqueue<int> q;\n\tq.push(s);\n\tdep[s]=1;\n\twhile(!q.empty())\n\t{\n\t\tint u=q.front();\n\t\tq.pop();\n\t\tfor(int i=h[u];i;i=nxt[i])\n\t\t{\n\t\t\tint v=to[i];\n\t\t\tif(c[i]>0&&dep[v]==0)\n\t\t\t{\n\t\t\t\tdep[v]=dep[u]+1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn dep[t]>0;\n}\n\nint dfs(int u,int w)\n{\n\tif(u==t)\n\t{\n\t\treturn w;\n\t}\n\tint sum=0;\n\tfor(int &i=cur[u];i;i=nxt[i])\n\t{\n\t\tint v=to[i];\n\t\tif(c[i]>0&&dep[v]==dep[u]+1)\n\t\t{\n\t\t\tint re=dfs(v,min(w,c[i]));\n\t\t\tc[i]-=re;\n\t\t\tc[i^1]+=re;\n\t\t\tw-=re;\n\t\t\tsum+=re;\n\t\t\tif(w==0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn sum;\n}\n\ninline int dinic()\n{\n\tint ans=0;\n\twhile(bfs())\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tcur[i]=h[i];\n\t\t}\n\t\tans+=dfs(s,1e8);\n\t}\n\treturn ans;\n}\n\ninline int slove(int x,int y)\n{\n\tinit();\n\ts=x;\n\tt=y;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tadd(ineu[i],inev[i],inew[i]);\n\t\tadd(inev[i],ineu[i],0);\n\t\tadd(inev[i],ineu[i],inew[i]);\n\t\tadd(ineu[i],inev[i],0);\n\t}\n\treturn dinic();\n}\n\nvoid built(int l,int r)\n{\n\tif(l==r)\n\t{\n\t\treturn; \n\t}\n\tint nans=slove(nd[l],nd[r]);\n\tadd2(nd[l],nd[r],nans);\n\tadd2(nd[r],nd[l],nans);\n\ttot1=0;\n\ttot2=0;\n\tfor(int i=l;i<=r;i++)\n\t{\n\t\tif(dep[nd[i]]>0)\n\t\t{\n\t\t\ttmp1[++tot1]=nd[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmp2[++tot2]=nd[i];\n\t\t}\n\t}\n\tfor(int i=1;i<=tot1;i++)\n\t{\n\t\tnd[l+i-1]=tmp1[i];\n\t}\n\tfor(int i=1;i<=tot2;i++)\n\t{\n\t\tnd[l+tot1-1+i]=tmp2[i];\n\t}\n\tint l1=l,r1=l+tot1-1;\n\tint l2=l+tot1,r2=r;\n\tbuilt(l1,r1);\n\tbuilt(l2,r2);\n}\n\nvoid initque(int u,int fa,int val)\n{\n\tdepp[u]=depp[fa]+1;\n\tup[u][0]=fa;\n\tminn[u][0]=val;\n\tfor(int i=1;i<=25;i++)\n\t{\n\t\tup[u][i]=up[up[u][i-1]][i-1];\n\t\tif(up[u][i]!=0)\n\t\t{\n\t\t\tminn[u][i]=min(minn[u][i-1],minn[up[u][i-1]][i-1]);\n\t\t}\n\t}\n\tfor(int i=h2[u];i;i=nxt2[i])\n\t{\n\t\tint v=to2[i];\n\t\tif(v==fa)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tinitque(v,u,c2[i]);\n\t}\n}\n\ninline int quemin(int x,int y)\n{\n\tif(depp[x]<depp[y])\n\t{\n\t\tint t=x;\n\t\tx=y;\n\t\ty=t;\n\t}\n\tint res=1e8;\n\tfor(int i=25;i>=0;i--)\n\t{\n\t\tif(depp[up[x][i]]>=depp[y])\n\t\t{\n\t\t\tres=min(res,minn[x][i]);\n\t\t\tx=up[x][i]; \n\t\t}\n\t}\n\tif(x==y)\n\t{\n\t\treturn res;\n\t}\n\tfor(int i=25;i>=0;i--)\n\t{\n\t\tif(up[x][i]!=up[y][i])\n\t\t{\n\t\t\tres=min(res,min(minn[x][i],minn[y][i]));\n\t\t\tx=up[x][i];\n\t\t\ty=up[y][i];\n\t\t}\n\t}\n\tres=min(res,min(minn[x][0],minn[y][0]));\n\treturn res;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d%d\",&ineu[i],&inev[i],&inew[i]);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tnd[i]=i;\n\t}\n\tbuilt(1,n);\n\tinitque(1,0,0);\n\tscanf(\"%d\",&q);\n\twhile(q--)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tprintf(\"%d\\n\",quemin(x,y));\n\t}\n\treturn 0;\n}\n```\n\n### 练习题目\n\n[P4123 [CQOI2016]不同的最小割](https://www.luogu.com.cn/problem/P4123)\n\n[P3329 [ZJOI2011]最小割](https://www.luogu.com.cn/problem/P3329)\n\n[UVA11594 All Pairs Maximum Flow](https://www.luogu.com.cn/problem/UVA11594)\n\n[P4214 [CERC2015]Juice Junctions](https://www.luogu.com.cn/problem/P4214)\n\n[CF343E Pumping Stations](https://www.luogu.com.cn/problem/CF343E)\n",
			"tags": [{"name":"学习笔记"},{"name":"图论"},{"name":"网络流"}],
			"title": "最小割树（GHT）学习笔记",
			"link": "https://exber.qzz.io/post/%E6%9C%80%E5%B0%8F%E5%89%B2%E6%A0%91%EF%BC%88GHT%EF%BC%89%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-03-21 09:58:59"
		},
	
		{
			"abstract": "",
			"content": "~~顾名思义，主席树就是主席想出来的一种数据结构。~~\n\n**经典例题**\n\n[P3919 【模板】可持久化线段树 1（可持久化数组）](https://www.luogu.com.cn/problem/P3919)\n\n**主席树，大名“可持久化线段树”**。线段树大家都知道，**“可持久化”即为可以访问某一版本下的树**。\n\n很容易想到，可以开 $m$ 棵线段树来实现可持久化线段树，可是**这样的空间复杂度太高了，达到了 $O(4nm)$**。\n\n但是容易发现，**每一次单点更新操作，最多只会有 $O(logn)$ 个节点被更改**。所以**对于每次单点更新操作，可以只新建出 $O(logn)$ 个节点，以节省空间**。\n\n例如这是一颗线段树：（第一个数代表版本号，第二、三个数代表区间）\n\n![](../post-images/1679363809375.webp)\n\n假设我们需要修改位置 `3` 那么就需要新增一些节点：\n\n![](../post-images/1679363818030.webp)\n\n假设我们又需要修改位置 `5` 那么又需要新增一些节点：\n\n![](../post-images/1679363824397.webp)\n\n~~所以主席树这玩意根本不是树嘛……~~\n\n怎么样，**这种沿用旧节点的思想是不是很奇妙** awa。\n\n可持久化线段树的难点主要在修改，**查询基本和线段树是一样的，只不过多了版本号，需要记下每个版本对应的根节点**。\n\n给出模板题代码：\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\n#define S 1000005\n\nusing namespace std;\n\nstruct node\n{\n\tint l,r,num;\n}tree[S*20];\n\nint n,m,cnt,a[S],r[S];\n\nvoid built(int &now,int l,int r)\n{\n\tif(l==r)\n\t{\n\t\ttree[++cnt].num=a[l];\n\t\tnow=cnt;\n\t\treturn;\n\t}\n\tint mid=l+r>>1;\n\tnow=++cnt;\n\tbuilt(tree[now].l,l,mid);\n\tbuilt(tree[now].r,mid+1,r);\n}\n\nvoid upd(int &now,int las,int l,int r,int wh,int val)\n{\n\ttree[++cnt]=tree[las];\n\tnow=cnt; \n\tif(l==r)\n\t{\n\t\ttree[now].num=val;\n\t\treturn;\n\t}\n\tint mid=l+r>>1;\n\tif(wh<=mid)\n\t{\n\t\tupd(tree[now].l,tree[las].l,l,mid,wh,val);\n\t}\n\telse\n\t{\n\t\tupd(tree[now].r,tree[las].r,mid+1,r,wh,val);\n\t}\n}\n\nint que(int now,int l,int r,int wh)\n{\n\tif(l==r)\n\t{\n\t\treturn tree[now].num;\n\t}\n\tint mid=l+r>>1;\n\tif(wh<=mid)\n\t{\n\t\treturn que(tree[now].l,l,mid,wh);\n\t}\n\telse\n\t{\n\t\treturn que(tree[now].r,mid+1,r,wh);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tbuilt(r[0],1,n);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint v,type,pos;\n\t\tscanf(\"%d%d%d\",&v,&type,&pos);\n\t\tif(type==1)\n\t\t{\n\t\t\tint val;\n\t\t\tscanf(\"%d\",&val);\n\t\t\tupd(r[i],r[v],1,n,pos,val);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"%d\\n\",que(r[v],1,n,pos));\n\t\t\tr[i]=r[v];\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n### 练习题目\n\n[P3834 【模板】可持久化线段树 2](https://www.luogu.com.cn/problem/P3834)\n\n[P3402 可持久化并查集](https://www.luogu.com.cn/problem/P3402)\n\n[P3168 [CQOI2015]任务查询系统](https://www.luogu.com.cn/problem/P3168)\n\n[P3567 [POI2014]KUR-Couriers](https://www.luogu.com.cn/problem/P3567)\n\n[P3293 [SCOI2016]美味](https://www.luogu.com.cn/problem/P3293)\n\n[P4587 [FJOI2016]神秘数](https://www.luogu.com.cn/problem/P4587)\n\n[P2617 Dynamic Rankings](https://www.luogu.com.cn/problem/P2617)\n\n[P1383 高级打字机](https://www.luogu.com.cn/problem/P1383)\n\n[P6166 [IOI2012]scrivener](https://www.luogu.com.cn/problem/P6166)\n\n[P4602 [CTSC2018]混合果汁](https://www.luogu.com.cn/problem/P4602)\n\n[P4137 Rmq Problem / mex](https://www.luogu.com.cn/problem/P4137)\n\n[P2633 Count on a tree](https://www.luogu.com.cn/problem/P2633)\n\n[P3567 [POI2014]KUR-Couriers](https://www.luogu.com.cn/problem/P3567)\n",
			"tags": [{"name":"学习笔记"},{"name":"数据结构"}],
			"title": "主席树（可持久化线段树）学习笔记",
			"link": "https://exber.qzz.io/post/%E4%B8%BB%E5%B8%AD%E6%A0%91%EF%BC%88%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%89%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-03-21 09:54:13"
		},
	
		{
			"abstract": "",
			"content": "\n![](../post-images/1679363235407.webp)\n\n练习题单：[dead_X 的莫队题单](https://www.luogu.com.cn/training/38213#information)\n\n众所周知，莫队是一种优雅的**暴力**……（两根小手指瞎跳）\n\n## Part.1 基础莫队\n### 详解\n\n莫队主要是用来求一段区间的**某种特征值**的，例如一段区间内**有多少种不同的元素**。\n\n**经典例题**\n\n```\n对于一段长度为 n 的数列，有 m 个询问，每次求一段区间 [l,r] 中有多少种不同的元素。\n\n第一行输入 n,m；\n\n接下来输入 n 个数 a[i]；\n\n接下来 m 行，每行两个数 l[i],r[i]。\n\n你需要输出 m 行，为每次询问的答案。\n\n1 <= n <= 10000\n\n1 <= m <= 100000\n\n1 <= a[i] <= 100000\n```\n\n考虑最朴素的做法，每次**暴力枚举来求答案**。可这样的做法是 $O(nm)$ 的，显然会 `T` 飞/fad。\n\n考虑优化，由于可以**从以前询问的答案通过移动左右端点来推出当前询问的答案**，所以可以这么做：\n\n```cpp\nint n,m,a[10005];\nint sum,cnt[100005];\n......\ninline void add(int x)\n{\n\tcnt[a[x]]++;\n\tif(cnt[a[x]]==1)\n\t{\n\t\tsum++;\n\t}\n}\n\ninline void del(int x)\n{\n\tcnt[a[x]]--;\n\tif(cnt[a[x]]==0)\n\t{\n\t\tsum--;\n\t}\n}\n\nint main()\n{\n\t......\n\tint lpos=1,rpos=0;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint l,r;\n\t\tscanf(\"%d%d\",&l,&r);\n\t\twhile(lpos>l) add(--lpos);\n\t\twhile(rpos<r) add(++rpos);\n\t\twhile(lpos<l) del(lpos++);\n\t\twhile(rpos>r) del(pos--);\n\t\tprintf(\"%d\\n\",sum);\n\t}\n\treturn 0;\n}\n```\n\n但是，这么做有个缺点，如果遇到这样的询问：\n```\n1 1\n10000 10000\n1 1\n10000 10000\n```\n\n那这样做就无法起到优化效果了。\n\n但是由于**询问是离线的**（不必处理完第 $i-1$ 次询问才能处理第 $i$ 次），所以我们可以**按一定方法来给询问排序**，**排序方法便是莫队算法的核心思想**。\n\n考虑如何排序，我们可以**先把整个序列分成很多长度为 $\\sqrt n$ 的小块**，因为这样做**可以分摊时间复杂度，令它大致为 $O(n\\sqrt n)$**。在排序比较函数内判断一下两次询问的左端点的块编号，如果相同那么按右端点升序排序；否则按左端点升序排序。\n\n这样排序的代码是这样的：\n\n```cpp\nstruct node\n{\n\tint l,r,id;\n}que[100005];\n\nint n,m,blo;\n......\ninline bool cmp(node x,node y)\n{\n\tint xlid=(x.l-1)/blo+1,ylid=(y.l-1)/blo+1;\n\tif(xlid==ylid)\n\t{\n\t\treturn x.r<y.r;\n\t}\n\treturn x.l<y.l;\n}\n......\nint main()\n{\n\t......\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d\",&que[i].l,&que[i].r);\n\t\tque[i].id=i;\n\t}\n\tblo=sqrt(n);\n\tsort(que+1,que+m+1,cmp);\n\t......\n\treturn 0;\n}\n\n```\n\n但是这样的排序还是能优化的。我们可以**让块编号为奇数的块左端点升序排序，块编号为偶数的块左端点降序排序**。这样其实**相当于让右端点移动得更少**，假设左端点块编号为 $i$ 的所有询问已经处理完了，现在开始处理左端点块编号为 $i+1$ 的块。如果按照之前的排序方法，右端点会**从最大值跳到最小值**。但是这样排序可以令右端点**从最大值跳到最大值或从最小值跳到最小值**，可以理解成下一块“接应”上一块 awa。\n\n这样排序的代码是这样的：（大家叫它“奇偶优化排序”）\n\n```cpp\nstruct node\n{\n\tint l,r,id;\n}que[100005];\n\nint n,m,blo;\n......\ninline bool cmp(node x,node y)\n{\n\tint xlid=(x.l-1)/blo+1,ylid=(y.l-1)/blo+1;\n\tif(xlid==ylid)\n\t{\n\t\treturn (xlid&1)?x.r<y.r:x.r>y.r;\n\t}\n\treturn x.l<y.l;\n}\n......\nint main()\n{\n\t......\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d\",&que[i].l,&que[i].r);\n\t\tque[i].id=i;\n\t}\n\tblo=sqrt(n);\n\tsort(que+1,que+m+1,cmp);\n\t......\n\treturn 0;\n}\n```\n\n至此，这道例题的莫队解法便呼之欲出了。完整代码如下：\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\nstruct node\n{\n\tint l,r,id;\n}que[100005];\n\nint n,m,blo,a[10005];\nint sum,cnt[100005];\nint ans[100005];\n\ninline bool cmp(node x,node y)\n{\n\tint xlid=(x.l-1)/blo+1,ylid=(y.l-1)/blo+1;\n\tif(xlid==ylid)\n\t{\n\t\treturn (xlid&1)?x.r<y.r:x.r>y.r;\n\t}\n\treturn x.l<y.l;\n}\n\ninline void add(int x)\n{\n\tcnt[a[x]]++;\n\tif(cnt[a[x]]==1)\n\t{\n\t\tsum++;\n\t}\n}\n\ninline void del(int x)\n{\n\tcnt[a[x]]--;\n\tif(cnt[a[x]]==0)\n\t{\n\t\tsum--;\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d\",&que[i].l,&que[i].r);\n\t\tque[i].id=i;\n\t}\n\tblo=sqrt(n);\n\tsort(que+1,que+m+1,cmp);\n\tint lpos=1,rpos=0;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint l=que[i].l,r=que[i].r,id=que[i].id;\n\t\twhile(lpos>l) add(--lpos);\n\t\twhile(rpos<r) add(++rpos);\n\t\twhile(lpos<l) del(lpos++);\n\t\twhile(rpos>r) del(pos--);\n\t\tans[id]=sum;\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tprintf(\"%d\\n\",ans[i]);\n\t}\n\treturn 0;\n}\n```\n\n### 练习题目\n[P3901 数列找不同](https://www.luogu.com.cn/problem/P3901)\n\n[P1494 [国家集训队]小Z的袜子](https://www.luogu.com.cn/problem/P1494)\n\n[CF86D Powerful array](https://www.luogu.com.cn/problem/CF86D)\n\n[P2709 小B的询问](https://www.luogu.com.cn/problem/P2709)\n\n[P5355 [Ynoi2017] 由乃的玉米田](https://www.luogu.com.cn/problem/P5355)\n[双倍经验](https://www.luogu.com.cn/problem/P3674)\n\n[P5072 [Ynoi 2015] 盼君莫忘](https://www.luogu.com.cn/problem/P5072)\n\n## Part.2 带修莫队\n\n基础的莫队是不支持修改操作的，不过想要支持也不是不可以，只需要加上一条时间轴即可。\n\n[例题：P1903 [国家集训队]数颜色 / 维护队列](https://www.luogu.com.cn/problem/P1903)\n\n这题除了有修改操作外和普通莫队的例题差不多，所以可以直接把上一题的代码拿过来用。不过需要给询问结构体多加一个变量来存当前询问是第几次修改之后的，移动区间也要在时间轴上移动，而排序时也要根据时间轴排序。\n\n最后值得注意的一点是，带修莫队的块长是 $n^{2/3}$，具体讲解可以看[这一篇博客](https://blog.csdn.net/chenxiaoran666/article/details/82220385)。\n\n完整代码如下：\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n\n#define S1 200005\n#define S2 1000005\n\nusing namespace std;\n\nstruct node\n{\n\tint l,r,gsum,id;\n}que[S1];\n\nstruct change\n{\n\tint wh,lst,nxt;\n}cge[S1];\n\nint n,m,a[S1];\nint suma,sumc;\nint lpos=1,rpos,preans,cgecnt,cnt[S2];\nint blo;\nint ans[S1];\n\ninline bool cmp(node x,node y)\n{\n\tint xlid=(x.l-1)/blo+1,ylid=(y.l-1)/blo+1;\n\tint xrid=(x.r-1)/blo+1,yrid=(y.r-1)/blo+1;\n\tif(xlid==ylid)\n\t{\n\t\tif(xrid==yrid)\n\t\t{\n\t\t\treturn x.gsum<y.gsum;\n\t\t}\n\t\treturn x.r<y.r;\n\t}\n\treturn x.l<y.l;\n}\n\ninline void add(int x)\n{\n\tcnt[a[x]]++;\n\tif(cnt[a[x]]==1)\n\t{\n\t\tpreans++;\n\t}\n}\n\ninline void del(int x)\n{\n\tcnt[a[x]]--;\n\tif(cnt[a[x]]==0)\n\t{\n\t\tpreans--;\n\t}\n}\n\ninline void upd(int type)\n{\n\tif(type==-1)\n\t{\n\t\tint pt=cge[cgecnt].wh;\n\t\tif(pt>=lpos&&pt<=rpos)\n\t\t{\n\t\t\tdel(pt);\n\t\t}\n\t\ta[pt]=cge[cgecnt].lst;\n\t\tif(pt>=lpos&&pt<=rpos)\n\t\t{\n\t\t\tadd(pt);\n\t\t}\n\t}\n\tcgecnt+=type;\n\tif(type==1)\n\t{\n\t\tint pt=cge[cgecnt].wh;\n\t\tif(pt>=lpos&&pt<=rpos)\n\t\t{\n\t\t\tdel(pt);\n\t\t}\n\t\ta[pt]=cge[cgecnt].nxt;\n\t\tif(pt>=lpos&&pt<=rpos)\n\t\t{\n\t\t\tadd(pt);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tchar opt;\n\t\tscanf(\" %c\",&opt);\n\t\tif(opt=='Q')\n\t\t{\n\t\t\tint l,r;\n\t\t\tscanf(\"%d%d\",&l,&r);\n\t\t\tsuma++;\n\t\t\tque[suma]=(node){l,r,sumc,suma};\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint p,x;\n\t\t\tscanf(\"%d%d\",&p,&x);\n\t\t\tcge[++sumc]=(change){p,a[p],x};\n\t\t\ta[p]=x;\n\t\t}\n\t}\n\tfor(int i=sumc;i>=1;i--)\n\t{\n\t\ta[cge[i].wh]=cge[i].lst;\n\t}\n\tblo=pow(n,0.66666);\n\tsort(que+1,que+suma+1,cmp);\n\tfor(int i=1;i<=suma;i++)\n\t{\n\t\tint l=que[i].l,r=que[i].r,gsum=que[i].gsum,id=que[i].id;\n\t\twhile(lpos<l) del(lpos++);\n\t\twhile(rpos>r) del(rpos--);\n\t\twhile(lpos>l) add(--lpos);\n\t\twhile(rpos<r) add(++rpos);\n\t\twhile(gsum>cgecnt) upd(1);\n\t\twhile(gsum<cgecnt) upd(-1);\n\t\tans[id]=preans;\n\t}\n\tfor(int i=1;i<=suma;i++)\n\t{\n\t\tprintf(\"%d\\n\",ans[i]);\n\t}\n\treturn 0;\n}\n```\n### 练习题目\n\n[CF940F Machine Learning](https://www.luogu.com.cn/problem/CF940F)\n\n## Part.3 回滚莫队\n\n~~顾名思义，回滚莫队就是滚来滚去的莫队。~~\n\n回滚莫队主要用来处理一些**方便扩区间但不方便缩区间的情况**，例如下面这道题：\n\n**经典例题**\n\n[AT1219 歴史の研究](https://www.luogu.com.cn/problem/AT1219)\n\n如果我们还用普通莫队的思路来解这道题，`add` 函数还很好写，可是到了 `del` 函数，我们就发现很难写了。因为**维护重要度最大，需要维护重要度次大；维护重要度次大，需要维护重要度第大**……这就是方便扩区间但不方便缩区间的情况。\n\n出现这种情况，我们可以**排序时先按左端点块编号升序排序，对于块编号一样的情况，按右端点升序排序**。这样就**能保证左端点块编号相同的询问右端点只需要扩展而不需要收缩了**。另外，**对于左端点和右端点在同一块内的情况，直接暴力处理即可**。\n\n考虑处理连续的一段左端点块编号相同的询问。可以**先把莫队区间右端点移到当前左端点所属块的右端点，左端点为右端点加一**，每次扩区间的时候右端点就可以保持只往右扩了。由于左端点不一定只往左扩，所以我们需要**先把右端点扩完，记录下当前的答案 `lstans`，再把左端点扩到适当的位置，求出当前的答案**。\n\n接下来就需要进行“回滚”操作了，具体就是**先把左端点移回 `R[l]+1`，但不改变答案，这时，答案可以直接赋值为之前保存的 `lstans`**，因为区间一样，答案自然也一样了。\n\n回滚莫队的精髓就体现在“回滚”操作上了。\n\n完整代码如下：\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n\n#define S 100005\n\nusing namespace std;\n\nstruct ask\n{\n    int l,r,id;\n}q[S];\n\nstruct node\n{\n    int x,id;\n}temp[S];\n\nint n,m,a[S],bullet[S];\nlong long pre,lst,ans[S],cnt[S],cntt[S];\nint blo,who[S],L[S],R[S];\n\ninline int read()\n{\n    int s=0,w=1,ch=getchar();\n    while(ch<'0'||ch>'9') ch=='-'?w=-1,ch=getchar():ch=getchar();\n    while(ch>='0'&&ch<='9') s=(s<<1)+(s<<3)+(ch^48),ch=getchar();\n    return s*w;\n}\n\ninline bool cmp(node &x,node &y)\n{\n    return x.x<y.x;\n}\n\ninline bool cmp1(node &x,node &y)\n{\n    return x.id<y.id;\n}\n\ninline bool cmp2(ask &x,ask &y)\n{\n    return (who[x.l]==who[y.l])?(x.r<y.r):(who[x.l]<who[y.l]);\n}\n\ninline void add(int x)\n{\n    pre=max(pre,++cnt[a[x]]*bullet[a[x]]);\n}\n\ninline void del(int x)\n{\n    --cnt[a[x]];\n}\n\nint main()\n{\n    n=read();\n    m=read();\n    blo=sqrt(n);\n    for(int i=1;i<=n;i++)\n    {\n        temp[i].x=read();\n        temp[i].id=i;\n        who[i]=(i-1)/blo+1;\n        L[who[i]]=(who[i]-1)*blo+1;\n        R[who[i]]=min(who[i]*blo,n);\n    }\n    for(int i=1;i<=m;i++)\n    {\n        q[i].l=read();\n        q[i].r=read();\n        q[i].id=i;\n    }\n    sort(temp+1,temp+n+1,cmp);\n    int tail=0;\n    for(int i=1;i<=n;i++)\n    {\n        if(temp[i].x!=bullet[tail])\n        {\n            bullet[++tail]=temp[i].x;\n        }\n        temp[i].x=tail;\n    }\n    sort(temp+1,temp+n+1,cmp1);\n    for(int i=1;i<=n;i++)\n    {\n        a[i]=temp[i].x;\n    }\n    sort(q+1,q+m+1,cmp2);\n    int lpos=1,rpos=0;\n    for(int i=1;i<=m;i++)\n    {\n        int l=q[i].l,r=q[i].r,id=q[i].id;\n        lpos=R[who[l]];\n        if(who[l]>who[q[i-1].l])\n        {\n            memset(cnt,0,sizeof(cnt));\n            pre=0;\n            lst=0;\n            rpos=lpos-1;\n        }\n        if(who[l]==who[r])\n        {\n            long long maxx=0;\n            for(int j=l;j<=r;j++)\n            {\n                maxx=max(maxx,++cntt[a[j]]*bullet[a[j]]);\n            }\n            ans[id]=maxx;\n            for(int j=l;j<=r;j++)\n            {\n            \tcntt[a[j]]=0;\n            }\n            continue;\n        }\n        while(rpos<r) add(++rpos);\n        lst=pre;\n        while(lpos>l) add(--lpos);\n        ans[id]=pre;\n        while(lpos<R[who[l]]) del(lpos++);\n        pre=lst;\n    }\n    for(int i=1;i<=m;i++)\n    {\n        printf(\"%lld\\n\",ans[i]);\n    }\n    return 0;\n}\n```\n同理，**方便缩区间但不方便扩区间的情况**回滚莫队也可以做。\n\n**经典例题**\n\n[P8078 [WC2022] 秃子酋长](https://www.luogu.com.cn/problem/P8078)\n\n这道题显然莫队要维护一个有序的序列，支持插入、删除和求前驱后继。\n\n容易发现，如果**没有插入操作的话，前驱后继只要仿照双向链表删除的方法来维护就行了**。所以考虑不插入的回滚莫队。\n\n仿照不删除的回滚莫队：\n\n首先**把莫队区间设置为 $[1,n]$**。\n\n排序时先按左端点块编号升序排序，对于块编号一样的情况，按右端点**降序**排序。这样就能保证左端点块编号相同的询问右端点**只需要收缩而不需要扩展了**。需要注意的是，**对于左端点和右端点在同一块内的情况，不需要暴力处理**。\n\n考虑处理连续的一段左端点块编号相同的询问。可以**先把莫队区间右端点移到 $n$，左端点为当前块的左端点**，每次缩区间的时候右端点就可以保持只往左缩了。由于左端点不一定只往右边缩，所以我们需要**先把右端点缩完，再把左端点缩到适当的位置，求出当前的答案**。\n\n和不删除的回滚莫队不一样的是，**缩左端点和右端点时要把一路上更改的前驱后继用栈记录下来，这样执行“回滚”操作时就能成功恢复了，处理下一个块时右端点也能顺利恢复到 $n$**。\n\n求出当前答案后就需要进行“回滚”操作了，具体就是**按照栈中的值来更新答案并且扩展左端点**。\n\n注意**要特判没有前驱或者后继的节点**，然后就是**要开 `long long`**。\n\n完整代码如下：\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\nconst long long MS=500005;\n\nstruct pr\n{\n\tint x,y;\n}b[MS];\n\nstruct tr\n{\n\tint x,y,z;\n}sta[MS];\n\nstruct node\n{\n\tint l,r,id;\n}que[MS];\n\nint n,m,blo;\nint L[MS],a[MS];\nint fir[MS],nxt[MS];\nlong long preans,ans[MS];\nint top;\n\ninline bool cmp(node x,node y)\n{\n\tint xid=(x.l-1)/blo+1,yid=(y.l-1)/blo+1;\n\treturn xid!=yid?x.l<y.l:x.r>y.r;\n}\n\ninline bool cmp2(pr x,pr y)\n{\n\treturn x.x<y.x;\n}\n\ninline void del(int x)\n{\n\tint lb=fir[x],rb=nxt[x];\n\tsta[++top]=(tr){lb,x,rb};\n\tnxt[lb]=rb;\n\tif(rb==x)\n\t{\n\t\tnxt[lb]=lb;\n\t}\n\tfir[rb]=lb;\n\tif(lb==x)\n\t{\n\t\tfir[rb]=rb;\n\t}\n\tpreans-=abs(x-lb)+abs(x-rb);\n\tif(lb!=x&&rb!=x)\n\t{\n\t\tpreans+=abs(lb-rb);\n\t}\n}\n\ninline void bak()\n{\n\tint lb=sta[top].x,x=sta[top].y,rb=sta[top].z;\n\ttop--;\n\tfir[x]=lb;\n\tif(lb!=x)\n\t{\n\t\tnxt[lb]=x;\n\t}\n\tnxt[x]=rb;\n\tif(rb!=x)\n\t{\n\t\tfir[rb]=x;\n\t}\n\tif(lb!=x&&rb!=x)\n\t{\n\t\tpreans-=abs(lb-rb);\n\t}\n\tpreans+=abs(x-lb)+abs(x-rb);\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tblo=sqrt(n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tb[i].x=a[i];\n\t\tb[i].y=i;\n\t\tL[i]=(i-1)/blo!=(i-2)/blo||i==1?i:L[i-1];\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d\",&que[i].l,&que[i].r);\n\t\tque[i].id=i;\n\t}\n\tsort(que+1,que+m+1,cmp);\n\tint lpos=1,rpos=n;\n\tsort(b+1,b+n+1,cmp2);\n\tfir[b[1].y]=b[1].y;\n\tnxt[b[n].y]=b[n].y;\n\tfor(int i=2;i<=n-1;i++)\n\t{\n\t\tfir[b[i].y]=b[i-1].y;\n\t\tnxt[b[i-1].y]=b[i].y;\n\t\tnxt[b[i].y]=b[i+1].y;\n\t\tfir[b[i+1].y]=b[i].y;\n\t\tpreans+=abs(b[i].y-b[i-1].y);\n\t}\n\tpreans+=abs(b[n].y-b[n-1].y);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint l=que[i].l,r=que[i].r,id=que[i].id;\n\t\tint LL=L[l],lstL=L[que[i-1].l];\n\t\tif(LL!=lstL)\n\t\t{\n\t\t\twhile(top>0) bak();\n\t\t\tlpos=max(1,lstL);\n\t\t\trpos=n;\n\t\t\twhile(lpos<LL) del(lpos++);\n\t\t\ttop=0;\n\t\t}\n\t\twhile(rpos>r) del(rpos--);\n\t\twhile(lpos<l) del(lpos++);\n\t\tans[id]=preans;\n\t\twhile(lpos>LL) bak(),lpos--;\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tprintf(\"%lld\\n\",ans[i]);\n\t}\n\treturn 0;\n}\n```\n\n### 练习题目\n\n[P5906 【模板】回滚莫队&不删除莫队](https://www.luogu.com.cn/problem/P5906)\n\n## Part.4 树上莫队\n\n~~树上莫队，顾名思义，就是莫队上树了。~~\n\n树上莫队主要是用来求树上两点之间最短路径的**某种特征值**的，例如两点的最短路径上**有多少种不同的元素**。\n\n**经典例题**\n\n[SP10707 COT2 - Count on a tree II](https://www.luogu.com.cn/problem/SP10707)\n\n首先我们考虑如何把一棵树“拍扁”。`dfs` 序固然可以，但它**无法维护树上父子关系**。这时就需要介绍一种新的把树“拍扁”的方式了——欧拉序。\n\n欧拉序和 `dfs` 序基本上是一样的，但是**一个点在刚访问和访问结束的时候都会加进序列里，也就是说对于一个 $n$ 个节点的树，它的欧拉序长度为 $2n$，每个点都会在欧拉序中出现两次**。\n\n为了下文表述方便，我们**记 $in_i$ 表示点 $i$ 在欧拉序中第一次出现的位置，$out_i$ 表示点 $i$ 在欧拉序中最后一次出现的位置**。显然，**$i$ 的子树的欧拉序就是 $[in_i,out_i]$ 这段区间所对应的欧拉序**。\n\n这样，我们就实现了“拍扁”一颗树 awa。\n\n但这还没完，考虑如何处理询问。首先**记 $x$ 为一组询问中 $in$ 较小的那个点，$y$ 为一组询问中 $in$ 较大的那个点**。那么**如果询问的两个点在同一棵子树内，即 $lca(x,y)=x$，那么需要处理的区间即为 $[in_x,in_y]$。但是由于树可能会有分叉，所以区间中出现两次的点不能算贡献**。\n\n考虑 $lca(x,y)\\ne x$ 的情况。对于这种情况，**我们需要处理的区间便变为了 $[out_x,in_y]$。同样的，区间中出现两次的点不能算贡献。但由于没有把 $lca(x,y)$ 算进去，所以还需要算上 $lca(x,y)$ 的贡献。**\n\n这是树上莫队最难懂的地方，我也是看了好多文章才理解的 /kk。\n\n梳理一下思路：\n\n- 先 `dfs` 一次预处理出欧拉序和倍增数组\n\n- 处理每一次询问，处理出询问对应的区间\n\n- 正常莫队处理\n\n例题完整代码：\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\n#define S 200005\n#define MS 100005\n\nstruct node\n{\n\tint l,r,lca,id;\n}que[MS];\n\nint n,m;\nint col[MS],b[MS];\nint esum,to[S],nxt[S],h[MS];\nint dep[MS],up[MS][30];\nint cnt,a[MS],in[MS],out[MS];\nint blo;\nbool vis[MS];\nint tot[MS],preans;\nint ans[MS];\n\ninline bool cmp(node x,node y)\n{\n\tint xlid=(x.l-1)/blo+1,ylid=(y.l-1)/blo+1;\n\tif(xlid==ylid)\n\t{\n\t\treturn (xlid&1)?x.r<y.r:x.r>y.r;\n\t}\n\treturn x.l<y.l;\n}\n\ninline void added(int x,int y)\n{\n\tto[++esum]=y;\n\tnxt[esum]=h[x];\n\th[x]=esum;\n}\n\nvoid dfs(int u,int fa)\n{\n\ta[++cnt]=u;\n\tin[u]=cnt;\n\tdep[u]=dep[fa]+1;\n\tup[u][0]=fa;\n\tfor(int i=1;i<=25;i++)\n\t{\n\t\tup[u][i]=up[up[u][i-1]][i-1];\n\t}\n\tfor(int i=h[u];i;i=nxt[i])\n\t{\n\t\tint v=to[i];\n\t\tif(v==fa)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(v,u);\n\t}\n\ta[++cnt]=u;\n\tout[u]=cnt;\n}\n\ninline int getlca(int x,int y)\n{\n\tif(dep[x]<dep[y])\n\t{\n\t\tint t=x;\n\t\tx=y;\n\t\ty=t;\n\t}\n\tfor(int i=25;i>=0;i--)\n\t{\n\t\tif(dep[up[x][i]]>=dep[y])\n\t\t{\n\t\t\tx=up[x][i];\n\t\t}\n\t}\n\tif(x==y)\n\t{\n\t\treturn x;\n\t}\n\tfor(int i=25;i>=0;i--)\n\t{\n\t\tif(up[x][i]!=up[y][i])\n\t\t{\n\t\t\tx=up[x][i];\n\t\t\ty=up[y][i];\n\t\t}\n\t}\n\treturn up[x][0];\n}\n\ninline void add(int x)\n{\n\tif(!vis[x])\n\t{\n\t\tvis[x]=true;\n\t\ttot[col[x]]++;\n\t\tif(tot[col[x]]==1)\n\t\t{\n\t\t\tpreans++;\n\t\t}\n\t}\n\telse\n\t{\n\t\tvis[x]=false;\n\t\ttot[col[x]]--;\n\t\tif(tot[col[x]]==0)\n\t\t{\n\t\t\tpreans--;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&col[i]);\n\t\tb[i]=col[i];\n\t}\n\tsort(b+1,b+n+1);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcol[i]=lower_bound(b+1,b+n+1,col[i])-b;\n\t}\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadded(x,y);\n\t\tadded(y,x);\n\t}\n\tdfs(1,0);\n\tblo=sqrt(n*2);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(in[x]>in[y])\n\t\t{\n\t\t\tint t=x;\n\t\t\tx=y;\n\t\t\ty=t;\n\t\t}\n\t\tint lca=getlca(x,y);\n\t\tif(lca==x)\n\t\t{\n\t\t\tque[i]=(node){in[x],in[y],0,i};\n\t\t}\n\t\telse\n\t\t{\n\t\t\tque[i]=(node){out[x],in[y],lca,i};\n\t\t}\n\t}\n\tsort(que+1,que+m+1,cmp);\n\tint lpos=1,rpos=0;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint l=que[i].l,r=que[i].r,lca=que[i].lca,id=que[i].id;\n\t\twhile(lpos>l) add(a[--lpos]);\n\t\twhile(rpos<r) add(a[++rpos]);\n\t\twhile(lpos<l) add(a[lpos++]);\n\t\twhile(rpos>r) add(a[rpos--]);\n\t\tif(lca!=0)\n\t\t{\n\t\t\tadd(lca);\n\t\t}\n\t\tans[id]=preans;\n\t\tif(lca!=0)\n\t\t{\n\t\t\tadd(lca);\n\t\t}\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tprintf(\"%d\\n\",ans[i]);\n\t}\n\treturn 0;\n}\n```\n\n### 练习题目\n\n[P4074 [WC2013] 糖果公园](https://www.luogu.com.cn/problem/P4074)\n\n## 小技巧\n\n- 莫队常配合其它数据结构，如莫队套树状数组、莫队套 `bitset` 等等\n\n- 强制在线的题莫队无法解决\n\n- 莫队一定要先扩区间再缩区间\n",
			"tags": [{"name":"分块"},{"name":"学习笔记"}],
			"title": "莫队学习笔记",
			"link": "https://exber.qzz.io/post/%E8%8E%AB%E9%98%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-03-21 09:45:07"
		},
	
		{
			"abstract": "",
			"content": "## 算法讲解\n分块是一种很暴力的数据结构，它的思想主要是通过将序列分成长度为 $\\sqrt n$ 的许多块来分别处理来保证时间复杂度为 $n\\sqrt n$。\n\n分块的实现十分简单，下面就以最基础的区间加法为例。\n\n[例题](https://www.luogu.com.cn/problem/P3372)\n\n首先我们需要初始化出每一块的左端点、右端点还有原数组中每一个位置所对应的块编号。为了方便，我们用 $L_i$ 和 $R_i$ 表示第 $i$ 块的左端点和右端点；$sum_i$ 表示第 $i$ 块的和；$lasy_i$ 表示第 $i$ 块应该整体加上多少；$who_i$ 表示原数组中第 $i$ 个位置对应的块编号。那么预处理代码如下：\n\n```cpp\nint n,m;\nlong long a[100005];\nint blo,L[100005],R[100005],who[100005]; // 块数/块长、每一块的左右端点、原序列每一个位置对应的块编号 \nlong long sum[100005]; // 每一块的和\nlong long lazy[100005]; // 每一块整体应该加上多少\n\ninline void init()\n{\n\tblo=sqrt(n);\n\tfor(int i=1;i<=blo;i++) // 预处理出每一块的左右端点 \n\t{\n\t\tL[i]=R[i-1]+1;\n\t\tR[i]=L[i]+blo-1;\n\t}\n\tR[blo]=n; // 最后一块的右端点特殊处理\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\twho[i]=(i-1)/blo+1; // 预处理出原数组每个位置对应的块编号 \n\t\tsum[who[i]]+=a[i]; // 预处理出每一块的和\n\t}\n}\n```\n\n接下来，我们需要考虑怎么处理区间加操作。假设当前需要把 $[l,r]$ 加上 $k$，那么对于 $[l,r]$ 中整块的部分，可以将它们的 $lazy_i$ 直接加上 $k$；对于两边不满一块的部分，可以把它们的 $a_i$ 分别加上 $k$，因为不满一块的长度不会超过 $\\sqrt n$，所以时间复杂度是正确的。\n\n区间加的代码如下：\n\n```cpp\ninline void add(int l,int r,long long k)\n{\n\tif(who[l]==who[r]) // 同一块内 \n\t{\n\t\tfor(int i=l;i<=r;i++)\n\t\t{\n\t\t\ta[i]+=k;\n\t\t}\n\t\treturn;\n\t}\n\t// 不满一块的部分暴力处理 \n\tfor(int i=l;i<=R[who[l]];i++)\n\t{\n\t\ta[i]+=k;\n\t}\n\tfor(int i=L[who[r]];i<=r;i++)\n\t{\n\t\ta[i]+=k;\n\t}\n\t// 中间的整块直接加上 \n\tfor(int i=who[l]+1;i<=who[r]-1;i++)\n\t{\n\t\tlazy[i]+=k;\n\t}\n}\n```\n\n最后，询问的处理也呼之欲出了。只需要仿照区间加来操作就行了，不过注意要加上 $lazy$ 值。\n\n询问的代码如下：\n\n```cpp\ninline long long que(int l,int r)\n{\n\tif(who[l]==who[r]) // 同一块内 \n\t{\n\t\tlong long res=0;\n\t\tfor(int i=l;i<=r;i++)\n\t\t{\n\t\t\tres+=a[i]+lazy[who[l]]; // 不要漏了 lazy \n\t\t}\n\t\treturn res;\n\t}\n\tlong long res=0;\n\t// 不满一块的部分暴力处理 \n\tfor(int i=l;i<=R[who[l]];i++)\n\t{\n\t\tres+=a[i]+lazy[who[l]]; // 不要漏了 lazy \n\t}\n\tfor(int i=L[who[r]];i<=r;i++)\n\t{\n\t\tres+=a[i]+lazy[who[r]]; // 不要漏了 lazy \n\t}\n\t// 中间的整块直接加上 \n\tfor(int i=who[l]+1;i<=who[r]-1;i++)\n\t{\n\t\tres+=sum[i]+lazy[i]; // 不要漏了 lazy \n\t}\n}\n```\n\n完整代码如下，是不是比线段树短很多，但是会 TLE，因为 $O(m \\sqrt n)$ 的时间复杂度不够优秀。\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\nint n,m;\nlong long a[100005];\nint blo,L[100005],R[100005],who[100005]; // 块数/块长、每一块的左右端点、原序列每一个位置对应的块编号 \nlong long sum[100005]; // 每一块的和\nlong long lazy[100005]; // 每一块整体应该加上多少\n\ninline void init()\n{\n\tblo=sqrt(n);\n\tfor(int i=1;i<=blo;i++) // 预处理出每一块的左右端点 \n\t{\n\t\tL[i]=R[i-1]+1;\n\t\tR[i]=L[i]+blo-1;\n\t}\n\tR[blo]=n; // 最后一块的右端点特殊处理\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\twho[i]=(i-1)/blo+1; // 预处理出原数组每个位置对应的块编号 \n\t\tsum[who[i]]+=a[i]; // 预处理出每一块的和\n\t}\n}\n\ninline void add(int l,int r,long long k)\n{\n\tif(who[l]==who[r]) // 同一块内 \n\t{\n\t\tfor(int i=l;i<=r;i++)\n\t\t{\n\t\t\ta[i]+=k;\n\t\t}\n\t\treturn;\n\t}\n\t// 不满一块的部分暴力处理 \n\tfor(int i=l;i<=R[who[l]];i++)\n\t{\n\t\ta[i]+=k;\n\t}\n\tfor(int i=L[who[r]];i<=r;i++)\n\t{\n\t\ta[i]+=k;\n\t}\n\t// 中间的整块直接加上 \n\tfor(int i=who[l]+1;i<=who[r]-1;i++)\n\t{\n\t\tlazy[i]+=k;\n\t}\n}\n\ninline long long que(int l,int r)\n{\n\tif(who[l]==who[r]) // 同一块内 \n\t{\n\t\tlong long res=0;\n\t\tfor(int i=l;i<=r;i++)\n\t\t{\n\t\t\tres+=a[i]+lazy[who[l]]; // 不要漏了 lazy \n\t\t}\n\t\treturn res;\n\t}\n\tlong long res=0;\n\t// 不满一块的部分暴力处理 \n\tfor(int i=l;i<=R[who[l]];i++)\n\t{\n\t\tres+=a[i]+lazy[who[l]]; // 不要漏了 lazy \n\t}\n\tfor(int i=L[who[r]];i<=r;i++)\n\t{\n\t\tres+=a[i]+lazy[who[r]]; // 不要漏了 lazy \n\t}\n\t// 中间的整块直接加上 \n\tfor(int i=who[l]+1;i<=who[r]-1;i++)\n\t{\n\t\tres+=sum[i]+lazy[i]; // 不要漏了 lazy \n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld\",&a[i]);\n\t}\n\twhile(m--)\n\t{\n\t\tint type,l,r;\n\t\tscanf(\"%d%d%d\",&type,&l,&r);\n\t\tif(type==1)\n\t\t{\n\t\t\tlong long k;\n\t\t\tscanf(\"%lld\",&k);\n\t\t\tadd(l,r,k);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"%lld\\n\",que(l,r));\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n## 练习题目\n### 由乃打扑克\n[链接](https://www.luogu.com.cn/problem/P5356)\n\n这题比较简单，主体思路就是二分套二分再加上排序什么的乱搞一通。\n\n建议先做完[P2801 教主的魔法](https://www.luogu.com.cn/problem/P2801)再来做这题。（双倍经验）\n\n### 初始化\n\n[链接](https://www.luogu.com.cn/problem/P5309)\n\n这题有点难，要对长度为 $x$ 的每次询问弄前缀和和后缀和，不过不怎么卡常，代码也是相当地短。\n",
			"tags": [{"name":"分块"},{"name":"学习笔记"}],
			"title": "数列分块学习笔记",
			"link": "https://exber.qzz.io/post/%E6%95%B0%E5%88%97%E5%88%86%E5%9D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-03-21 09:34:47"
		},
	
		{
			"abstract": "",
			"content": "KMP 是一种用来处理字符串匹配问题的算法。\n\n对于长度分别为 $n,m$ 的字符串 $S,T$，显然可以暴力地找到 $T$ 在 $S$ 中的所有出现位置：\n\n```cpp\nfor(int i=1;i<=n-m+1;i++)\n{\n\tbool f=true;\n\tfor(int j=1;j<=m;j++)\n\t\tif(S[i+j-1]!=T[j])\n\t\t{\n\t\t\tf=false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(f) printf(\"%d\\n\",i);\n}\n```\n\n但是这样的算法时间复杂度是 $O(nm)$ 的。\n\n考虑改进这个算法，注意到下面这两个字符串匹配时：\n\n`S:ACACBEAC`\n\n`T:ACACE`\n\n模式串匹配到 `E` 时发现失配了，但此时可以不仅仅把 $T$ 移动一位，而是直接移动两位：\n\n`S:ACACBEEAC`\n\n`T:^^ACACE`\n\n因为 $T_{[1,4]}$ 已经匹配了，而在 $T_{[1,4]}$ 中，前两位构成的前缀 $T_{[1,2]}$ 和后两位构成的后缀 $T_{[3,4]}$ 相同，所以可以移动两位。\n\n对于一个字符串 $S$，定义 $b$ 为 $S$ 的 border 当且仅当 $1\\le b< |S|$ 且 $S_{[1,|b|]}=S_{[|S|-b+1,|S|]}$。那么当 $T$ 的前 $j$ 位已匹配，第 $j+1$ 位失配时，就可以将 $j$ 设置成 $T_{[1,j]}$ 的最长的 border 的长度。\n\n设 $kmp_i$ 表示 $T_{[1,i]}$ 的最长 border 的长度，那么匹配的过程就可以变成这样：\n\n```cpp\nint j=0;\nfor(int i=1;i<=n;i++)\n{\n\twhile(j!=0&&T[j+1]!=S[i]) j=kmp[j]; // 如果失配，那么不停移动 T\n\tif(T[j+1]==S[i]) j++; // 能匹配就匹配\n\tif(j==m) printf(\"%d\\n\",i-m+1); // 匹配成功\n}\n```\n\n而 $kmp$ 数组的求解就可以看作是 $T$ 和自己匹配：\n\n```cpp\nkmp[1]=0; // kmp[1]=0\nfor(int i=2,j=0;i<=m;i++) // T 和自己匹配 \n{\n\twhile(j!=0&&T[j+1]!=T[i]) j=kmp[j]; // 失配则不断移动 T\n\tif(T[j+1]==T[i]) j++; // 匹配 \n\tkmp[i]=j; // 当前匹配的长度就是 kmp[i] \n}\n```\n\n这样做的时间复杂度是 $O(n+m)$ 的。\n\n时间复杂度证明：\n\n首先预处理 $kmp$ 数组是 $O(m)$ 的，因为 $j$ 总共最多只会增加 $m$ 次，每次跳 $kmp$ 至少会让 $j$ 减少 $1$，所以最多回跳 $m$ 次。\n\n匹配的时间复杂度是 $O(n)$ 的，具体原理同上。\n\n实际上 $kmp$ 数组相当于单串 AC 自动机的 $fail$ 数组。\n\n#### 一些拓展\n\n- 想要求 $T_{[1,i]}$ 的小于等于 $i-x$ 或者 $\\lfloor\\frac{i}{x}\\rfloor$ 的最长的 border 也可以用类似求 $kmp$ 数组的方法来求：\n\n  ```cpp\n  num[1]=0; \n  for(int i=2,j=0;i<=n;i++)\n  {\n  \twhile(j!=0&&a[j+1]!=a[i]) j=kmp[j];\n  \tif(a[j+1]==a[i]) j++;\n  \twhile(j*2>i) j=kmp[j];\n  \tnum[i]=j;\n  }\n  ```\n\n  这段代码求的就是 $num_i$ 表示 $a_{[1,i]}$ 长度小于等于 $\\lfloor\\frac{i}{2}\\rfloor$ 的最长的 border 的长度。\n\n  这样做的时间复杂度是 $O(n)$ 的，证明类似求 $kmp$ 数组的时间复杂度的证明。\n\n- [一些字符串的定理](../一些字符串的定理/)\n",
			"tags": [{"name":"学习笔记"},{"name":"数据结构"},{"name":"字符串"}],
			"title": "KMP 学习笔记",
			"link": "https://exber.qzz.io/post/KMP%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0",
			"date": "2023-03-19 14:21:59"
		}
	
	]
}
